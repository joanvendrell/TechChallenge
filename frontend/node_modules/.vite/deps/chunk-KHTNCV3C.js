import {
  areMatricesEqual,
  degreesFromRadians,
  macro,
  mat4_exports,
  quat_exports,
  radiansFromDegrees,
  vtkBoundingBox
} from "./chunk-UJ7GCCMN.js";

// node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
var CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants = {
  CoordinateSystem
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
var {
  CoordinateSystem: CoordinateSystem2
} = Constants;
function notImplemented(method) {
  return () => macro.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index = 0; index < model.textures.length; ++index) {
      const m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {
  };
  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];
  publicAPI.pick = notImplemented("pick");
  publicAPI.hasKey = notImplemented("hasKey");
  publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  publicAPI.getRedrawMTime = () => model.mtime;
  publicAPI.setEstimatedRenderTime = (t) => {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = (t) => {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = (t) => {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = () => false;
  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = (texture) => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = (texture) => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = (texture) => {
    const newTextureList = model.textures.filter((item) => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };
  publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(CoordinateSystem2.WORLD);
  publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(CoordinateSystem2.DISPLAY);
}
var DEFAULT_VALUES = {
  // _parentProp: null,
  allocatedRenderTime: 10,
  coordinateSystem: CoordinateSystem2.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkProp");
var vtkProp$1 = {
  newInstance,
  extend,
  ...Constants
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var VTK_EPSILON = 1e-6;
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = (deltaXYZ) => {
    model.position = model.position.map((value, index) => value + deltaXYZ[index]);
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = () => {
    const q = quat_exports.create();
    mat4_exports.getRotation(q, model.rotation);
    const oaxis = new Float64Array(3);
    const w = quat_exports.getAxisAngle(oaxis, q);
    return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.getOrientationQuaternion = function() {
    let out = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return mat4_exports.getRotation(out, model.rotation);
  };
  publicAPI.rotateX = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees, x, y, z) => {
    if (degrees === 0 || x === 0 && y === 0 && z === 0) {
      return;
    }
    const angle = radiansFromDegrees(degrees);
    const q = quat_exports.create();
    quat_exports.setAxisAngle(q, [x, y, z], angle);
    const quatMat = new Float64Array(16);
    mat4_exports.fromQuat(quatMat, q);
    mat4_exports.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.rotateQuaternion = (orientationQuaternion) => {
    if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
      return;
    }
    const oriQuatMat = mat4_exports.fromQuat(new Float64Array(16), orientationQuaternion);
    mat4_exports.multiply(model.rotation, model.rotation, oriQuatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = (x, y, z) => {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    mat4_exports.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setOrientationFromQuaternion = (q) => {
    const rotation = mat4_exports.create();
    mat4_exports.fromQuat(rotation, q);
    if (!areMatricesEqual(rotation, model.rotation)) {
      model.rotation = rotation;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.setUserMatrix = (matrix) => {
    if (areMatricesEqual(model.userMatrix, matrix)) {
      return false;
    }
    mat4_exports.copy(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = () => {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      mat4_exports.identity(model.matrix);
      if (model.userMatrix) {
        mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, model.origin);
      mat4_exports.translate(model.matrix, model.matrix, model.position);
      mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
      mat4_exports.scale(model.matrix, model.matrix, model.scale);
      mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      mat4_exports.transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getBoundsByReference = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds;
      model.bounds = [...vtkBoundingBox.INIT_BOUNDS];
      model.boundsMTime.modified();
      return bds;
    }
    if (!model.mapperBounds || !bds.every((_, i) => bds[i] === model.mapperBounds[i]) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      macro.vtkDebugMacro("Recomputing bounds...");
      model.mapperBounds = bds;
      publicAPI.computeMatrix();
      const transposedMatrix = new Float64Array(16);
      mat4_exports.transpose(transposedMatrix, model.matrix);
      vtkBoundingBox.transformBounds(bds, transposedMatrix, model.bounds);
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getBounds = () => {
    const bounds = publicAPI.getBoundsByReference();
    try {
      return [...bounds];
    } catch {
      return bounds;
    }
  };
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(model.bounds);
  publicAPI.getLength = () => vtkBoundingBox.getLength(model.bounds);
  publicAPI.getXRange = () => vtkBoundingBox.getXRange(model.bounds);
  publicAPI.getYRange = () => vtkBoundingBox.getYRange(model.bounds);
  publicAPI.getZRange = () => vtkBoundingBox.getZRange(model.bounds);
  publicAPI.getUserMatrix = () => model.userMatrix;
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
  publicAPI.getProperty = function() {
    var _a;
    let mapperInputPort = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.properties[mapperInputPort] == null) {
      model.properties[mapperInputPort] = (_a = publicAPI.makeProperty) == null ? void 0 : _a.call(publicAPI);
    }
    return model.properties[mapperInputPort];
  };
  publicAPI.getProperties = () => {
    var _a;
    if (model.properties.length === 0) {
      model.properties[0] = (_a = publicAPI.makeProperty) == null ? void 0 : _a.call(publicAPI);
    }
    return model.properties;
  };
  publicAPI.setProperty = (firstArg, secondArg) => {
    const useInputPortArgument = Number.isInteger(firstArg);
    const [mapperInputPort, property] = useInputPortArgument ? [firstArg, secondArg] : [0, firstArg];
    if (model.properties[mapperInputPort] === property) {
      return false;
    }
    model.properties[mapperInputPort] = property;
    return true;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    model.properties.forEach((property) => {
      if (property !== null) {
        const time = property.getMTime();
        mt = time > mt ? time : mt;
      }
    });
    return mt;
  };
}
var DEFAULT_VALUES2 = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [...vtkBoundingBox.INIT_BOUNDS],
  properties: [],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  macro.setGet(publicAPI, model, ["properties"]);
  model.matrix = mat4_exports.identity(new Float64Array(16));
  model.rotation = mat4_exports.identity(new Float64Array(16));
  model.userMatrix = mat4_exports.identity(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkProp3D");
var vtkProp3D$1 = {
  newInstance: newInstance2,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2
};
var Representation = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2
};
var Interpolation = Shading;
var PropertyConst = {
  Shading,
  Representation,
  Interpolation
};

// node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var {
  Representation: Representation2,
  Interpolation: Interpolation2
} = PropertyConst;
function notImplemented2(method) {
  return () => macro.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
}
function vtkProperty(publicAPI, model) {
  model.classHierarchy.push("vtkProperty");
  publicAPI.setColor = (r, g, b) => {
    if (Array.isArray(r)) {
      if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
      model.color[0] = r;
      model.color[1] = g;
      model.color[2] = b;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented2("ComputeCompositeColor");
  publicAPI.getColor = () => {
    let norm = 0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm = 1 / (model.ambient + model.diffuse + model.specular);
    }
    for (let i = 0; i < 3; i++) {
      model.color[i] = norm * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
    }
    return [].concat(model.color);
  };
  publicAPI.setSpecularPower = (specularPower) => {
    const roughness = 1 / Math.max(1, specularPower);
    if (model.roughness !== roughness || model.specularPower !== specularPower) {
      model.specularPower = specularPower;
      model.roughness = roughness;
      publicAPI.modified();
    }
  };
  publicAPI.addShaderVariable = notImplemented2("AddShaderVariable");
  publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation2.FLAT);
  publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation2.GOURAUD);
  publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation2.PHONG);
  publicAPI.getInterpolationAsString = () => macro.enumToString(Interpolation2, model.interpolation);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation2.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation2.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation2.POINTS);
  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation2, model.representation);
}
var DEFAULT_VALUES3 = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],
  ambient: 0,
  diffuse: 1,
  metallic: 0,
  roughness: 0.6,
  normalStrength: 1,
  emission: 1,
  baseIOR: 1.45,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation2.GOURAUD,
  representation: Representation2.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,
  shading: false,
  materialName: null,
  ORMTexture: null,
  RMTexture: null
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["lighting", "interpolation", "ambient", "diffuse", "metallic", "roughness", "normalStrength", "emission", "baseIOR", "specular", "specularPower", "opacity", "edgeVisibility", "lineWidth", "pointSize", "backfaceCulling", "frontfaceCulling", "representation", "diffuseTexture", "metallicTexture", "roughnessTexture", "normalTexture", "ambientOcclusionTexture", "emissionTexture", "ORMTexture", "RMTexture"]);
  macro.setGetArray(publicAPI, model, ["ambientColor", "specularColor", "diffuseColor", "edgeColor"], 3);
  vtkProperty(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkProperty");
var vtkProperty$1 = {
  newInstance: newInstance3,
  extend: extend3,
  ...PropertyConst
};

// node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
function vtkActor(publicAPI, model) {
  model.classHierarchy.push("vtkActor");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getActors = () => [publicAPI];
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.properties[0]) {
      publicAPI.getProperty();
    }
    let isOpaque = model.properties[0].getOpacity() >= 1;
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    if (!model.properties[0]) {
      publicAPI.getProperty();
    }
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = vtkProperty$1.newInstance;
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.backfaceProperty !== null) {
      const time = model.backfaceProperty.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (model.mapper && model.mapper.processSelectorPixelBuffers) {
      model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
    }
  };
}
var DEFAULT_VALUES4 = {
  mapper: null,
  backfaceProperty: null,
  forceOpaque: false,
  forceTranslucent: false
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.setGet(publicAPI, model, ["backfaceProperty", "forceOpaque", "forceTranslucent", "mapper"]);
  vtkActor(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend4, "vtkActor");
var vtkActor$1 = {
  newInstance: newInstance4,
  extend: extend4
};

export {
  vtkProp$1,
  vtkProp3D$1,
  Representation,
  PropertyConst,
  vtkProperty$1,
  extend4 as extend,
  newInstance4 as newInstance,
  vtkActor$1
};
//# sourceMappingURL=chunk-KHTNCV3C.js.map
