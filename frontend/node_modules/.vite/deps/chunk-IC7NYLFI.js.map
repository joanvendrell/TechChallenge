{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/OpenGL/Texture.js", "../../@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js", "../../@kitware/vtk.js/Common/Core/HalfFloat.js", "../../@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js", "../../@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js", "../../@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js", "../../@kitware/vtk.js/Rendering/OpenGL/Texture/supportsNorm16Linear.js", "../../@kitware/vtk.js/Rendering/WebGPU/Sampler.js", "../../@kitware/vtk.js/Rendering/WebGPU/Types.js", "../../@kitware/vtk.js/Rendering/WebGPU/TextureView.js", "../../@kitware/vtk.js/Rendering/WebGPU/Texture.js", "../../@kitware/vtk.js/Rendering/OpenGL/Shader.js", "../../@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js", "../../@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js", "../../@kitware/vtk.js/Rendering/OpenGL/BufferObject.js", "../../@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject/helpers.js", "../../@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js", "../../@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js", "../../@kitware/vtk.js/Rendering/OpenGL/Helper.js", "../../@kitware/vtk.js/Rendering/WebGPU/BindGroup.js", "../../@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js", "../../@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js", "../../@kitware/vtk.js/Rendering/WebGPU/Pipeline.js", "../../@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js", "../../@kitware/vtk.js/Rendering/WebGPU/VertexInput.js", "../../@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js", "../../@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js", "../../@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js", "../../@kitware/vtk.js/Rendering/WebGPU/Buffer.js", "../../@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js", "../../@kitware/vtk.js/Rendering/WebGPU/BufferManager.js", "../../@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js", "../../@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js", "../../@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js"],
  "sourcesContent": ["import DeepEqual from 'fast-deep-equal';\nimport Constants from './Texture/Constants.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport { n as newInstance$1, o as obj, s as set, e as setGet, g as get, i as moveToProtected, a as newTypedArray, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { Y as isPowerOfTwo, T as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport supportsNorm16LinearCached from './Texture/supportsNorm16Linear.js';\n\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro,\n  requiredParam\n} = macro;\nconst {\n  toHalf\n} = HalfFloat;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  function getTexParams() {\n    return {\n      internalFormat: model.internalFormat,\n      format: model.format,\n      openGLDataType: model.openGLDataType,\n      width: model.width,\n      height: model.height\n    };\n  }\n\n  // Renders myself\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      if (model.renderable.getImageBitmap() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImageBitmap() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImageBitmap(model.renderable.getImageBitmap());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw({\n          width: canvas.width,\n          height: canvas.height,\n          numComps: 4,\n          dataType: VtkDataTypes.UNSIGNED_CHAR,\n          data: canvas,\n          flip: true\n        });\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw({\n          width: jsid.width,\n          height: jsid.height,\n          numComps: 4,\n          dataType: VtkDataTypes.UNSIGNED_CHAR,\n          data: jsid.data,\n          flip: true\n        });\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw({\n            width: ext[1] - ext[0] + 1,\n            height: ext[3] - ext[2] + 1,\n            numComps: inScalars.getNumberOfComponents(),\n            dataType: inScalars.getDataType(),\n            data\n          });\n        } else {\n          publicAPI.create2DFromRaw({\n            width: ext[1] - ext[0] + 1,\n            height: ext[3] - ext[2] + 1,\n            numComps: inScalars.getNumberOfComponents(),\n            dataType: inScalars.getDataType(),\n            data: inScalars.getData()\n          });\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n  const getNorm16Ext = () => {\n    if ((model.minificationFilter === Filter.LINEAR || model.magnificationFilter === Filter.LINEAR) && !supportsNorm16LinearCached()) {\n      return undefined;\n    }\n    return model.oglNorm16Ext;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model._prevTexParams = null;\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model._prevTexParams = null;\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model._forceInternalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension('OES_texture_float_linear')) {\n      vtkWarningMacro('Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.');\n    }\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, getNorm16Ext(), publicAPI.useHalfFloat());\n    if (result) {\n      return result;\n    }\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return result;\n  };\n  publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = iFormat => {\n    model._forceInternalFormat = true;\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model._prevTexParams = null;\n    model.format = 0;\n    model.internalFormat = 0;\n    model._forceInternalFormat = false;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = vtkScalarType => {\n    const useHalfFloat = publicAPI.useHalfFloat();\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        // prefer norm16 since that is accurate compared to\n        // half float which is not\n        case getNorm16Ext() && !useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.SHORT;\n        case getNorm16Ext() && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.UNSIGNED_SHORT;\n        // use half float type\n        case useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!model.openGLDataType || forceUpdate) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);\n    }\n    return model.openGLDataType;\n  };\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n    }\n    return {\n      shift,\n      scale\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Gets the extent's size.\n   * @param {Extent} extent\n   */\n  function getExtentSize(extent) {\n    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;\n    return [xmax - xmin + 1, ymax - ymin + 1, zmax - zmin + 1];\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Gets the number of pixels in the extent.\n   * @param {Extent} extent\n   */\n  function getExtentPixelCount(extent) {\n    const [sx, sy, sz] = getExtentSize(extent);\n    return sx * sy * sz;\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Reads a flattened extent from the image data and writes to the given output array.\n   *\n   * Assumes X varies the fastest and Z varies the slowest.\n   *\n   * @param {*} data\n   * @param {*} dataDims\n   * @param {Extent} extent\n   * @param {TypedArray} outArray\n   * @param {number} outOffset\n   * @returns\n   */\n  function readExtentIntoArray(data, dataDims, extent, outArray, outOffset) {\n    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;\n    const [dx, dy] = dataDims;\n    const sxy = dx * dy;\n    let writeOffset = outOffset;\n    for (let zi = zmin; zi <= zmax; zi++) {\n      const zOffset = zi * sxy;\n      for (let yi = ymin; yi <= ymax; yi++) {\n        const zyOffset = zOffset + yi * dx;\n        // explicit alternative to data.subarray,\n        // due to potential perf issues on v8\n        for (let readOffset = zyOffset + xmin, end = zyOffset + xmax; readOffset <= end; readOffset++, writeOffset++) {\n          outArray[writeOffset] = data[readOffset];\n        }\n      }\n    }\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Reads several image extents into a contiguous pixel array.\n   *\n   * @param {*} data\n   * @param {Extent[]} extent\n   * @param {TypedArrayConstructor} typedArrayConstructor optional typed array constructor\n   * @returns\n   */\n  function readExtents(data, extents) {\n    let typedArrayConstructor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const constructor = typedArrayConstructor || data.constructor;\n    const numPixels = extents.reduce((count, extent) => count + getExtentPixelCount(extent), 0);\n    const extentPixels = new constructor(numPixels);\n    const dataDims = [model.width, model.height, model.depth];\n    let writeOffset = 0;\n    extents.forEach(extent => {\n      readExtentIntoArray(data, dataDims, extent, extentPixels, writeOffset);\n      writeOffset += getExtentPixelCount(extent);\n    });\n    return extentPixels;\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Updates the data array to match the required data type for OpenGL.\n   *\n   * This function takes the input data and converts it to the appropriate\n   * format required by the OpenGL texture, based on the specified data type.\n   *\n   * @param {string} dataType - The original data type of the input data.\n   * @param {Array} data - The input data array that needs to be updated.\n   * @param {boolean} [depth=false] - Indicates whether the data is a 3D array.\n   * @param {Array<Extent>} imageExtents only consider these image extents (default: [])\n   * @returns {Array} The updated data array that matches the OpenGL data type.\n   */\n  publicAPI.updateArrayDataTypeForGL = function (dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let imageExtents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n    const onlyUpdateExtents = !!imageExtents.length;\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          if (onlyUpdateExtents) {\n            pixData.push(readExtents(data[idx], imageExtents, Float32Array));\n          } else {\n            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n            pixData.push(new Float32Array(dataArrayToCopy));\n          }\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          if (onlyUpdateExtents) {\n            pixData.push(readExtents(data[idx], imageExtents, Uint8Array));\n          } else {\n            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n            pixData.push(new Uint8Array(dataArrayToCopy));\n          }\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    let halfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const src = onlyUpdateExtents ? readExtents(data[idx], imageExtents) : data[idx];\n          const newArray = new Uint16Array(onlyUpdateExtents ? src.length : pixCount);\n          const newArrayLen = newArray.length;\n          for (let i = 0; i < newArrayLen; i++) {\n            newArray[i] = toHalf(src[i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(onlyUpdateExtents && data[i] ? readExtents(data[i], imageExtents) : data[i]);\n      }\n    }\n    return pixData;\n  };\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = nearestPowerOfTwo(width);\n      const newHeight = nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function useTexStorage(dataType) {\n    if (model._openGLRenderWindow) {\n      if (model.resizable || model.renderable?.getResizable()) {\n        // Cannot use texStorage if the texture is supposed to be resizable.\n        return false;\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        const webGLInfo = model._openGLRenderWindow.getGLInformations();\n        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && getNorm16Ext() && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {\n          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.\n          // No errors reported but the texture is unusable.\n          return false;\n        }\n        // Use texStorage for WebGL2\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n\n  publicAPI.create2DFromRaw = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      numComps = requiredParam('numComps'),\n      dataType = requiredParam('dataType'),\n      data = requiredParam('data'),\n      flip = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType, true);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (scaledData[0] != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      numComps = requiredParam('numComps'),\n      dataType = requiredParam('dataType'),\n      data = requiredParam('data')\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);\n    }\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        if (useTexStorage(dataType)) {\n          if (tempData != null) {\n            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);\n          }\n        } else {\n          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        }\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      dataType = requiredParam('dataType'),\n      data = requiredParam('data')\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (data != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = image => {\n    // Determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));\n    let textureSource = image;\n    let targetWidth = image.width;\n    let targetHeight = image.height;\n    let flipY = true;\n\n    // For WebGL1, we need to scale the image to the nearest power of two\n    // dimensions if the image is not already a power of two. For WebGL2, we can\n    // use the image as is. Note: Chrome has a perf issue where the path\n    // HTMLImageElement -> Canvas -> texSubImage2D is faster than\n    // HTMLImageElement -> texSubImage2D directly. See\n    // https://issues.chromium.org/issues/41311312#comment7\n    // Tested on Chrome 137.0.7151.104 Windows 11\n    const isChrome = window.chrome;\n    if (needNearestPowerOfTwo || isChrome) {\n      const canvas = new OffscreenCanvas(nearestPowerOfTwo(image.width), nearestPowerOfTwo(image.height));\n      targetWidth = canvas.width;\n      targetHeight = canvas.height;\n      const ctx = canvas.getContext('2d');\n      ctx.translate(0, canvas.height);\n      ctx.scale(1, -1);\n      ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n      textureSource = canvas;\n      flipY = false; // we are flipping the image manually using translate/scale\n    }\n\n    model.width = targetWidth;\n    model.height = targetHeight;\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flipY);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, textureSource);\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, textureSource);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImageBitmap = imageBitmap => {\n    // Determine the texture parameters.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Prepare texture unpack alignment\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    model.width = imageBitmap.width;\n    model.height = imageBitmap.height;\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, imageBitmap);\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, imageBitmap);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  // Compute scale and offset per component from min and max per component\n  function computeScaleOffsets(min, max, numComps) {\n    const offset = new Array(numComps);\n    const scale = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c] || 1.0;\n    }\n    return {\n      scale,\n      offset\n    };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function setCanUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    publicAPI.getOpenGLDataType(dataType);\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    const isExactHalfFloat = hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy;\n    let useHalfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // If OES_texture_float_linear is not available, and using a half float would still be exact, force half floats\n      // This is because half floats are always texture filterable in webgl2, while full *32F floats are not (unless the extension is present)\n      const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension('OES_texture_float_linear') === null && isExactHalfFloat;\n      useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;\n  }\n  function processDataArray(dataArray, preferSizeOverAccuracy) {\n    const numComps = dataArray.getNumberOfComponents();\n    const dataType = dataArray.getDataType();\n    const data = dataArray.getData();\n\n    // Compute min max from array\n    // Using the vtkDataArray.getRange() enables caching\n    const minArray = new Array(numComps);\n    const maxArray = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      const [min, max] = dataArray.getRange(c);\n      minArray[c] = min;\n      maxArray[c] = max;\n    }\n    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);\n\n    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247\n    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);\n\n    // since our default is to use half float, in case that we can't use it\n    // we need to use another type\n    if (!publicAPI.useHalfFloat()) {\n      publicAPI.getOpenGLDataType(dataType, true);\n    }\n    return {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    };\n  }\n  publicAPI.create2DFilterableFromRaw = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      numComps = requiredParam('numComps'),\n      dataType = requiredParam('dataType'),\n      data = requiredParam('data'),\n      preferSizeOverAccuracy = false,\n      ranges = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return publicAPI.create2DFilterableFromDataArray({\n      width,\n      height,\n      dataArray: vtkDataArray.newInstance({\n        numberOfComponents: numComps,\n        dataType,\n        values: data,\n        ranges\n      }),\n      preferSizeOverAccuracy\n    });\n  };\n  publicAPI.create2DFilterableFromDataArray = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      dataArray = requiredParam('dataArray'),\n      preferSizeOverAccuracy = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      numComps,\n      dataType,\n      data\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    publicAPI.create2DFromRaw({\n      width,\n      height,\n      numComps,\n      dataType,\n      data\n    });\n  };\n  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {\n    let isScalingApplied = false;\n    const useHalfFloat = publicAPI.useHalfFloat();\n\n    // Initialize volume info if it doesn't exist\n    if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {\n      model.volumeInfo = {\n        scale: new Array(numComps),\n        offset: new Array(numComps)\n      };\n    }\n\n    // Default scaling and offset\n    for (let c = 0; c < numComps; ++c) {\n      model.volumeInfo.scale[c] = 1.0;\n      model.volumeInfo.offset[c] = 0.0;\n    }\n\n    // Handle SHORT data type with EXT_texture_norm16 extension\n    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes.SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 32767.0; // Scale to [-1, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_SHORT data type with EXT_texture_norm16 extension\n    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 65535.0; // Scale to [0, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_CHAR data type\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 255.0; // Scale to [0, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // No scaling needed for FLOAT or HalfFloat (SHORT/UNSIGNED_SHORT)\n    if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n      isScalingApplied = true;\n    }\n    return isScalingApplied;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      depth = requiredParam('depth'),\n      numComps = requiredParam('numComps'),\n      dataType = requiredParam('dataType'),\n      data = requiredParam('data'),\n      updatedExtents = []\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let dataTypeToUse = dataType;\n    let dataToUse = data;\n    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {\n      const numPixelsIn = width * height * depth;\n      const scaleOffsetsCopy = structuredClone(model.volumeInfo);\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // use computed scale and offset\n      model.volumeInfo.offset = scaleOffsetsCopy.offset;\n      model.volumeInfo.scale = scaleOffsetsCopy.scale;\n      let count = 0;\n      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      dataToUse = newArray;\n    }\n\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const hasUpdatedExtents = updatedExtents.length > 0;\n\n    // It's possible for the texture parameters to change while\n    // streaming, so check for such a change.\n    const rebuildEntireTexture = !hasUpdatedExtents || !DeepEqual(model._prevTexParams, getTexParams());\n\n    // Create an array of texture with one texture\n    const dataArray = [dataToUse];\n    const is3DArray = true;\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray, rebuildEntireTexture ? [] : updatedExtents);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (rebuildEntireTexture) {\n      if (useTexStorage(dataTypeToUse)) {\n        model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);\n        if (scaledData[0] != null) {\n          model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);\n        }\n      } else {\n        model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n      }\n      model._prevTexParams = getTexParams();\n    } else if (hasUpdatedExtents) {\n      const extentPixels = scaledData[0];\n      let readOffset = 0;\n      for (let i = 0; i < updatedExtents.length; i++) {\n        const extent = updatedExtents[i];\n        const extentSize = getExtentSize(extent);\n        const extentPixelCount = getExtentPixelCount(extent);\n        const textureData = new extentPixels.constructor(extentPixels.buffer, readOffset, extentPixelCount);\n        readOffset += textureData.byteLength;\n        model.context.texSubImage3D(model.target, 0, extent[0], extent[2], extent[4], extentSize[0], extentSize[1], extentSize[2], model.format, model.openGLDataType, textureData);\n      }\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  // Prefer create3DFilterableFromDataArray to enable caching of min and max values\n  publicAPI.create3DFilterableFromRaw = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      depth = requiredParam('depth'),\n      numComps = requiredParam('numComps'),\n      dataType = requiredParam('dataType'),\n      data = requiredParam('data'),\n      preferSizeOverAccuracy = false,\n      ranges = undefined,\n      updatedExtents = []\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return publicAPI.create3DFilterableFromDataArray({\n      width,\n      height,\n      depth,\n      dataArray: vtkDataArray.newInstance({\n        numberOfComponents: numComps,\n        dataType,\n        values: data,\n        ranges\n      }),\n      preferSizeOverAccuracy,\n      updatedExtents\n    });\n  };\n\n  //----------------------------------------------------------------------------\n  // This method create a 3D texture from dimensions and a DataArray\n  publicAPI.create3DFilterableFromDataArray = function () {\n    let {\n      width = requiredParam('width'),\n      height = requiredParam('height'),\n      depth = requiredParam('depth'),\n      dataArray = requiredParam('dataArray'),\n      preferSizeOverAccuracy = false,\n      updatedExtents = []\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = {\n      scale,\n      offset,\n      dataComputedScale: scaleOffsets.scale,\n      dataComputedOffset: scaleOffsets.offset,\n      width,\n      height,\n      depth\n    };\n\n    // Create a copy of scale and offset to avoid aliasing issues\n    // Original is read only, copy is read/write\n    // Use the copy as volumeInfo.scale and volumeInfo.offset\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      return publicAPI.create3DFromRaw({\n        width,\n        height,\n        depth,\n        numComps,\n        dataType,\n        data,\n        updatedExtents\n      });\n    }\n    const numPixelsIn = width * height * depth;\n    const scaleOffsetsCopy = structuredClone(scaleOffsets);\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        scaleOffsetsCopy.offset[c] = 0.0;\n        scaleOffsetsCopy.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = scaleOffsetsCopy.offset;\n    model.volumeInfo.scale = scaleOffsetsCopy.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (newArray != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    }\n    publicAPI.deactivate();\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n    return -1;\n  };\n\n  // set use half float\n  publicAPI.enableUseHalfFloat = use => {\n    model.enableUseHalfFloat = use;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  _forceInternalFormat: false,\n  _prevTexParams: null,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n  oglNorm16Ext: null,\n  allocatedGPUMemoryInBytes: 0,\n  // by default it is enabled\n  enableUseHalfFloat: true,\n  // but by default we don't know if we can use half float base on the data range\n  canUseHalfFloat: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  obj(model.textureBuildTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  set(publicAPI, model, ['format', 'openGLDataType']);\n  setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);\n  get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLTexture$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\n\nexport { vtkOpenGLTexture$1 as default, extend, newInstance };\n", "const Wrap = {\n  CLAMP_TO_EDGE: 0,\n  REPEAT: 1,\n  MIRRORED_REPEAT: 2\n};\nconst Filter = {\n  NEAREST: 0,\n  LINEAR: 1,\n  NEAREST_MIPMAP_NEAREST: 2,\n  NEAREST_MIPMAP_LINEAR: 3,\n  LINEAR_MIPMAP_NEAREST: 4,\n  LINEAR_MIPMAP_LINEAR: 5\n};\nvar Constants = {\n  Wrap,\n  Filter\n};\n\nexport { Filter, Wrap, Constants as default };\n", "/* eslint-disable no-bitwise */\n\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\n/* eslint-disable no-bitwise */\n/* This method is faster than the OpenEXR implementation (very often\n * used, eg. in Ogre), with the additional benefit of rounding, inspired\n * by James Tursa?s half-precision code. */\nfunction toHalf(val) {\n  floatView[0] = val;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000; /* Get the sign */\n  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n  const e = x >> 23 & 0xff; /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n  bits |= e - 112 << 10 | m >> 1;\n  /* Extra rounding. An overflow will set mantissa to 0 and increment\n   * the exponent, which is OK. */\n  bits += m & 1;\n  return bits;\n}\nfunction fromHalf(h) {\n  const s = (h & 0x8000) >> 15;\n  const e = (h & 0x7c00) >> 10;\n  const f = h & 0x03ff;\n  if (e === 0) {\n    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n  }\n  if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n}\nvar HalfFloat = {\n  fromHalf,\n  toHalf\n};\n\nexport { HalfFloat as default };\n", "import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst PASS_TYPES = ['Build', 'Render'];\n\n// ----------------------------------------------------------------------------\n// vtkViewNode methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkViewNode');\n\n  /**\n   * Convenient method to move a child to a specific index.\n   * @param {*} child the child to move\n   * @param {*} toIndex the index to move the child to\n   * @returns true if the child was moved, false otherwise\n   */\n  function moveChild(child, toIndex) {\n    for (let i = 0; i < model.children.length; ++i) {\n      // Start browsing from toIndex + 1\n      const childIndex = (toIndex + 1 + i) % model.children.length;\n      if (model.children[childIndex] === child) {\n        model.children[childIndex] = model.children[toIndex];\n        model.children[toIndex] = child;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Builds myself.\n  publicAPI.build = prepass => {};\n\n  // Renders myself\n  publicAPI.render = prepass => {};\n  publicAPI.traverse = renderPass => {\n    // we can choose to do special\n    // traversal here based on pass\n    const passTraversal = renderPass.getTraverseOperation();\n    const fn = publicAPI[passTraversal];\n    if (fn) {\n      fn(renderPass);\n      return;\n    }\n\n    // default traversal\n    publicAPI.apply(renderPass, true);\n    for (let index = 0; index < model.children.length; index++) {\n      model.children[index].traverse(renderPass);\n    }\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.apply = (renderPass, prepass) => {\n    const customRenderPass = publicAPI[renderPass.getOperation()];\n    if (customRenderPass) {\n      customRenderPass(prepass, renderPass);\n    }\n  };\n  publicAPI.getViewNodeFor = function (dataObject) {\n    let hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (hint && hint.renderable === dataObject) {\n      return hint;\n    }\n    if (model.renderable === dataObject) {\n      return publicAPI;\n    }\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const vn = child.getViewNodeFor(dataObject);\n      if (vn) {\n        return vn;\n      }\n    }\n    return undefined;\n  };\n  publicAPI.getFirstAncestorOfType = type => {\n    if (!model._parent) {\n      return null;\n    }\n    if (model._parent.isA(type)) {\n      return model._parent;\n    }\n    return model._parent.getFirstAncestorOfType(type);\n  };\n  publicAPI.getLastAncestorOfType = type => {\n    if (!model._parent) {\n      return null;\n    }\n    const lastAncestor = model._parent.getLastAncestorOfType(type);\n    if (lastAncestor) {\n      return lastAncestor;\n    }\n    if (model._parent.isA(type)) {\n      return model._parent;\n    }\n    return null;\n  };\n\n  // add a missing node/child for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNode = dobj => {\n    if (!dobj) {\n      return undefined;\n    }\n\n    // if found just mark as visited\n    const result = model._renderableChildMap.get(dobj);\n    if (result !== undefined) {\n      result.setVisited(true);\n      return result;\n    }\n\n    // otherwise create a node\n    const newNode = publicAPI.createViewNode(dobj);\n    if (newNode) {\n      newNode.setParent(publicAPI);\n      newNode.setVisited(true);\n      model._renderableChildMap.set(dobj, newNode);\n      model.children.push(newNode);\n      return newNode;\n    }\n    return undefined;\n  };\n\n  // add missing nodes/children for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNodes = function (dataObjs) {\n    let enforceOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!dataObjs || !dataObjs.length) {\n      return;\n    }\n    let nextIndex;\n    for (let index = 0; index < dataObjs.length; ++index) {\n      const dobj = dataObjs[index];\n      const node = publicAPI.addMissingNode(dobj);\n      if (enforceOrder && node !== undefined) {\n        if (nextIndex === undefined) {\n          // First node can be anywhere\n          nextIndex = model.children.lastIndexOf(node); // node is likely the list child\n        } else if (model.children[nextIndex] !== node) {\n          moveChild(model.children, node);\n        }\n        // Next node must follow current node\n        nextIndex++;\n      }\n    }\n  };\n\n  // ability to add children that have no renderable use in the same manner\n  // as addMissingNodes This case is when a normal viewnode wants to\n  // delegate passes to a helper or child that doeasn't map to a clear\n  // renderable or any renderable\n  publicAPI.addMissingChildren = children => {\n    if (!children || !children.length) {\n      return;\n    }\n    for (let index = 0; index < children.length; ++index) {\n      const child = children[index];\n      const cindex = model.children.indexOf(child);\n      if (cindex === -1) {\n        child.setParent(publicAPI);\n        model.children.push(child);\n        const childRenderable = child.getRenderable();\n        if (childRenderable) {\n          model._renderableChildMap.set(childRenderable, child);\n        }\n      }\n      child.setVisited(true);\n    }\n  };\n  publicAPI.removeNode = child => {\n    const childIdx = model.children.findIndex(x => x === child);\n    if (childIdx < 0) {\n      return false;\n    }\n    const renderable = child.getRenderable();\n    if (renderable) {\n      model._renderableChildMap.delete(renderable);\n    }\n    child.delete();\n    model.children.splice(childIdx, 1);\n    return true;\n  };\n  publicAPI.prepareNodes = () => {\n    for (let index = 0; index < model.children.length; ++index) {\n      model.children[index].setVisited(false);\n    }\n  };\n  publicAPI.setVisited = val => {\n    model.visited = val;\n  };\n  publicAPI.removeUnusedNodes = () => {\n    let visitedCount = 0;\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const visited = child.getVisited();\n      if (visited) {\n        model.children[visitedCount++] = child;\n        child.setVisited(false);\n      } else {\n        const renderable = child.getRenderable();\n        if (renderable) {\n          model._renderableChildMap.delete(renderable);\n        }\n        child.delete();\n      }\n    }\n    model.children.length = visitedCount;\n  };\n  publicAPI.createViewNode = dataObj => {\n    if (!model.myFactory) {\n      vtkErrorMacro('Cannot create view nodes without my own factory');\n      return null;\n    }\n    const ret = model.myFactory.createNode(dataObj);\n    if (ret) {\n      ret.setRenderable(dataObj);\n    }\n    return ret;\n  };\n  const parentDelete = publicAPI.delete;\n  publicAPI.delete = () => {\n    for (let i = 0; i < model.children.length; i++) {\n      model.children[i].delete();\n    }\n    parentDelete();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // _parent: null,\n  renderable: null,\n  myFactory: null,\n  children: [],\n  visited: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.event(publicAPI, model, 'event');\n  model._renderableChildMap = new Map();\n  macro.get(publicAPI, model, ['visited']);\n  macro.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);\n  macro.getArray(publicAPI, model, ['children']);\n  macro.moveToProtected(publicAPI, model, ['parent']);\n\n  // Object methods\n  vtkViewNode(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNode');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNode$1 = {\n  newInstance,\n  extend,\n  PASS_TYPES\n};\n\nexport { vtkViewNode$1 as default };\n", "import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkViewNodeFactory methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNodeFactory(publicAPI, model) {\n  // Make sure our overrides is just for our instance not shared with everyone...\n  if (!model.overrides) {\n    model.overrides = {};\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkViewNodeFactory');\n  publicAPI.createNode = dataObject => {\n    if (dataObject.isDeleted()) {\n      return null;\n    }\n    let cpt = 0;\n    let className = dataObject.getClassName(cpt++);\n    let isObject = false;\n    const keys = Object.keys(model.overrides);\n    while (className && !isObject) {\n      if (keys.indexOf(className) !== -1) {\n        isObject = true;\n      } else {\n        className = dataObject.getClassName(cpt++);\n      }\n    }\n    if (!isObject) {\n      return null;\n    }\n    const vn = model.overrides[className]();\n    vn.setMyFactory(publicAPI);\n    return vn;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // overrides: {},\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Object methods\n  vtkViewNodeFactory(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNodeFactory');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNodeFactory$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkViewNodeFactory$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkViewNodeFactory$1 from '../SceneGraph/ViewNodeFactory.js';\n\nconst CLASS_MAPPING = Object.create(null);\nfunction registerOverride(className, fn) {\n  CLASS_MAPPING[className] = fn;\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLViewNodeFactory methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLViewNodeFactory(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLViewNodeFactory');\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Static class mapping shared across instances\n  model.overrides = CLASS_MAPPING;\n\n  // Inheritance\n  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLViewNodeFactory(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLViewNodeFactory');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNodeFactory = {\n  newInstance,\n  extend\n};\n\nexport { vtkViewNodeFactory as default, extend, newInstance, registerOverride };\n", "/**\n * Even when the EXT_texture_norm16 extension is present, linear filtering\n * might not be supported for normalized fixed point textures.\n *\n * This is a driver bug. See https://github.com/KhronosGroup/WebGL/issues/3706\n * @return {boolean}\n */\nfunction supportsNorm16Linear() {\n  try {\n    const canvasSize = 4;\n    const texWidth = 2;\n    const texHeight = 1;\n    const texData = new Int16Array([0, 2 ** 15 - 1]);\n    const pixelToCheck = [1, 1];\n    const canvas = document.createElement('canvas');\n    canvas.width = canvasSize;\n    canvas.height = canvasSize;\n    const gl = canvas.getContext('webgl2');\n    if (!gl) {\n      return false;\n    }\n    const ext = gl.getExtension('EXT_texture_norm16');\n    if (!ext) {\n      return false;\n    }\n    const vs = `#version 300 es\n    void main() {\n      gl_PointSize = ${canvasSize.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `;\n    const fs = `#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    `;\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, vs);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      return false;\n    }\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, fs);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      return false;\n    }\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      return false;\n    }\n    const tex = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texImage2D(gl.TEXTURE_2D, 0, ext.R16_SNORM_EXT, texWidth, texHeight, 0, gl.RED, gl.SHORT, texData);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.useProgram(program);\n    gl.drawArrays(gl.POINTS, 0, 1);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    const [r, g, b] = pixel;\n    const webglLoseContext = gl.getExtension('WEBGL_lose_context');\n    if (webglLoseContext) {\n      webglLoseContext.loseContext();\n    }\n    return r === g && g === b && r !== 0;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * @type {boolean | undefined}\n */\nlet supportsNorm16LinearCache;\nfunction supportsNorm16LinearCached() {\n  // Only create a canvas+texture+shaders the first time\n  if (supportsNorm16LinearCache === undefined) {\n    supportsNorm16LinearCache = supportsNorm16Linear();\n  }\n  return supportsNorm16LinearCache;\n}\n\nexport { supportsNorm16LinearCached as default };\n", "import { m as macro } from '../../macros2.js';\n\n/* eslint-disable no-bitwise */\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUSampler methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSampler(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSampler');\n  publicAPI.create = function (device) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    model.device = device;\n    model.options.addressModeU = options.addressModeU ? options.addressModeU : 'clamp-to-edge';\n    model.options.addressModeV = options.addressModeV ? options.addressModeV : 'clamp-to-edge';\n    model.options.addressModeW = options.addressModeW ? options.addressModeW : 'clamp-to-edge';\n    model.options.magFilter = options.magFilter ? options.magFilter : 'nearest';\n    model.options.minFilter = options.minFilter ? options.minFilter : 'nearest';\n    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : 'nearest';\n    model.options.label = model.label;\n    model.handle = model.device.getHandle().createSampler(model.options);\n    model.bindGroupTime.modified();\n  };\n  publicAPI.getShaderCode = (binding, group) => {\n    const result = `@binding(${binding}) @group(${group}) var ${model.label}: sampler;`;\n    return result;\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: model.handle\n    };\n    return foo;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  device: null,\n  handle: null,\n  label: null,\n  options: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  model.options = {};\n  model.bindGroupLayoutEntry = {\n    /* eslint-disable no-undef */\n    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n    /* eslint-enable no-undef */\n    sampler: {\n      // type: 'filtering',\n    }\n  };\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  macro.get(publicAPI, model, ['bindGroupTime', 'handle', 'options']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label']);\n  vtkWebGPUSampler(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUSampler$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUSampler$1 as default, extend, newInstance };\n", "import { r as vtkErrorMacro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUDevice static functions\n//\n// WebGPU uses types in a many places and calls, and often those types\n// need to be associated with byte sizes, alignments, native arrays etc.\n// The folowing methods are designed to help vtk.js introspect those types.\n// WebGPU currently tends to use multiple type formats:\n//  - buffer types such as float32x4\n//  - shader types suchs as vec4<f32>\n//  - texture types such as rgba32float\n// ----------------------------------------------------------------------------\n\n// see https://gpuweb.github.io/gpuweb/#texture-formats\n// for possible formats, there are a lot of them\nconst textureDetails = {\n  // 8-bit formats\n  r8unorm: {\n    numComponents: 1,\n    nativeType: Uint8Array,\n    stride: 1,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  r8snorm: {\n    numComponents: 1,\n    nativeType: Int8Array,\n    stride: 1,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  r8uint: {\n    numComponents: 1,\n    nativeType: Uint8Array,\n    stride: 1,\n    elementSize: 1,\n    sampleType: 'uint'\n  },\n  r8sint: {\n    numComponents: 1,\n    nativeType: Int8Array,\n    stride: 1,\n    elementSize: 1,\n    sampleType: 'sint'\n  },\n  // 16-bit formats\n  r16uint: {\n    numComponents: 1,\n    nativeType: Uint16Array,\n    stride: 2,\n    elementSize: 2,\n    sampleType: 'uint'\n  },\n  r16sint: {\n    numComponents: 1,\n    nativeType: Int16Array,\n    stride: 2,\n    elementSize: 2,\n    sampleType: 'sint'\n  },\n  r16float: {\n    numComponents: 1,\n    nativeType: Float32Array,\n    stride: 2,\n    elementSize: 2,\n    sampleType: 'float'\n  },\n  rg8unorm: {\n    numComponents: 2,\n    nativeType: Uint8Array,\n    stride: 2,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  rg8snorm: {\n    numComponents: 2,\n    nativeType: Int8Array,\n    stride: 2,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  rg8uint: {\n    numComponents: 2,\n    nativeType: Uint8Array,\n    stride: 2,\n    elementSize: 1,\n    sampleType: 'uint'\n  },\n  rg8sint: {\n    numComponents: 2,\n    nativeType: Int8Array,\n    stride: 2,\n    elementSize: 1,\n    sampleType: 'sint'\n  },\n  // 32-bit formats\n  r32uint: {\n    numComponents: 1,\n    nativeType: Uint32Array,\n    stride: 4,\n    elementSize: 4,\n    sampleType: 'uint'\n  },\n  r32sint: {\n    numComponents: 1,\n    nativeType: Int32Array,\n    stride: 4,\n    elementSize: 4,\n    sampleType: 'sint'\n  },\n  r32float: {\n    numComponents: 1,\n    nativeType: Float32Array,\n    stride: 4,\n    elementSize: 4,\n    sampleType: 'unfilterable-float'\n  },\n  rg16uint: {\n    numComponents: 2,\n    nativeType: Uint16Array,\n    stride: 4,\n    elementSize: 2,\n    sampleType: 'uint'\n  },\n  rg16sint: {\n    numComponents: 2,\n    nativeType: Int16Array,\n    stride: 4,\n    elementSize: 2,\n    sampleType: 'sint'\n  },\n  rg16float: {\n    numComponents: 2,\n    nativeType: Float32Array,\n    stride: 4,\n    elementSize: 2,\n    sampleType: 'float'\n  },\n  rgba8unorm: {\n    numComponents: 4,\n    nativeType: Uint8Array,\n    stride: 4,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  'rgba8unorm-srgb': {\n    numComponents: 4,\n    nativeType: Uint8Array,\n    stride: 4,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  rgba8snorm: {\n    numComponents: 4,\n    nativeType: Int8Array,\n    stride: 4,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  rgba8uint: {\n    numComponents: 4,\n    nativeType: Uint8Array,\n    stride: 4,\n    elementSize: 1,\n    sampleType: 'uint'\n  },\n  rgba8sint: {\n    numComponents: 4,\n    nativeType: Int8Array,\n    stride: 4,\n    elementSize: 1,\n    sampleType: 'sint'\n  },\n  bgra8unorm: {\n    numComponents: 4,\n    nativeType: Uint8Array,\n    stride: 4,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  'bgra8unorm-srgb': {\n    numComponents: 4,\n    nativeType: Uint8Array,\n    stride: 4,\n    elementSize: 1,\n    sampleType: 'float'\n  },\n  // Packed 32-bit formats\n  rgb9e5ufloat: {\n    numComponents: 4,\n    nativeType: Uint32Array,\n    stride: 4,\n    sampleType: 'float'\n  },\n  rgb10a2unorm: {\n    numComponents: 4,\n    nativeType: Uint32Array,\n    stride: 4,\n    sampleType: 'float'\n  },\n  rg11b10ufloat: {\n    numComponents: 4,\n    nativeType: Float32Array,\n    stride: 4,\n    sampleType: 'float'\n  },\n  // 64-bit formats\n  rg32uint: {\n    numComponents: 2,\n    nativeType: Uint32Array,\n    stride: 8,\n    elementSize: 4,\n    sampleType: 'uint'\n  },\n  rg32sint: {\n    numComponents: 2,\n    nativeType: Int32Array,\n    stride: 8,\n    elementSize: 4,\n    sampleType: 'sint'\n  },\n  rg32float: {\n    numComponents: 2,\n    nativeType: Float32Array,\n    stride: 8,\n    elementSize: 4,\n    sampleType: 'unfilterable-float'\n  },\n  rgba16uint: {\n    numComponents: 4,\n    nativeType: Uint16Array,\n    stride: 8,\n    elementSize: 2,\n    sampleType: 'uint'\n  },\n  rgba16sint: {\n    numComponents: 4,\n    nativeType: Int16Array,\n    stride: 8,\n    elementSize: 2,\n    sampleType: 'sint'\n  },\n  rgba16float: {\n    numComponents: 4,\n    nativeType: Float32Array,\n    stride: 8,\n    elementSize: 2,\n    sampleType: 'float'\n  },\n  // 128-bit formats\n  rgba32uint: {\n    numComponents: 4,\n    nativeType: Uint32Array,\n    stride: 16,\n    elementSize: 4,\n    sampleType: 'uint'\n  },\n  rgba32sint: {\n    numComponents: 4,\n    nativeType: Int32Array,\n    stride: 16,\n    elementSize: 4,\n    sampleType: 'sint'\n  },\n  rgba32float: {\n    numComponents: 4,\n    nativeType: Float32Array,\n    stride: 16,\n    elementSize: 4,\n    sampleType: 'unfilterable-float'\n  },\n  // Depth and stencil formats\n  stencil8: {\n    numComponents: 1,\n    nativeType: Uint8Array,\n    stride: 1,\n    elementSize: 1,\n    sampleType: 'uint'\n  },\n  depth16unorm: {\n    numComponents: 1,\n    nativeType: Uint16Array,\n    stride: 2,\n    elementSize: 2,\n    sampleType: 'depth'\n  },\n  depth24plus: {\n    numComponents: 1,\n    nativeType: Uint32Array,\n    stride: 4,\n    elementSize: 3,\n    sampleType: 'depth'\n  },\n  'depth24plus-stencil8': {\n    numComponents: 2,\n    nativeType: Uint32Array,\n    stride: 4,\n    sampleType: 'mixed'\n  },\n  depth32float: {\n    numComponents: 1,\n    nativeType: Float32Array,\n    stride: 4,\n    elementSize: 4,\n    sampleType: 'depth'\n  }\n};\nfunction getDetailsFromTextureFormat(format) {\n  if (!format || format.length < 6) return 0;\n  if (format in textureDetails === true) {\n    return textureDetails[format];\n  }\n  vtkErrorMacro(`unknown format ${format}`);\n  return null;\n}\n\n// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat\n// for possible formats\nfunction getByteStrideFromBufferFormat(format) {\n  if (!format || format.length < 5) return 0;\n\n  // options are x2, x3, x4 or nothing\n  let numComp = 1;\n  if (format[format.length - 2] === 'x') {\n    numComp = Number(format[format.length - 1]);\n  }\n  const sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;\n  // options are 8, 16, 32 resulting in 8, 6, 2 as the last char\n  // plugged into the formula below gives 1, 2, 4 respectively\n  const num = Number(format[sizeStart]);\n  if (Number.isNaN(num)) {\n    vtkErrorMacro(`unknown format ${format}`);\n    return 0;\n  }\n  const typeSize = 5 - num / 2;\n  return numComp * typeSize;\n}\n\n// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat\n// for possible formats\nfunction getNumberOfComponentsFromBufferFormat(format) {\n  if (!format || format.length < 5) return 0;\n\n  // options are x2, x3, x4 or nothing\n  let numComp = 1;\n  if (format[format.length - 2] === 'x') {\n    numComp = Number(format[format.length - 1]);\n  }\n  return numComp;\n}\n\n// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat\n// for possible formats\nfunction getNativeTypeFromBufferFormat(format) {\n  if (!format || format.length < 5) return 0;\n\n  // raw types are Uint Int or Float as follows\n  let result;\n  if (format[0] === 'f') {\n    result = 'Float';\n  } else if (format[0] === 's') {\n    result = 'Int';\n  } else if (format[0] === 'u') {\n    result = 'Uint';\n  } else {\n    vtkErrorMacro(`unknown format ${format}`);\n    return undefined;\n  }\n\n  // options are 8, 16, 32 resulting in 8, 6, 2 as the last char\n  // plugged into the formula below gives 1, 2, 4 respectively\n  const base = format.split('x')[0];\n  const num = Number(base[base.length - 1]);\n  if (Number.isNaN(num)) {\n    vtkErrorMacro(`unknown format ${format}`);\n    return undefined;\n  }\n  result += 8 * (5 - num / 2);\n  result += 'Array';\n  return result;\n}\nfunction getShaderTypeFromBufferFormat(format) {\n  let dataType;\n  if (format[0] === 'f' || format[1] === 'n') {\n    dataType = 'f32';\n  } else if (format[0] === 's' && format[1] === 'i') {\n    dataType = 'i32';\n  } else if (format[0] === 'u' && format[1] === 'i') {\n    dataType = 'u32';\n  } else {\n    vtkErrorMacro(`unknown format ${format}`);\n    return undefined;\n  }\n\n  // options are x2, x3, x4 or nothing\n  let numComp = 1;\n  if (format[format.length - 2] === 'x') {\n    numComp = Number(format[format.length - 1]);\n  }\n  if (numComp === 4) return `vec4<${dataType}>`;\n  if (numComp === 3) return `vec3<${dataType}>`;\n  if (numComp === 2) return `vec2<${dataType}>`;\n  return dataType;\n}\nfunction getByteStrideFromShaderFormat(format) {\n  if (!format) return 0;\n  let numComp = 1;\n  if (format.substring(0, 3) === 'vec') {\n    numComp = Number(format[3]);\n  } else if (format.substring(0, 3) === 'mat') {\n    numComp = format[3] * format[5];\n  }\n  const typeSize = 4;\n  return numComp * typeSize;\n}\nfunction getNativeTypeFromShaderFormat(format) {\n  if (!format) return undefined;\n  if (format.includes('f32')) return 'Float32Array';\n  if (format.includes('i32')) return 'Int32Array';\n  if (format.includes('u32')) return 'Uint32Array';\n  vtkErrorMacro(`unknown format ${format}`);\n  return undefined;\n}\nvar vtkWebGPUTypes = {\n  getDetailsFromTextureFormat,\n  getByteStrideFromBufferFormat,\n  getNumberOfComponentsFromBufferFormat,\n  getNativeTypeFromBufferFormat,\n  getShaderTypeFromBufferFormat,\n  getByteStrideFromShaderFormat,\n  getNativeTypeFromShaderFormat\n};\n\nexport { vtkWebGPUTypes as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport vtkWebGPUTypes from './Types.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUTextureView methods\n// ----------------------------------------------------------------------------\n\n/* eslint-disable no-bitwise */\n\nfunction vtkWebGPUTextureView(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUTextureView');\n  publicAPI.create = (texture, options) => {\n    model.texture = texture;\n    model.options = options;\n    model.options.dimension = model.options.dimension || '2d';\n    model.options.label = model.label;\n    model.textureHandle = texture.getHandle();\n    model.handle = model.textureHandle.createView(model.options);\n    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;\n    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.texture.getFormat());\n    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;\n  };\n  publicAPI.createFromTextureHandle = (textureHandle, options) => {\n    model.texture = null;\n    model.options = options;\n    model.options.dimension = model.options.dimension || '2d';\n    model.options.label = model.label;\n    model.textureHandle = textureHandle;\n    model.handle = model.textureHandle.createView(model.options);\n    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;\n    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(options.format);\n    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;\n    model.bindGroupTime.modified();\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: publicAPI.getHandle()\n    };\n    return foo;\n  };\n  publicAPI.getShaderCode = (binding, group) => {\n    let ttype = 'f32';\n    if (model.bindGroupLayoutEntry.texture.sampleType === 'sint') {\n      ttype = 'i32';\n    } else if (model.bindGroupLayoutEntry.texture.sampleType === 'uint') {\n      ttype = 'u32';\n    }\n    let result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;\n    if (model.bindGroupLayoutEntry.texture.sampleType === 'depth') {\n      result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_depth_${model.options.dimension};`;\n    }\n    return result;\n  };\n  publicAPI.addSampler = (device, options) => {\n    const newSamp = vtkWebGPUSampler.newInstance({\n      label: `${model.label}Sampler`\n    });\n    newSamp.create(device, options);\n    publicAPI.setSampler(newSamp);\n  };\n  publicAPI.getBindGroupTime = () => {\n    // check if the handle changed\n    if (model.texture && model.texture.getHandle() !== model.textureHandle) {\n      model.textureHandle = model.texture.getHandle();\n      model.handle = model.textureHandle.createView(model.options);\n      model.bindGroupTime.modified();\n    }\n    return model.bindGroupTime;\n  };\n\n  // if the texture has changed then get a new view\n  publicAPI.getHandle = () => {\n    if (model.texture && model.texture.getHandle() !== model.textureHandle) {\n      model.textureHandle = model.texture.getHandle();\n      model.handle = model.textureHandle.createView(model.options);\n      model.bindGroupTime.modified();\n    }\n    return model.handle;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  texture: null,\n  handle: null,\n  sampler: null,\n  label: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  model.bindGroupLayoutEntry = {\n    /* eslint-disable no-undef */\n    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n    /* eslint-enable no-undef */\n    texture: {\n      sampleType: 'float',\n      viewDimension: '2d'\n      // multisampled: false,\n    }\n  };\n\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  macro.get(publicAPI, model, ['bindGroupTime', 'texture']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'label', 'sampler']);\n  vtkWebGPUTextureView(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUTextureView$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUTextureView$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport vtkWebGPUTextureView from './TextureView.js';\nimport vtkWebGPUTypes from './Types.js';\nimport vtkTexture from '../Core/Texture.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUTexture');\n  publicAPI.create = (device, options) => {\n    model.device = device;\n    model.width = options.width;\n    model.height = options.height;\n    model.depth = options.depth ? options.depth : 1;\n    const dimension = model.depth === 1 ? '2d' : '3d';\n    model.format = options.format ? options.format : 'rgba8unorm';\n    model.mipLevel = options.mipLevel ? options.mipLevel : 0;\n    /* eslint-disable no-undef */\n    /* eslint-disable no-bitwise */\n    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    /* eslint-enable no-undef */\n    /* eslint-enable no-bitwise */\n    model.handle = model.device.getHandle().createTexture({\n      size: [model.width, model.height, model.depth],\n      format: model.format,\n      // 'rgba8unorm',\n      usage: model.usage,\n      label: model.label,\n      dimension,\n      mipLevelCount: model.mipLevel + 1\n    });\n  };\n  publicAPI.assignFromHandle = (device, handle, options) => {\n    model.device = device;\n    model.handle = handle;\n    model.width = options.width;\n    model.height = options.height;\n    model.depth = options.depth ? options.depth : 1;\n    model.format = options.format ? options.format : 'rgba8unorm';\n    /* eslint-disable no-undef */\n    /* eslint-disable no-bitwise */\n    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    /* eslint-enable no-undef */\n    /* eslint-enable no-bitwise */\n  };\n\n  publicAPI.writeImageData = req => {\n    let nativeArray = [];\n    const _copyImageToTexture = source => {\n      model.device.getHandle().queue.copyExternalImageToTexture({\n        source,\n        flipY: req.flip\n      }, {\n        texture: model.handle,\n        premultipliedAlpha: true,\n        mipLevel: 0,\n        origin: {\n          x: 0,\n          y: 0,\n          z: 0\n        }\n      }, [source.width, source.height, model.depth]);\n\n      // Generate mipmaps on GPU if needed\n      if (publicAPI.getDimensionality() !== 3 && model.mipLevel > 0) {\n        vtkTexture.generateMipmaps(model.device.getHandle(), model.handle, model.mipLevel + 1);\n      }\n      model.ready = true;\n    };\n    if (req.canvas) {\n      _copyImageToTexture(req.canvas);\n      return;\n    }\n    if (req.imageBitmap) {\n      req.width = req.imageBitmap.width;\n      req.height = req.imageBitmap.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n      req.flip = true;\n      _copyImageToTexture(req.imageBitmap);\n      return;\n    }\n    if (req.jsImageData) {\n      req.width = req.jsImageData.width;\n      req.height = req.jsImageData.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n      req.flip = true;\n      _copyImageToTexture(req.jsImageData);\n      return;\n    }\n    if (req.image) {\n      req.width = req.image.width;\n      req.height = req.image.height;\n      req.depth = 1;\n      req.format = 'rgba8unorm';\n      req.flip = true;\n      _copyImageToTexture(req.image);\n      return;\n    }\n    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);\n    let bufferBytesPerRow = model.width * tDetails.stride;\n\n    /**\n     * Align texture data to ensure bytesPerRow is a multiple of 256.\n     * This is necessary for WebGPU texture uploads, especially for half-float formats.\n     * It also handles half-float conversion if the texture format requires it.\n     * @param {*} arr - The input array containing texture data.\n     * @param {*} height - The height of the texture.\n     * @param {*} depth - The depth of the texture (1 for 2D textures).\n     * @returns\n     */\n    const alignTextureData = (arr, height, depth) => {\n      // bytesPerRow must be a multiple of 256 so we might need to rebuild\n      // the data here before passing to the buffer. e.g. if it is unorm8x4 then\n      // we need to have width be a multiple of 64\n      // Check if the texture is half float\n      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n      const bytesPerElement = arr.BYTES_PER_ELEMENT;\n      const inWidthInBytes = arr.length / (height * depth) * bytesPerElement;\n\n      // No changes needed if not half float and already aligned\n      if (!halfFloat && inWidthInBytes % 256 === 0) {\n        return [arr, inWidthInBytes];\n      }\n\n      // Calculate dimensions for the new buffer\n      const inWidth = inWidthInBytes / bytesPerElement;\n      const outBytesPerElement = tDetails.elementSize;\n      const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);\n      const outWidth = outWidthInBytes / outBytesPerElement;\n\n      // Create the output array\n      const outArray = macro.newTypedArray(halfFloat ? 'Uint16Array' : arr.constructor.name, outWidth * height * depth);\n\n      // Copy and convert data when needed\n      const totalRows = height * depth;\n      if (halfFloat) {\n        for (let v = 0; v < totalRows; v++) {\n          const inOffset = v * inWidth;\n          const outOffset = v * outWidth;\n          for (let i = 0; i < inWidth; i++) {\n            outArray[outOffset + i] = HalfFloat.toHalf(arr[inOffset + i]);\n          }\n        }\n      } else if (outWidth === inWidth) {\n        // If the output width is the same as input, just copy\n        outArray.set(arr);\n      } else {\n        for (let v = 0; v < totalRows; v++) {\n          outArray.set(arr.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);\n        }\n      }\n      return [outArray, outWidthInBytes];\n    };\n    if (req.nativeArray) {\n      nativeArray = req.nativeArray;\n    }\n    const is3D = publicAPI.getDimensionality() === 3;\n    const alignedTextureData = alignTextureData(nativeArray, model.height, is3D ? model.depth : 1);\n    bufferBytesPerRow = alignedTextureData[1];\n    const data = alignedTextureData[0];\n    model.device.getHandle().queue.writeTexture({\n      texture: model.handle,\n      mipLevel: 0,\n      origin: {\n        x: 0,\n        y: 0,\n        z: 0\n      }\n    }, data, {\n      offset: 0,\n      bytesPerRow: bufferBytesPerRow,\n      rowsPerImage: model.height\n    }, {\n      width: model.width,\n      height: model.height,\n      depthOrArrayLayers: is3D ? model.depth : 1\n    });\n    if (!is3D && model.mipLevel > 0) {\n      vtkTexture.generateMipmaps(model.device.getHandle(), model.handle, model.mipLevel + 1);\n    }\n    model.ready = true;\n  };\n\n  // when data is pulled out of this texture what scale must be applied to\n  // get back to the original source data. For formats such as r8unorm we\n  // have to multiply by 255.0, for formats such as r16float it is 1.0\n  publicAPI.getScale = () => {\n    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);\n    const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n    return halfFloat ? 1.0 : 255.0;\n  };\n  publicAPI.getNumberOfComponents = () => {\n    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);\n    return tDetails.numComponents;\n  };\n  publicAPI.getDimensionality = () => {\n    let dims = 0;\n    if (model.width > 1) dims++;\n    if (model.height > 1) dims++;\n    if (model.depth > 1) dims++;\n    return dims;\n  };\n  publicAPI.resizeToMatch = tex => {\n    if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {\n      model.width = tex.getWidth();\n      model.height = tex.getHeight();\n      model.depth = tex.getDepth();\n      model.handle = model.device.getHandle().createTexture({\n        size: [model.width, model.height, model.depth],\n        format: model.format,\n        usage: model.usage,\n        label: model.label\n      });\n    }\n  };\n  publicAPI.resize = function (width, height) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    if (width !== model.width || height !== model.height || depth !== model.depth) {\n      model.width = width;\n      model.height = height;\n      model.depth = depth;\n      model.handle = model.device.getHandle().createTexture({\n        size: [model.width, model.height, model.depth],\n        format: model.format,\n        usage: model.usage,\n        label: model.label\n      });\n    }\n  };\n  publicAPI.createView = function (label) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // if options is missing values try to add them in\n    if (!options.dimension) {\n      options.dimension = model.depth === 1 ? '2d' : '3d';\n    }\n    const view = vtkWebGPUTextureView.newInstance({\n      label\n    });\n    view.create(publicAPI, options);\n    return view;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  device: null,\n  handle: null,\n  buffer: null,\n  ready: false,\n  label: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['handle', 'ready', 'width', 'height', 'depth', 'format', 'usage']);\n  macro.setGet(publicAPI, model, ['device', 'label']);\n  vtkWebGPUTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUTexture$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUTexture$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// export const SHADER_TYPES = ['Vertex', 'Fragment', 'Geometry', 'Unknown'];\n\n// ----------------------------------------------------------------------------\n// vtkShader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShader');\n  publicAPI.compile = () => {\n    let stype = model.context.VERTEX_SHADER;\n    if (!model.source || !model.source.length || model.shaderType === 'Unknown') {\n      return false;\n    }\n\n    // Ensure we delete the previous shader if necessary.\n    if (model.handle !== 0) {\n      model.context.deleteShader(model.handle);\n      model.handle = 0;\n    }\n    switch (model.shaderType) {\n      // case vtkShader::Geometry:\n      //   type = GL_GEOMETRY_SHADER;\n      //   break;\n      case 'Fragment':\n        stype = model.context.FRAGMENT_SHADER;\n        break;\n      case 'Vertex':\n      default:\n        stype = model.context.VERTEX_SHADER;\n        break;\n    }\n    model.handle = model.context.createShader(stype);\n    model.context.shaderSource(model.handle, model.source);\n    model.context.compileShader(model.handle);\n    const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);\n    if (!isCompiled) {\n      const lastError = model.context.getShaderInfoLog(model.handle);\n      vtkErrorMacro(`Error compiling shader '${model.source}': ${lastError}`);\n      model.context.deleteShader(model.handle);\n      model.handle = 0;\n      return false;\n    }\n\n    // The shader compiled, store its handle and return success.\n    return true;\n  };\n  publicAPI.cleanup = () => {\n    if (model.shaderType === 'Unknown' || model.handle === 0) {\n      return;\n    }\n    model.context.deleteShader(model.handle);\n    model.handle = 0;\n    model.dirty = true;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  shaderType: 'Unknown',\n  source: '',\n  error: '',\n  handle: 0,\n  dirty: false,\n  context: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['shaderType', 'source', 'error', 'handle', 'context']);\n\n  // Object methods\n  vtkShader(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShader');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShader$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkShader$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkShader from './Shader.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// perform in place string substitutions, indicate if a substitution was done\n// this is useful for building up shader strings which typically involve\n// lots of string substitutions. Return true if a substitution was done.\nfunction substitute(source, search, replace, all) {\n  // We only accept strings or array of strings, typeof is faster than Array.isArray\n  const replaceStr = typeof replace === 'string' ? replace : replace.join('\\n');\n\n  // We don't need to instantiate a RegExp if we don't want a global substitution.\n  // In all other cases, we need to take the provided string or RegExp and\n  // instantiate a new one to add the `g` flag.\n  // Argument defaults are transpiled to slow `arguments`-based operations\n  // better assume undefined as flag to know if the value is set or not\n  const replaceSearch = all === false ? search : new RegExp(search, 'g');\n  const resultstr = source.replace(replaceSearch, replaceStr);\n  return {\n    // If the result is different than the input, we did perform a replacement\n    replace: resultstr !== replaceStr,\n    result: resultstr\n  };\n}\n\n// ----------------------------------------------------------------------------\n// vtkShaderProgram methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderProgram(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderProgram');\n  publicAPI.compileShader = () => {\n    if (!model.vertexShader.compile()) {\n      vtkErrorMacro(model.vertexShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.vertexShader.getError());\n      return 0;\n    }\n    if (!model.fragmentShader.compile()) {\n      vtkErrorMacro(model.fragmentShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.fragmentShader.getError());\n      return 0;\n    }\n    // skip geometry for now\n    if (!publicAPI.attachShader(model.vertexShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.attachShader(model.fragmentShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.link()) {\n      vtkErrorMacro(`Links failed: ${model.error}`);\n      return 0;\n    }\n    publicAPI.setCompiled(true);\n    return 1;\n  };\n  publicAPI.cleanup = () => {\n    if (model.shaderType === 'Unknown' || model.handle === 0) {\n      return;\n    }\n    publicAPI.release();\n    if (model.vertexShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.vertexShaderHandle);\n      model.vertexShaderHandle = 0;\n    }\n    if (model.fragmentShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      model.fragmentShaderHandle = 0;\n    }\n    model.context.deleteProgram(model.handle);\n    model.handle = 0;\n    publicAPI.setCompiled(false);\n  };\n  publicAPI.bind = () => {\n    if (!model.linked && !publicAPI.link()) {\n      return false;\n    }\n    model.context.useProgram(model.handle);\n    publicAPI.setBound(true);\n    return true;\n  };\n  publicAPI.isBound = () => !!model.bound;\n  publicAPI.release = () => {\n    model.context.useProgram(null);\n    publicAPI.setBound(false);\n  };\n  publicAPI.setContext = ctx => {\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.link = () => {\n    if (model.linked) {\n      return true;\n    }\n    if (model.handle === 0) {\n      model.error = 'Program has not been initialized, and/or does not have shaders.';\n      return false;\n    }\n\n    // clear out the list of uniforms used\n    model.uniformLocs = {};\n    model.context.linkProgram(model.handle);\n    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);\n    if (!isCompiled) {\n      const lastError = model.context.getProgramInfoLog(model.handle);\n      vtkErrorMacro(`Error linking shader ${lastError}`);\n      model.handle = 0;\n      return false;\n    }\n    publicAPI.setLinked(true);\n    model.attributeLocs = {};\n    return true;\n  };\n  publicAPI.setUniformMatrix = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix4fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformMatrix3x3 = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix3fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformf = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1f(location, v);\n    return true;\n  };\n  publicAPI.setUniformfv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1fv(location, v);\n    return true;\n  };\n  publicAPI.setUniformi = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1i(location, v);\n    return true;\n  };\n  publicAPI.setUniformiv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2f = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2f(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2i = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2i(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3f = (name, a1, a2, a3) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (a3 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a1, a2, a3);\n    return true;\n  };\n  publicAPI.setUniform3fArray = (name, a) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (!Array.isArray(a) || a.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a[0], a[1], a[2]);\n    return true;\n  };\n  publicAPI.setUniform3fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3i(location, array[0], array[1], array[2]);\n    return true;\n  };\n  publicAPI.setUniform3iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4f = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4iv(location, v);\n    return true;\n  };\n  publicAPI.findUniform = name => {\n    if (!name || !model.linked) {\n      return -1;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    if (loc === null) {\n      model.error = `Uniform ${name} not found in current shader program.`;\n      model.uniformLocs[name] = -1;\n      return -1;\n    }\n    model.uniformLocs[name] = loc;\n    return loc;\n  };\n  publicAPI.isUniformUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc !== null;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    model.uniformLocs[name] = loc;\n    if (loc === null) {\n      return false;\n    }\n    return true;\n  };\n  publicAPI.isAttributeUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    if (name in model.attributeLocs) {\n      return true;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    const loc = model.context.getAttribLocation(model.handle, name);\n    if (loc === -1) {\n      return false;\n    }\n    model.attributeLocs[name] = loc;\n    return true;\n  };\n  publicAPI.attachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'Shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      const thandle = model.context.createProgram();\n      if (thandle === 0) {\n        model.error = 'Could not create shader program.';\n        return false;\n      }\n      model.handle = thandle;\n      model.linked = false;\n    }\n    if (shader.getShaderType() === 'Vertex') {\n      if (model.vertexShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.vertexShaderHandle);\n      }\n      model.vertexShaderHandle = shader.getHandle();\n    }\n    if (shader.getShaderType() === 'Fragment') {\n      if (model.fragmentShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      }\n      model.fragmentShaderHandle = shader.getHandle();\n    }\n    model.context.attachShader(model.handle, shader.getHandle());\n    publicAPI.setLinked(false);\n    return true;\n  };\n  publicAPI.detachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      model.error = 'This shader program has not been initialized yet.';\n    }\n    switch (shader.getShaderType()) {\n      case 'Vertex':\n        if (model.vertexShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.vertexShaderHandle = 0;\n        model.linked = false;\n        return true;\n      case 'Fragment':\n        if (model.fragmentShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.fragmentShaderHandle = 0;\n        model.linked = false;\n        return true;\n      default:\n        return false;\n    }\n  };\n  publicAPI.setContext = ctx => {\n    model.context = ctx;\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.setLastCameraMTime = mtime => {\n    model.lastCameraMTime = mtime;\n  };\n\n  // publicAPI.enableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.enableVertexAttribArray(location);\n  //   return true;\n  // };\n\n  // publicAPI.disableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.disableVertexAttribArray(location);\n  //   return true;\n  // };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  vertexShaderHandle: 0,\n  fragmentShaderHandle: 0,\n  geometryShaderHandle: 0,\n  vertexShader: null,\n  fragmentShader: null,\n  geometryShader: null,\n  linked: false,\n  bound: false,\n  compiled: false,\n  error: '',\n  handle: 0,\n  numberOfOutputs: 0,\n  attributesLocs: null,\n  uniformLocs: null,\n  md5Hash: 0,\n  context: null,\n  lastCameraMTime: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Instantiate internal objects\n  model.attributesLocs = {};\n  model.uniformLocs = {};\n  model.vertexShader = vtkShader.newInstance();\n  model.vertexShader.setShaderType('Vertex');\n  model.fragmentShader = vtkShader.newInstance();\n  model.fragmentShader.setShaderType('Fragment');\n  model.geometryShader = vtkShader.newInstance();\n  model.geometryShader.setShaderType('Geometry');\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['lastCameraMTime']);\n  macro.setGet(publicAPI, model, ['error', 'handle', 'compiled', 'bound', 'md5Hash', 'vertexShader', 'fragmentShader', 'geometryShader', 'linked']);\n\n  // Object methods\n  vtkShaderProgram(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShaderProgram');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShaderProgram$1 = {\n  newInstance,\n  extend,\n  substitute\n};\n\nexport { vtkShaderProgram$1 as default, substitute };\n", "const ObjectType = {\n  ARRAY_BUFFER: 0,\n  ELEMENT_ARRAY_BUFFER: 1,\n  TEXTURE_BUFFER: 2\n};\nvar Constants = {\n  ObjectType\n};\n\nexport { ObjectType, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport Constants from './BufferObject/Constants.js';\n\nconst {\n  ObjectType\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLBufferObject');\n\n  // Class-specific private functions\n  function convertType(type) {\n    switch (type) {\n      case ObjectType.ELEMENT_ARRAY_BUFFER:\n        return model.context.ELEMENT_ARRAY_BUFFER;\n      case ObjectType.TEXTURE_BUFFER:\n        if ('TEXTURE_BUFFER' in model.context) {\n          return model.context.TEXTURE_BUFFER;\n        }\n      /* eslint-disable no-fallthrough */\n      // Intentional fallthrough in case there is no TEXTURE_BUFFER in WebGL\n      case ObjectType.ARRAY_BUFFER:\n      default:\n        return model.context.ARRAY_BUFFER;\n      /* eslint-enable no-fallthrough */\n    }\n  }\n\n  let internalType = null;\n  let internalHandle = null;\n  let dirty = true;\n  let error = '';\n\n  // Public API methods\n  publicAPI.getType = () => internalType;\n  publicAPI.setType = value => {\n    internalType = value;\n  };\n  publicAPI.getHandle = () => internalHandle;\n  publicAPI.isReady = () => dirty === false;\n  publicAPI.generateBuffer = type => {\n    const objectTypeGL = convertType(type);\n    if (internalHandle === null) {\n      internalHandle = model.context.createBuffer();\n      internalType = type;\n    }\n    return convertType(internalType) === objectTypeGL;\n  };\n  publicAPI.upload = (data, type) => {\n    // buffer, size, type\n    const alreadyGenerated = publicAPI.generateBuffer(type);\n    if (!alreadyGenerated) {\n      error = 'Trying to upload array buffer to incompatible buffer.';\n      return false;\n    }\n    model.context.bindBuffer(convertType(internalType), internalHandle);\n    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);\n    model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;\n    dirty = false;\n    return true;\n  };\n  publicAPI.bind = () => {\n    if (!internalHandle) {\n      return false;\n    }\n    model.context.bindBuffer(convertType(internalType), internalHandle);\n    return true;\n  };\n  publicAPI.release = () => {\n    if (!internalHandle) {\n      return false;\n    }\n    model.context.bindBuffer(convertType(internalType), null);\n    return true;\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    if (internalHandle !== null) {\n      model.context.bindBuffer(convertType(internalType), null);\n      model.context.deleteBuffer(internalHandle);\n      internalHandle = null;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n  publicAPI.getError = () => error;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  objectType: ObjectType.ARRAY_BUFFER,\n  // _openGLRenderWindow: null,\n  context: null,\n  allocatedGPUMemoryInBytes: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['_openGLRenderWindow', 'allocatedGPUMemoryInBytes']);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n  vtkOpenGLBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkBufferObject = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkBufferObject as default, extend, newInstance };\n", "import { vec3, mat4, quat } from 'gl-matrix';\n\nfunction computeCoordShiftAndScale(points) {\n  // Find out if shift scale should be used\n  // Compute squares of diagonal size and distance from the origin\n  let diagSq = 0.0;\n  let distSq = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const range = points.getRange(i);\n    const delta = range[1] - range[0];\n    diagSq += delta * delta;\n    const distShift = 0.5 * (range[1] + range[0]);\n    distSq += distShift * distShift;\n  }\n  const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||\n  // If data is far from the origin relative to its size\n  Math.abs(Math.log10(diagSq)) > 3.0 ||\n  // If the size is huge when not far from the origin\n  diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n  if (useShiftAndScale) {\n    // Compute shift and scale vectors\n    const coordShift = new Float64Array(3);\n    const coordScale = new Float64Array(3);\n    for (let i = 0; i < 3; ++i) {\n      const range = points.getRange(i);\n      const delta = range[1] - range[0];\n      coordShift[i] = 0.5 * (range[1] + range[0]);\n      coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n    }\n    return {\n      useShiftAndScale,\n      coordShift,\n      coordScale\n    };\n  }\n  return {\n    useShiftAndScale,\n    coordShift: new Float32Array([0, 0, 0]),\n    coordScale: new Float32Array([1, 1, 1])\n  };\n}\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\nvar helpers = {\n  computeCoordShiftAndScale,\n  computeInverseShiftAndScaleMatrix\n};\n\nexport { computeCoordShiftAndScale, computeInverseShiftAndScaleMatrix, helpers as default };\n", "import { vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { computeCoordShiftAndScale, computeInverseShiftAndScaleMatrix } from './CellArrayBufferObject/helpers.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    }\n\n    // Figure out how big each block will be, currently 6 or 7 floats.\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;\n\n    // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n    if (options.customAttributes) {\n      options.customAttributes.forEach(a => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset, cellId) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i], cellId);\n        }\n      },\n      linesToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n        }\n      },\n      polysToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);\n          }\n        }\n      },\n      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 1], cellIdx);\n          }\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 2], cellIdx);\n          }\n        }\n      },\n      polysToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n          addAPoint(cellPts[offset + i + 2], cellIdx);\n        }\n      },\n      stripsToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);\n        }\n      }\n    };\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      }\n    };\n    let func = null;\n    let countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n    for (let index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    let vboidx = 0;\n    let ucidx = 0;\n\n    // Find out if shift scale should be used\n    const {\n      useShiftAndScale,\n      coordShift,\n      coordScale\n    } = computeCoordShiftAndScale(options.points);\n    if (useShiftAndScale) {\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    }\n\n    // Initialize the structures used to keep track of point ids and cell ids for selectors\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n    let pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(pointId, cellId) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = pointId;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n      ++pointCount;\n\n      // Vertices\n      pointIdx = pointId * 3;\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = pointId * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n      model.customData.forEach(attr => {\n        custIdx = pointId * attr.components;\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n      if (tcoordData !== null) {\n        if (options.useTCoordsPerCell) {\n          tcoordIdx = cellId * textureComponents;\n        } else {\n          tcoordIdx = pointId * textureComponents;\n        }\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = pointId * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n\n    // Browse the cell array: the index is at the beginning of a cell\n    // The value of 'array' at the position 'index' is the number of points in the cell\n    for (let index = 0; index < size; index += array[index] + 1, cellCount++) {\n      func(array[index], array, index + 1, cellCount + options.cellOffset);\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);\n\n  // Object specific methods\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance,\n  extend\n};\n\nexport { vtkCellArrayBufferObject as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport { ObjectType } from './BufferObject/Constants.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject');\n\n  // Public API methods\n  publicAPI.exposedMethod = () => {\n    // This is a publicly exposed method of this object\n  };\n  publicAPI.initialize = () => {\n    model.instancingExtension = null;\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');\n    }\n    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object');\n      // Start setting up VAO\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n  publicAPI.isReady = () =>\n  // We either probed and allocated a VAO, or are falling back as the current\n  // hardware does not support VAOs.\n  model.handleVAO !== 0 || model.supported === false;\n  publicAPI.bind = () => {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  publicAPI.release = () => {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.shaderProgramChanged = () => {\n    publicAPI.release();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    publicAPI.shaderProgramChanged();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);\n  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {\n    if (!program) {\n      return false;\n    }\n\n    // Check the program is bound, and the buffer is valid.\n    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {\n      return false;\n    }\n\n    // Perform initialization if necessary, ensure program matches VAOs.\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n    const gl = model.context;\n    const attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n    if (attribs.Index === -1) {\n      return false;\n    }\n\n    // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n    attribs.buffer = buffer.getHandle();\n\n    // If vertex array objects are not supported then build up our list.\n    if (!model.supported) {\n      // find the buffer\n      let buffFound = false;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          let found = false;\n          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            const attrIt = buff.attributes[iatt];\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n      if (!buffFound) {\n        model.buffers.push({\n          buffer: attribs.buffer,\n          attributes: [attribs]\n        });\n      }\n    }\n    return true;\n  };\n  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {\n    // bind the first row of values\n    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);\n    if (!result) {\n      return result;\n    }\n    const gl = model.context;\n    const index = gl.getAttribLocation(model.handleProgram, name);\n    for (let i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.removeAttributeArray = name => {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    }\n\n    // If we don't have real VAOs find the entry and remove it too.\n    if (!model.supported) {\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects initialization\n  model.buffers = [];\n\n  // Object methods\n  macro.obj(publicAPI, model);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['supported']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['forceEmulation']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLVertexArrayObject');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVertexArrayObject = {\n  newInstance,\n  extend\n};\n\nexport { vtkVertexArrayObject as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCellArrayBufferObject from './CellArrayBufferObject.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport { Representation } from '../Core/Property/Constants.js';\n\nconst primTypes = {\n  Start: 0,\n  Points: 0,\n  Lines: 1,\n  Tris: 2,\n  TriStrips: 3,\n  TrisEdges: 4,\n  TriStripsEdges: 5,\n  End: 6\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHelper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHelper');\n  publicAPI.setOpenGLRenderWindow = win => {\n    model.context = win.getContext();\n    model.program.setContext(model.context);\n    model.VAO.setOpenGLRenderWindow(win);\n    model.CABO.setOpenGLRenderWindow(win);\n  };\n  publicAPI.releaseGraphicsResources = oglwin => {\n    model.VAO.releaseGraphicsResources();\n    model.CABO.releaseGraphicsResources();\n    model.CABO.setElementCount(0);\n  };\n  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {\n    // Are there any entries\n    if (model.CABO.getElementCount()) {\n      // are we drawing edges\n      const mode = publicAPI.getOpenGLMode(rep);\n      const wideLines = publicAPI.haveWideLines(ren, actor);\n      const gl = model.context;\n      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);\n      if (model.pointPicking) {\n        gl.depthMask(false);\n      }\n      const drawingLines = mode === gl.LINES;\n      if (drawingLines && wideLines) {\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));\n      } else {\n        gl.lineWidth(actor.getProperty().getLineWidth());\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArrays(mode, 0, model.CABO.getElementCount());\n        // reset the line width\n        gl.lineWidth(1);\n      }\n      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);\n      if (model.pointPicking) {\n        gl.depthMask(depthMask);\n      }\n      return model.CABO.getElementCount() / stride;\n    }\n    return 0;\n  };\n  publicAPI.getOpenGLMode = rep => {\n    if (model.pointPicking) {\n      return model.context.POINTS;\n    }\n    const type = model.primitiveType;\n    if (rep === Representation.POINTS || type === primTypes.Points) {\n      return model.context.POINTS;\n    }\n    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {\n      return model.context.LINES;\n    }\n    return model.context.TRIANGLES;\n  };\n  publicAPI.haveWideLines = (ren, actor) => {\n    if (actor.getProperty().getLineWidth() > 1.0) {\n      // we have wide lines, but the OpenGL implementation may\n      // actually support them, check the range to see if we\n      // really need have to implement our own wide lines\n      if (model.CABO.getOpenGLRenderWindow()) {\n        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // mapper modified (lighting complexity)\n    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      oglMapper.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== publicAPI.getProgram()) {\n        publicAPI.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        publicAPI.getVAO().releaseGraphicsResources();\n      }\n      publicAPI.getShaderSourceTime().modified();\n    } else {\n      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());\n    }\n    publicAPI.getVAO().bind();\n    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);\n    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);\n    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);\n    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);\n    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (ren, actor, size) => {\n    if (publicAPI.haveWideLines(ren, actor)) {\n      publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);\n      const lineWidth = parseFloat(actor.getProperty().getLineWidth());\n      const halfLineWidth = lineWidth / 2.0;\n      publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));\n      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);\n    }\n    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {\n      publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());\n    } else if (model.pointPicking) {\n      publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n\n    // Always set point size in case we need picking\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result;\n\n    // for lines, make sure we add the width code\n    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;\n    }\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.getPointPickingPrimitiveSize = () => {\n    if (model.primitiveType === primTypes.Points) {\n      return 2;\n    }\n    if (model.primitiveType === primTypes.Lines) {\n      return 4;\n    }\n    return 6;\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  program: null,\n  shaderSourceTime: null,\n  VAO: null,\n  attributeUpdateTime: null,\n  CABO: null,\n  primitiveType: 0,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  model.shaderSourceTime = {};\n  macro.obj(model.shaderSourceTime);\n  model.attributeUpdateTime = {};\n  macro.obj(model.attributeUpdateTime);\n  macro.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);\n  model.program = vtkShaderProgram.newInstance();\n  model.VAO = vtkVertexArrayObject.newInstance();\n  model.CABO = vtkCellArrayBufferObject.newInstance();\n\n  // Object methods\n  vtkOpenGLHelper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkHelper = {\n  newInstance,\n  extend,\n  primTypes\n};\n\nexport { vtkHelper as default, extend, newInstance, primTypes };\n", "import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUBindGroup methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUBindGroup(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUBindGroup');\n  publicAPI.setBindables = bindables => {\n    // is there a difference between the old and new list?\n    if (model.bindables.length === bindables.length) {\n      let allMatch = true;\n      for (let i = 0; i < model.bindables.length; i++) {\n        if (model.bindables[i] !== bindables[i]) {\n          allMatch = false;\n        }\n      }\n      if (allMatch) {\n        return;\n      }\n    }\n\n    // there is a difference\n    model.bindables = bindables;\n    publicAPI.modified();\n  };\n  publicAPI.getBindGroupLayout = device => {\n    const entries = [];\n    for (let i = 0; i < model.bindables.length; i++) {\n      const entry = model.bindables[i].getBindGroupLayoutEntry();\n      entry.binding = i;\n      entries.push(entry);\n    }\n    return device.getBindGroupLayout({\n      entries\n    });\n  };\n  publicAPI.getBindGroup = device => {\n    // check mtime\n    let mtime = publicAPI.getMTime();\n    for (let i = 0; i < model.bindables.length; i++) {\n      const tm = model.bindables[i].getBindGroupTime().getMTime();\n      mtime = tm > mtime ? tm : mtime;\n    }\n    if (mtime < model.bindGroupTime.getMTime()) {\n      return model.bindGroup;\n    }\n    const entries = [];\n    for (let i = 0; i < model.bindables.length; i++) {\n      const entry = model.bindables[i].getBindGroupEntry();\n      entry.binding = i;\n      entries.push(entry);\n    }\n    model.bindGroup = device.getHandle().createBindGroup({\n      layout: publicAPI.getBindGroupLayout(device),\n      entries,\n      label: model.label\n    });\n    model.bindGroupTime.modified();\n    return model.bindGroup;\n  };\n  publicAPI.getShaderCode = pipeline => {\n    const lines = [];\n    const bgroup = pipeline.getBindGroupLayoutCount(model.label);\n    for (let i = 0; i < model.bindables.length; i++) {\n      lines.push(model.bindables[i].getShaderCode(i, bgroup));\n    }\n    return lines.join('\\n');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  device: null,\n  handle: null,\n  label: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  model.bindables = [];\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  macro.get(publicAPI, model, ['bindGroupTime', 'handle', 'sizeInBytes', 'usage']);\n  macro.setGet(publicAPI, model, ['label', 'device', 'arrayInformation']);\n  vtkWebGPUBindGroup(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUBindGroup$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUBindGroup$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUShaderModule methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUShaderModule(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUShaderModule');\n  publicAPI.initialize = (device, shaderDesc) => {\n    model.device = device;\n    // console.log(shaderDesc.getCode());\n    model.handle = model.device.getHandle().createShaderModule({\n      code: shaderDesc.getCode()\n    });\n  };\n\n  // publicAPI.setLastCameraMTime = (mtime) => {\n  //   model.lastCameraMTime = mtime;\n  // };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  device: null,\n  handle: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['lastCameraMTime']);\n  macro.setGet(publicAPI, model, ['device', 'handle']);\n\n  // Object methods\n  vtkWebGPUShaderModule(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUShaderModule');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUShaderModule$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUShaderModule$1 as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtkWebGPUShaderModule from './ShaderModule.js';\n\n// perform in place string substitutions, indicate if a substitution was done\n// this is useful for building up shader strings which typically involve\n// lots of string substitutions. Return true if a substitution was done.\nfunction substitute(source, search, replace) {\n  let all = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const replaceStr = Array.isArray(replace) ? replace.join('\\n') : replace;\n  let replaced = false;\n  if (source.search(search) !== -1) {\n    replaced = true;\n  }\n  let gflag = '';\n  if (all) {\n    gflag = 'g';\n  }\n  const regex = new RegExp(search, gflag);\n  const resultstr = source.replace(regex, replaceStr);\n  return {\n    replace: replaced,\n    result: resultstr\n  };\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUShaderCache methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUShaderCache(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUShaderCache');\n  publicAPI.getShaderModule = shaderDesc => {\n    // has it already been created?\n    const sType = shaderDesc.getType();\n    const sHash = shaderDesc.getHash();\n    const keys = model._shaderModules.keys();\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key.getHash() === sHash && key.getType() === sType) {\n        return model._shaderModules.get(key);\n      }\n    }\n\n    // console.log(JSON.stringify(shaderDesc));\n\n    const sm = vtkWebGPUShaderModule.newInstance();\n    sm.initialize(model.device, shaderDesc);\n    model._shaderModules.set(shaderDesc, sm);\n    return sm;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  shaderModules: null,\n  device: null,\n  window: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects\n  model._shaderModules = new Map();\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['device', 'window']);\n\n  // Object methods\n  vtkWebGPUShaderCache(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUShaderCache');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUShaderCache$1 = {\n  newInstance,\n  extend,\n  substitute\n};\n\nexport { vtkWebGPUShaderCache$1 as default, extend, newInstance };\n", "import { n as newInstance$1, o as obj, g as get, e as setGet } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUPipeline methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUPipeline(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUPipeline');\n  publicAPI.getShaderDescriptions = () => model.shaderDescriptions;\n  publicAPI.initialize = (device, hash) => {\n    // start with the renderencoder settings\n    model.pipelineDescription = model.renderEncoder.getPipelineSettings();\n    model.pipelineDescription.primitive.topology = model.topology;\n    model.pipelineDescription.vertex = model.vertexState;\n    model.pipelineDescription.label = hash;\n\n    // add in bind group layouts\n    const bindGroupLayouts = [];\n    for (let i = 0; i < model.layouts.length; i++) {\n      bindGroupLayouts.push(model.layouts[i].layout);\n    }\n    model.pipelineLayout = device.getHandle().createPipelineLayout({\n      bindGroupLayouts\n    });\n    model.pipelineDescription.layout = model.pipelineLayout;\n    for (let i = 0; i < model.shaderDescriptions.length; i++) {\n      const sd = model.shaderDescriptions[i];\n      const sm = device.getShaderModule(sd);\n      if (sd.getType() === 'vertex') {\n        model.pipelineDescription.vertex.module = sm.getHandle();\n        model.pipelineDescription.vertex.entryPoint = 'main';\n      }\n      if (sd.getType() === 'fragment') {\n        model.pipelineDescription.fragment.module = sm.getHandle();\n        model.pipelineDescription.fragment.entryPoint = 'main';\n      }\n    }\n    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);\n  };\n  publicAPI.getShaderDescription = stype => {\n    for (let i = 0; i < model.shaderDescriptions.length; i++) {\n      if (model.shaderDescriptions[i].getType() === stype) return model.shaderDescriptions[i];\n    }\n    return null;\n  };\n  publicAPI.addBindGroupLayout = bindGroup => {\n    if (!bindGroup) {\n      return;\n    }\n    model.layouts.push({\n      layout: bindGroup.getBindGroupLayout(model.device),\n      label: bindGroup.getLabel()\n    });\n  };\n  publicAPI.getBindGroupLayout = idx => model.layouts[idx].layout;\n  publicAPI.getBindGroupLayoutCount = llabel => {\n    for (let i = 0; i < model.layouts.length; i++) {\n      if (model.layouts[i].label === llabel) {\n        return i;\n      }\n    }\n    return 0;\n  };\n  publicAPI.bindVertexInput = (renderEncoder, vInput) => {\n    vInput.bindBuffers(renderEncoder);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  handle: null,\n  layouts: null,\n  renderEncoder: null,\n  shaderDescriptions: null,\n  vertexState: null,\n  topology: null,\n  pipelineDescription: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  model.layouts = [];\n  model.shaderDescriptions = [];\n  get(publicAPI, model, ['handle', 'pipelineDescription']);\n  setGet(publicAPI, model, ['device', 'renderEncoder', 'topology', 'vertexState']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUPipeline(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPUPipeline');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPUPipeline$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUPipeline$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUShaderDescription methods\n// ----------------------------------------------------------------------------\n\n// shader description\n\nfunction vtkWebGPUShaderDescription(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUShaderDescription');\n  publicAPI.hasOutput = name => model.outputNames.includes(name);\n  publicAPI.addOutput = function (type, name) {\n    let interpolation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    model.outputTypes.push(type);\n    model.outputNames.push(name);\n    model.outputInterpolations.push(interpolation);\n  };\n  publicAPI.addBuiltinOutput = (type, name) => {\n    model.builtinOutputTypes.push(type);\n    model.builtinOutputNames.push(name);\n  };\n  publicAPI.addBuiltinInput = (type, name) => {\n    model.builtinInputTypes.push(type);\n    model.builtinInputNames.push(name);\n  };\n\n  // perform shader replacements for the input and outputs\n  // of this shader. That includes vertex inputs if specified\n  publicAPI.replaceShaderCode = (priorStage, vertexInput) => {\n    const inputImpl = [];\n    let iodec = [];\n    if (vertexInput) {\n      inputImpl.push(vertexInput.getShaderCode());\n    }\n    if (priorStage || model.builtinInputNames.length) {\n      const inputStruct = [];\n      inputStruct.push(`struct ${model.type}Input\\n{`);\n      if (priorStage) {\n        const inputNames = priorStage.getOutputNamesByReference();\n        const inputTypes = priorStage.getOutputTypesByReference();\n        const inputInterpolations = priorStage.getOutputInterpolationsByReference();\n        for (let i = 0; i < inputNames.length; i++) {\n          if (inputInterpolations[i] !== undefined) {\n            inputStruct.push(`  @location(${i}) @interpolate(${inputInterpolations[i]}) ${inputNames[i]} : ${inputTypes[i]},`);\n          } else {\n            inputStruct.push(`  @location(${i}) ${inputNames[i]} : ${inputTypes[i]},`);\n          }\n        }\n      }\n      for (let i = 0; i < model.builtinInputNames.length; i++) {\n        inputStruct.push(`  ${model.builtinInputNames[i]} : ${model.builtinInputTypes[i]},`);\n      }\n      if (inputStruct.length > 1) {\n        inputStruct.push('};');\n        iodec = inputStruct;\n        inputImpl[inputImpl.length - 1] += ',';\n        inputImpl.push(`input: ${model.type}Input`);\n      }\n    }\n    if (inputImpl.length) {\n      model.code = vtkWebGPUShaderCache.substitute(model.code, '//VTK::IOStructs::Input', inputImpl).result;\n    }\n    if (model.outputNames.length + model.builtinOutputNames.length) {\n      const outputStruct = [`struct ${model.type}Output\\n{`];\n      for (let i = 0; i < model.outputNames.length; i++) {\n        if (model.outputInterpolations[i] !== undefined) {\n          outputStruct.push(`  @location(${i}) @interpolate(${model.outputInterpolations[i]}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);\n        } else {\n          outputStruct.push(`  @location(${i}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);\n        }\n      }\n      for (let i = 0; i < model.builtinOutputNames.length; i++) {\n        outputStruct.push(`  ${model.builtinOutputNames[i]} : ${model.builtinOutputTypes[i]},`);\n      }\n      outputStruct.push('};');\n      iodec = iodec.concat(outputStruct);\n      model.code = vtkWebGPUShaderCache.substitute(model.code, '//VTK::IOStructs::Output', [`-> ${model.type}Output`]).result;\n    }\n    model.code = vtkWebGPUShaderCache.substitute(model.code, '//VTK::IOStructs::Dec', iodec).result;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  type: null,\n  // 'vertex' or 'fragment'\n  hash: null,\n  code: null,\n  outputNames: null,\n  outputTypes: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  model.outputNames = [];\n  model.outputTypes = [];\n  model.outputInterpolations = [];\n  model.builtinOutputNames = [];\n  model.builtinOutputTypes = [];\n  model.builtinInputNames = [];\n  model.builtinInputTypes = [];\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['type', 'hash', 'code']);\n  macro.getArray(publicAPI, model, ['outputTypes', 'outputNames', 'outputInterpolations']);\n\n  // Object methods\n  vtkWebGPUShaderDescription(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUShaderDescription');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUShaderDescription$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUShaderDescription$1 as default, extend, newInstance };\n", "import { n as newInstance$1, o as obj, e as setGet } from '../../macros2.js';\nimport vtkWebGPUTypes from './Types.js';\n\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!b.includes(a[i])) return false;\n  }\n  return true;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUVertexInput methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUVertexInput(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVertexInput');\n  publicAPI.addBuffer = function (buffer, inames) {\n    let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';\n    let names = inames;\n    if (!Array.isArray(names)) {\n      names = [names];\n    }\n    // only add if it is a new setting\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (arraysEqual(model.inputs[i].names, names)) {\n        if (model.inputs[i].buffer === buffer) {\n          return;\n        }\n        model.inputs[i].buffer = buffer;\n        return;\n      }\n    }\n\n    // when adding a new entry, make sure we sort the array\n    // as the order is important to the shader and must always\n    // be the same, so alphabetical is an easy option\n    model.inputs.push({\n      buffer,\n      stepMode,\n      names\n    });\n    model.inputs = model.inputs.sort((v1, v2) => {\n      if (v1.names[0] < v2.names[0]) {\n        return -1;\n      }\n      if (v1.names[0] > v2.names[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  };\n  publicAPI.removeBufferIfPresent = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        model.inputs.splice(i, 1);\n      }\n    }\n  };\n  publicAPI.getBuffer = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer;\n      }\n    }\n    return null;\n  };\n  publicAPI.hasAttribute = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  publicAPI.getAttributeTime = name => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer.getSourceTime();\n      }\n    }\n    return 0;\n  };\n  publicAPI.getShaderCode = () => {\n    let result = '';\n    let nameCount = 0;\n    for (let i = 0; i < model.inputs.length; i++) {\n      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];\n        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);\n        if (nameCount > 0) {\n          result += ',\\n';\n        }\n        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;\n        nameCount++;\n      }\n    }\n    return result;\n  };\n  publicAPI.getVertexInputInformation = () => {\n    const info = {};\n    if (model.inputs.length) {\n      const vertexBuffers = [];\n      let nameCount = 0;\n      for (let i = 0; i < model.inputs.length; i++) {\n        const buf = model.inputs[i].buffer;\n        const buffer = {\n          arrayStride: buf.getStrideInBytes(),\n          stepMode: model.inputs[i].stepMode,\n          attributes: []\n        };\n        const arrayInfo = buf.getArrayInformation();\n        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {\n          buffer.attributes.push({\n            shaderLocation: nameCount,\n            offset: arrayInfo[nm].offset,\n            format: arrayInfo[nm].format\n          });\n          nameCount++;\n        }\n        vertexBuffers.push(buffer);\n      }\n      info.buffers = vertexBuffers;\n    }\n    return info;\n  };\n  publicAPI.bindBuffers = renderEncoder => {\n    for (let i = 0; i < model.inputs.length; i++) {\n      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());\n    }\n    if (model.indexBuffer) {\n      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);\n    }\n  };\n  publicAPI.getReady = () => {};\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.created) {\n      model.inputs = [];\n      model.bindingDescriptions = [];\n      model.attributeDescriptions = [];\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  inputs: null,\n  bindingDescriptions: false,\n  attributeDescriptions: null,\n  indexBuffer: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  model.bindingDescriptions = [];\n  model.attributeDescriptions = [];\n  model.inputs = [];\n  setGet(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUVertexInput(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPUVertexInput');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPUVertexInput$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUVertexInput$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUPipeline from './Pipeline.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUShaderDescription from './ShaderDescription.js';\nimport vtkWebGPUVertexInput from './VertexInput.js';\n\nconst vtkWebGPUSimpleMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\nconst vtkWebGPUSimpleMapperFS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUSimpleMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSimpleMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSimpleMapper');\n  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {\n    // create the shader descriptions\n    const vDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'vertex',\n      hash,\n      code: model.vertexShaderTemplate\n    });\n    const fDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'fragment',\n      hash,\n      code: model.fragmentShaderTemplate\n    });\n\n    // add them to the pipeline\n    const sdrs = pipeline.getShaderDescriptions();\n    sdrs.push(vDesc);\n    sdrs.push(fDesc);\n\n    // look for replacements to invoke\n    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;\n    // eslint-disable-next-line prefer-regex-literals\n    const re = new RegExp('//VTK::[^:]*::', 'g');\n    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);\n    const fnames = unique.map(v => `replaceShader${v.substring(7, v.length - 2)}`);\n\n    // now invoke shader replacement functions\n    for (let i = 0; i < fnames.length; i++) {\n      const fname = fnames[i];\n      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {\n        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);\n      }\n    }\n\n    // always replace the IOStructs last as other replacement funcs may\n    // add inputs or outputs\n    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);\n\n    // console.log(vDesc.getCode());\n    // console.log(fDesc.getCode());\n  };\n\n  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.replaceShaderCode(null, vertexInput);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.replaceShaderCode(vDesc);\n  };\n  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {\n    model.renderEncoder.replaceShaderCode(pipeline);\n  };\n  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);\n  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {\n    if (!model.WebGPURenderer) {\n      return;\n    }\n    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);\n  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {\n    const ubocode = model.bindGroup.getShaderCode(pipeline);\n    const vDesc = pipeline.getShaderDescription('vertex');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec2<f32>', 'tcoordVS');\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.addTextureView = view => {\n    // is it already there?\n    if (model.textureViews.includes(view)) {\n      return;\n    }\n    model.textureViews.push(view);\n  };\n\n  // do everything required for this mapper to be rerady to draw\n  // but do not bind or do the actual draw commands as the pipeline\n  // is not neccessarily bound yet\n  publicAPI.prepareToDraw = renderEncoder => {\n    model.renderEncoder = renderEncoder;\n\n    // do anything needed to get our input data up to date\n    publicAPI.updateInput();\n\n    // make sure buffers are created and up to date\n    publicAPI.updateBuffers();\n\n    // update bindings and bind groups/layouts\n    // does not acutally bind them, that is done in draw(...)\n    publicAPI.updateBindings();\n\n    // update the pipeline, includes computing the hash, and if needed\n    // creating the pipeline, shader code etc\n    publicAPI.updatePipeline();\n  };\n  publicAPI.updateInput = () => {};\n  publicAPI.updateBuffers = () => {};\n  publicAPI.updateBindings = () => {\n    // bindings can change without a pipeline change\n    // as long as their layout remains the same.\n    // That is why this is done even when the pipeline\n    // hash doesn't change.\n    model.bindGroup.setBindables(publicAPI.getBindables());\n  };\n  publicAPI.computePipelineHash = () => {};\n  publicAPI.registerDrawCallback = encoder => {\n    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n  publicAPI.prepareAndDraw = encoder => {\n    publicAPI.prepareToDraw(encoder);\n    encoder.setPipeline(model.pipeline);\n    publicAPI.draw(encoder);\n  };\n\n  // do the rest of the calls required to draw this mapper\n  // at this point the command encouder and pipeline are\n  // created and bound\n  publicAPI.draw = renderEncoder => {\n    const pipeline = renderEncoder.getBoundPipeline();\n\n    // bind the mapper bind group\n    renderEncoder.activateBindGroup(model.bindGroup);\n    if (model.WebGPURenderer) {\n      model.WebGPURenderer.bindUBO(renderEncoder);\n    }\n\n    // bind the vertex input\n    pipeline.bindVertexInput(renderEncoder, model.vertexInput);\n    const indexBuffer = model.vertexInput.getIndexBuffer();\n    if (indexBuffer) {\n      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);\n    } else {\n      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);\n    }\n  };\n  publicAPI.getBindables = () => {\n    const bindables = [...model.additionalBindables];\n    if (model.UBO) {\n      bindables.push(model.UBO);\n    }\n    if (model.SSBO) {\n      bindables.push(model.SSBO);\n    }\n\n    // add texture BindGroupLayouts\n    for (let t = 0; t < model.textureViews.length; t++) {\n      bindables.push(model.textureViews[t]);\n      const samp = model.textureViews[t].getSampler();\n      if (samp) {\n        bindables.push(samp);\n      }\n    }\n    return bindables;\n  };\n  publicAPI.updatePipeline = () => {\n    publicAPI.computePipelineHash();\n    model.pipeline = model.device.getPipeline(model.pipelineHash);\n\n    // build the pipeline if needed\n    if (!model.pipeline) {\n      model.pipeline = vtkWebGPUPipeline.newInstance();\n      model.pipeline.setDevice(model.device);\n      if (model.WebGPURenderer) {\n        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());\n      }\n      model.pipeline.addBindGroupLayout(model.bindGroup);\n      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);\n      model.pipeline.setTopology(model.topology);\n      model.pipeline.setRenderEncoder(model.renderEncoder);\n      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());\n      model.device.createPipeline(model.pipelineHash, model.pipeline);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  additionalBindables: undefined,\n  bindGroup: null,\n  device: null,\n  fragmentShaderTemplate: null,\n  numberOfInstances: 1,\n  numberOfVertices: 0,\n  pipelineHash: null,\n  shaderReplacements: null,\n  SSBO: null,\n  textureViews: null,\n  topology: 'triangle-list',\n  UBO: null,\n  vertexShaderTemplate: null,\n  WebGPURenderer: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.textureViews = [];\n  model.vertexInput = vtkWebGPUVertexInput.newInstance();\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'mapperBG'\n  });\n  model.additionalBindables = [];\n  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;\n  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;\n  model.shaderReplacements = new Map();\n\n  // Build VTK API\n  macro.get(publicAPI, model, ['pipeline', 'vertexInput']);\n  macro.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']);\n\n  // Object methods\n  vtkWebGPUSimpleMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUSimpleMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUSimpleMapper$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUSimpleMapper$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUSimpleMapper from './SimpleMapper.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUFullScreenQuad methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUFullScreenQuad(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUFullScreenQuad');\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    vDesc.addOutput('vec4<f32>', 'vertexVC');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);', 'output.vertexVC = vec4<f32>(vertexBC, 1);']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.updateBuffers = () => {\n    const buff = model.device.getBufferManager().getFullScreenQuadBuffer();\n    model.vertexInput.addBuffer(buff, ['vertexBC']);\n    model.numberOfVertices = 6;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUSimpleMapper.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkWebGPUFullScreenQuad(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUFullScreenQuad');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUFullScreenQuad$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUFullScreenQuad$1 as default, extend, newInstance };\n", "const BufferUsage = {\n  Verts: 0,\n  Lines: 1,\n  Triangles: 2,\n  Strips: 3,\n  LinesFromStrips: 4,\n  LinesFromTriangles: 5,\n  Points: 6,\n  UniformArray: 7,\n  PointArray: 8,\n  NormalsFromPoints: 9,\n  Texture: 10,\n  RawVertex: 11,\n  Storage: 12,\n  Index: 13\n};\nconst PrimitiveTypes = {\n  Start: 0,\n  Points: 0,\n  Lines: 1,\n  Triangles: 2,\n  TriangleStrips: 3,\n  TriangleEdges: 4,\n  TriangleStripEdges: 5,\n  End: 6\n};\nvar Constants = {\n  BufferUsage,\n  PrimitiveTypes\n};\n\nexport { BufferUsage, PrimitiveTypes, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport Constants from './BufferManager/Constants.js';\n\n// methods we forward to the handle\nconst forwarded = ['getMappedRange', 'mapAsync', 'unmap'];\nfunction bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {\n  const byteCount = srcArrayBuffer.byteLength;\n  const srcBuffer = device.createBuffer({\n    size: byteCount,\n    /* eslint-disable no-undef */\n    usage: GPUBufferUsage.COPY_SRC,\n    /* eslint-enable no-undef */\n    mappedAtCreation: true\n  });\n  const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);\n  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer)); // memcpy\n  srcBuffer.unmap();\n  const encoder = device.createCommandEncoder();\n  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);\n  const commandBuffer = encoder.finish();\n  const queue = device.queue;\n  queue.submit([commandBuffer]);\n  srcBuffer.destroy();\n}\n// ----------------------------------------------------------------------------\n// vtkWebGPUBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUBuffer');\n  publicAPI.create = (sizeInBytes, usage) => {\n    model.handle = model.device.getHandle().createBuffer({\n      size: sizeInBytes,\n      usage,\n      label: model.label\n    });\n    model.sizeInBytes = sizeInBytes;\n    model.usage = usage;\n  };\n  publicAPI.write = data => {\n    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);\n  };\n  publicAPI.createAndWrite = (data, usage) => {\n    const paddedSize = Math.ceil(data.byteLength / 4) * 4;\n    model.handle = model.device.getHandle().createBuffer({\n      size: paddedSize,\n      usage,\n      mappedAtCreation: true,\n      label: model.label\n    });\n    model.sizeInBytes = paddedSize;\n    model.usage = usage;\n    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer)); // memcpy\n    model.handle.unmap();\n  };\n\n  // simple forwarders\n  for (let i = 0; i < forwarded.length; i++) {\n    publicAPI[forwarded[i]] = function () {\n      return model.handle[forwarded[i]](...arguments);\n    };\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  device: null,\n  handle: null,\n  sizeInBytes: 0,\n  strideInBytes: 0,\n  arrayInformation: null,\n  usage: null,\n  label: null,\n  sourceTime: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['handle', 'sizeInBytes', 'usage']);\n  macro.setGet(publicAPI, model, ['strideInBytes', 'device', 'arrayInformation', 'label', 'sourceTime']);\n  vtkWebGPUBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUBuffer$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkWebGPUBuffer$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport Constants from './BufferManager/Constants.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkWebGPUBuffer from './Buffer.js';\n\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  PrimitiveTypes\n} = Constants;\n\n// Simulate a small map of pointId to flatId for a cell. The original code\n// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed\n// length arrays with a count is so much faster even with the required for\n// loops and if statements. This only works as we know the usage is\n// restricted to clear(), set() get() and has() so the count is always\n// incrmenting except for clear where it goes back to 0. Performance\n// improvement is probably due to this appoach not hitting the heap but wow\n// it is so much faster. Code that adds to these vectors checks against 9 to\n// make sure there is room. Switching to test against vec.length -1 results\n// in a small performance hit, so if you change 10, search for 9 in this\n// small class and change those as well.\nclass _LimitedMap {\n  constructor() {\n    this.keys = new Uint32Array(10);\n    this.values = new Uint32Array(10);\n    this.count = 0;\n  }\n  clear() {\n    this.count = 0;\n  }\n  has(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return true;\n      }\n    }\n    return undefined;\n  }\n  get(key) {\n    for (let i = 0; i < this.count; i++) {\n      if (this.keys[i] === key) {\n        return this.values[i];\n      }\n    }\n    return undefined;\n  }\n  set(key, value) {\n    if (this.count < 9) {\n      this.keys[this.count] = key;\n      this.values[this.count++] = value;\n    }\n  }\n}\nfunction getPrimitiveName(primType) {\n  switch (primType) {\n    case PrimitiveTypes.Points:\n      return 'points';\n    case PrimitiveTypes.Lines:\n      return 'lines';\n    case PrimitiveTypes.Triangles:\n    case PrimitiveTypes.TriangleEdges:\n      return 'polys';\n    case PrimitiveTypes.TriangleStripEdges:\n    case PrimitiveTypes.TriangleStrips:\n      return 'strips';\n    default:\n      return '';\n  }\n}\nfunction _getOrAddFlatId(state, ptId, cellId) {\n  let flatId = state.pointIdToFlatId[ptId];\n  if (flatId < 0) {\n    flatId = state.flatId;\n    state.pointIdToFlatId[ptId] = flatId;\n    state.flatIdToPointId[state.flatId] = ptId;\n    state.flatIdToCellId[state.flatId] = cellId;\n    state.flatId++;\n  }\n  return flatId;\n}\nfunction fillCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId);\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        const flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    let ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      let flatId = _getOrAddFlatId(state, ptId, cellId);\n      // mark provoking and add to ibo\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, flatId);\n      // when provoking always set the cellId as an original non-provoking value\n      // will have been stored and we need to overwrite that\n      state.flatIdToCellId[flatId] = cellId;\n      state.ibo[state.iboId++] = flatId;\n\n      // insert remaining ptIds (they do not need to provoke)\n      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        ptId = ptIds[ptIdx2 % numPtIds];\n        flatId = _getOrAddFlatId(state, ptId, cellId);\n        // add to ibo\n        state.ibo[state.iboId++] = flatId;\n      }\n      // all done now\n      return;\n    }\n  }\n\n  // if we got here then none of the ptIds could be used to provoke\n  // so just duplicate the first one\n  let ptId = ptIds[0];\n  let flatId = state.flatId;\n  state.cellProvokedMap.set(ptId, flatId);\n  state.flatIdToPointId[state.flatId] = ptId;\n  state.flatIdToCellId[state.flatId] = cellId;\n  state.flatId++;\n\n  // add to ibo\n  state.ibo[state.iboId++] = flatId;\n\n  // insert remaining ptIds (they do not need to provoke)\n  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {\n    ptId = ptIds[ptIdx2];\n    flatId = _getOrAddFlatId(state, ptId, cellId);\n    // add to ibo\n    state.ibo[state.iboId++] = flatId;\n  }\n}\nfunction countCell(ptIds, cellId, state) {\n  const numPtIds = ptIds.length;\n  state.iboSize += numPtIds;\n\n  // are any points already marked for this cell? If so use that as the provoking point\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      return;\n    }\n  }\n\n  // else have any of the points not been used yet? (not in provokedPointIds)\n  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    const ptId = ptIds[ptIdx];\n    if (!state.provokedPointIds[ptId]) {\n      state.provokedPointIds[ptId] = 1;\n      state.cellProvokedMap.set(ptId, 1);\n      return;\n    }\n  }\n  // if we got here then none of the ptIds could be used to provoke\n  state.cellProvokedMap.set(ptIds[0], 1);\n  state.extraPoints++;\n}\nlet processCell;\nconst _single = new Uint32Array(1);\nconst _double = new Uint32Array(2);\nconst _triple = new Uint32Array(3);\nconst _indexCellBuilders = {\n  // easy, every input point becomes an output point\n  anythingToPoints(numPoints, cellPts, offset, cellId, state) {\n    for (let i = 0; i < numPoints; ++i) {\n      _single[0] = cellPts[offset + i];\n      processCell(_single, cellId, state);\n    }\n  },\n  linesToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for lines we add a bunch of segments\n    for (let i = 0; i < numPoints - 1; ++i) {\n      _double[0] = cellPts[offset + i];\n      _double[1] = cellPts[offset + i + 1];\n      processCell(_double, cellId, state);\n    }\n  },\n  polysToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for polys we add a bunch of segments and close it\n    if (numPoints > 2) {\n      for (let i = 0; i < numPoints; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + (i + 1) % numPoints];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {\n    if (numPoints > 2) {\n      // for strips we add a bunch of segments and close it\n      for (let i = 0; i < numPoints - 1; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 1];\n        processCell(_double, cellId, state);\n      }\n      for (let i = 0; i < numPoints - 2; i++) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 2];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  polysToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset];\n      _triple[1] = cellPts[offset + i + 1];\n      _triple[2] = cellPts[offset + i + 2];\n      processCell(_triple, cellId, state);\n    }\n  },\n  stripsToSurface(npts, cellPts, offset, cellId, state) {\n    for (let i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset + i];\n      _triple[1] = cellPts[offset + i + 1 + i % 2];\n      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];\n      processCell(_triple, cellId, state);\n    }\n  }\n};\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUIndexBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUIndexBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUIndexBuffer');\n  publicAPI.buildIndexBuffer = req => {\n    const cellArray = req.cells;\n    const primitiveType = req.primitiveType;\n    const representation = req.representation;\n    const cellOffset = req.cellOffset;\n    const array = cellArray.getData();\n    const cellArraySize = array.length;\n    const inRepName = getPrimitiveName(primitiveType);\n    const numPts = req.numberOfPoints;\n    const state = {\n      provokedPointIds: new Uint8Array(numPts),\n      // size is good\n      extraPoints: 0,\n      iboSize: 0,\n      flatId: 0,\n      iboId: 0,\n      cellProvokedMap: new _LimitedMap()\n    };\n    let func = null;\n    if (representation === Representation.POINTS || primitiveType === PrimitiveTypes.Points) {\n      func = _indexCellBuilders.anythingToPoints;\n    } else if (representation === Representation.WIREFRAME || primitiveType === PrimitiveTypes.Lines) {\n      func = _indexCellBuilders[`${inRepName}ToWireframe`];\n    } else {\n      func = _indexCellBuilders[`${inRepName}ToSurface`];\n    }\n\n    // first we count how many extra provoking points we need\n    processCell = countCell;\n    let cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n\n    // then we allocate the remaining structures\n    // (we pick the best size to save space and transfer costs)\n    if (numPts <= 0xffff) {\n      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);\n    }\n    if (numPts + state.extraPoints < 0x8fff) {\n      state.pointIdToFlatId = new Int16Array(numPts);\n    } else {\n      state.pointIdToFlatId = new Int32Array(numPts);\n    }\n    if (numPts + state.extraPoints <= 0xffff) {\n      state.ibo = new Uint16Array(state.iboSize);\n      req.format = 'uint16';\n    } else {\n      state.ibo = new Uint32Array(state.iboSize);\n      req.format = 'uint32';\n    }\n    if (cellId <= 0xffff) {\n      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);\n    }\n    state.pointIdToFlatId.fill(-1);\n    state.provokedPointIds.fill(0);\n\n    // and fill them in\n    processCell = fillCell;\n    cellId = cellOffset || 0;\n    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    }\n    delete state.provokedPointIds;\n    delete state.pointIdToFlatId;\n\n    // store the results we need\n    req.nativeArray = state.ibo;\n    model.flatIdToPointId = state.flatIdToPointId;\n    model.flatIdToCellId = state.flatIdToCellId;\n    model.flatSize = state.flatId;\n    model.indexCount = state.iboId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  flatIdToPointId: null,\n  flatIdToCellId: null,\n  flatSize: 0,\n  indexCount: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUBuffer.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);\n  vtkWebGPUIndexBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUIndexBuffer$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkWebGPUIndexBuffer$1 as default, extend, newInstance };\n", "import { n as newInstance$1, o as obj, e as setGet, c as macro, a as newTypedArray } from '../../macros2.js';\nimport { j as cross, l as normalize } from '../../Common/Core/Math/index.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkWebGPUBuffer from './Buffer.js';\nimport vtkWebGPUIndexBuffer from './IndexBuffer.js';\nimport vtkWebGPUTypes from './Types.js';\nimport Constants from './BufferManager/Constants.js';\n\nconst {\n  BufferUsage\n} = Constants;\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\n\n// the webgpu constants all show up as undefined\n/* eslint-disable no-undef */\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {};\nfunction _getFormatForDataArray(dataArray) {\n  let format;\n  switch (dataArray.getDataType()) {\n    case VtkDataTypes.UNSIGNED_CHAR:\n      format = 'uint8';\n      break;\n    case VtkDataTypes.FLOAT:\n      format = 'float32';\n      break;\n    case VtkDataTypes.UNSIGNED_INT:\n      format = 'uint32';\n      break;\n    case VtkDataTypes.INT:\n      format = 'sint32';\n      break;\n    case VtkDataTypes.DOUBLE:\n      format = 'float32';\n      break;\n    case VtkDataTypes.UNSIGNED_SHORT:\n      format = 'uint16';\n      break;\n    case VtkDataTypes.SHORT:\n      format = 'sin16';\n      break;\n    default:\n      format = 'float32';\n      break;\n  }\n  switch (dataArray.getNumberOfComponents()) {\n    case 2:\n      format += 'x2';\n      break;\n    case 3:\n      // only 32bit types support x3\n      if (!format.includes('32')) {\n        vtkErrorMacro(`unsupported x3 type for ${format}`);\n      }\n      format += 'x3';\n      break;\n    case 4:\n      format += 'x4';\n      break;\n  }\n  return format;\n}\nfunction packArray(indexBuffer, inArrayData, numComp, outputType, options) {\n  const result = {};\n  const flatSize = indexBuffer.getFlatSize();\n  if (!flatSize) {\n    return result;\n  }\n\n  // setup shift and scale\n  let shift = [0.0, 0.0, 0.0, 0.0];\n  if (options.shift) {\n    if (options.shift.length) {\n      shift = options.shift;\n    } else {\n      shift.fill(options.shift);\n    }\n  }\n  let scale = [1.0, 1.0, 1.0, 1.0];\n  if (options.scale) {\n    if (options.scale.length) {\n      scale = options.scale;\n    } else {\n      scale.fill(options.scale);\n    }\n  }\n  const packExtra = Object.prototype.hasOwnProperty.call(options, 'packExtra') ? options.packExtra : false;\n  let addAPoint;\n  let vboidx = 0;\n  const stride = numComp + (packExtra ? 1 : 0);\n  const packedVBO = newTypedArray(outputType, flatSize * stride);\n\n  // pick the right function based on point versus cell data\n  let flatIdMap = indexBuffer.getFlatIdToPointId();\n  if (options.cellData) {\n    flatIdMap = indexBuffer.getFlatIdToCellId();\n  }\n\n  // add data based on number of components\n  if (numComp === 1) {\n    addAPoint = function addAPointFunc(i) {\n      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];\n    };\n  } else if (numComp === 2) {\n    addAPoint = function addAPointFunc(i) {\n      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];\n      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];\n    };\n  } else if (numComp === 3 && !packExtra) {\n    addAPoint = function addAPointFunc(i) {\n      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];\n      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];\n      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];\n    };\n  } else if (numComp === 3 && packExtra) {\n    addAPoint = function addAPointFunc(i) {\n      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];\n      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];\n      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];\n      packedVBO[vboidx++] = scale[3] * 1.0 + shift[3];\n    };\n  } else if (numComp === 4) {\n    addAPoint = function addAPointFunc(i) {\n      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];\n      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];\n      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];\n      packedVBO[vboidx++] = scale[3] * inArrayData[i + 3] + shift[3];\n    };\n  }\n\n  // for each entry in the flat array process it\n  for (let index = 0; index < flatSize; index++) {\n    const inArrayId = numComp * flatIdMap[index];\n    addAPoint(inArrayId);\n  }\n  result.nativeArray = packedVBO;\n  return result;\n}\nfunction getNormal(pointData, i0, i1, i2) {\n  const v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];\n  const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];\n  const result = [];\n  cross(v1, v2, result);\n  normalize(result);\n  return result;\n}\nfunction generateNormals(cellArray, pointArray) {\n  const pointData = pointArray.getData();\n  const cellArrayData = cellArray.getData();\n  if (!cellArrayData || !pointData) {\n    return null;\n  }\n\n  // return a cellArray of normals\n  const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);\n  const size = cellArrayData.length;\n  let vboidx = 0;\n  for (let index = 0; index < size;) {\n    const normal = getNormal(pointData, cellArrayData[index + 1], cellArrayData[index + 2], cellArrayData[index + 3]);\n    packedVBO[vboidx++] = 127 * normal[0];\n    packedVBO[vboidx++] = 127 * normal[1];\n    packedVBO[vboidx++] = 127 * normal[2];\n    packedVBO[vboidx++] = 127;\n    index += cellArrayData[index] + 1;\n  }\n  return packedVBO;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUBufferManager methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUBufferManager(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUBufferManager');\n  function _createBuffer(req) {\n    // if a dataArray is provided set the nativeArray\n    if (req.dataArray && !req.nativeArray) {\n      req.nativeArray = req.dataArray.getData();\n    }\n    let buffer;\n    let gpuUsage;\n\n    // handle index buffers\n    if (req.usage === BufferUsage.Index) {\n      // todo change to FlattenedIndex to be more clear\n      buffer = vtkWebGPUIndexBuffer.newInstance({\n        label: req.label\n      });\n      buffer.setDevice(model.device);\n      /* eslint-disable no-bitwise */\n      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;\n      /* eslint-enable no-bitwise */\n      buffer.buildIndexBuffer(req);\n      buffer.createAndWrite(req.nativeArray, gpuUsage);\n      buffer.setArrayInformation([{\n        format: req.format\n      }]);\n    }\n\n    // create one if not done already\n    if (!buffer) {\n      buffer = vtkWebGPUBuffer.newInstance({\n        label: req.label\n      });\n      buffer.setDevice(model.device);\n    }\n\n    // handle uniform buffers\n    if (req.usage === BufferUsage.UniformArray) {\n      /* eslint-disable no-bitwise */\n      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n      /* eslint-enable no-bitwise */\n      buffer.createAndWrite(req.nativeArray, gpuUsage);\n    }\n\n    // handle storage buffers\n    if (req.usage === BufferUsage.Storage) {\n      /* eslint-disable no-bitwise */\n      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;\n      /* eslint-enable no-bitwise */\n      buffer.createAndWrite(req.nativeArray, gpuUsage);\n    }\n\n    // handle textures\n    if (req.usage === BufferUsage.Texture) {\n      /* eslint-disable no-bitwise */\n      gpuUsage = GPUBufferUsage.COPY_SRC;\n      /* eslint-enable no-bitwise */\n      buffer.createAndWrite(req.nativeArray, gpuUsage);\n    }\n\n    // all of the below types that have gpuUsage = VERTEX require format\n    // to be provided.\n\n    // handle point data\n    if (req.usage === BufferUsage.PointArray) {\n      gpuUsage = GPUBufferUsage.VERTEX;\n      const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);\n      const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {\n        packExtra: req.packExtra,\n        shift: req.shift,\n        scale: req.scale,\n        cellData: req.cellData,\n        cellOffset: req.cellOffset\n      });\n      buffer.createAndWrite(result.nativeArray, gpuUsage);\n      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));\n      buffer.setArrayInformation([{\n        offset: 0,\n        format: req.format,\n        interpolation: req.cellData ? 'flat' : 'perspective'\n      }]);\n    }\n\n    // handle normals from points, snorm8x4\n    if (req.usage === BufferUsage.NormalsFromPoints) {\n      gpuUsage = GPUBufferUsage.VERTEX;\n      const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);\n      const normals = generateNormals(req.cells, req.dataArray);\n      const result = packArray(req.indexBuffer, normals, 4, arrayType, {\n        cellData: true\n      });\n      buffer.createAndWrite(result.nativeArray, gpuUsage);\n      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));\n      buffer.setArrayInformation([{\n        offset: 0,\n        format: req.format,\n        interpolation: 'flat'\n      }]);\n    }\n    if (req.usage === BufferUsage.RawVertex) {\n      gpuUsage = GPUBufferUsage.VERTEX;\n      buffer.createAndWrite(req.nativeArray, gpuUsage);\n      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));\n      buffer.setArrayInformation([{\n        offset: 0,\n        format: req.format\n      }]);\n    }\n    buffer.setSourceTime(req.time);\n    return buffer;\n  }\n\n  // is the buffer already present?\n  publicAPI.hasBuffer = hash => model.device.hasCachedObject(hash);\n  publicAPI.getBuffer = req => {\n    // if we have a source the get/create/cache the buffer\n    if (req.hash) {\n      return model.device.getCachedObject(req.hash, _createBuffer, req);\n    }\n    return _createBuffer(req);\n  };\n  publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {\n    const format = _getFormatForDataArray(dataArray);\n    const buffRequest = {\n      hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format}`,\n      usage: BufferUsage.PointArray,\n      format,\n      dataArray,\n      indexBuffer\n    };\n    return publicAPI.getBuffer(buffRequest);\n  };\n  publicAPI.getFullScreenQuadBuffer = () => {\n    if (model.fullScreenQuadBuffer) {\n      return model.fullScreenQuadBuffer;\n    }\n    model.fullScreenQuadBuffer = vtkWebGPUBuffer.newInstance();\n    model.fullScreenQuadBuffer.setDevice(model.device);\n\n    // prettier-ignore\n    const array = new Float32Array([-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0]);\n    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);\n    model.fullScreenQuadBuffer.setStrideInBytes(12);\n    model.fullScreenQuadBuffer.setArrayInformation([{\n      offset: 0,\n      format: 'float32x3'\n    }]);\n    return model.fullScreenQuadBuffer;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  device: null,\n  fullScreenQuadBuffer: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  obj(publicAPI, model);\n  setGet(publicAPI, model, ['device']);\n  vtkWebGPUBufferManager(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUBufferManager$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkWebGPUBufferManager$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\n\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUUniformBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUUniformBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUUniformBuffer');\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model.sortDirty = true;\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),\n      offset: -1,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n      packed: false\n    });\n  };\n\n  // UBOs have layout rules in terms of how memory is aligned so we\n  // have to be careful how we order the entries. For example a vec4<f32>\n  // must be aligned on a 16 byte offset, etc. See\n  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts\n  // for more details. Right now you can create a situation that would fail\n  // in the future we could add dummy spacer entries where needed to\n  // handle alignment issues\n  publicAPI.sortBufferEntries = () => {\n    if (!model.sortDirty) {\n      return;\n    }\n    let currOffset = 0;\n    const newEntries = [];\n\n    // compute the max alignment, this is required as WebGPU defines a UBO to have\n    // a size that is a multiple of the maxAlignment\n    let maxAlignment = 4;\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.sizeInBytes % 16 === 0) {\n        maxAlignment = Math.max(16, maxAlignment);\n      }\n      if (entry.sizeInBytes % 8 === 0) {\n        maxAlignment = Math.max(8, maxAlignment);\n      }\n    }\n\n    // pack anything whose size is a multiple of 16 bytes first\n    // this includes a couple types that don't require 16 byte alignment\n    // such as mat2x2<f32> but that is OK\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // now it gets tough, we have the following common types (f32, i32, u32)\n    // - vec2<f32> 8 byte size, 8 byte alignment\n    // - vec3<f32> 12 byte size, 16 byte alignment\n    // - f32 4 byte size, 4 byte alignment\n\n    // try adding 12 byte, 4 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (entry.packed === false && entry.sizeInBytes === 12) {\n        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (entry2.packed === false && entry2.sizeInBytes === 4) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 8 byte pairs\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {\n            entry.packed = true;\n            entry.offset = currOffset;\n            newEntries.push(entry);\n            currOffset += entry.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    }\n\n    // try adding 8 byte, 4 byte 4 byte triplets\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes % 8 === 0) {\n        let found = false;\n        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {\n          const entry2 = model.bufferEntries[i2];\n          if (!entry2.packed && entry2.sizeInBytes === 4) {\n            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {\n              const entry3 = model.bufferEntries[i3];\n              if (!entry3.packed && entry3.sizeInBytes === 4) {\n                entry.packed = true;\n                entry.offset = currOffset;\n                newEntries.push(entry);\n                currOffset += entry.sizeInBytes;\n                entry2.packed = true;\n                entry2.offset = currOffset;\n                newEntries.push(entry2);\n                currOffset += entry2.sizeInBytes;\n                entry3.packed = true;\n                entry3.offset = currOffset;\n                newEntries.push(entry3);\n                currOffset += entry3.sizeInBytes;\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Add anything remaining that is larger than 4 bytes and hope we get lucky.\n    // Likely if there is more than one item added here it will result\n    // in a failed UBO\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed && entry.sizeInBytes > 4) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // finally add remaining 4 byte items\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      if (!entry.packed) {\n        entry.packed = true;\n        entry.offset = currOffset;\n        newEntries.push(entry);\n        currOffset += entry.sizeInBytes;\n      }\n    }\n\n    // update entries and entryNames\n    model.bufferEntries = newEntries;\n    model._bufferEntryNames.clear();\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      model._bufferEntryNames.set(model.bufferEntries[i].name, i);\n    }\n    model.sizeInBytes = currOffset;\n    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);\n    model.sortDirty = false;\n  };\n  publicAPI.sendIfNeeded = device => {\n    if (!model.UBO) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.UniformArray,\n        label: model.label\n      };\n      model.UBO = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model.sendDirty = false;\n    }\n\n    // send data down if needed\n    if (model.sendDirty) {\n      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);\n      model.sendDirty = false;\n    }\n\n    // always updated as mappers depend on this time\n    // it is more of a sentIfNeededTime\n    model.sendTime.modified();\n  };\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n  publicAPI.setValue = (name, val) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    if (entry.lastValue !== val) {\n      view[entry.offset / view.BYTES_PER_ELEMENT] = val;\n      model.sendDirty = true;\n    }\n    entry.lastValue = val;\n  };\n  publicAPI.setArray = (name, arr) => {\n    publicAPI.sortBufferEntries();\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    let changed = false;\n    for (let i = 0; i < arr.length; i++) {\n      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {\n        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      model.sendDirty = true;\n      entry.lastValue = [...arr];\n    }\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model.UBO.getHandle()\n      }\n    };\n    return foo;\n  };\n  publicAPI.getSendTime = () => model.sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    // sort the entries\n    publicAPI.sortBufferEntries();\n    const lines = [`struct ${model.label}Struct\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(`};\\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);\n    return lines.join('\\n');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  bindGroupLayoutEntry: null,\n  bindGroupEntry: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n\n  // default UBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'uniform'\n    }\n  };\n  model.sendTime = {};\n  macro.obj(model.sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  model.sendDirty = true;\n  model.sortDirty = true;\n  macro.get(publicAPI, model, ['binding', 'bindGroupTime']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']);\n\n  // Object methods\n  vtkWebGPUUniformBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUUniformBuffer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUUniformBuffer$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUUniformBuffer$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\n\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer - similar to the UniformBuffer class\n// but YOU are responsible for layout issues and alignment.\n// The order you add entries is the order they will be layed out\n// in memory. But you must follow layout rules.\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStorageBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStorageBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStorageBuffer');\n  publicAPI.addEntry = (name, type) => {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(`entry named ${name} already exists`);\n      return;\n    }\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);\n    model.bufferEntries.push({\n      name,\n      type,\n      sizeInBytes,\n      offset: model.sizeInBytes,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)\n    });\n    model.sizeInBytes += sizeInBytes;\n  };\n  publicAPI.send = device => {\n    if (!model._buffer) {\n      const req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.Storage,\n        label: model.label\n      };\n      model._buffer = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model._sendTime.modified();\n      return;\n    }\n    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);\n    model._sendTime.modified();\n  };\n  publicAPI.createView = type => {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n  publicAPI.setValue = (name, instance, val) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;\n  };\n  publicAPI.setArray = (name, instance, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n    for (let i = 0; i < arr.length; i++) {\n      view[ioffset + i] = arr[i];\n    }\n  };\n  publicAPI.setAllInstancesFromArray = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i];\n      }\n    }\n  };\n  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = arr.length / model.numberOfInstances;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let i = 0; i < numComponents; i++) {\n        view[ioffset + i] = arr[inst * numComponents + i] / 255.0;\n      }\n    }\n  };\n  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {\n    const idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(`entry named ${name} not found in UBO`);\n      return;\n    }\n    const entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    const view = model[entry.nativeType];\n    const numComponents = 9;\n    for (let inst = 0; inst < model.numberOfInstances; inst++) {\n      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;\n      for (let j = 0; j < 3; j++) {\n        for (let i = 0; i < 3; i++) {\n          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];\n        }\n      }\n    }\n  };\n  publicAPI.getSendTime = () => model._sendTime.getMTime();\n  publicAPI.getShaderCode = (binding, group) => {\n    const lines = [`struct ${model.label}StructEntry\\n{`];\n    for (let i = 0; i < model.bufferEntries.length; i++) {\n      const entry = model.bufferEntries[i];\n      lines.push(`  ${entry.name}: ${entry.type},`);\n    }\n    lines.push(`\n};\nstruct ${model.label}Struct\n{\n  values: array<${model.label}StructEntry>,\n};\n@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;\n`);\n    return lines.join('\\n');\n  };\n  publicAPI.getBindGroupEntry = () => {\n    const foo = {\n      resource: {\n        buffer: model._buffer.getHandle()\n      }\n    };\n    return foo;\n  };\n  publicAPI.clearData = () => {\n    model.numberOfInstances = 0;\n    model.sizeInBytes = 0;\n    model.bufferEntries = [];\n    model._bufferEntryNames = new Map();\n    model._buffer = null;\n    delete model.arrayBuffer;\n    delete model.Float32Array;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  numberOfInstances: 1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Internal objects\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = [];\n  model._sendTime = {};\n  macro.obj(model._sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n\n  // default SSBO desc\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'read-only-storage'\n    }\n  };\n  macro.get(publicAPI, model, ['bindGroupTime']);\n  macro.setGet(publicAPI, model, ['device', 'bindGroupLayoutEntry', 'label', 'numberOfInstances', 'sizeInBytes']);\n\n  // Object methods\n  vtkWebGPUStorageBuffer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUStorageBuffer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUStorageBuffer$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUStorageBuffer$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkViewNodeFactory from '../SceneGraph/ViewNodeFactory.js';\n\nconst CLASS_MAPPING = Object.create(null);\nfunction registerOverride(className, fn) {\n  CLASS_MAPPING[className] = fn;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUViewNodeFactory methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUViewNodeFactory(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUViewNodeFactory');\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Static class mapping shared across instances\n  model.overrides = CLASS_MAPPING;\n\n  // Inheritance\n  vtkViewNodeFactory.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkWebGPUViewNodeFactory(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUViewNodeFactory');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUViewNodeFactory$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUViewNodeFactory$1 as default, extend, newInstance, registerOverride };\n"],
  "mappings": "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",
  "names": ["vtkErrorMacro", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "vtkViewNodeFactory", "Wrap", "Filter", "vtkErrorMacro", "toHalf", "DeepEqual", "outIdx", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "Constants", "ObjectType", "Constants", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "normalize", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "substitute", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "Constants", "DEFAULT_VALUES", "extend", "newInstance", "Constants", "Representation", "PrimitiveTypes", "Constants", "ptId", "flatId", "DEFAULT_VALUES", "extend", "newInstance", "BufferUsage", "Constants", "vtkErrorMacro", "VtkDataTypes", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "BufferUsage", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "BufferUsage", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "CLASS_MAPPING", "registerOverride", "DEFAULT_VALUES", "extend", "newInstance"]
}
