{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/Core/Texture.js"],
  "sourcesContent": ["import { m as macro } from '../../macros2.js';\n\n/* eslint-disable no-bitwise */\n\n// ----------------------------------------------------------------------------\n// vtkTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTexture');\n  publicAPI.imageLoaded = () => {\n    model.image.removeEventListener('load', publicAPI.imageLoaded);\n    model.imageLoaded = true;\n    publicAPI.modified();\n  };\n  publicAPI.setJsImageData = imageData => {\n    if (model.jsImageData === imageData) {\n      return;\n    }\n\n    // clear other entries\n    if (imageData !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.image = null;\n      model.canvas = null;\n      model.imageBitmap = null;\n    }\n    model.jsImageData = imageData;\n    model.imageLoaded = true;\n    publicAPI.modified();\n  };\n  publicAPI.setImageBitmap = imageBitmap => {\n    if (model.imageBitmap === imageBitmap) {\n      return;\n    }\n\n    // clear other entries\n    if (imageBitmap !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.image = null;\n      model.canvas = null;\n      model.jsImageData = null;\n    }\n    model.imageBitmap = imageBitmap;\n    model.imageLoaded = true;\n    publicAPI.modified();\n  };\n  publicAPI.setCanvas = canvas => {\n    if (model.canvas === canvas) {\n      return;\n    }\n\n    // clear other entries\n    if (canvas !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.image = null;\n      model.imageBitmap = null;\n      model.jsImageData = null;\n    }\n    model.canvas = canvas;\n    publicAPI.modified();\n  };\n  publicAPI.setImage = image => {\n    if (model.image === image) {\n      return;\n    }\n\n    // clear other entries\n    if (image !== null) {\n      publicAPI.setInputData(null);\n      publicAPI.setInputConnection(null);\n      model.canvas = null;\n      model.jsImageData = null;\n      model.imageBitmap = null;\n    }\n    model.image = image;\n    model.imageLoaded = false;\n    if (image.complete) {\n      publicAPI.imageLoaded();\n    } else {\n      image.addEventListener('load', publicAPI.imageLoaded);\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getDimensionality = () => {\n    let width = 0;\n    let height = 0;\n    let depth = 1;\n    if (publicAPI.getInputData()) {\n      const data = publicAPI.getInputData();\n      width = data.getDimensions()[0];\n      height = data.getDimensions()[1];\n      depth = data.getDimensions()[2];\n    }\n    if (model.jsImageData) {\n      width = model.jsImageData.width;\n      height = model.jsImageData.height;\n    }\n    if (model.canvas) {\n      width = model.canvas.width;\n      height = model.canvas.height;\n    }\n    if (model.image) {\n      width = model.image.width;\n      height = model.image.height;\n    }\n    if (model.imageBitmap) {\n      width = model.imageBitmap.width;\n      height = model.imageBitmap.height;\n    }\n    const dimensionality = (width > 1) + (height > 1) + (depth > 1);\n    return dimensionality;\n  };\n  publicAPI.getInputAsJsImageData = () => {\n    if (!model.imageLoaded || publicAPI.getInputData()) return null;\n    if (model.jsImageData) {\n      return model.jsImageData;\n    }\n    if (model.imageBitmap) {\n      return model.imageBitmap;\n    }\n    if (model.canvas) {\n      const context = model.canvas.getContext('2d');\n      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);\n      return imageData;\n    }\n    if (model.image) {\n      const width = model.image.width;\n      const height = model.image.height;\n      const canvas = new OffscreenCanvas(width, height);\n      const context = canvas.getContext('2d');\n      context.translate(0, height);\n      context.scale(1, -1);\n      context.drawImage(model.image, 0, 0, width, height);\n      const imageData = context.getImageData(0, 0, width, height);\n      return imageData;\n    }\n    return null;\n  };\n}\n\n/**\n * Generates mipmaps for a given GPU texture using a compute shader.\n *\n * This function iteratively generates each mip level for the provided texture,\n * using a bilinear downsampling compute shader implemented in WGSL. It creates\n * the necessary pipeline, bind groups, and dispatches compute passes for each\n * mip level.\n *\n * @param {GPUDevice} device - The WebGPU device used to create resources and submit commands.\n * @param {GPUTexture} texture - The GPU texture for which mipmaps will be generated. Must be created with mip levels.\n * @param {number} mipLevelCount - The total number of mip levels to generate (including the base level).\n */\nconst generateMipmaps = (device, texture, mipLevelCount) => {\n  const computeShaderCode = `\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(8, 8)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n      let texelCoord = vec2<i32>(global_id.xy);\n      let outputSize = textureDimensions(outputTexture);\n\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\n        return;\n      }\n\n      let inputSize = textureDimensions(inputTexture);\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\n\n      // Compute the floating-point source coordinate\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\n\n      // Get integer coordinates for the four surrounding texels\n      let x0 = i32(floor(srcCoord.x));\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\n      let y0 = i32(floor(srcCoord.y));\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\n\n      // Compute the weights\n      let wx = srcCoord.x - f32(x0);\n      let wy = srcCoord.y - f32(y0);\n\n      // Fetch the four texels\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\n\n      // Bilinear interpolation\n      let color = mix(\n        mix(c00, c10, wx),\n        mix(c01, c11, wx),\n        wy\n      );\n\n      textureStore(outputTexture, texelCoord, color);\n    }\n  `;\n  const computeShader = device.createShaderModule({\n    code: computeShaderCode\n  });\n  const bindGroupLayout = device.createBindGroupLayout({\n    entries: [{\n      binding: 0,\n      // eslint-disable-next-line no-undef\n      visibility: GPUShaderStage.COMPUTE,\n      texture: {\n        sampleType: 'float'\n      }\n    }, {\n      binding: 1,\n      // eslint-disable-next-line no-undef\n      visibility: GPUShaderStage.COMPUTE,\n      storageTexture: {\n        format: 'rgba8unorm',\n        access: 'write-only'\n      }\n    }, {\n      binding: 2,\n      // eslint-disable-next-line no-undef\n      visibility: GPUShaderStage.COMPUTE,\n      sampler: {\n        type: 'filtering'\n      }\n    }]\n  });\n  const pipelineLayout = device.createPipelineLayout({\n    bindGroupLayouts: [bindGroupLayout]\n  });\n  const pipeline = device.createComputePipeline({\n    label: 'ComputeMipmapPipeline',\n    layout: pipelineLayout,\n    compute: {\n      module: computeShader,\n      entryPoint: 'main'\n    }\n  });\n  const sampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear'\n  });\n\n  // Generate each mip level\n  for (let mipLevel = 1; mipLevel < mipLevelCount; mipLevel++) {\n    const srcView = texture.createView({\n      baseMipLevel: mipLevel - 1,\n      mipLevelCount: 1\n    });\n    const dstView = texture.createView({\n      baseMipLevel: mipLevel,\n      mipLevelCount: 1\n    });\n    const bindGroup = device.createBindGroup({\n      layout: pipeline.getBindGroupLayout(0),\n      entries: [{\n        binding: 0,\n        resource: srcView\n      }, {\n        binding: 1,\n        resource: dstView\n      }, {\n        binding: 2,\n        resource: sampler\n      }]\n    });\n    const commandEncoder = device.createCommandEncoder({\n      label: `MipmapGenerateCommandEncoder`\n    });\n    const computePass = commandEncoder.beginComputePass();\n    computePass.setPipeline(pipeline);\n    computePass.setBindGroup(0, bindGroup);\n    const mipWidth = Math.max(1, texture.width >> mipLevel);\n    const mipHeight = Math.max(1, texture.height >> mipLevel);\n    const workgroupsX = Math.ceil(mipWidth / 8);\n    const workgroupsY = Math.ceil(mipHeight / 8);\n    computePass.dispatchWorkgroups(workgroupsX, workgroupsY);\n    computePass.end();\n    device.queue.submit([commandEncoder.finish()]);\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  image: null,\n  canvas: null,\n  jsImageData: null,\n  imageBitmap: null,\n  imageLoaded: false,\n  repeat: false,\n  interpolate: false,\n  edgeClamp: false,\n  mipLevel: 0,\n  resizable: false // must be set at construction time if the texture can be resizable\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 6, 0);\n  macro.get(publicAPI, model, ['canvas', 'image', 'jsImageData', 'imageBitmap', 'imageLoaded', 'resizable']);\n  macro.setGet(publicAPI, model, ['repeat', 'edgeClamp', 'interpolate', 'mipLevel']);\n  vtkTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTexture');\nconst STATIC = {\n  generateMipmaps\n};\n\n// ----------------------------------------------------------------------------\n\nvar vtkTexture$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkTexture$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": []
}
