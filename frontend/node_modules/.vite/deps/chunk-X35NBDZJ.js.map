{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/OpenGL/Actor.js", "../../@kitware/vtk.js/Rendering/OpenGL/Actor2D.js", "../../@kitware/vtk.js/Rendering/OpenGL/Camera.js", "../../@kitware/vtk.js/Rendering/Core/CubeAxesActor.js", "../../@kitware/vtk.js/Rendering/OpenGL/CubeAxesActor.js", "../../@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js", "../../@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js", "../../@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js", "../../@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js", "../../@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js", "../../@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DFS.glsl.js", "../../@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DVS.glsl.js", "../../@kitware/vtk.js/Rendering/Core/Property2D/Constants.js", "../../@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper2D.js", "../../@kitware/vtk.js/Rendering/OpenGL/Renderer.js", "../../@kitware/vtk.js/Rendering/OpenGL/ScalarBarActor.js", "../../@kitware/vtk.js/Rendering/OpenGL/Skybox.js", "../../@kitware/vtk.js/Rendering/WebGPU/Actor.js", "../../@kitware/vtk.js/Rendering/WebGPU/Actor2D.js", "../../@kitware/vtk.js/Rendering/WebGPU/Camera.js", "../../@kitware/vtk.js/Rendering/WebGPU/CubeAxesActor.js", "../../@kitware/vtk.js/Rendering/Core/Property2D.js", "../../@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js", "../../@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper.js", "../../@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js", "../../@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper2D.js", "../../@kitware/vtk.js/Rendering/WebGPU/Renderer.js", "../../@kitware/vtk.js/Rendering/WebGPU/ScalarBarActor.js"],
  "sourcesContent": ["import { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, e as setGet, g as get } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLActor');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model.context = model._openGLRenderWindow.getContext();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNodes(model.renderable.getTextures());\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n\n      // we store textures and mapper\n      model.ogltextures = null;\n      model.activeTextures = null;\n      for (let index = 0; index < model.children.length; index++) {\n        const child = model.children[index];\n        if (child.isA('vtkOpenGLTexture')) {\n          if (!model.ogltextures) {\n            model.ogltextures = [];\n          }\n          model.ogltextures.push(child);\n        } else {\n          model.oglmapper = child;\n        }\n      }\n    }\n  };\n\n  // render both opaque and translucent actors\n  publicAPI.traverseZBufferPass = renderPass => {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n\n  // only render opaque actors\n  publicAPI.traverseOpaqueZBufferPass = renderPass => publicAPI.traverseOpaquePass(renderPass);\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseOpaquePass = renderPass => {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseTranslucentPass = renderPass => {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.activateTextures = () => {\n    // always traverse textures first, then mapper\n    if (!model.ogltextures) {\n      return;\n    }\n    model.activeTextures = [];\n    for (let index = 0; index < model.ogltextures.length; index++) {\n      const child = model.ogltextures[index];\n      child.render();\n      if (child.getHandle()) {\n        model.activeTextures.push(child);\n      }\n    }\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      if (model.renderable.getIsOpaque()) {\n        renderPass.incrementOpaqueActorCount();\n      } else {\n        renderPass.incrementTranslucentActorCount();\n      }\n    }\n  };\n  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);\n  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(true);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(model._openGLRenderer.getSelector() && model.renderable.getNestedPickable());\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n  publicAPI.getKeyMatrices = () => {\n    // has the actor changed?\n    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {\n      model.renderable.computeMatrix();\n      mat4.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());\n      mat4.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);\n      if (model.renderable.getIsIdentity()) {\n        mat3.identity(model.keyMatrices.normalMatrix);\n      } else {\n        mat3.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);\n        mat3.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n        mat3.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n      }\n      model.keyMatrixTime.modified();\n    }\n    return model.keyMatrices;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  keyMatrixTime: null,\n  keyMatrices: null,\n  activeTextures: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: mat3.identity(new Float64Array(9)),\n    mcwc: mat4.identity(new Float64Array(16))\n  };\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']);\n\n  // Object methods\n  vtkOpenGLActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkActor = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkActor', newInstance);\n\nexport { vtkActor as default, extend, newInstance };\n", "import { n as newInstance$1, e as setGet, g as get } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLActor2D(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLActor2D');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model.context = model._openGLRenderWindow.getContext();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNodes(model.renderable.getTextures());\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n\n      // we store textures and mapper\n      model.ogltextures = null;\n      model.activeTextures = null;\n      for (let index = 0; index < model.children.length; index++) {\n        const child = model.children[index];\n        if (child.isA('vtkOpenGLTexture')) {\n          if (!model.ogltextures) {\n            model.ogltextures = [];\n          }\n          model.ogltextures.push(child);\n        } else {\n          model.oglmapper = child;\n        }\n      }\n    }\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      renderPass.incrementOverlayActorCount();\n    }\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseOpaquePass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseTranslucentPass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.traverseOverlayPass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.activateTextures = () => {\n    // always traverse textures first, then mapper\n    if (!model.ogltextures) {\n      return;\n    }\n    model.activeTextures = [];\n    for (let index = 0; index < model.ogltextures.length; index++) {\n      const child = model.ogltextures[index];\n      child.render();\n      if (child.getHandle()) {\n        model.activeTextures.push(child);\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(true);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      // deactivate textures\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(false);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.overlayPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(true);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      // deactivate textures\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  activeTextures: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']);\n\n  // Object methods\n  vtkOpenGLActor2D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkActor2D = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkActor2D', newInstance);\n\nexport { vtkActor2D as default, extend, newInstance };\n", "import { mat4, mat3 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, e as setGet } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCamera');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  // Renders myself\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();\n      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);\n      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);\n    }\n  };\n  publicAPI.translucentPass = publicAPI.opaquePass;\n  publicAPI.zBufferPass = publicAPI.opaquePass;\n  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;\n  publicAPI.volumePass = publicAPI.opaquePass;\n  publicAPI.getKeyMatrices = ren => {\n    // has the camera changed?\n    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {\n      mat4.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());\n      mat3.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);\n      mat3.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n      mat4.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);\n      const aspectRatio = model._openGLRenderer.getAspectRatio();\n      mat4.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));\n      mat4.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);\n      mat4.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);\n      model.keyMatrixTime.modified();\n      model.lastRenderer = ren;\n    }\n    return model.keyMatrices;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  lastRenderer: null,\n  keyMatrixTime: null,\n  keyMatrices: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime);\n\n  // values always get set by the get method\n  model.keyMatrices = {\n    normalMatrix: new Float64Array(9),\n    vcpc: new Float64Array(16),\n    wcvc: new Float64Array(16),\n    wcpc: new Float64Array(16)\n  };\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context', 'keyMatrixTime']);\n\n  // Object methods\n  vtkOpenGLCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkCamera = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkCamera', newInstance);\n\nexport { vtkCamera as default, extend, newInstance };\n", "import { vec3, mat4 } from 'gl-matrix';\nimport * as d3 from 'd3-scale';\nimport { S as normalize2D, T as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\n\n// ----------------------------------------------------------------------------\n// vtkCubeAxesActor\n// ----------------------------------------------------------------------------\n// faces are -x x -y y -z z\n// point 0 is 0,0,0 and then +x fastest changing, +y then +z\nconst faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];\nconst faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];\nconst edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];\nconst edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];\nconst faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];\n\n//\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n\n// some shared temp variables to reduce heap allocs\nconst ptv3 = new Float64Array(3);\nconst pt2v3 = new Float64Array(3);\nconst tmpv3 = new Float64Array(3);\nconst tmp2v3 = new Float64Array(3);\nconst xDir = new Float64Array(3);\nconst yDir = new Float64Array(3);\nconst invmat = new Float64Array(16);\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;\n}\nfunction defaultGenerateTicks(dataBounds) {\n  const ticks = [];\n  const tickStrings = [];\n  for (let i = 0; i < 3; i++) {\n    const scale = d3.scaleLinear().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);\n    ticks[i] = scale.ticks(5);\n    const format = scale.tickFormat(5);\n    tickStrings[i] = ticks[i].map(format);\n  }\n  return {\n    ticks,\n    tickStrings\n  };\n}\n\n// many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\nfunction vtkCubeAxesActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActorHelper');\n  publicAPI.setRenderable = renderable => {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.tmActor.addTexture(model.renderable.getTmTexture());\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    publicAPI.modified();\n  };\n\n  // called by updateTexturePolyData\n  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {\n    const value = model.renderable.get_tmAtlas().get(text);\n    if (!value) {\n      return;\n    }\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n\n    // compute pixel to distance factors\n    const size = model.lastSize;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    vec3.transformMat4(tmpv3, ptv3, cmat);\n    // moving 0.1 in NDC\n    tmpv3[0] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(xDir, pt2v3, ptv3);\n    tmpv3[0] -= 0.1;\n    tmpv3[1] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(yDir, pt2v3, ptv3);\n    for (let i = 0; i < 3; i++) {\n      xDir[i] /= 0.5 * 0.1 * size[0];\n      yDir[i] /= 0.5 * 0.1 * size[1];\n    }\n\n    // have to find the four corners of the texture polygon for this label\n    // convert anchor point to View Coords\n    let ptIdx = results.ptIdx;\n    let cellIdx = results.cellIdx;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    // horizontal left, right, or middle alignment based on dir[0]\n    if (dir[0] < -0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);\n    } else if (dir[0] > 0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset);\n    } else {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);\n    }\n    vec3.add(ptv3, ptv3, tmpv3);\n    vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    vec3.scale(tmpv3, yDir, value.height);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.subtract(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++;\n\n    // add the two triangles to represent the quad\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  };\n\n  // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n  publicAPI.updateTexturePolyData = () => {\n    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);\n    mat4.transpose(cmat, cmat);\n\n    // update the polydata\n    const numLabels = model.renderable.getTextValues().length;\n    const numPts = numLabels * 4;\n    const numTris = numLabels * 2;\n    const points = new Float64Array(numPts * 3);\n    const polys = new Uint16Array(numTris * 4);\n    const tcoords = new Float32Array(numPts * 2);\n    mat4.invert(invmat, cmat);\n    const results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys,\n      points,\n      tcoords\n    };\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisIdx = 0;\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n    const textValues = model.renderable.getTextValues();\n    while (ptIdx < coords.length / 3) {\n      // compute the direction to move out\n      ptv3[0] = coords[ptIdx * 3];\n      ptv3[1] = coords[ptIdx * 3 + 1];\n      ptv3[2] = coords[ptIdx * 3 + 2];\n      vec3.transformMat4(tmpv3, ptv3, cmat);\n      ptv3[0] = coords[ptIdx * 3 + 3];\n      ptv3[1] = coords[ptIdx * 3 + 4];\n      ptv3[2] = coords[ptIdx * 3 + 5];\n      vec3.transformMat4(tmp2v3, ptv3, cmat);\n      vec3.subtract(tmpv3, tmpv3, tmp2v3);\n      const dir = [tmpv3[0], tmpv3[1]];\n      normalize2D(dir);\n\n      // write the axis label\n      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);\n      ptIdx += 2;\n      textIdx++;\n\n      // write the tick labels\n      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {\n        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);\n        ptIdx++;\n        textIdx++;\n      }\n      axisIdx++;\n    }\n    const tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    model.camera = camera;\n\n    // compute bounds for label quads whenever the camera changes\n    publicAPI.updateTexturePolyData();\n  };\n}\nconst newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  macro.setGet(publicAPI, model, ['renderable']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);\n  model.forceUpdate = false;\n  model.lastRedrawTime = {};\n  macro.obj(model.lastRedrawTime, {\n    mtime: 0\n  });\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1];\n\n  // internal variables\n  model.lastTickBounds = [];\n  vtkCubeAxesActorHelper(publicAPI, model);\n}, 'vtkCubeAxesActorHelper');\nfunction vtkCubeAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActor');\n  publicAPI.setCamera = cam => {\n    if (model.camera === cam) {\n      return;\n    }\n    if (model.cameraModifiedSub) {\n      model.cameraModifiedSub.unsubscribe();\n      model.cameraModifiedSub = null;\n    }\n    model.camera = cam;\n    if (cam) {\n      model.cameraModifiedSub = cam.onModified(publicAPI.update);\n    }\n    publicAPI.update();\n    publicAPI.modified();\n  };\n\n  // estimate from a camera model what faces to draw\n  // return true if the list of faces to draw has changed\n  publicAPI.computeFacesToDraw = () => {\n    const cmat = model.camera.getViewMatrix();\n    mat4.transpose(cmat, cmat);\n    let changed = false;\n    const length = vtkBoundingBox.getDiagonalLength(model.dataBounds);\n    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);\n    for (let f = 0; f < 6; f++) {\n      let drawit = false;\n      const faceAxis = Math.floor(f / 2);\n      const otherAxis1 = (faceAxis + 1) % 3;\n      const otherAxis2 = (faceAxis + 2) % 3;\n      // only for non degenerate axes\n      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {\n        // for each face transform the center and off center to get a direction vector\n        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];\n        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);\n        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);\n        vec3.transformMat4(tmpv3, ptv3, cmat);\n        ptv3[faceAxis] = model.dataBounds[f];\n        vec3.transformMat4(tmp2v3, ptv3, cmat);\n        vec3.subtract(tmpv3, tmp2v3, tmpv3);\n        vec3.normalize(tmpv3, tmpv3);\n        // tmpv3 now holds the face normal vector\n        drawit = tmpv3[2] > faceDot;\n        // for perspctive we need the view direction to the plane\n        if (!model.camera.getParallelProjection()) {\n          vec3.normalize(tmp2v3, tmp2v3);\n          drawit = vec3.dot(tmp2v3, tmpv3) > faceDot;\n        }\n      }\n      if (drawit !== model.lastFacesToDraw[f]) {\n        model.lastFacesToDraw[f] = drawit;\n        changed = true;\n      }\n    }\n    return changed;\n  };\n\n  // update the polydata that represents the boundingd edges and gridlines\n  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {\n    // compute the number of points and lines required\n    let numPts = 0;\n    let numLines = 0;\n    numPts += 8; // always start with the 8 cube points\n\n    // count edgesToDraw\n    let numEdgesToDraw = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        numEdgesToDraw++;\n      }\n    }\n    numLines += numEdgesToDraw;\n\n    // add values for gridlines\n    if (model.gridLines) {\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;\n          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;\n        }\n      }\n    }\n\n    // now allocate the memory\n    const points = new Float64Array(numPts * 3);\n    const lines = new Uint32Array(numLines * 3);\n    let ptIdx = 0;\n    let lineIdx = 0;\n\n    // add the 8 corner points\n    for (let z = 0; z < 2; z++) {\n      for (let y = 0; y < 2; y++) {\n        for (let x = 0; x < 2; x++) {\n          points[ptIdx * 3] = model.dataBounds[x];\n          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];\n          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];\n          ptIdx++;\n        }\n      }\n    }\n\n    // draw the edges\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        lines[lineIdx * 3] = 2;\n        lines[lineIdx * 3 + 1] = edgePoints[e][0];\n        lines[lineIdx * 3 + 2] = edgePoints[e][1];\n        lineIdx++;\n      }\n    }\n\n    // now handle gridlines\n    // grid lines are tick[axis1] + ticks[axes2] lines each having two points\n    // for simplicity we don;t worry about duplicating points, this is tiny\n\n    if (model.gridLines) {\n      // for each visible face\n      // add the points\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          const faceIdx = Math.floor(f / 2);\n          let aticks = ticks[faceAxes[f][0]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n          aticks = ticks[faceAxes[f][1]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n        }\n      }\n    }\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getLines().setData(lines, 1);\n    model.polyData.getLines().modified();\n    model.polyData.modified();\n  };\n\n  // update the data that represents where to put the labels\n  // in world coordinates. This only changes when faces to draw changes\n  // of dataBounds changes\n  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {\n    // count outside edgesToDraw\n    let textPointCount = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] === 1) {\n        textPointCount += 2;\n        textPointCount += ticks[edgeAxes[e]].length;\n      }\n    }\n    const points = model.polyData.getPoints().getData();\n    const textPoints = new Float64Array(textPointCount * 3);\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisCount = 0;\n    for (let f = 0; f < 6; f++) {\n      if (facesToDraw[f]) {\n        for (let e = 0; e < 4; e++) {\n          const edgeIdx = faceEdges[f][e];\n          if (edgesToDraw[edgeIdx] === 1) {\n            const edgeAxis = edgeAxes[edgeIdx];\n            // add a middle point on the edge\n            const ptIdx1 = edgePoints[edgeIdx][0] * 3;\n            const ptIdx2 = edgePoints[edgeIdx][1] * 3;\n            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);\n            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);\n            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);\n            ptIdx++;\n            // add a middle face point, we use this to\n            // move the labels away from the edge in the right direction\n            const faceIdx = Math.floor(f / 2);\n            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);\n            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);\n            ptIdx++;\n            // set the text\n            model.textValues[textIdx] = model.axisLabels[edgeAxis];\n            textIdx++;\n\n            // now add the tick marks along the edgeAxis\n            const otherAxis1 = (edgeAxis + 1) % 3;\n            const otherAxis2 = (edgeAxis + 2) % 3;\n            const aticks = ticks[edgeAxis];\n            const atickStrings = tickStrings[edgeAxis];\n            model.tickCounts[axisCount] = aticks.length;\n            for (let t = 0; t < aticks.length; t++) {\n              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];\n              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];\n              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];\n              ptIdx++;\n              // set the text\n              model.textValues[textIdx] = atickStrings[t];\n              textIdx++;\n            }\n            axisCount++;\n          }\n        }\n      }\n    }\n    model.textPolyData.getPoints().setData(textPoints, 3);\n    model.textPolyData.modified();\n  };\n\n  // main method to rebuild the cube axes, gets called on camera modify\n  // and changes to key members\n  publicAPI.update = () => {\n    // Can't do anything if we don't have a camera...\n    if (!model.camera) {\n      return;\n    }\n\n    // compute what faces to draw\n    const facesChanged = publicAPI.computeFacesToDraw();\n    const facesToDraw = model.lastFacesToDraw;\n\n    // have the bounds changed?\n    let boundsChanged = false;\n    for (let i = 0; i < 6; i++) {\n      if (model.dataBounds[i] !== model.lastTickBounds[i]) {\n        boundsChanged = true;\n        model.lastTickBounds[i] = model.dataBounds[i];\n      }\n    }\n\n    // did something significant change? If so rebuild a lot of things\n    if (facesChanged || boundsChanged || model.forceUpdate) {\n      // compute the edges to draw\n      // for each drawn face, mark edges, all single mark edges we draw\n      const edgesToDraw = new Array(12).fill(0);\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          for (let e = 0; e < 4; e++) {\n            edgesToDraw[faceEdges[f][e]]++;\n          }\n        }\n      }\n\n      // compute tick marks for axes\n      const t = model.generateTicks(model.dataBounds);\n\n      // update gridlines / edge lines\n      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);\n\n      // compute label world coords and text\n      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);\n\n      // rebuild the texture only when force or changed bounds, face\n      // visibility changes do to change the atlas\n      if (boundsChanged || model.forceUpdate) {\n        publicAPI.updateTextureAtlas(t.tickStrings);\n      }\n    }\n    model.forceUpdate = false;\n  };\n\n  // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n  publicAPI.updateTextureAtlas = tickStrings => {\n    // compute the width and height we need\n\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n\n    // first the three labels\n    model._tmAtlas.clear();\n    let maxWidth = 0;\n    let totalHeight = 1; // start one pixel in so we have a border\n    for (let i = 0; i < 3; i++) {\n      if (!model._tmAtlas.has(model.axisLabels[i])) {\n        applyTextStyle(model.tmContext, model.axisTextStyle);\n        const metrics = model.tmContext.measureText(model.axisLabels[i]);\n        const entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.axisTextStyle\n        };\n        model._tmAtlas.set(model.axisLabels[i], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n      }\n      // and the ticks\n      applyTextStyle(model.tmContext, model.tickTextStyle);\n      for (let t = 0; t < tickStrings[i].length; t++) {\n        if (!model._tmAtlas.has(tickStrings[i][t])) {\n          const metrics = model.tmContext.measureText(tickStrings[i][t]);\n          const entry = {\n            height: metrics.actualBoundingBoxAscent + 2,\n            startingHeight: totalHeight,\n            width: metrics.width + 2,\n            textStyle: model.tickTextStyle\n          };\n          model._tmAtlas.set(tickStrings[i][t], entry);\n          totalHeight += entry.height;\n          if (maxWidth < entry.width) {\n            maxWidth = entry.width;\n          }\n        }\n      }\n    }\n\n    // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight);\n\n    // set the tcoord values\n    model._tmAtlas.forEach(value => {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    });\n\n    // make sure we have power of two dimensions\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);\n\n    // draw the text onto the texture\n    model._tmAtlas.forEach((value, key) => {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    model.tmTexture.modified();\n  };\n\n  // Make sure the data is correct\n  publicAPI.onModified(() => {\n    model.forceUpdate = true;\n    publicAPI.update();\n  });\n  publicAPI.setTickTextStyle = tickStyle => {\n    model.tickTextStyle = {\n      ...model.tickTextStyle,\n      ...tickStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = axisStyle => {\n    model.axisTextStyle = {\n      ...model.axisTextStyle,\n      ...axisStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.get_tmAtlas = () => model._tmAtlas;\n\n  // try to get the bounds for the annotation. This is complicated\n  // as it relies on the pixel size of the window. Every time the camera\n  // changes the bounds change. This method simplifies by just expanding\n  // the grid bounds by a user specified factor.\n  publicAPI.getBounds = () => {\n    publicAPI.update();\n    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());\n    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);\n    return model.bounds;\n  };\n\n  // Make sure the grid share the actor property\n  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);\n  publicAPI.setProperty = p => _setProp(p)[0];\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(publicAPI, model, initialValues) {\n  return {\n    boundsScaleFactor: 1.3,\n    camera: null,\n    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],\n    faceVisibilityAngle: 8,\n    gridLines: true,\n    axisLabels: null,\n    axisTitlePixelOffset: 35.0,\n    tickLabelPixelOffset: 12.0,\n    generateTicks: defaultGenerateTicks,\n    ...initialValues,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif',\n      ...initialValues?.axisTextStyle\n    },\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif',\n      ...initialValues?.tickTextStyle\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Inheritance\n  vtkActor.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));\n\n  // internal variables\n  model.lastFacesToDraw = [false, false, false, false, false, false];\n  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];\n  model.tickCounts = [];\n  model.textValues = [];\n  model.lastTickBounds = [];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map();\n\n  // for texture atlas\n  model.tmTexture = vtkTexture.newInstance({\n    resizable: true\n  });\n  model.tmTexture.setInterpolate(false);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  model.gridMapper = vtkMapper.newInstance();\n  model.polyData = vtkPolyData.newInstance();\n  model.gridMapper.setInputData(model.polyData);\n  model.gridActor = vtkActor.newInstance();\n  model.gridActor.setMapper(model.gridMapper);\n  model.gridActor.setProperty(publicAPI.getProperty());\n  model.gridActor.setParentProp(publicAPI);\n  model.textPolyData = vtkPolyData.newInstance();\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset', 'generateTicks']);\n  macro.setGetArray(publicAPI, model, ['dataBounds'], 6);\n  macro.setGetArray(publicAPI, model, ['axisLabels'], 3);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);\n\n  // Object methods\n  vtkCubeAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCubeAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCubeAxesActor$1 = {\n  newInstance,\n  extend,\n  newCubeAxesActorHelper,\n  defaultGenerateTicks\n};\n\nexport { vtkCubeAxesActor$1 as default, extend, newInstance };\n", "import { n as newInstance$1 } from '../../macros2.js';\nimport vtkCubeAxesActor from '../Core/CubeAxesActor.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCubeAxesActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCubeAxesActor(publicAPI, model) {\n  model.classHierarchy.push('vtkOpenGLCubeAxesActor');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      if (!model.CubeAxesActorHelper.getRenderable()) {\n        model.CubeAxesActorHelper.setRenderable(model.renderable);\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());\n      publicAPI.addMissingNode(model.renderable.getGridActor());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;\n      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();\n      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.CubeAxesActorHelper = vtkCubeAxesActor.newCubeAxesActorHelper();\n\n  // Object methods\n  vtkOpenGLCubeAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLCubeAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkCubeAxesActor', newInstance);\n\nexport { index as default, extend, newInstance };\n", "var vtkPolyDataVS = \"//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n\";\n\nexport { vtkPolyDataVS as v };\n", "var vtkPolyDataFS = \"//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n\";\n\nexport { vtkPolyDataFS as v };\n", "import vtkShaderProgram from './ShaderProgram.js';\n\nfunction implementReplaceShaderCoincidentOffset(publicAPI, model) {\n  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {\n    const cp = publicAPI.getCoincidentParameters(ren, actor);\n\n    // if we need an offset handle it here\n    // The value of .000016 is suitable for depth buffers\n    // of at least 16 bit depth. We do not query the depth\n    // right now because we would need some mechanism to\n    // cache the result taking into account FBO changes etc.\n    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;\n      if (model.context.getExtension('EXT_frag_depth')) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      shaders.Fragment = FSSource;\n    }\n  };\n}\nfunction implementBuildShadersWithReplacements(publicAPI, model) {\n  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {\n    let shaderReplacements = null;\n    if (viewSpec) {\n      shaderReplacements = viewSpec.ShaderReplacements;\n    }\n    if (shaderReplacements) {\n      for (let i = 0; i < shaderReplacements.length; i++) {\n        const currReplacement = shaderReplacements[i];\n        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {\n          const shaderType = currReplacement.shaderType;\n          const ssrc = shaders[shaderType];\n          const substituteRes = vtkShaderProgram.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);\n          shaders[shaderType] = substituteRes.result;\n        }\n      }\n    }\n  };\n  publicAPI.buildShaders = (shaders, ren, actor) => {\n    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);\n    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;\n\n    // apply any renderPassReplacements\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;\n\n    // user specified pre replacements\n    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n\n    // user specified post replacements\n    publicAPI.applyShaderReplacements(shaders, openGLSpec);\n  };\n  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {\n    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    let vertexShaderCode = shaders.Vertex;\n    if (openGLSpecProp) {\n      const vertexSpecProp = openGLSpecProp.VertexShaderCode;\n      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {\n        vertexShaderCode = vertexSpecProp;\n      }\n    }\n    shaders.Vertex = vertexShaderCode;\n    let fragmentShaderCode = shaders.Fragment;\n    if (openGLSpecProp) {\n      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;\n      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {\n        fragmentShaderCode = fragmentSpecProp;\n      }\n    }\n    shaders.Fragment = fragmentShaderCode;\n    let geometryShaderCode = shaders.Geometry;\n    if (openGLSpecProp) {\n      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;\n      if (geometrySpecProp !== undefined) {\n        geometryShaderCode = geometrySpecProp;\n      }\n    }\n    shaders.Geometry = geometryShaderCode;\n  };\n}\nvar vtkReplacementShaderMapper = {\n  implementReplaceShaderCoincidentOffset,\n  implementBuildShadersWithReplacements\n};\n\nexport { vtkReplacementShaderMapper as default };\n", "import { mat3, mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet, o as obj, c as macro } from '../../macros2.js';\nimport vtkHelper from './Helper.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport { l as normalize } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport { PassTypes } from './HardwareSelector/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport '../Core/Mapper/CoincidentTopologyHelper.js';\nimport { Resolve } from '../Core/Mapper/Static.js';\n\nconst {\n  FieldAssociations\n} = vtkDataSet;\n\n/* eslint-disable no-lonely-if */\n\nconst {\n  primTypes\n} = vtkHelper;\nconst {\n  Representation,\n  Shading\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  Filter,\n  Wrap\n} = vtkOpenGLTexture;\nconst {\n  vtkErrorMacro\n} = macro;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\nconst {\n  CoordinateSystem\n} = vtkProp;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction getPickState(renderer) {\n  const selector = renderer.getSelector();\n  if (selector) {\n    return selector.getCurrentPass();\n  }\n  return PassTypes.MIN_KNOWN_PASS - 1;\n}\nfunction vtkOpenGLPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');\n      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera(), model.openGLCamera);\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = () => {\n    const ctx = model._openGLRenderWindow.getContext();\n    if (model.context !== ctx) {\n      model.context = ctx;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n    const actor = model.openGLActor.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    // create the material/color property declarations, and VS implementation\n    // these are always defined\n    let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];\n    // add more for specular\n    if (lastLightComplexity) {\n      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n    }\n\n    // now handle the more complex fragment shader implementation\n    // the following are always defined variables.  We start\n    // by assigning a default value from the uniform\n    let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n    }\n    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n    }\n\n    // add scalar vertex coloring\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n    }\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else {\n      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;\n      } else {\n        if (actor.getBackfaceProperty() && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);\n          if (lastLightComplexity) {\n            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);\n          } else {\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);\n          }\n        }\n        if (model.haveCellScalars && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // check for shadow maps\n    const shadowFactor = '';\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    let sstring = [];\n    switch (lastLightComplexity) {\n      case 0:\n        // no lighting or RENDER_VALUES\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 1:\n        // headlight\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 2:\n        // light kit\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      case 3:\n        // positional\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${lc},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      default:\n        vtkErrorMacro('bad light complexity');\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.lastBoundBO.getCABO().getNormalOffset()) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',\n        //  if (!gl_FrontFacing) does not work in intel hd4000 mac\n        //  if (int(gl_FrontFacing) == 0) does not work on mesa\n        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n      } else {\n        if (model.haveCellNormals) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n        } else {\n          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {\n            // generate a normal for lines, it will be perpendicular to the line\n            // and maximally aligned with the camera view direction\n            // no clue if this is the best way to do this.\n            // the code below has been optimized a bit so what follows is\n            // an explanation of the basic approach. Compute the gradient of the line\n            // with respect to x and y, the the larger of the two\n            // cross that with the camera view direction. That gives a vector\n            // orthogonal to the camera view and the line. Note that the line and the camera\n            // view are probably not orthogonal. Which is why when we cross result that with\n            // the line gradient again we get a reasonable normal. It will be othogonal to\n            // the line (which is a plane but maximally aligned with the camera view.\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;\n          } else {\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', [\n            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',\n            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',\n            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',\n            // the code below is faster, but does not work on some devices\n            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',\n            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;\n          }\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n\n    // do we need the vertex in the shader in View Coordinates\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;\n    } else {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.drawingEdges) {\n        return;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n\n      // we only handle the first texture by default\n      // additional textures are activated and we set the uniform\n      // for the texture unit they are assigned to, but you have to\n      // add in the shader code to do something with them\n      const tus = model.openGLActor.getActiveTextures();\n      let tNumComp = 2;\n      let tcdim = 2;\n      if (tus && tus.length > 0) {\n        tNumComp = tus[0].getComponents();\n        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {\n          tcdim = 3;\n        }\n      }\n      if (model.renderable.getColorTextureMap()) {\n        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();\n        tcdim = 2;\n      }\n      if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        if (tus && tus.length >= 1) {\n          switch (tNumComp) {\n            case 1:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n              break;\n            case 2:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n              break;\n            default:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n          }\n        }\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;\n        switch (tNumComp) {\n          case 1:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n            break;\n          case 2:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n            break;\n          default:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    // 1. ResolveCoincidentTopology is On and non zero for this primitive\n    // type\n    let cp = {\n      factor: 0.0,\n      offset: 0.0\n    };\n    const prop = actor.getProperty();\n    if (\n    // backwards compat with code that (errorneously) set this to boolean\n    // eslint-disable-next-line eqeqeq\n    model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {\n      const primType = model.lastBoundBO.getPrimitiveType();\n      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {\n        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();\n      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {\n        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();\n      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n      }\n      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n        cp.factor /= 2.0;\n        cp.offset /= 2.0;\n      }\n    }\n\n    // hardware picking always offset due to saved zbuffer\n    // This gets you above the saved surface depth buffer.\n    const selector = model._openGLRenderer.getSelector();\n    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      cp.offset -= 2.0;\n    }\n    return cp;\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    let VSSource = shaders.Vertex;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;\n    if (!model._openGLRenderer.getSelector()) {\n      return;\n    }\n    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\\n', 'uniform int VertexIDOffset;\\n']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;\n    }\n    switch (model.lastSelectionState) {\n      case PassTypes.ID_LOW24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;\n        break;\n      case PassTypes.ID_HIGH24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);').result;\n        break;\n      default:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    }\n    shaders.Fragment = FSSource;\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderNormal(shaders, ren, actor);\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    let lightComplexity = 0;\n    let numberOfLights = 0;\n    const primType = cellBO.getPrimitiveType();\n    const poly = model.currentInput;\n\n    // different algo from C++ as of 5/2019\n    let needLighting = false;\n    const pointNormals = poly.getPointData().getNormals();\n    const cellNormals = poly.getCellData().getNormals();\n    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;\n    const representation = actor.getProperty().getRepresentation();\n    const mode = cellBO.getOpenGLMode(representation, primType);\n    // 1) all surfaces need lighting\n    if (mode === model.context.TRIANGLES) {\n      needLighting = true;\n      // 2) all cell normals without point normals need lighting\n    } else if (cellNormals && !pointNormals) {\n      needLighting = true;\n      // 3) Phong + pointNormals need lighting\n    } else if (!flat && pointNormals) {\n      needLighting = true;\n      // 4) Phong Lines need lighting\n    } else if (!flat && mode === model.context.LINES) {\n      needLighting = true;\n    }\n    // 5) everything else is unlit\n\n    // do we need lighting?\n    if (actor.getProperty().getLighting() && needLighting) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      const lights = ren.getLightsByReference();\n      for (let index = 0; index < lights.length; ++index) {\n        const light = lights[index];\n        const status = light.getSwitch();\n        if (status > 0) {\n          numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      }\n    }\n    let needRebuild = false;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {\n      model.lastBoundBO.set({\n        lastLightComplexity: lightComplexity\n      }, true);\n      model.lastBoundBO.set({\n        lastLightCount: numberOfLights\n      }, true);\n      needRebuild = true;\n    }\n\n    // has the render pass shader replacement changed? Two options\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {\n    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n    if (listCallbacks) {\n      listCallbacks.forEach(object => {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {\n      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);\n    }\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting normalMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('normalMC');\n      }\n      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {\n        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);\n          }\n        }\n      });\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      const planeEquations = [];\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n    }\n    const tus = model.openGLActor.getActiveTextures();\n    if (tus) {\n      for (let index = 0; index < tus.length; ++index) {\n        const tex = tus[index];\n        const texUnit = tex.getTextureUnit();\n        const tname = `texture${texUnit + 1}`;\n        if (cellBO.getProgram().isUniformUsed(tname)) {\n          cellBO.getProgram().setUniformi(tname, texUnit);\n        }\n      }\n    }\n\n    // handle depth requests\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    // handle wide lines\n    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n    const selector = model._openGLRenderer.getSelector();\n    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n  };\n  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {\n    // for unlit and headlight there are no lighting parameters\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 2) {\n      return;\n    }\n    const program = cellBO.getProgram();\n\n    // bind some light settings\n    let numberOfLights = 0;\n    const lights = ren.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const dColor = light.getColorByReference();\n        const intensity = light.getIntensity();\n        model.lightColor[0] = dColor[0] * intensity;\n        model.lightColor[1] = dColor[1] * intensity;\n        model.lightColor[2] = dColor[2] * intensity;\n        // get required info from light\n        const ld = light.getDirection();\n        const transform = ren.getActiveCamera().getViewMatrix();\n        const newLightDirection = [...ld];\n        if (light.lightTypeIsSceneLight()) {\n          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];\n          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];\n          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];\n          normalize(newLightDirection);\n        }\n        model.lightDirection[0] = newLightDirection[0];\n        model.lightDirection[1] = newLightDirection[1];\n        model.lightDirection[2] = newLightDirection[2];\n        normalize(model.lightDirection);\n        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);\n        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);\n        numberOfLights++;\n      }\n    }\n\n    // we are done unless we have positional lights\n    if (lastLightComplexity < 3) {\n      return;\n    }\n\n    // for lightkit case there are some parameters to set\n    const cam = ren.getActiveCamera();\n    const viewTF = cam.getViewMatrix();\n    mat4.transpose(viewTF, viewTF);\n    numberOfLights = 0;\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const lp = light.getTransformedPosition();\n        const np = new Float64Array(3);\n        vec3.transformMat4(np, lp, viewTF);\n        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());\n        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());\n        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());\n        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());\n        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);\n        numberOfLights++;\n      }\n    }\n  };\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce((res, matrix, index) => {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const cam = ren.getActiveCamera();\n    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();\n    const progm = program.getLastCameraMTime();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    const actorIsIdentity = actor.getIsIdentity();\n    const actMats = actorIsIdentity ? {\n      mcwc: null,\n      normalMatrix: null\n    } : model.openGLActor.getKeyMatrices();\n    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {\n      const size = model._openGLRenderer.getTiledSizeAndOrigin();\n      mat4.identity(model.tmpMat4);\n      model.tmpMat4[0] = 2.0 / size.usize;\n      model.tmpMat4[12] = -1.0;\n      model.tmpMat4[5] = 2.0 / size.vsize;\n      model.tmpMat4[13] = -1.0;\n      mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    } else {\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('normalMatrix')) {\n      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));\n    }\n    if (progm !== camm) {\n      if (program.isUniformUsed('cameraParallel')) {\n        program.setUniformi('cameraParallel', cam.getParallelProjection());\n      }\n      program.setLastCameraMTime(camm);\n    }\n    if (!actorIsIdentity) {\n      // reset the cam mtime as actor modified the shader values\n      program.setLastCameraMTime(0);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    let ppty = actor.getProperty();\n    let opacity = ppty.getOpacity();\n    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();\n    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();\n    let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();\n    let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();\n    let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();\n    const specularPower = ppty.getSpecularPower();\n    program.setUniformf('opacityUniform', opacity);\n    program.setUniform3fArray('ambientColorUniform', aColor);\n    program.setUniform3fArray('diffuseColorUniform', dColor);\n    program.setUniformf('ambient', aIntensity);\n    program.setUniformf('diffuse', dIntensity);\n\n    // we are done unless we have lighting\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 1) {\n      return;\n    }\n    let sColor = ppty.getSpecularColorByReference();\n    program.setUniform3fArray('specularColorUniform', sColor);\n    program.setUniformf('specularPowerUniform', specularPower);\n    program.setUniformf('specular', sIntensity);\n\n    // now set the backface properties if we have them\n    if (program.isUniformUsed('ambientIntensityBF')) {\n      ppty = actor.getBackfaceProperty();\n      opacity = ppty.getOpacity();\n      aColor = ppty.getAmbientColor();\n      aIntensity = ppty.getAmbient();\n      dColor = ppty.getDiffuseColor();\n      dIntensity = ppty.getDiffuse();\n      sColor = ppty.getSpecularColor();\n      sIntensity = ppty.getSpecular();\n      program.setUniformf('ambientIntensityBF', aIntensity);\n      program.setUniformf('diffuseIntensityBF', dIntensity);\n      program.setUniformf('opacityUniformBF', opacity);\n      program.setUniform3fArray('ambientColorUniformBF', aColor);\n      program.setUniform3fArray('diffuseColorUniformBF', dColor);\n\n      // we are done unless we have lighting\n      if (lastLightComplexity < 1) {\n        return;\n      }\n      program.setUniformf('specularIntensityBF', sIntensity);\n      program.setUniform3fArray('specularColorUniformBF', sColor);\n      program.setUniformf('specularPowerUniformBF', specularPower);\n    }\n  };\n  publicAPI.updateMaximumPointCellIds = (ren, actor) => {\n    const selector = model._openGLRenderer.getSelector();\n    if (!selector) {\n      return;\n    }\n    if (model.selectionWebGLIdsToVTKIds?.points?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.points.length;\n      selector.setMaximumPointId(length - 1);\n    }\n    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.cells.length;\n      selector.setMaximumCellId(length - 1);\n    }\n    const fieldAssociation = selector.getFieldAssociation();\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      model.pointPicking = true;\n    }\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    model.primitiveIDOffset = 0;\n    model.vertexIDOffset = 0;\n    const picking = getPickState(model._openGLRenderer);\n    if (model.lastSelectionState !== picking) {\n      model.selectionStateChanged.modified();\n      model.lastSelectionState = picking;\n    }\n    if (model._openGLRenderer.getSelector()) {\n      switch (picking) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n      }\n    }\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n    const selector = model._openGLRenderer.getSelector();\n    // If we are picking points, we need to tell it to the helper\n    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);\n\n    // for every primitive type\n    for (let i = primTypes.Start; i < primTypes.End; i++) {\n      model.primitives[i].setPointPicking(pointPicking);\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);\n        // don't draw edges when rendering depth or rendering for picking\n        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {\n          model.lastBoundBO = model.primitives[i];\n          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();\n        }\n      }\n    }\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    if (model.LastBoundBO) {\n      model.LastBoundBO.getVAO().release();\n    }\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // apply faceCulling\n    const gl = model.context;\n    const backfaceCulling = actor.getProperty().getBackfaceCulling();\n    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n    // Always call this function as the selector can change\n    publicAPI.updateMaximumPointCellIds();\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    model.haveCellScalars = false;\n    const scalarMode = model.renderable.getScalarMode();\n    if (model.renderable.getScalarVisibility()) {\n      // We must figure out how the scalars should be mapped to the polydata.\n      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n        model.haveCellScalars = true;\n      }\n    }\n\n    // Do we have normals?\n    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;\n    if (n === null && poly.getCellData().getNormals()) {\n      model.haveCellNormals = true;\n      n = poly.getCellData().getNormals();\n    }\n\n    // rebuild the VBO if the data has changed we create a string for the VBO what\n    // can change the VBO? points normals tcoords colors so what can change those?\n    // the input data is clearly one as it can change all four items tcoords may\n    // haveTextures or not colors may change based on quite a few mapping\n    // parameters in the mapper\n\n    const representation = actor.getProperty().getRepresentation();\n    let tcoords = poly.getPointData().getTCoords();\n    if (!model.openGLActor.getActiveTextures()) {\n      tcoords = null;\n    }\n\n    // Flag to check if tcoords are per cell instead of per point\n    let useTCoordsPerCell = false;\n    // handle color mapping via texture\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n      const tex = model.internalColorTexture;\n      // the following 4 lines allow for NPOT textures\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const input = model.renderable.getColorTextureMap();\n      const ext = input.getExtent();\n      const inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw({\n        width: ext[1] - ext[0] + 1,\n        height: ext[3] - ext[2] + 1,\n        numComps: inScalars.getNumberOfComponents(),\n        dataType: inScalars.getDataType(),\n        data: inScalars.getData()\n      });\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n    const customAttributes = model.renderable.getCustomShaderAttributes();\n    const customAttributesArrays = customAttributes.map(arrayName => poly.getPointData().getArrayByName(arrayName));\n    const toString = `${poly.getMTime()}` + `A${representation}` + `B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}` + `D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}` + `G${customAttributesArrays.map(attributeArray => attributeArray.getMTime()).join(',')}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const points = poly.getPoints();\n      const options = {\n        points,\n        normals: n,\n        tcoords,\n        colors: c,\n        cellOffset: 0,\n        vertexOffset: 0,\n        // Used to keep track of vertex ids across primitives for selection\n        useTCoordsPerCell,\n        haveCellScalars: model.haveCellScalars,\n        haveCellNormals: model.haveCellNormals,\n        customAttributes: customAttributesArrays\n      };\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.selectionWebGLIdsToVTKIds = {\n          points: null,\n          cells: null\n        };\n      }\n      const primitives = [{\n        inRep: 'verts',\n        cells: poly.getVerts()\n      }, {\n        inRep: 'lines',\n        cells: poly.getLines()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }];\n      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {\n          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);\n          options.vertexOffset += model.primitives[i].getCABO().getElementCount();\n        } else {\n          // if we have edge visibility build the edge VBOs\n          if (drawSurfaceWithEdges) {\n            // VBOs for edges in \"surface with edges\" are the last to be built,\n            // they are not used when picking with a hardware selector so they\n            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset\n            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, {\n              ...options,\n              tcoords: null,\n              colors: null,\n              haveCellScalars: false,\n              haveCellNormals: false\n            });\n          } else {\n            // otherwise free them\n            model.primitives[i].releaseGraphicsResources();\n          }\n        }\n      }\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);\n      }\n      model.VBOBuildString = toString;\n    }\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => {\n    let memUsed = 0;\n    model.primitives.forEach(prim => {\n      memUsed += prim.getAllocatedGPUMemoryInBytes();\n    });\n    // Return in MB\n    return memUsed;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null,\n  tmpMat4: null,\n  ambientColor: [],\n  // used internally\n  diffuseColor: [],\n  // used internally\n  specularColor: [],\n  // used internally\n  lightColor: [],\n  // used internally\n  lightDirection: [],\n  // used internally\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,\n  selectionStateChanged: null,\n  selectionWebGLIdsToVTKIds: null,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  for (let i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  }\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.selectionStateChanged = {};\n  obj(model.selectionStateChanged, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLPolyDataMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLPolyDataMapper$1 = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkMapper', newInstance);\n\nexport { vtkOpenGLPolyDataMapper$1 as default, extend, newInstance };\n", "import { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// import { mat4, vec3 }     from 'gl-matrix';\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPixelSpaceCallbackMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {\n  model.classHierarchy.push('vtkOpenGLPixelSpaceCallbackMapper');\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n    model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n    const aspectRatio = model._openGLRenderer.getAspectRatio();\n    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;\n    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();\n    let texels = null;\n    if (model.renderable.getUseZValues()) {\n      const zbt = renderPass.getZBufferTexture();\n      const width = Math.floor(zbt.getWidth());\n      const height = Math.floor(zbt.getHeight());\n      const gl = model._openGLRenderWindow.getContext();\n      zbt.bind();\n\n      // Here we need to use vtkFramebuffer to save current settings (bindings/buffers)\n      const fb = renderPass.getFramebuffer();\n      if (!fb) {\n        vtkDebugMacro('No framebuffer to save/restore');\n      } else {\n        // save framebuffer settings\n        fb.saveCurrentBindingsAndBuffers();\n      }\n      const framebuffer = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);\n      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {\n        texels = new Uint8Array(width * height * 4);\n        gl.viewport(0, 0, width, height);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);\n      }\n\n      // Now we need to restore framebuffer bindings/buffers\n      if (fb) {\n        fb.restorePreviousBindingsAndBuffers();\n      }\n      gl.deleteFramebuffer(framebuffer);\n    }\n    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (model.renderable.getUseZValues()) {\n        renderPass.requestDepth();\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPixelSpaceCallbackMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPixelSpaceCallbackMapper = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkPixelSpaceCallbackMapper', newInstance);\n\nexport { vtkPixelSpaceCallbackMapper as default, extend, newInstance };\n", "var vtkPolyData2DFS = \"//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n\";\n\nexport { vtkPolyData2DFS as v };\n", "var vtkPolyData2DVS = \"//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n\";\n\nexport { vtkPolyData2DVS as v };\n", "const DisplayLocation = {\n  BACKGROUND: 0,\n  FOREGROUND: 1\n};\nvar Constants = {\n  DisplayLocation\n};\n\nexport { DisplayLocation, Constants as default };\n", "import { mat4 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet, o as obj, c as macro } from '../../macros2.js';\nimport vtkHelper from './Helper.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport { v as vtkPolyData2DFS } from './glsl/vtkPolyData2DFS.glsl.js';\nimport { v as vtkPolyData2DVS } from './glsl/vtkPolyData2DVS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport { R as round } from '../../Common/Core/Math/index.js';\nimport { DisplayLocation } from '../Core/Property2D/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// import { mat3, mat4, vec3 } from 'gl-matrix';\nconst {\n  primTypes\n} = vtkHelper;\nconst {\n  Filter,\n  Wrap\n} = vtkOpenGLTexture;\nconst {\n  vtkErrorMacro\n} = macro;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper2D methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLPolyDataMapper2D(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper2D');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.openGLActor2D = publicAPI.getFirstAncestorOfType('vtkOpenGLActor2D');\n      model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera(), model.openGLCamera);\n    }\n  };\n  publicAPI.overlayPass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyData2DVS;\n    shaders.Fragment = vtkPolyData2DFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.render = () => {\n    const ctx = model._openGLRenderWindow.getContext();\n    if (model.context !== ctx) {\n      model.context = ctx;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n    const actor = model.openGLActor2D.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // cull back face to avoid double drawing\n    const gl = model.context;\n    model._openGLRenderWindow.enableCullFace();\n    gl.cullFace(gl.BACK);\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    model.primitiveIDOffset = 0;\n    if (model._openGLRenderer.getSelector()) {\n      switch (model._openGLRenderer.getSelector().getCurrentPass()) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n      }\n    }\n\n    // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    }\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, actor.getProperty().getOpacity());\n    const c = model.renderable.getColorMapColors();\n    const representation = actor.getProperty().getRepresentation();\n    let tcoords = poly.getPointData().getTCoords();\n    if (!model.openGLActor2D.getActiveTextures()) {\n      tcoords = null;\n    }\n\n    // Flag to check if tcoords are per cell instead of per point\n    let useTCoordsPerCell = false;\n    // handle color mapping via texture\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n      const tex = model.internalColorTexture;\n      // the following 4 lines allow for NPOT textures\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const input = model.renderable.getColorTextureMap();\n      const ext = input.getExtent();\n      const inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw({\n        width: ext[1] - ext[0] + 1,\n        height: ext[3] - ext[2] + 1,\n        numComps: inScalars.getNumberOfComponents(),\n        dataType: inScalars.getDataType(),\n        data: inScalars.getData()\n      });\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n    const transformCoordinate = model.renderable.getTransformCoordinate();\n    const view = ren.getRenderWindow().getViews()[0];\n    const vsize = view.getViewportSize(ren);\n    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${c ? c.getMTime() : 1}` + `D${tcoords ? tcoords.getMTime() : 1}` + `E${transformCoordinate ? ren.getMTime() : 1}` + `F${vsize}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      let points = poly.getPoints();\n      if (transformCoordinate) {\n        const p = vtkPoints.newInstance();\n        const numPts = points.getNumberOfPoints();\n        p.setNumberOfPoints(numPts);\n        const point = [];\n        for (let i = 0; i < numPts; ++i) {\n          points.getPoint(i, point);\n          transformCoordinate.setValue(point);\n          const v = transformCoordinate.getComputedDoubleViewportValue(ren);\n          p.setPoint(i, v[0], v[1], 0.0);\n        }\n        points = p;\n      }\n      const options = {\n        points,\n        tcoords,\n        colors: c,\n        cellOffset: 0,\n        useTCoordsPerCell,\n        haveCellScalars: model.renderable.getAreScalarsMappedFromCells(),\n        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))\n      };\n      options.cellOffset += model.primitives[primTypes.Points].getCABO().createVBO(poly.getVerts(), 'verts', representation, options);\n      options.cellOffset += model.primitives[primTypes.Lines].getCABO().createVBO(poly.getLines(), 'lines', representation, options);\n      options.cellOffset += model.primitives[primTypes.Tris].getCABO().createVBO(poly.getPolys(), 'polys', representation, options);\n      options.cellOffset += model.primitives[primTypes.TriStrips].getCABO().createVBO(poly.getStrips(), 'strips', representation, options);\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const gl = model.context;\n    gl.depthMask(true);\n\n    // for every primitive type\n    for (let i = primTypes.Start; i < primTypes.End; i++) {\n      // if there are entries\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        model.lastBoundBO = model.primitives[i];\n        model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n      }\n    }\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    if (model.lastBoundBO) {\n      model.lastBoundBO.getVAO().release();\n    }\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n\n    // create the color property declarations\n    // these are always defined\n    let colorDec = ['uniform vec3 diffuseColorUniform;', 'uniform float opacityUniform;'];\n\n    // now handle the more complex fragment shader implementation\n    let colorImpl = ['vec3 diffuseColor = diffuseColorUniform;', 'float opacity = opacityUniform;'];\n\n    // add scalar vertex colors\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else if (model.renderable.getAreScalarsMappedFromCells()) {\n      colorImpl = colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  opacity = opacity*texColor.a;']);\n    }\n    colorImpl = colorImpl.concat(['gl_FragData[0] = vec4(diffuseColor, opacity);']);\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();\n      if (tcdim === 1) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', ['in float tcoordMC;', 'out float tcoordVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput[];\\n', 'out float tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, ['//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));']).result;\n      } else if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordMC;', 'out vec2 tcoordVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];\\n', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', ['tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);']).result;\n      }\n      if (model.renderable.getAreScalarsMappedFromCells()) {\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PrimID::Impl', ['gl_PrimitiveID = gl_PrimitiveIDIn;']).result;\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform vec3 mapperIndex;', 'uniform int picking;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n  };\n  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {\n    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n    if (listCallbacks) {\n      listCallbacks.forEach(object => {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n    if (cellBO.getProgram().isAttributeUsed('vertexWC')) {\n      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n        vtkErrorMacro('Error setting vertexWC in shader VAO.');\n      }\n    }\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {\n        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);\n          }\n        }\n      });\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n        const texUnit = model.internalColorTexture.getTextureUnit();\n        if (texUnit > -1) {\n          cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n        }\n      }\n      const tus = model.openGLActor2D.getActiveTextures();\n      if (tus) {\n        for (let index = 0; index < tus.length; ++index) {\n          const tex = tus[index];\n          const texUnit = tex.getTextureUnit();\n          const tname = `texture${texUnit + 1}`;\n          if (cellBO.getProgram().isUniformUsed(tname)) {\n            cellBO.getProgram().setUniformi(tname, texUnit);\n          }\n        }\n      }\n\n      // handle wide lines\n      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n      const selector = model._openGLRenderer.getSelector();\n      cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n      cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const c = model.renderable.getColorMapColors();\n    if (!c || c.getNumberOfComponents() === 0) {\n      const program = cellBO.getProgram();\n      const ppty = actor.getProperty();\n      const opacity = ppty.getOpacity();\n      program.setUniformf('opacityUniform', opacity);\n      const dColor = ppty.getColor();\n      program.setUniform3fArray('diffuseColorUniform', dColor);\n    }\n  };\n  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {\n    // no-op\n  };\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce((res, matrix, index) => {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n\n    // Get the position of the actor\n    const view = ren.getRenderWindow().getViews()[0];\n    const size = view.getViewportSize(ren);\n    const vport = ren.getViewport();\n    const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);\n\n    // Get the window info\n    // Assume tile viewport is 0 1 based on vtkOpenGLRenderer\n    const tileViewport = [0.0, 0.0, 1.0, 1.0];\n    const visVP = [0.0, 0.0, 1.0, 1.0];\n    visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];\n    visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];\n    visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];\n    visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];\n    if (visVP[0] >= visVP[2]) {\n      return;\n    }\n    if (visVP[1] >= visVP[3]) {\n      return;\n    }\n    size[0] = round(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));\n    size[1] = round(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));\n    const winSize = model._openGLRenderer.getParent().getSize();\n    const xoff = round(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);\n    const yoff = round(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);\n\n    // set ortho projection\n    const left = -xoff;\n    let right = -xoff + size[0];\n    const bottom = -yoff;\n    let top = -yoff + size[1];\n\n    // it's an error to call glOrtho with\n    // either left==right or top==bottom\n    if (left === right) {\n      right = left + 1.0;\n    }\n    if (bottom === top) {\n      top = bottom + 1.0;\n    }\n\n    // compute the combined ModelView matrix and send it down to save time in the shader\n    const tmpMat4 = mat4.identity(new Float64Array(16));\n    tmpMat4[0] = 2.0 / (right - left);\n    tmpMat4[1 * 4 + 1] = 2.0 / (top - bottom);\n    tmpMat4[0 * 4 + 3] = -1.0 * (right + left) / (right - left);\n    tmpMat4[1 * 4 + 3] = -1.0 * (top + bottom) / (top - bottom);\n    tmpMat4[2 * 4 + 2] = 0.0;\n    tmpMat4[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? -1.0 : 1.0;\n    tmpMat4[3 * 4 + 3] = 1.0;\n    mat4.transpose(tmpMat4, tmpMat4);\n    program.setUniformMatrix('WCVCMatrix', safeMatrixMultiply([tmpMat4, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => {\n    let memUsed = 0;\n    model.primitives.forEach(prim => {\n      memUsed += prim.getAllocatedGPUMemoryInBytes();\n    });\n    // Return in MB\n    return memUsed;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  for (let i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  }\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLPolyDataMapper2D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper2D');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyDataMapper2D = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkMapper2D', newInstance);\n\nexport { vtkPolyDataMapper2D as default, extend, newInstance };\n", "import { n as newInstance$1, g as get, e as setGet, i as moveToProtected, c as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLRenderer methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-bitwise */\n\nfunction vtkOpenGLRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLRenderer');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      publicAPI.updateLights();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.renderable.getActiveCamera());\n      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps(), true);\n      publicAPI.removeUnusedNodes();\n    }\n  };\n  publicAPI.updateLights = () => {\n    let count = 0;\n    const lights = model.renderable.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      if (lights[index].getSwitch() > 0.0) {\n        count++;\n      }\n    }\n    if (!count) {\n      vtkDebugMacro('No lights are on, creating one.');\n      model.renderable.createLight();\n    }\n    return count;\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      let clearMask = 0;\n      const gl = model.context;\n      if (!model.renderable.getTransparent()) {\n        model.context.clearColor(1.0, 0.0, 0.0, 1.0);\n        clearMask |= gl.COLOR_BUFFER_BIT;\n      }\n      if (!model.renderable.getPreserveDepthBuffer()) {\n        gl.clearDepth(1.0);\n        clearMask |= gl.DEPTH_BUFFER_BIT;\n        model.context.depthMask(true);\n      }\n      const ts = publicAPI.getTiledSizeAndOrigin();\n      gl.enable(gl.SCISSOR_TEST);\n      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);\n      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);\n      gl.colorMask(true, true, true, true);\n      if (clearMask) {\n        gl.clear(clearMask);\n      }\n      gl.enable(gl.DEPTH_TEST);\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n\n  // Renders myself\n  publicAPI.cameraPass = prepass => {\n    if (prepass) {\n      publicAPI.clear();\n    }\n  };\n  publicAPI.getAspectRatio = () => {\n    const size = model._parent.getSizeByReference();\n    const viewport = model.renderable.getViewportByReference();\n    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);\n  };\n  publicAPI.getTiledSizeAndOrigin = () => {\n    const vport = model.renderable.getViewportByReference();\n\n    // if there is no window assume 0 1\n    const tileViewPort = [0.0, 0.0, 1.0, 1.0];\n\n    // find the lower left corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu = vport[0] - tileViewPort[0];\n    const vpv = vport[1] - tileViewPort[1];\n\n    // store the result as a pixel value\n    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);\n    const lowerLeftU = Math.round(ndvp[0]);\n    const lowerLeftV = Math.round(ndvp[1]);\n\n    // find the upper right corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu2 = vport[2] - tileViewPort[0];\n    const vpv2 = vport[3] - tileViewPort[1];\n    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);\n\n    // now compute the size of the intersection of the viewport with the\n    // current tile\n    let usize = Math.round(ndvp2[0]) - lowerLeftU;\n    let vsize = Math.round(ndvp2[1]) - lowerLeftV;\n    if (usize < 0) {\n      usize = 0;\n    }\n    if (vsize < 0) {\n      vsize = 0;\n    }\n    return {\n      usize,\n      vsize,\n      lowerLeftU,\n      lowerLeftV\n    };\n  };\n  publicAPI.clear = () => {\n    let clearMask = 0;\n    const gl = model.context;\n    if (!model.renderable.getTransparent()) {\n      const background = model.renderable.getBackgroundByReference();\n      // renderable ensures that background has 4 entries.\n      gl.clearColor(background[0], background[1], background[2], background[3]);\n      clearMask |= gl.COLOR_BUFFER_BIT;\n    }\n    if (!model.renderable.getPreserveDepthBuffer()) {\n      gl.clearDepth(1.0);\n      clearMask |= gl.DEPTH_BUFFER_BIT;\n      gl.depthMask(true);\n    }\n    gl.colorMask(true, true, true, true);\n    const ts = publicAPI.getTiledSizeAndOrigin();\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);\n    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);\n    if (clearMask) {\n      gl.clear(clearMask);\n    }\n    gl.enable(gl.DEPTH_TEST);\n    /* eslint-enable no-bitwise */\n  };\n\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.selector !== null) {\n      model.selector.releaseGraphicsResources();\n    }\n    // Releasing resources means that the next render should re-create resources\n    if (model.renderable) {\n      model.renderable.getViewProps().forEach(prop => {\n        prop.modified();\n      });\n    }\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  _openGLRenderWindow: null,\n  selector: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Build VTK API\n  get(publicAPI, model, ['shaderCache']);\n  setGet(publicAPI, model, ['selector']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLRenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLRenderer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkRenderer = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkRenderer', newInstance);\n\nexport { vtkRenderer as default, extend, newInstance };\n", "import { n as newInstance$1 } from '../../macros2.js';\nimport vtkScalarBarActor from '../Core/ScalarBarActor.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLScalarBarActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLScalarBarActor(publicAPI, model) {\n  model.classHierarchy.push('vtkOpenGLScalarBarActor');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      if (!model.scalarBarActorHelper.getRenderable()) {\n        model.scalarBarActorHelper.setRenderable(model.renderable);\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());\n      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;\n      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();\n      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.scalarBarActorHelper = vtkScalarBarActor.newScalarBarActorHelper();\n\n  // Object methods\n  vtkOpenGLScalarBarActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLScalarBarActor');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkScalarBarActor', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, e as setGet, g as get, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLSkybox methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSkybox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSkybox');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera(), model.openGLCamera);\n    }\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      renderPass.incrementOpaqueActorCount();\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass && !model._openGLRenderer.getSelector()) {\n      publicAPI.updateBufferObjects();\n      model.context.depthMask(true);\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());\n      model.openGLTexture.render(model._openGLRenderWindow);\n      const texUnit = model.openGLTexture.getTextureUnit();\n      model.tris.getProgram().setUniformi('sbtexture', texUnit);\n      const ren = model._openGLRenderer.getRenderable();\n      const keyMats = model.openGLCamera.getKeyMatrices(ren);\n      const imat = new Float64Array(16);\n      mat4.invert(imat, keyMats.wcpc);\n      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);\n      if (model.lastFormat === 'box') {\n        const camPos = ren.getActiveCamera().getPosition();\n        model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);\n      }\n      model.tris.getVAO().bind();\n\n      // draw polygons\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n      model.openGLTexture.deactivate();\n    }\n  };\n  publicAPI.updateBufferObjects = () => {\n    // build the VBO if needed, only happens once\n    if (!model.tris.getCABO().getElementCount()) {\n      const ptsArray = new Float32Array(12);\n      for (let i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = 1.0;\n      }\n      const points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      const cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      const cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points,\n        cellOffset: 0\n      });\n    }\n\n    // update the program?\n    if (model.renderable.getFormat() !== model.lastFormat) {\n      model.lastFormat = model.renderable.getFormat();\n      if (model.lastFormat === 'box') {\n        // we invert Y below because opengl is messed up!\n        // Cube Maps have been specified to follow the RenderMan\n        // specification (for whatever reason), and RenderMan\n        // assumes the images' origin being in the upper left,\n        // contrary to the usual OpenGL behaviour of having the\n        // image origin in the lower left. That's why things get\n        // swapped in the Y direction. It totally breaks with the usual\n        // OpenGL semantics and doesn't make sense at all.\n        // But now we're stuck with it.  From\n        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping\n        //\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }`, `//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }`, ''));\n      }\n      if (model.lastFormat === 'background') {\n        // maps the texture to the window\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }`, `//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }`, ''));\n      }\n      model.tris.getShaderSourceTime().modified();\n      model.tris.getVAO().bind();\n      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n        vtkErrorMacro('Error setting vertexMC in shader VAO.');\n      }\n    }\n\n    // set/update the texture map if needed\n    const tmaps = model.renderable.getTextures();\n    if (!tmaps.length) {\n      vtkErrorMacro('vtkSkybox requires a texture map');\n    }\n    if (model.openGLTexture.getRenderable() !== tmaps[0]) {\n      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.openGLTexture.setRenderable(tmaps[0]);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.tris = vtkHelper.newInstance();\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: mat3.identity(new Float64Array(9)),\n    mcwc: mat4.identity(new Float64Array(16))\n  };\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']);\n\n  // Object methods\n  vtkOpenGLSkybox(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkSkybox = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkSkybox', newInstance);\n\nexport { vtkSkybox as default, extend, newInstance };\n", "import { mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  CoordinateSystem\n} = vtkProp;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUActor');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');\n      if (model.propID === undefined) {\n        model.propID = model.WebGPURenderWindow.getUniquePropID();\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseOpaquePass = renderPass => {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    if (model.children[0]) {\n      model.children[0].traverse(renderPass);\n    }\n    publicAPI.apply(renderPass, false);\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseTranslucentPass = renderPass => {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    if (model.children[0]) {\n      model.children[0].traverse(renderPass);\n    }\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      if (model.renderable.getIsOpaque()) {\n        renderPass.incrementOpaqueActorCount();\n      } else {\n        renderPass.incrementTranslucentActorCount();\n      }\n    }\n  };\n  publicAPI.getBufferShift = wgpuRen => {\n    publicAPI.getKeyMatrices(wgpuRen);\n    return model.bufferShift;\n  };\n  publicAPI.getKeyMatrices = wgpuRen => {\n    // has the actor or stabilization center changed?\n    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {\n      model.renderable.computeMatrix();\n      const mcwc = model.renderable.getMatrix();\n\n      // compute the net shift, only apply stabilized coords with world coordinates\n      model.bufferShift[0] = mcwc[3];\n      model.bufferShift[1] = mcwc[7];\n      model.bufferShift[2] = mcwc[11];\n      const center = wgpuRen.getStabilizedCenterByReference();\n      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {\n        model.bufferShift[0] -= center[0];\n        model.bufferShift[1] -= center[1];\n        model.bufferShift[2] -= center[2];\n      }\n      mat4.transpose(model.keyMatrices.bcwc, mcwc);\n      if (model.renderable.getIsIdentity()) {\n        mat4.identity(model.keyMatrices.normalMatrix);\n      } else {\n        // we use bcwc BEFORE the translate below (just to get transposed mcvc)\n        mat4.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);\n        // zero out translation\n        model.keyMatrices.normalMatrix[3] = 0.0;\n        model.keyMatrices.normalMatrix[7] = 0.0;\n        model.keyMatrices.normalMatrix[11] = 0.0;\n        mat4.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n        mat4.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n      }\n\n      // only need the buffer shift to get to world\n      mat4.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);\n\n      // to get to stabilized we also need the center\n      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {\n        mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);\n      } else {\n        mat4.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);\n      }\n      model.keyMatricesTime.modified();\n    }\n    return model.keyMatrices;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  keyMatricesTime: null,\n  keyMatrices: null,\n  propID: undefined,\n  bufferShift: undefined\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatricesTime = {};\n  macro.obj(model.keyMatricesTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: new Float64Array(16),\n    bcwc: new Float64Array(16),\n    bcsc: new Float64Array(16)\n  };\n  macro.get(publicAPI, model, ['propID', 'keyMatricesTime']);\n  model.bufferShift = [0, 0, 0, 0];\n\n  // Object methods\n  vtkWebGPUActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkActor', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  CoordinateSystem\n} = vtkProp;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUActor2D(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUActor2D');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');\n      if (model.propID === undefined) {\n        model.propID = model.WebGPURenderWindow.getUniquePropID();\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseOpaquePass = renderPass => {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    if (model.children[0]) {\n      model.children[0].traverse(renderPass);\n    }\n    publicAPI.apply(renderPass, false);\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseTranslucentPass = renderPass => {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    if (model.children[0]) {\n      model.children[0].traverse(renderPass);\n    }\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      if (model.renderable.getIsOpaque()) {\n        renderPass.incrementOpaqueActorCount();\n      } else {\n        renderPass.incrementTranslucentActorCount();\n      }\n    }\n  };\n  publicAPI.getBufferShift = wgpuRen => {\n    publicAPI.getKeyMatrices(wgpuRen);\n    return model.bufferShift;\n  };\n  publicAPI.getKeyMatrices = wgpuRen => {\n    // has the actor or stabilization center changed?\n    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {\n      // compute the net shift, only apply stabilized coords with world coordinates\n      model.bufferShift[0] = 0.0;\n      model.bufferShift[1] = 0.0;\n      model.bufferShift[2] = 0.0;\n      const center = wgpuRen.getStabilizedCenterByReference();\n      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {\n        model.bufferShift[0] -= center[0];\n        model.bufferShift[1] -= center[1];\n        model.bufferShift[2] -= center[2];\n      }\n      mat4.identity(model.keyMatrices.bcwc);\n      mat4.identity(model.keyMatrices.normalMatrix);\n\n      // only meed the buffer shift to get to world\n      mat4.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);\n\n      // to get to stabilized we also need the center\n      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {\n        mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);\n      } else {\n        mat4.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);\n      }\n      model.keyMatricesTime.modified();\n    }\n    return model.keyMatrices;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  keyMatricesTime: null,\n  keyMatrices: null,\n  propID: undefined,\n  bufferShift: undefined\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatricesTime = {};\n  macro.obj(model.keyMatricesTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: new Float64Array(16),\n    bcwc: new Float64Array(16),\n    bcsc: new Float64Array(16)\n  };\n  macro.get(publicAPI, model, ['propID', 'keyMatricesTime']);\n  model.bufferShift = [0, 0, 0, 0];\n\n  // Object methods\n  vtkWebGPUActor2D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkActor2D', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUCamera');\n  publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {\n    mat4.identity(outMat);\n    if (model.renderable.getParallelProjection()) {\n      // set up a rectangular parallelipiped\n      const parallelScale = model.renderable.getParallelScale();\n      const width = parallelScale * aspect;\n      const height = parallelScale;\n      const xmin = (windowCenter[0] - 1.0) * width;\n      const xmax = (windowCenter[0] + 1.0) * width;\n      const ymin = (windowCenter[1] - 1.0) * height;\n      const ymax = (windowCenter[1] + 1.0) * height;\n      const xr = 1.0 / (xmax - xmin);\n      const yr = 1.0 / (ymax - ymin);\n      outMat[0] = 2.0 * xr;\n      outMat[5] = 2.0 * yr;\n      outMat[10] = 1.0 / (cRange[1] - cRange[0]);\n      outMat[12] = (xmax + xmin) * xr;\n      outMat[13] = (ymax + ymin) * yr;\n      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);\n    } else {\n      const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360.0);\n      let width;\n      let height;\n      if (model.renderable.getUseHorizontalViewAngle() === true) {\n        width = cRange[0] * tmp;\n        height = cRange[0] * tmp / aspect;\n      } else {\n        width = cRange[0] * tmp * aspect;\n        height = cRange[0] * tmp;\n      }\n      const xmin = (windowCenter[0] - 1.0) * width;\n      const xmax = (windowCenter[0] + 1.0) * width;\n      const ymin = (windowCenter[1] - 1.0) * height;\n      const ymax = (windowCenter[1] + 1.0) * height;\n      outMat[0] = 2.0 * cRange[0] / (xmax - xmin);\n      outMat[5] = 2.0 * cRange[0] / (ymax - ymin);\n      outMat[12] = (xmin + xmax) / (xmax - xmin);\n      outMat[13] = (ymin + ymax) / (ymax - ymin);\n      outMat[10] = 0.0;\n      outMat[14] = cRange[0];\n      outMat[11] = -1.0;\n      outMat[15] = 0.0;\n    }\n  };\n  publicAPI.convertToOpenGLDepth = val => {\n    if (model.renderable.getParallelProjection()) {\n      return 1.0 - val;\n    }\n    const cRange = model.renderable.getClippingRangeByReference();\n    let zval = -cRange[0] / val;\n    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2.0 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));\n    return 0.5 * zval + 0.5;\n  };\n  publicAPI.getKeyMatrices = webGPURenderer => {\n    // has the camera changed?\n    const ren = webGPURenderer.getRenderable();\n    const webGPURenderWindow = webGPURenderer.getParent();\n    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {\n      const wcvc = model.renderable.getViewMatrix();\n      mat4.copy(model.keyMatrices.normalMatrix, wcvc);\n      // zero out translation\n      model.keyMatrices.normalMatrix[3] = 0.0;\n      model.keyMatrices.normalMatrix[7] = 0.0;\n      model.keyMatrices.normalMatrix[11] = 0.0;\n      mat4.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n      mat4.transpose(model.keyMatrices.wcvc, wcvc);\n      const center = webGPURenderer.getStabilizedCenterByReference();\n      mat4.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);\n      const aspectRatio = webGPURenderer.getAspectRatio();\n      const cRange = model.renderable.getClippingRangeByReference();\n      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());\n      mat4.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);\n      mat4.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);\n      model.keyMatrixTime.modified();\n    }\n    return model.keyMatrices;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  keyMatrixTime: null,\n  keyMatrices: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatrixTime = {};\n  macro.obj(model.keyMatrixTime);\n\n  // values always get set by the get method\n  model.keyMatrices = {\n    normalMatrix: new Float64Array(16),\n    vcpc: new Float64Array(16),\n    pcsc: new Float64Array(16),\n    wcvc: new Float64Array(16),\n    scpc: new Float64Array(16),\n    scvc: new Float64Array(16)\n  };\n\n  // Build VTK API\n  macro.setGet(publicAPI, model, ['keyMatrixTime']);\n\n  // Object methods\n  vtkWebGPUCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkCamera', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { n as newInstance$1 } from '../../macros2.js';\nimport vtkCubeAxesActor from '../Core/CubeAxesActor.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUCubeAxesActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUCubeAxesActor(publicAPI, model) {\n  model.classHierarchy.push('vtkWebGPUCubeAxesActor');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      if (!model.CubeAxesActorHelper.getRenderable()) {\n        model.CubeAxesActorHelper.setRenderable(model.renderable);\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());\n      publicAPI.addMissingNode(model.renderable.getGridActor());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;\n      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();\n      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.CubeAxesActorHelper = vtkCubeAxesActor.newCubeAxesActorHelper();\n\n  // Object methods\n  vtkWebGPUCubeAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUCubeAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkCubeAxesActor', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport Constants from './Property2D/Constants.js';\nimport { Representation } from './Property/Constants.js';\n\nconst {\n  DisplayLocation\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// vtkProperty2D methods\n// ----------------------------------------------------------------------------\n\nfunction vtkProperty2D(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkProperty2D');\n  publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(DisplayLocation.BACKGROUND);\n  publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(DisplayLocation.FOREGROUND);\n  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation.WIREFRAME);\n  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation.SURFACE);\n  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation.POINTS);\n  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation, model.representation);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  color: [1, 1, 1],\n  opacity: 1,\n  pointSize: 1,\n  lineWidth: 1,\n  representation: Representation.SURFACE,\n  displayLocation: DisplayLocation.FOREGROUND\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['opacity', 'lineWidth', 'pointSize', 'displayLocation', 'representation']);\n  macro.setGetArray(publicAPI, model, ['color'], 3);\n\n  // Object methods\n  vtkProperty2D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkProperty2D');\n\n// ----------------------------------------------------------------------------\n\nvar vtkProperty2D$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkProperty2D$1 as default, extend, newInstance };\n", "import { mat3, mat4 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet } from '../../macros2.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkProperty2D from '../Core/Property2D.js';\nimport vtkTexture from '../Core/Texture.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSimpleMapper from './SimpleMapper.js';\nimport vtkWebGPUTypes from './Types.js';\n\nconst {\n  BufferUsage,\n  PrimitiveTypes\n} = vtkWebGPUBufferManager;\nconst {\n  Representation\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  CoordinateSystem\n} = vtkProp;\nconst {\n  DisplayLocation\n} = vtkProperty2D;\nconst vtkWebGPUPolyDataVS = `\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\nconst vtkWebGPUPolyDataFS = `\nstruct PBRData {\n  diffuse: vec3<f32>,\n  specular: vec3<f32>,\n}\n\nstruct Material {\n  ior: f32,\n  roughness: f32,\n  metallic: f32,\n  base: vec3<f32>,\n};\n\nstruct DirectionalLight {\n  direction: vec3<f32>,\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  position: vec3<f32>,\n  color: vec3<f32>,\n};\n\nstruct SpotLight {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  cones: vec2<f32>,\n  color: vec3<f32>,\n};\n\nconst pi: f32 = 3.14159265359;\n\n// Dot product with the max already in it\nfn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\n  return max(0.0, dot(a, b));\n}\n// Dot product with a max in it that does not allow for negative values\n// Physically based rendering is accurate as long as normals are accurate,\n// however this is pretty often not the case. In order to prevent negative\n// values from ruining light calculations and creating zones of zero light,\n// this remapping is used, which smoothly clamps the dot product between\n// zero and one while still maintaining a good amount of accuracy.\nfn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\n  var d: f32 = max(0.0, dot(a, b));\n  d = pow((d + 1.0) / 2.0, 2.6);\n  return d;\n}\n\n// Lambertian diffuse model\nfn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {\n  var NdotL: f32 = mdot(N, L);\n  NdotL = pow(NdotL, 1.5);\n  return (base/pi)*NdotL;\n}\n\n// Yasuhiro Fujii improvement on the Oren-Nayar model\n// https://mimosa-pudica.net/improved-oren-nayar.html\n// p is surface color, o is roughness\nfn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {\n  var invpi: f32 = 0.31830988618; // 1/pi\n\n  var o2 = o*o;\n  var NdotL: f32 = mdot(N, L);\n  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the \"seams\" between lights better\n\n  var NdotV: f32 = mdot(N, V);\n  var LdotV: f32 = mdot(L, V);\n\n  var s: f32 = LdotV - NdotL*NdotV;\n  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement\n  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));\n  A = invpi*(1 - A);\n  var B: f32 = 0.45*(o2 / (o2 + 0.09));\n  B = invpi*B;\n\n  return p*NdotL*(A + B*(s/t));\n}\n\n// Fresnel portion of BRDF (IOR only, simplified)\nfn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {\n  var NdotV: f32 = mdot(V, N);\n  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not\n  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);\n}\n\n// Fresnel portion of BRDF (Color ior, better)\nfn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {\n  var NdotV: f32 = mdot(V, N);\n  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);\n}\n\n// Normal portion of BRDF\n// https://learnopengl.com/PBR/Theory\n// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2\nfn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {\n  var a2: f32 = a*a;\n  var NdotH = mdot(N, H);\n  var NdotH2 = NdotH*NdotH;\n\n  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;\n\n  return a2 / max((pi*denom*denom), 0.000001);\n}\n\n// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent\nfn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {\n  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;\n\n  var ggx1: f32 = trGGX(N + Op*s, H, a);\n  var ggx2: f32 = trGGX(N - Op*s, H, a);\n  return (0.5 * ggx1 + 0.5 * ggx2);\n}\n\n// Geometry portion of BRDF\nfn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {\n  var NdotX = cdot(N, X);\n  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));\n}\n\nfn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {\n  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));\n  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));\n  return ggx1*ggx2;\n}\n\n// BRDF Combination\nfn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {\n  var num: f32 = D*F*G;\n  var denom: f32 = 4*cdot(V, N)*cdot(L, N);\n\n  return num / max(denom, 0.000001);\n}\n\n// Different lighting calculations for different light sources\nfn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, mat: Material, light: DirectionalLight) -> PBRData {\n  var L: vec3<f32> = normalize(light.direction); // Light Vector\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n\n  var alpha = mat.roughness * mat.roughness;\n  var k: f32 = alpha * alpha / 2.0;\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later\n  var incoming: vec3<f32> = light.color;\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5);\n\n  var specular: vec3<f32> = brdf * incoming * angle;\n  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate\n  // control property for the diffuse vs specular roughness\n  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);\n  // Stores the specular and diffuse separately to allow for finer post processing\n  var out = PBRData(diffuse, specular);\n\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\nfn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: PointLight) -> PBRData {\n  var L: vec3<f32> = normalize(light.position - fragPos);\n  var H: vec3<f32> = normalize(L + V);\n  var dist = distance(light.position, fragPos);\n\n  var alpha = mat.roughness * mat.roughness;\n  var k: f32 = alpha * alpha / 2.0;\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  var F: f32 = schlickFresnelIOR(V, N, mat.ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);\n  var incoming: vec3<f32> = light.color * (1.0 / (dist * dist));\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \"seams\" between light sources\n\n  var specular: vec3<f32> = brdf * incoming * angle;\n  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);\n  // Stores the specular and diffuse separately to allow for finer post processing\n  // Could also be done (propably more properly) with a struct\n  var out = PBRData(diffuse, specular);\n\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights\nfn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: SpotLight) -> PBRData {\n  var L: vec3<f32> = normalize(light.position - fragPos);\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\n  var dist = distance(light.position, fragPos);\n\n  var alpha = mat.roughness * mat.roughness;\n  var k: f32 = alpha * alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8\n\n  var D: f32 = trGGX(N, H, alpha); // Distribution\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\n\n  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);\n\n  var theta: f32 = mdot(normalize(light.direction), L);\n  var epsilon: f32 = light.cones.x - light.cones.y;\n  var intensity: f32 = (theta - light.cones.y) / epsilon;\n  intensity = clamp(intensity, 0.0, 1.0);\n  intensity /= dist * dist;\n\n  var incoming: vec3<f32> = light.color * intensity;\n\n  var angle: f32 = mdot(L, N);\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \"seams\" between light sources\n\n  var specular: vec3<f32> = brdf * incoming * angle;\n  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);\n\n  // Stores the specular and diffuse separately to allow for finer post processing\n  // Could also be done (propably more properly) with a struct\n  var out = PBRData(diffuse, specular);\n\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\n}\n\n// Environment mapping stuff\n// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\n  var tau: f32 = 6.28318530718;\n  var out: vec2<f32> = vec2<f32>(0.0);\n\n  out.x = atan2(dir.z, dir.x) / tau;\n  out.x += 0.5;\n\n  var phix: f32 = length(vec2(dir.x, dir.z));\n  out.y = atan2(dir.y, phix) / pi + 0.5;\n\n  return out;\n}\n\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::TCoord::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  // Temporary ambient, diffuse, and opacity\n  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;\n  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;\n  var opacity: f32 = mapperUBO.Opacity;\n  var ior: f32 = mapperUBO.BaseIOR;\n\n  // This should be declared somewhere else\n  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);\n  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);\n  var _metallicMap: vec4<f32> = vec4<f32>(1.0);\n  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment\n  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);\n  var _emissionMap: vec4<f32> = vec4<f32>(0.);\n\n  //VTK::Color::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Normal::Impl\n\n  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);\n\n  //VTK::Light::Impl\n\n  //VTK::Select::Impl\n\n  // Use texture alpha for transparency\n  computedColor.a = mapperUBO.Opacity * _diffuseMap.a;\n  if (computedColor.a == 0.0) { discard; };\n\n  //VTK::Position::Impl\n\n  //VTK::RenderEncoder::Impl\n\n  return output;\n}\n`;\nfunction isEdges(hash) {\n  // edge pipelines have \"edge\" in them\n  return hash.indexOf('edge') >= 0;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUCellArrayMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUCellArrayMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUCellArrayMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (model.is2D) {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');\n        model.forceZValue = true;\n      } else {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');\n        model.forceZValue = false;\n      }\n      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();\n      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem.DISPLAY;\n      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.updateUBO = () => {\n    const actor = model.WebGPUActor.getRenderable();\n    const ppty = actor.getProperty();\n    const utime = model.UBO.getSendTime();\n    if (publicAPI.getMTime() <= utime && ppty.getMTime() <= utime && model.renderable.getMTime() <= utime) {\n      return;\n    }\n\n    // --- Matrix Updates ---\n    const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);\n    model.UBO.setArray('BCWCMatrix', keyMats.bcwc);\n    model.UBO.setArray('BCSCMatrix', keyMats.bcsc);\n    model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);\n\n    // --- 2D or 3D ---\n    if (model.is2D) {\n      const displayLoc = ppty.getDisplayLocation?.() ?? DisplayLocation.BACKGROUND;\n      model.UBO.setValue('ZValue', displayLoc === DisplayLocation.FOREGROUND ? 1.0 : 0.0);\n      const aColor = ppty.getColorByReference();\n      model.UBO.setValue('AmbientIntensity', 1.0);\n      model.UBO.setArray('DiffuseColor', [...aColor, 1.0]);\n      model.UBO.setValue('DiffuseIntensity', 0.0);\n      model.UBO.setValue('SpecularIntensity', 0.0);\n    } else {\n      // Base Colors\n      model.UBO.setValue('AmbientIntensity', ppty.getAmbient());\n      model.UBO.setArray('AmbientColor', [...ppty.getAmbientColorByReference(), 1.0]);\n      model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());\n      model.UBO.setArray('DiffuseColor', [...ppty.getDiffuseColorByReference(), 1.0]);\n      // Roughness\n      model.UBO.setValue('Roughness', ppty.getRoughness());\n      model.UBO.setValue('BaseIOR', ppty.getBaseIOR());\n      // Metallic\n      model.UBO.setValue('Metallic', ppty.getMetallic());\n      // Normal\n      model.UBO.setValue('NormalStrength', ppty.getNormalStrength());\n      // Emission\n      model.UBO.setValue('Emission', ppty.getEmission());\n      // Specular\n      model.UBO.setValue('SpecularIntensity', ppty.getSpecular());\n      if (ppty.getSpecularColorByReference()) {\n        model.UBO.setArray('SpecularColor', [...ppty.getSpecularColorByReference(), 1.0]);\n      }\n    }\n\n    // --- Edge and Misc ---\n    const edgeColor = ppty.getEdgeColorByReference?.();\n    if (edgeColor) model.UBO.setArray('EdgeColor', [...edgeColor, 1.0]);\n    model.UBO.setValue('LineWidth', ppty.getLineWidth());\n    model.UBO.setValue('Opacity', ppty.getOpacity());\n    model.UBO.setValue('PropID', model.WebGPUActor.getPropID());\n\n    // Only send if needed\n    model.UBO.sendIfNeeded(model.WebGPURenderWindow.getDevice());\n  };\n  publicAPI.haveWideLines = () => {\n    const actor = model.WebGPUActor.getRenderable();\n    const representation = actor.getProperty().getRepresentation();\n    if (actor.getProperty().getLineWidth() <= 1.0) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Verts) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {\n      return representation === Representation.WIREFRAME;\n    }\n    return true;\n  };\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    let code = vDesc.getCode();\n    if (model.useRendererMatrix) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    }\n    if (publicAPI.haveWideLines()) {\n      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex');\n      // widen the edge\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);',\n      // could become a setting\n      '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {\n    const normalBuffer = vertexInput.getBuffer('normalMC');\n    const actor = model.WebGPUActor.getRenderable();\n    if (normalBuffer) {\n      const vDesc = pipeline.getShaderDescription('vertex');\n      if (!vDesc.hasOutput('normalVC')) {\n        vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('tangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('bitangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      let code = vDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);',\n      // This is just an approximation, but it happens to work extremely well\n      // It only works well for normals that are head on and not super angled though\n      // Definitely needs to be replaced\n      '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;\n      vDesc.setCode(code);\n      const fDesc = pipeline.getShaderDescription('fragment');\n      code = fDesc.getCode();\n      if (actor.getProperty().getNormalTexture()) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;\n      } else {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;\n      }\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n\n  // we only apply lighting when there is a \"var normal\" declaration in the\n  // fragment shader code. That is the lighting trigger.\n  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {\n    if (hash.includes('sel')) return;\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    const renderer = model.WebGPURenderer.getRenderable();\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n\n    // Code that runs if the fragment shader includes normals\n    if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {\n      const lightingCode = [\n      // Vectors needed for light calculations\n      '  let fragPos = vec3<f32>(input.vertexVC.xyz);', '  let V = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector',\n      // Values needed for light calculations\n      '  let baseColor = _diffuseMap.rgb * diffuseColor.rgb;', '  let roughness = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);',\n      // Need to have a different way of sampling greyscale values aside from .r\n      '  let metallic = mapperUBO.Metallic * _metallicMap.r;', '  let alpha = roughness * roughness;', '  let k = alpha * alpha / 2.0;',\n      // Split diffuse and specular components\n      '  var diffuse = vec3<f32>(0.);', '  var specular = vec3<f32>(0.);', '  let emission = _emissionMap.rgb * mapperUBO.Emission;', '', '  // Material struct', '  let mat = Material(ior, roughness, metallic, baseColor);', '',\n      // Summing diffuse and specular components of directional lights\n      '  {', '    var i = 0;', '    loop {', '      if (!(i < rendererUBO.LightCount)) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           let pos = (rendererLightSSBO.values[i].LightPos).xyz;', '           let pointLight = PointLight(pos, color);', '           let result = calcPointLight(normal, V, fragPos, mat, pointLight);', '           diffuse += max(vec3<f32>(0), result.diffuse);', '           specular += max(vec3<f32>(0), result.specular);', '          }', '         // Directional light', '         case 1 {', '           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);', '           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           let dirLight = DirectionalLight(dir, color);', '           let result = calcDirectionalLight(normal, V, mat, dirLight); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), result.diffuse);', '           specular += max(vec3<f32>(0), result.specular);', '         }', '         // Spot Light', '         case 2 {', '           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           let pos = (rendererLightSSBO.values[i].LightPos).xyz;', '           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);', '           let cones = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           let spotLight = SpotLight(pos, dir, cones, color);', '           let result = calcSpotLight(normal, V, fragPos, mat, spotLight);', '           diffuse += max(vec3<f32>(0), result.diffuse);', '           specular += max(vec3<f32>(0), result.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }',\n      // Final variables for combining specular and diffuse\n      '  let fresnel = min(1.0, schlickFresnelIOR(V, normal, ior, k)); // Fresnel', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  let fresnelMetallic = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  let kS = min(vec3<f32>(1.0), mix(vec3<f32>(fresnel), fresnelMetallic, metallic));', '  let kD = (1.0 - kS) * (1.0 - metallic);', '  let PBR = mapperUBO.DiffuseIntensity * kD * diffuse + kS * specular;', '  computedColor = vec4<f32>(PBR + emission, mapperUBO.Opacity);'];\n      if (renderer.getEnvironmentTexture()?.getImageLoaded()) {\n        lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  let diffuseIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  let diffuseCoords = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  let VreflN = normalize(reflect(-V, normal));', '  let reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  let specularCoords = vecToRectCoord(reflectionIBLCoords);', '  let diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);',\n        // Level multiplier should be set by UBO\n        '  let level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  let specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);',\n        // Manual mip smoothing since not all formats support smooth level sampling\n        '  let specularIBLContribution = specularIBL.rgb * rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution * kS, 0);', '  let diffuseIBLContribution = diffuseIBL.rgb * rendererUBO.BackgroundDiffuseStrength;', '  computedColor += vec4<f32>(diffuseIBLContribution * baseColor * _ambientOcclusionMap.rgb * kD, 0);');\n      }\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', lightingCode).result;\n      fDesc.setCode(code);\n      // If theres no normals, just set the specular color to be flat\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', ['  let diffuse = diffuseColor.rgb;', '  let specular = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);\n  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {\n    // By default, set the colors to be flat\n    if (isEdges(hash)) {\n      const fDesc = pipeline.getShaderDescription('fragment');\n      let code = fDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;\n      fDesc.setCode(code);\n      return;\n    }\n\n    // If there's no vertex color buffer return the shader as is\n    const colorBuffer = vertexInput.getBuffer('colorVI');\n    if (!colorBuffer) return;\n\n    // Modifies the vertex shader to include the vertex colors and interpolation in the outputs\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;\n    vDesc.setCode(code);\n\n    // Sets the fragment shader to accept the color inputs from the vertex shader\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);\n  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {\n    if (!vertexInput.hasAttribute('tcoord')) return;\n    const vDesc = pipeline.getShaderDescription('vertex');\n    const tcoords = vertexInput.getBuffer('tcoord');\n    const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n    let code = vDesc.getCode();\n    vDesc.addOutput(`vec${numComp}<f32>`, 'tcoordVS');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    const actor = model.WebGPUActor.getRenderable();\n    const property = actor.getProperty();\n    const checkDims = texture => {\n      if (!texture) return false;\n      const dims = texture.getDimensionality();\n      return dims === numComp;\n    };\n    const usedTextures = [];\n    const diffuseTexture = property.getDiffuseTexture?.();\n    if (diffuseTexture?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {\n      if (\n      // Chained or statements here are questionable\n      checkDims(diffuseTexture) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {\n        usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');\n      }\n    }\n    const ormTexture = property.getORMTexture?.();\n    const rmTexture = property.getRMTexture?.();\n    const roughnessTexture = property.getRoughnessTexture?.();\n    const metallicTexture = property.getMetallicTexture?.();\n    const ambientOcclusionTexture = property.getAmbientOcclusionTexture?.();\n    const emissionTexture = property.getEmissionTexture?.();\n    const normalTexture = property.getNormalTexture?.();\n\n    // ORM texture support: if present, sample R/G/B for AO/Roughness/Metallic\n    if (ormTexture?.getImageLoaded()) {\n      if (checkDims(ormTexture)) {\n        usedTextures.push('_ambientOcclusionMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).rrra;', '_roughnessMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).ggga;', '_metallicMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).bbba;');\n      }\n    } else if (rmTexture?.getImageLoaded()) {\n      if (checkDims(rmTexture)) {\n        usedTextures.push('_roughnessMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).ggga;', '_metallicMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).bbba;');\n      }\n    } else {\n      if (roughnessTexture?.getImageLoaded()) {\n        if (checkDims(roughnessTexture)) {\n          usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS).ggga;');\n        }\n      }\n      if (metallicTexture?.getImageLoaded()) {\n        if (checkDims(metallicTexture)) {\n          usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS).bbba;');\n        }\n      }\n      if (ambientOcclusionTexture?.getImageLoaded()) {\n        if (checkDims(ambientOcclusionTexture)) {\n          usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS).rrra;');\n        }\n      }\n    }\n    if (emissionTexture?.getImageLoaded()) {\n      if (checkDims(emissionTexture)) {\n        usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');\n      }\n    }\n    if (normalTexture?.getImageLoaded()) {\n      if (checkDims(normalTexture)) {\n        usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {\n    if (hash.includes('sel')) {\n      const fDesc = pipeline.getShaderDescription('fragment');\n      let code = fDesc.getCode();\n      // by default there are no composites, so just 0\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);\n  publicAPI.getUsage = (rep, i) => {\n    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {\n      return BufferUsage.Verts;\n    }\n    if (i === PrimitiveTypes.Lines) {\n      return BufferUsage.Lines;\n    }\n    if (rep === Representation.WIREFRAME) {\n      if (i === PrimitiveTypes.Triangles) {\n        return BufferUsage.LinesFromTriangles;\n      }\n      return BufferUsage.LinesFromStrips;\n    }\n    if (i === PrimitiveTypes.Triangles) {\n      return BufferUsage.Triangles;\n    }\n    if (i === PrimitiveTypes.TriangleStrips) {\n      return BufferUsage.Strips;\n    }\n    if (i === PrimitiveTypes.TriangleEdges) {\n      return BufferUsage.LinesFromTriangles;\n    }\n\n    // only strip edges left which are lines\n    return BufferUsage.LinesFromStrips;\n  };\n  publicAPI.getHashFromUsage = usage => `pt${usage}`;\n  publicAPI.getTopologyFromUsage = usage => {\n    switch (usage) {\n      case BufferUsage.Triangles:\n        return 'triangle-list';\n      case BufferUsage.Verts:\n        return 'point-list';\n      case BufferUsage.Lines:\n      default:\n        return 'line-list';\n    }\n  };\n\n  // TODO: calculate tangents\n  publicAPI.buildVertexInput = () => {\n    const pd = model.currentInput;\n    const cells = model.cellArray;\n    const primType = model.primitiveType;\n    const actor = model.WebGPUActor.getRenderable();\n    let representation = actor.getProperty().getRepresentation();\n    const device = model.WebGPURenderWindow.getDevice();\n    let edges = false;\n    if (primType === PrimitiveTypes.TriangleEdges) {\n      edges = true;\n      representation = Representation.WIREFRAME;\n    }\n    const vertexInput = model.vertexInput;\n    const points = pd.getPoints();\n\n    // --- Index Buffer ---\n    let indexBuffer = null;\n    if (cells) {\n      indexBuffer = device.getBufferManager().getBuffer({\n        hash: `R${representation}P${primType}${cells.getMTime()}`,\n        usage: BufferUsage.Index,\n        cells,\n        numberOfPoints: points.getNumberOfPoints(),\n        primitiveType: primType,\n        representation\n      });\n      vertexInput.setIndexBuffer(indexBuffer);\n    } else {\n      vertexInput.setIndexBuffer(null);\n    }\n\n    // hash = all things that can change the values on the buffer\n    // since mtimes are unique we can use\n    // - indexBuffer mtime - because cells drive how we pack\n    // - relevant dataArray mtime - the source data\n    // - shift - not currently captured\n    // - scale - not currently captured\n    // - format\n    // - usage\n    // - packExtra - covered by format\n    // --- Points Buffer ---\n    if (points) {\n      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);\n      vertexInput.addBuffer(device.getBufferManager().getBuffer({\n        hash: `${points.getMTime()}I${indexBuffer?.getMTime?.() ?? 0}${shift.join()}float32x4`,\n        usage: BufferUsage.PointArray,\n        format: 'float32x4',\n        dataArray: points,\n        indexBuffer,\n        shift,\n        packExtra: true\n      }), ['vertexBC']);\n    } else {\n      vertexInput.removeBufferIfPresent('vertexBC');\n    }\n\n    // --- Normals ---\n    const usage = publicAPI.getUsage(representation, primType);\n    model._usesCellNormals = false;\n    if (!model.is2D && (\n    // no lighting on Property2D\n    usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {\n      const normals = pd.getPointData().getNormals();\n      // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html\n      // Need to find some way of using precomputed tangents (or computing new ones)\n      const buffRequest = {\n        format: 'snorm8x4',\n        indexBuffer,\n        packExtra: true,\n        shift: 0,\n        scale: 127\n      };\n      if (normals) {\n        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;\n        buffRequest.dataArray = normals;\n        buffRequest.usage = BufferUsage.PointArray;\n        vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ['normalMC']);\n      } else if (primType === PrimitiveTypes.Triangles) {\n        model._usesCellNormals = true;\n        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;\n        buffRequest.dataArray = points;\n        buffRequest.cells = cells;\n        buffRequest.usage = BufferUsage.NormalsFromPoints;\n        vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ['normalMC']);\n      } else {\n        vertexInput.removeBufferIfPresent('normalMC');\n      }\n    } else {\n      vertexInput.removeBufferIfPresent('normalMC');\n    }\n\n    // --- Colors ---\n    let haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      const c = model.renderable.getColorMapColors();\n      if (c && !edges) {\n        const scalarMode = model.renderable.getScalarMode();\n        // We must figure out how the scalars should be mapped to the polydata.\n        const haveCellScalars = (scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c;\n        vertexInput.addBuffer(device.getBufferManager().getBuffer({\n          usage: BufferUsage.PointArray,\n          format: 'unorm8x4',\n          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,\n          dataArray: c,\n          indexBuffer,\n          cellData: haveCellScalars,\n          cellOffset: 0\n        }), ['colorVI']);\n        haveColors = true;\n      }\n    }\n    if (!haveColors) vertexInput.removeBufferIfPresent('colorVI');\n\n    // --- Texture Coordinates ---\n    let tcoords = null;\n    if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n    } else {\n      tcoords = pd.getPointData().getTCoords();\n    }\n    if (tcoords && !edges) {\n      vertexInput.addBuffer(device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer()), ['tcoord']);\n    } else {\n      vertexInput.removeBufferIfPresent('tcoord');\n    }\n  };\n  publicAPI.updateTextures = () => {\n    // Track textures in-use and new\n    const usedTextures = [];\n    const newTextures = [];\n\n    // Add scalar color texture if available\n    const idata = model.renderable.getColorTextureMap?.();\n    if (idata && !model.colorTexture) {\n      model.colorTexture = vtkTexture.newInstance({\n        label: 'polyDataColor'\n      });\n    }\n    if (idata) {\n      model.colorTexture.setInputData(idata);\n      newTextures.push(['DiffuseTexture', model.colorTexture]);\n    }\n    const actor = model.WebGPUActor.getRenderable();\n    const renderer = model.WebGPURenderer.getRenderable();\n    const textures = [['DiffuseTexture', actor.getProperty().getDiffuseTexture?.()], ['DiffuseTexture', actor.getTextures()[0]], ['DiffuseTexture', model.colorTexture], ['ORMTexture', actor.getProperty().getORMTexture?.()], ['RMTexture', actor.getProperty().getRMTexture?.()], ['RoughnessTexture', actor.getProperty().getRoughnessTexture?.()], ['MetallicTexture', actor.getProperty().getMetallicTexture?.()], ['NormalTexture', actor.getProperty().getNormalTexture?.()], ['AmbientOcclusionTexture', actor.getProperty().getAmbientOcclusionTexture?.()], ['EmissionTexture', actor.getProperty().getEmissionTexture?.()], ['EnvironmentTexture', renderer.getEnvironmentTexture?.()]];\n    textures.forEach(_ref => {\n      let [name, tex] = _ref;\n      if (!tex) return;\n      if (tex.getInputData() || tex.getJsImageData() || tex.getCanvas() || tex.getImageBitmap()) {\n        newTextures.push([name, tex]);\n      }\n      if (tex.getImage() && tex.getImageLoaded()) {\n        newTextures.push([name, tex]);\n      }\n    });\n\n    // Add textures to manager only if not present\n    newTextures.forEach(_ref2 => {\n      let [textureName, srcTexture] = _ref2;\n      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture, textureName);\n      if (!newTex.getReady()) return;\n      let found = false;\n      for (let t = 0; t < model.textures.length; ++t) {\n        if (model.textures[t] === newTex) {\n          found = true;\n          usedTextures[t] = true;\n          break;\n        }\n      }\n      if (!found) {\n        usedTextures[model.textures.length] = true;\n        const tview = newTex.createView(textureName);\n        model.textures.push(newTex);\n        model.textureViews.push(tview);\n\n        // Sampler setup\n        const interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';\n        let addressMode = null;\n        if (srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';else if (srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';else if (srcTexture.getRepeat()) addressMode = 'repeat';\n\n        // Handle environment texture separately\n        let options = {\n          addressModeU: addressMode,\n          addressModeV: addressMode,\n          addressModeW: addressMode,\n          minFilter: interpolate,\n          magFilter: interpolate\n        };\n        if (textureName === 'EnvironmentTexture') {\n          options = {\n            addressModeU: 'repeat',\n            addressModeV: 'clamp-to-edge',\n            addressModeW: 'repeat',\n            minFilter: interpolate,\n            magFilter: interpolate,\n            mipmapFilter: 'linear'\n          };\n        }\n        tview.addSampler(model.device, options);\n      }\n    });\n\n    // remove unused textures\n    for (let i = model.textures.length - 1; i >= 0; i--) {\n      if (!usedTextures[i]) {\n        model.textures.splice(i, 1);\n        model.textureViews.splice(i, 1);\n      }\n    }\n  };\n\n  // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n  publicAPI.computePipelineHash = () => {\n    let pipelineHash = `pd${model.useRendererMatrix ? 'r' : ''}${model.forceZValue ? 'z' : ''}`;\n    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {\n      pipelineHash += 'edge';\n    } else {\n      if (model.vertexInput.hasAttribute(`normalMC`)) {\n        pipelineHash += `n`;\n      }\n      if (model.vertexInput.hasAttribute(`colorVI`)) {\n        pipelineHash += `c`;\n      }\n      if (model.vertexInput.hasAttribute(`tcoord`)) {\n        const tcoords = model.vertexInput.getBuffer('tcoord');\n        const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n        pipelineHash += `t${numComp}`;\n      }\n      if (model.textures.length) {\n        pipelineHash += `tx${model.textures.length}`;\n      }\n    }\n    if (model._usesCellNormals) {\n      pipelineHash += `cn`;\n    }\n    if (model.SSBO) {\n      pipelineHash += `ssbo`;\n    }\n    const uhash = publicAPI.getHashFromUsage(model.usage);\n    pipelineHash += uhash;\n    pipelineHash += model.renderEncoder.getPipelineHash();\n    model.pipelineHash = pipelineHash;\n  };\n  publicAPI.updateBuffers = () => {\n    // handle textures if not edges\n    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {\n      publicAPI.updateTextures();\n    }\n    const actor = model.WebGPUActor.getRenderable();\n    const rep = actor.getProperty().getRepresentation();\n\n    // handle per primitive type\n    model.usage = publicAPI.getUsage(rep, model.primitiveType);\n    publicAPI.buildVertexInput();\n    const vbo = model.vertexInput.getBuffer('vertexBC');\n    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());\n    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));\n    publicAPI.updateUBO();\n    if (publicAPI.haveWideLines()) {\n      const ppty = actor.getProperty();\n      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));\n    } else {\n      publicAPI.setNumberOfInstances(1);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  is2D: false,\n  cellArray: null,\n  currentInput: null,\n  cellOffset: 0,\n  primitiveType: 0,\n  colorTexture: null,\n  renderEncoder: null,\n  textures: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initiaLalues);\n\n  // Inheritance\n  vtkWebGPUSimpleMapper.extend(publicAPI, model, initiaLalues);\n  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;\n  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;\n  model._tmpMat3 = mat3.identity(new Float64Array(9));\n  model._tmpMat4 = mat4.identity(new Float64Array(16));\n\n  // UBO\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('AmbientColor', 'vec4<f32>');\n  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');\n  model.UBO.addEntry('EdgeColor', 'vec4<f32>');\n  model.UBO.addEntry('SpecularColor', 'vec4<f32>');\n  model.UBO.addEntry('AmbientIntensity', 'f32');\n  model.UBO.addEntry('DiffuseIntensity', 'f32');\n  model.UBO.addEntry('Roughness', 'f32');\n  model.UBO.addEntry('Metallic', 'f32');\n  model.UBO.addEntry('Ambient', 'f32');\n  model.UBO.addEntry('Normal', 'f32');\n  model.UBO.addEntry('Emission', 'f32');\n  model.UBO.addEntry('NormalStrength', 'f32');\n  model.UBO.addEntry('BaseIOR', 'f32');\n  model.UBO.addEntry('SpecularIntensity', 'f32');\n  model.UBO.addEntry('LineWidth', 'f32');\n  model.UBO.addEntry('Opacity', 'f32');\n  model.UBO.addEntry('ZValue', 'f32');\n  model.UBO.addEntry('PropID', 'u32');\n  model.UBO.addEntry('ClipNear', 'f32');\n  model.UBO.addEntry('ClipFar', 'f32');\n  model.UBO.addEntry('Time', 'u32');\n\n  // Build VTK API\n  setGet(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);\n  model.textures = [];\n\n  // Object methods\n  vtkWebGPUCellArrayMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUCellArrayMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUCellArrayMapper$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUCellArrayMapper$1 as default, extend, newInstance };\n", "import { n as newInstance$1, r as vtkErrorMacro } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  PrimitiveTypes\n} = vtkWebGPUBufferManager;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUPolyDataMapper');\n  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper.newInstance();\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      const poly = model.renderable.getInputData();\n      model.renderable.mapScalars(poly, 1.0);\n      publicAPI.updateCellArrayMappers(poly);\n    }\n  };\n  publicAPI.updateCellArrayMappers = poly => {\n    if (!poly) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];\n\n    // we instantiate a cell array mapper for each cellArray that has cells\n    // and they handle the rendering of that cell array\n    const cellMappers = [];\n    let cellOffset = 0;\n    // Handle all primitive types including strips\n    for (let i = PrimitiveTypes.Points; i <= PrimitiveTypes.TriangleStrips; i++) {\n      if (prims[i].getNumberOfValues() > 0) {\n        if (!model.primitives[i]) {\n          model.primitives[i] = publicAPI.createCellArrayMapper();\n        }\n        const cellMapper = model.primitives[i];\n        cellMapper.setCellArray(prims[i]);\n        cellMapper.setCurrentInput(poly);\n        cellMapper.setCellOffset(cellOffset);\n        cellMapper.setPrimitiveType(i);\n        cellMapper.setRenderable(model.renderable);\n        cellOffset += prims[i].getNumberOfCells();\n        cellMappers.push(cellMapper);\n      } else {\n        model.primitives[i] = null;\n      }\n    }\n\n    // Handle edge visibility for both triangles and triangle strips\n    if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {\n      // Handle triangle edges\n      if (prims[PrimitiveTypes.Triangles].getNumberOfValues() > 0) {\n        const i = PrimitiveTypes.TriangleEdges;\n        if (!model.primitives[i]) {\n          model.primitives[i] = publicAPI.createCellArrayMapper();\n        }\n        const cellMapper = model.primitives[i];\n        cellMapper.setCellArray(prims[PrimitiveTypes.Triangles]);\n        cellMapper.setCurrentInput(poly);\n        cellMapper.setCellOffset(model.primitives[PrimitiveTypes.Triangles].getCellOffset());\n        cellMapper.setPrimitiveType(i);\n        cellMapper.setRenderable(model.renderable);\n        cellMappers.push(cellMapper);\n      } else {\n        model.primitives[PrimitiveTypes.TriangleEdges] = null;\n      }\n\n      // Handle triangle strip edges\n      if (prims[PrimitiveTypes.TriangleStrips].getNumberOfValues() > 0) {\n        const i = PrimitiveTypes.TriangleStripEdges;\n        if (!model.primitives[i]) {\n          model.primitives[i] = publicAPI.createCellArrayMapper();\n        }\n        const cellMapper = model.primitives[i];\n        cellMapper.setCellArray(prims[PrimitiveTypes.TriangleStrips]);\n        cellMapper.setCurrentInput(poly);\n        cellMapper.setCellOffset(model.primitives[PrimitiveTypes.TriangleStrips].getCellOffset());\n        cellMapper.setPrimitiveType(i);\n        cellMapper.setRenderable(model.renderable);\n        cellMappers.push(cellMapper);\n      } else {\n        model.primitives[PrimitiveTypes.TriangleStripEdges] = null;\n      }\n    }\n    publicAPI.prepareNodes();\n    publicAPI.addMissingChildren(cellMappers);\n    publicAPI.removeUnusedNodes();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  primitives: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.primitives = [];\n\n  // Object methods\n  vtkWebGPUPolyDataMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUPolyDataMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUPolyDataMapper$1 = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkMapper', newInstance);\n\nexport { vtkWebGPUPolyDataMapper$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUPixelSpaceCallbackMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {\n  model.classHierarchy.push('vtkWebGPUPixelSpaceCallbackMapper');\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');\n    model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n    const aspectRatio = model.WebGPURenderer.getAspectRatio();\n    const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;\n    const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();\n    const texels = null;\n    if (model.renderable.getUseZValues()) ;\n    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUPixelSpaceCallbackMapper');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkPixelSpaceCallbackMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { n as newInstance$1 } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  PrimitiveTypes\n} = vtkWebGPUBufferManager;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUPolyDataMapper2D(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUPolyDataMapper2D');\n  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper.newInstance();\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      const poly = model.renderable.getInputData();\n      model.renderable.mapScalars(poly, 1.0);\n      publicAPI.updateCellArrayMappers(poly);\n    }\n  };\n  publicAPI.updateCellArrayMappers = poly => {\n    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];\n\n    // we instantiate a cell array mapper for each cellArray that has cells\n    // and they handle the rendering of that cell array\n    const cellMappers = [];\n    let cellOffset = 0;\n    for (let i = PrimitiveTypes.Points; i <= PrimitiveTypes.Triangles; i++) {\n      if (prims[i].getNumberOfValues() > 0) {\n        if (!model.primitives[i]) {\n          model.primitives[i] = publicAPI.createCellArrayMapper();\n        }\n        const cellMapper = model.primitives[i];\n        cellMapper.setCellArray(prims[i]);\n        cellMapper.setCurrentInput(poly);\n        cellMapper.setCellOffset(cellOffset);\n        cellMapper.setPrimitiveType(i);\n        cellMapper.setRenderable(model.renderable);\n        cellMapper.setIs2D(true);\n        cellOffset += prims[i].getNumberOfCells();\n        cellMappers.push(cellMapper);\n      } else {\n        model.primitives[i] = null;\n      }\n    }\n    publicAPI.prepareNodes();\n    publicAPI.addMissingChildren(cellMappers);\n    publicAPI.removeUnusedNodes();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    primitives: [],\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.primitives = [];\n\n  // Object methods\n  vtkWebGPUPolyDataMapper2D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUPolyDataMapper2D');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkMapper2D', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, o as obj, g as get, k as getArray, e as setGet, c as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUStorageBuffer from './StorageBuffer.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\nconst clearFragColorTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\nconst clearFragTextureTemplate = `\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\n  var tau: f32 = 6.28318530718;\n  var pi: f32 = 3.14159265359;\n  var out: vec2<f32> = vec2<f32>(0.0);\n\n  out.x = atan2(dir.z, dir.x) / tau;\n  out.x += 0.5;\n\n  var phix: f32 = length(vec2(dir.x, dir.z));\n  out.y = atan2(dir.y, phix) / pi + 0.5;\n\n  return out;\n}\n\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);\n  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);\n  // textureSampleLevel gets rid of some ugly artifacts\n  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);\n  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n`;\nconst _fsqClearMat4 = new Float64Array(16);\nconst _tNormalMat4 = new Float64Array(16);\n\n// Light type index gives either 0, 1, or 2 which indicates what type of light there is.\n// While technically, there are only spot and directional lights, within the CellArrayMapper\n// there is a third, positional light. It is technically just a variant of a spot light with\n// a cone angle of 90 or above, however certain calculations can be skipped if it is treated\n// separately.\n// The mappings are shown below:\n// 0 -> positional light\n// 1 -> directional light\n// 2 -> spot light\nfunction getLightTypeIndex(light) {\n  if (light.getPositional()) {\n    if (light.getConeAngle() >= 90) {\n      return 0;\n    }\n    return 2;\n  }\n  return 1;\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderer methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-bitwise */\n\nfunction vtkWebGPURenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderer');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      model.camera = model.renderable.getActiveCamera();\n      publicAPI.updateLights();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.camera);\n      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());\n      publicAPI.removeUnusedNodes();\n      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera, model.webgpuCamera);\n      publicAPI.updateStabilizedMatrix();\n    }\n  };\n  publicAPI.updateStabilizedMatrix = () => {\n    // This method is designed to help with floating point\n    // issues when rendering datasets that push the limits of\n    // resolutions on float.\n    //\n    // One of the most common cases is when the dataset is located far\n    // away from the origin relative to the clipping range we are looking\n    // at. For that case we want to perform the floating point sensitive\n    // multiplications on the CPU in double. To this end we want the\n    // vertex rendering ops to look something like\n    //\n    // Compute shifted points and load those into the VBO\n    // pointCoordsSC = WorldToStabilizedMatrix * pointCoords;\n    //\n    // In the vertex shader do the following\n    // positionVC = StabilizedToDeviceMatrix * ModelToStabilizedMatrix*vertexIn;\n    //\n    // We use two matrices because it is expensive to change the\n    // WorldToStabilized matrix as we have to reupload all pointCoords\n    // So that matrix (MCSCMatrix) is fairly static, the Stabilized to\n    // Device matrix is the one that gets updated every time the camera\n    // changes.\n    //\n    // The basic idea is that we should translate the data so that\n    // when the center of the view frustum moves a lot\n    // we recenter it. The center of the view frustum is roughly\n    // camPos + dirOfProj*(far + near)*0.5\n    const clipRange = model.camera.getClippingRange();\n    const pos = model.camera.getPositionByReference();\n    const dop = model.camera.getDirectionOfProjectionByReference();\n    const center = [];\n    const offset = [];\n    vec3.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));\n    vec3.add(center, pos, offset);\n    vec3.sub(offset, center, model.stabilizedCenter);\n    const length = vec3.len(offset);\n    if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {\n      model.stabilizedCenter = center;\n      model.stabilizedTime.modified();\n    }\n  };\n  publicAPI.updateLights = () => {\n    let count = 0;\n    const lights = model.renderable.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      if (lights[index].getSwitch() > 0.0) {\n        count++;\n      }\n    }\n    if (!count) {\n      vtkDebugMacro('No lights are on, creating one.');\n      model.renderable.createLight();\n    }\n    return count;\n  };\n  publicAPI.updateUBO = () => {\n    // make sure the data is up to date\n    // has the camera changed?\n    const utime = model.UBO.getSendTime();\n    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {\n      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n      model.UBO.setArray('WCVCMatrix', keyMats.wcvc);\n      model.UBO.setArray('SCPCMatrix', keyMats.scpc);\n      model.UBO.setArray('PCSCMatrix', keyMats.pcsc);\n      model.UBO.setArray('SCVCMatrix', keyMats.scvc);\n      model.UBO.setArray('VCPCMatrix', keyMats.vcpc);\n      model.UBO.setArray('WCVCNormals', keyMats.normalMatrix);\n      model.UBO.setValue('LightCount', model.renderable.getLights().length);\n      model.UBO.setValue('MaxEnvironmentMipLevel', model.renderable.getEnvironmentTexture()?.getMipLevel());\n      model.UBO.setValue('BackgroundDiffuseStrength', model.renderable.getEnvironmentTextureDiffuseStrength());\n      model.UBO.setValue('BackgroundSpecularStrength', model.renderable.getEnvironmentTextureSpecularStrength());\n      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();\n      model.UBO.setArray('viewportSize', [tsize.usize, tsize.vsize]);\n      model.UBO.setValue('cameraParallel', model.camera.getParallelProjection());\n      const device = model._parent.getDevice();\n      model.UBO.sendIfNeeded(device);\n    }\n  };\n  publicAPI.updateSSBO = () => {\n    const lights = model.renderable.getLights();\n    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n    let lightTimeString = `${model.renderable.getMTime()}`;\n    for (let i = 0; i < lights.length; i++) {\n      lightTimeString += lights[i].getMTime();\n    }\n    if (lightTimeString !== model.lightTimeString) {\n      const lightPosArray = new Float32Array(lights.length * 4);\n      const lightDirArray = new Float32Array(lights.length * 4);\n      const lightColorArray = new Float32Array(lights.length * 4);\n      const lightTypeArray = new Float32Array(lights.length * 4);\n      for (let i = 0; i < lights.length; i++) {\n        const offset = i * 4;\n\n        // Position\n        const viewCoordinatePosition = lights[i].getPosition();\n        vec3.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);\n        // viewCoordinatePosition\n        lightPosArray[offset] = viewCoordinatePosition[0];\n        lightPosArray[offset + 1] = viewCoordinatePosition[1];\n        lightPosArray[offset + 2] = viewCoordinatePosition[2];\n        lightPosArray[offset + 3] = 0;\n\n        // Rotation (All are negative to correct for -Z being forward)\n        lightDirArray[offset] = -lights[i].getDirection()[0];\n        lightDirArray[offset + 1] = -lights[i].getDirection()[1];\n        lightDirArray[offset + 2] = -lights[i].getDirection()[2];\n        lightDirArray[offset + 3] = 0;\n\n        // Color\n        lightColorArray[offset] = lights[i].getColor()[0];\n        lightColorArray[offset + 1] = lights[i].getColor()[1];\n        lightColorArray[offset + 2] = lights[i].getColor()[2];\n        lightColorArray[offset + 3] = lights[i].getIntensity() * 5; // arbitrary multiplication to fix the dullness of low value PBR lights\n\n        // Type\n        lightTypeArray[offset] = getLightTypeIndex(lights[i]); // Type\n        lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle())); // Inner Phi, should probably do some check on these to make sure they dont excede limits\n        lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff())); // Outer Phi\n        lightTypeArray[offset + 3] = 0;\n      }\n\n      // Im not sure how correct this is, but this is what the example does\n      // https://kitware.github.io/vtk-js/api/Rendering_WebGPU_VolumePassFSQ.html\n      model.SSBO.clearData();\n      model.SSBO.setNumberOfInstances(lights.length);\n      model.SSBO.addEntry('LightPos', 'vec4<f32>'); // Position\n      model.SSBO.addEntry('LightDir', 'vec4<f32>'); // Direction\n      model.SSBO.addEntry('LightColor', 'vec4<f32>'); // Color (r, g, b, intensity)\n      model.SSBO.addEntry('LightData', 'vec4<f32>'); // Other data (type, etc, etc, etc)\n\n      model.SSBO.setAllInstancesFromArray('LightPos', lightPosArray);\n      model.SSBO.setAllInstancesFromArray('LightDir', lightDirArray);\n      model.SSBO.setAllInstancesFromArray('LightColor', lightColorArray);\n      model.SSBO.setAllInstancesFromArray('LightData', lightTypeArray);\n      const device = model._parent.getDevice();\n      model.SSBO.send(device);\n    }\n    model.lightTimeString = lightTimeString;\n  };\n  publicAPI.scissorAndViewport = encoder => {\n    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();\n    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0.0, 1.0);\n    // set scissor\n    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);\n  };\n  publicAPI.bindUBO = renderEncoder => {\n    renderEncoder.activateBindGroup(model.bindGroup);\n  };\n\n  // Renders myself\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n      publicAPI.updateUBO();\n      publicAPI.updateSSBO();\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      publicAPI.clear();\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.clear = () => {\n    if (model.renderable.getTransparent() || model.suppressClear) {\n      return;\n    }\n    const device = model._parent.getDevice();\n    // Normal Solid Color\n    if (!model.clearFSQ) {\n      model.clearFSQ = vtkWebGPUFullScreenQuad.newInstance();\n      model.clearFSQ.setDevice(device);\n      model.clearFSQ.setPipelineHash('clearfsq');\n      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n      model.backgroundTex = model.renderable.getEnvironmentTexture();\n    }\n    // Textured Background\n    if (model.clearFSQ.getPipelineHash() !== 'clearfsqwithtexture' && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {\n      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex, 'EnvironmentTexture');\n      if (environmentTextureHash.getReady()) {\n        const tview = environmentTextureHash.createView(`EnvironmentTexture`);\n        model.clearFSQ.setTextureViews([tview]);\n        model.backgroundTexLoaded = true;\n        const interpolate = model.backgroundTex.getInterpolate() ? 'linear' : 'nearest';\n        tview.addSampler(device, {\n          addressModeU: 'repeat',\n          addressModeV: 'clamp-to-edge',\n          addressModeW: 'repeat',\n          minFilter: interpolate,\n          magFilter: interpolate,\n          mipmapFilter: 'linear'\n        });\n      }\n      model.clearFSQ.setPipelineHash('clearfsqwithtexture');\n    } else if (model.clearFSQ.getPipelineHash() === 'clearfsqwithtexture' && !model.renderable.getUseEnvironmentTextureAsBackground()) {\n      // In case the mode is changed at runtime\n      model.clearFSQ = vtkWebGPUFullScreenQuad.newInstance();\n      model.clearFSQ.setDevice(device);\n      model.clearFSQ.setPipelineHash('clearfsq');\n      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);\n      const ubo = vtkWebGPUUniformBuffer.newInstance({\n        label: 'mapperUBO'\n      });\n      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');\n      ubo.addEntry('BackgroundColor', 'vec4<f32>');\n      model.clearFSQ.setUBO(ubo);\n    }\n    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);\n    const background = model.renderable.getBackgroundByReference();\n    model.clearFSQ.getUBO().setArray('BackgroundColor', background);\n    mat4.transpose(_tNormalMat4, keyMats.normalMatrix);\n    mat4.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);\n    mat4.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);\n    model.clearFSQ.getUBO().setArray('FSQMatrix', _fsqClearMat4);\n    model.clearFSQ.getUBO().sendIfNeeded(device);\n    model.clearFSQ.prepareAndDraw(model.renderEncoder);\n  };\n  publicAPI.translucentPass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.volumeDepthRangePass = prepass => {\n    if (prepass) {\n      model.renderEncoder.begin(model._parent.getCommandEncoder());\n    } else {\n      publicAPI.scissorAndViewport(model.renderEncoder);\n      model.renderEncoder.end();\n    }\n  };\n  publicAPI.getAspectRatio = () => {\n    const size = model._parent.getSizeByReference();\n    const viewport = model.renderable.getViewportByReference();\n    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);\n  };\n  publicAPI.convertToOpenGLDepth = val => model.webgpuCamera.convertToOpenGLDepth(val);\n  publicAPI.getYInvertedTiledSizeAndOrigin = () => {\n    const res = publicAPI.getTiledSizeAndOrigin();\n    const size = model._parent.getSizeByReference();\n    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;\n    return res;\n  };\n  publicAPI.getTiledSizeAndOrigin = () => {\n    const vport = model.renderable.getViewportByReference();\n\n    // if there is no window assume 0 1\n    const tileViewPort = [0.0, 0.0, 1.0, 1.0];\n\n    // find the lower left corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu = vport[0] - tileViewPort[0];\n    const vpv = vport[1] - tileViewPort[1];\n\n    // store the result as a pixel value\n    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);\n    const lowerLeftU = Math.round(ndvp[0]);\n    const lowerLeftV = Math.round(ndvp[1]);\n\n    // find the upper right corner of the viewport, taking into account the\n    // lower left boundary of this tile\n    const vpu2 = vport[2] - tileViewPort[0];\n    const vpv2 = vport[3] - tileViewPort[1];\n    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);\n\n    // now compute the size of the intersection of the viewport with the\n    // current tile\n    let usize = Math.round(ndvp2[0]) - lowerLeftU;\n    let vsize = Math.round(ndvp2[1]) - lowerLeftV;\n    if (usize < 0) {\n      usize = 0;\n    }\n    if (vsize < 0) {\n      vsize = 0;\n    }\n    return {\n      usize,\n      vsize,\n      lowerLeftU,\n      lowerLeftV\n    };\n  };\n  publicAPI.getPropFromID = id => {\n    for (let i = 0; i < model.children.length; i++) {\n      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;\n      if (res === id) {\n        return model.children[i];\n      }\n    }\n    return null;\n  };\n  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();\n  publicAPI.releaseGraphicsResources = () => {\n    if (model.selector !== null) {\n      model.selector.releaseGraphicsResources();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bindGroup: null,\n  selector: null,\n  renderEncoder: null,\n  recenterThreshold: 20.0,\n  suppressClear: false,\n  stabilizedCenter: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // UBO\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'rendererUBO'\n  });\n  model.UBO.addEntry('WCVCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('SCPCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('PCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('SCVCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('VCPCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('WCVCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('viewportSize', 'vec2<f32>');\n  model.UBO.addEntry('LightCount', 'i32');\n  model.UBO.addEntry('MaxEnvironmentMipLevel', 'f32');\n  model.UBO.addEntry('BackgroundDiffuseStrength', 'f32');\n  model.UBO.addEntry('BackgroundSpecularStrength', 'f32');\n  model.UBO.addEntry('cameraParallel', 'u32');\n\n  // SSBO (Light data)\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'rendererLightSSBO'\n  });\n  model.lightTimeString = '';\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'rendererBG'\n  });\n  model.bindGroup.setBindables([model.UBO, model.SSBO]);\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  model.stabilizedTime = {};\n  obj(model.stabilizedTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  get(publicAPI, model, ['bindGroup', 'stabilizedTime']);\n  getArray(publicAPI, model, ['stabilizedCenter']);\n  setGet(publicAPI, model, ['renderEncoder', 'selector', 'suppressClear', 'UBO']);\n\n  // Object methods\n  vtkWebGPURenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPURenderer');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkRenderer', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { n as newInstance$1 } from '../../macros2.js';\nimport vtkScalarBarActor from '../Core/ScalarBarActor.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUScalarBarActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUScalarBarActor(publicAPI, model) {\n  model.classHierarchy.push('vtkWebGPUScalarBarActor');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      if (!model.scalarBarActorHelper.getRenderable()) {\n        model.scalarBarActorHelper.setRenderable(model.renderable);\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());\n      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;\n      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();\n      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.scalarBarActorHelper = vtkScalarBarActor.newScalarBarActorHelper();\n\n  // Object methods\n  vtkWebGPUScalarBarActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUScalarBarActor');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkScalarBarActor', newInstance);\n\nexport { index as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "newInstance", "Representation", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "primTypes", "Filter", "Wrap", "vtkErrorMacro", "StartEvent", "EndEvent", "DEFAULT_VALUES", "extend", "newInstance", "vtkDebugMacro", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "CoordinateSystem", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "CoordinateSystem", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "DisplayLocation", "DEFAULT_VALUES", "extend", "newInstance", "Representation", "ScalarMode", "CoordinateSystem", "DisplayLocation", "fDesc", "code", "DEFAULT_VALUES", "extend", "newInstance", "PrimitiveTypes", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "PrimitiveTypes", "defaultValues", "extend", "newInstance", "registerOverride", "newInstance", "vtkDebugMacro", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance"]
}
