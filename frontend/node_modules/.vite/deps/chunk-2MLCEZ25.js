import {
  VtkDataTypes,
  vtkDataArray$1,
  vtkDataSet$1
} from "./chunk-QTSXRC5W.js";
import {
  clampVector,
  createUninitializedBounds,
  hsv2rgb,
  isNan,
  macro,
  mat3_exports,
  mat4_exports,
  roundVector,
  vec3_exports,
  vtkBoundingBox
} from "./chunk-UJ7GCCMN.js";

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractMapper");
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = (plane) => {
    if (!plane.isA("vtkPlane")) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
  publicAPI.removeAllClippingPlanes = () => {
    if (model.clippingPlanes.length === 0) {
      return false;
    }
    model.clippingPlanes.length = 0;
    publicAPI.modified();
    return true;
  };
  publicAPI.removeClippingPlane = (clippingPlane) => {
    const i = model.clippingPlanes.indexOf(clippingPlane);
    if (i === -1) {
      return false;
    }
    model.clippingPlanes.splice(i, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = () => model.clippingPlanes;
  publicAPI.setClippingPlanes = (planes) => {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      const nbPlanes = planes.length;
      for (let i = 0; i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
    const clipPlanes = model.clippingPlanes;
    const mat = propMatrix;
    if (clipPlanes) {
      const n = clipPlanes.length;
      if (i >= 0 && i < n) {
        const plane = clipPlanes[i];
        const normal = plane.getNormal();
        const origin = plane.getOrigin();
        const v1 = normal[0];
        const v2 = normal[1];
        const v3 = normal[2];
        const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
        return;
      }
    }
    macro.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
  };
}
var DEFAULT_VALUES = {
  clippingPlanes: []
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}
var vtkAbstractMapper$1 = {
  extend
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = () => {
    macro.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
    return createUninitializedBounds();
  };
  publicAPI.getCenter = () => {
    var _a;
    const bounds = publicAPI.getBounds();
    model.center = vtkBoundingBox.isValid(bounds) ? vtkBoundingBox.getCenter(bounds) : null;
    return (_a = model.center) == null ? void 0 : _a.slice();
  };
  publicAPI.getLength = () => {
    const bounds = publicAPI.getBounds();
    return vtkBoundingBox.getDiagonalLength(bounds);
  };
}
var defaultValues = (initialValues) => ({
  bounds: [...vtkBoundingBox.INIT_BOUNDS],
  center: [0, 0, 0],
  viewSpecificProperties: {},
  ...initialValues
});
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["viewSpecificProperties"]);
  vtkAbstractMapper3D(publicAPI, model);
}
var vtkAbstractMapper3D$1 = {
  extend: extend2
};

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js
var StructuredType = {
  UNCHANGED: 0,
  SINGLE_POINT: 1,
  X_LINE: 2,
  Y_LINE: 3,
  Z_LINE: 4,
  XY_PLANE: 5,
  YZ_PLANE: 6,
  XZ_PLANE: 7,
  XYZ_GRID: 8,
  EMPTY: 9
};
var Constants = {
  StructuredType
};

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js
var {
  StructuredType: StructuredType2
} = Constants;
function getDataDescriptionFromExtent(inExt) {
  let dataDim = 0;
  for (let i = 0; i < 3; ++i) {
    if (inExt[i * 2] < inExt[i * 2 + 1]) {
      dataDim++;
    }
  }
  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
    return StructuredType2.EMPTY;
  }
  if (dataDim === 3) {
    return StructuredType2.XYZ_GRID;
  }
  if (dataDim === 2) {
    if (inExt[0] === inExt[1]) {
      return StructuredType2.YZ_PLANE;
    }
    if (inExt[2] === inExt[3]) {
      return StructuredType2.XZ_PLANE;
    }
    return StructuredType2.XY_PLANE;
  }
  if (dataDim === 1) {
    if (inExt[0] < inExt[1]) {
      return StructuredType2.X_LINE;
    }
    if (inExt[2] < inExt[3]) {
      return StructuredType2.Y_LINE;
    }
    return StructuredType2.Z_LINE;
  }
  return StructuredType2.SINGLE_POINT;
}
var vtkStructuredData = {
  getDataDescriptionFromExtent,
  ...Constants
};

// node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var {
  vtkErrorMacro
} = macro;
function vtkImageData(publicAPI, model) {
  model.classHierarchy.push("vtkImageData");
  publicAPI.setExtent = function() {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return false;
    }
    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
      inExtent[_key] = arguments[_key];
    }
    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
    if (extentArray.length !== 6) {
      return false;
    }
    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);
    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
      publicAPI.modified();
    }
    return changeDetected;
  };
  publicAPI.setDimensions = function() {
    let i;
    let j;
    let k;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    if (arguments.length === 1) {
      const array = arguments.length <= 0 ? void 0 : arguments[0];
      i = array[0];
      j = array[1];
      k = array[2];
    } else if (arguments.length === 3) {
      i = arguments.length <= 0 ? void 0 : arguments[0];
      j = arguments.length <= 1 ? void 0 : arguments[1];
      k = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      vtkErrorMacro("Bad dimension specification");
      return;
    }
    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
  };
  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
  publicAPI.getNumberOfCells = () => {
    const dims = publicAPI.getDimensions();
    let nCells = 1;
    for (let i = 0; i < 3; i++) {
      if (dims[i] === 0) {
        return 0;
      }
      if (dims[i] > 1) {
        nCells *= dims[i] - 1;
      }
    }
    return nCells;
  };
  publicAPI.getNumberOfPoints = () => {
    const dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };
  publicAPI.getPoint = (index) => {
    const dims = publicAPI.getDimensions();
    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro("Requesting a point from an empty image.");
      return null;
    }
    const ijk = new Float64Array(3);
    switch (model.dataDescription) {
      case StructuredType.EMPTY:
        return null;
      case StructuredType.SINGLE_POINT:
        break;
      case StructuredType.X_LINE:
        ijk[0] = index;
        break;
      case StructuredType.Y_LINE:
        ijk[1] = index;
        break;
      case StructuredType.Z_LINE:
        ijk[2] = index;
        break;
      case StructuredType.XY_PLANE:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0];
        break;
      case StructuredType.YZ_PLANE:
        ijk[1] = index % dims[1];
        ijk[2] = index / dims[1];
        break;
      case StructuredType.XZ_PLANE:
        ijk[0] = index % dims[0];
        ijk[2] = index / dims[0];
        break;
      case StructuredType.XYZ_GRID:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0] % dims[1];
        ijk[2] = index / (dims[0] * dims[1]);
        break;
      default:
        vtkErrorMacro("Invalid dataDescription");
        break;
    }
    const coords = [0, 0, 0];
    publicAPI.indexToWorld(ijk, coords);
    return coords;
  };
  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());
  publicAPI.extentToBounds = (ex) => vtkBoundingBox.transformBounds(ex, model.indexToWorld);
  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);
  publicAPI.computeTransforms = () => {
    mat4_exports.fromTranslation(model.indexToWorld, model.origin);
    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];
    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];
    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];
    mat4_exports.scale(model.indexToWorld, model.indexToWorld, model.spacing);
    mat4_exports.invert(model.worldToIndex, model.indexToWorld);
  };
  publicAPI.indexToWorld = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.indexToWorld);
    return aout;
  };
  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
  publicAPI.worldToIndex = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.worldToIndex);
    return aout;
  };
  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
  publicAPI.indexToWorldBounds = function(bin) {
    let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);
  };
  publicAPI.worldToIndexBounds = function(bin) {
    let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);
  };
  model._onOriginChanged = publicAPI.computeTransforms;
  model._onDirectionChanged = publicAPI.computeTransforms;
  model._onSpacingChanged = publicAPI.computeTransforms;
  publicAPI.computeTransforms();
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());
  publicAPI.computeHistogram = function(worldBounds) {
    let voxelFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);
    const point1 = [0, 0, 0];
    const point2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
    roundVector(point1, point1);
    roundVector(point2, point2);
    const dimensions = publicAPI.getDimensions();
    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
    const yStride = dimensions[0];
    const zStride = dimensions[0] * dimensions[1];
    const pixels = publicAPI.getPointData().getScalars().getData();
    let maximum = -Infinity;
    let minimum = Infinity;
    let sumOfSquares = 0;
    let isum = 0;
    let inum = 0;
    for (let z = point1[2]; z <= point2[2]; z++) {
      for (let y = point1[1]; y <= point2[1]; y++) {
        let index = point1[0] + y * yStride + z * zStride;
        for (let x = point1[0]; x <= point2[0]; x++) {
          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {
            const pixel = pixels[index];
            if (pixel > maximum) maximum = pixel;
            if (pixel < minimum) minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }
          ++index;
        }
      }
    }
    const average = inum > 0 ? isum / inum : 0;
    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
    const sigma = Math.sqrt(variance);
    return {
      minimum,
      maximum,
      average,
      variance,
      sigma,
      count: inum
    };
  };
  publicAPI.computeIncrements = function(extent) {
    let numberOfComponents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const increments = [];
    let incr = numberOfComponents;
    for (let idx = 0; idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
    }
    return increments;
  };
  publicAPI.computeOffsetIndex = (_ref) => {
    let [i, j, k] = _ref;
    const extent = publicAPI.getExtent();
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    const increments = publicAPI.computeIncrements(extent, numberOfComponents);
    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);
  };
  publicAPI.getOffsetIndexFromWorld = (xyz) => {
    const extent = publicAPI.getExtent();
    const index = publicAPI.worldToIndex(xyz);
    for (let idx = 0; idx < 3; ++idx) {
      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {
        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);
        return NaN;
      }
    }
    return publicAPI.computeOffsetIndex(index);
  };
  publicAPI.getScalarValueFromWorld = function(xyz) {
    let comp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);
      return NaN;
    }
    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      return offsetIndex;
    }
    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
  };
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = () => {
    publicAPI.set({
      direction: mat3_exports.identity(model.direction),
      spacing: [1, 1, 1],
      origin: [0, 0, 0],
      extent: [0, -1, 0, -1, 0, -1],
      dataDescription: StructuredType.EMPTY
    });
    return superInitialize();
  };
}
var DEFAULT_VALUES2 = {
  direction: null,
  // a mat3
  indexToWorld: null,
  // a mat4
  worldToIndex: null,
  // a mat4
  spacing: [1, 1, 1],
  origin: [0, 0, 0],
  extent: [0, -1, 0, -1, 0, -1],
  dataDescription: StructuredType.EMPTY
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  if (!model.direction) {
    model.direction = mat3_exports.identity(new Float64Array(9));
  } else if (Array.isArray(model.direction)) {
    model.direction = new Float64Array(model.direction.slice(0, 9));
  }
  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);
  macro.get(publicAPI, model, ["indexToWorld", "worldToIndex"]);
  macro.setGetArray(publicAPI, model, ["origin", "spacing"], 3);
  macro.setGetArray(publicAPI, model, ["direction"], 9);
  macro.getArray(publicAPI, model, ["extent"], 6);
  vtkImageData(publicAPI, model);
}
var newInstance = macro.newInstance(extend3, "vtkImageData");
var vtkImageData$1 = {
  newInstance,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js
var VectorMode = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2
};
var ScalarMappingTarget = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};
var Scale = {
  LINEAR: 0,
  LOG10: 1
};
var vtkScalarsToColors = {
  VectorMode,
  ScalarMappingTarget,
  Scale
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
var ColorMode = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2
};
var ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5
};
var GetArray = {
  BY_ID: 0,
  BY_NAME: 1
};
var Constants2 = {
  ColorMode,
  GetArray,
  ScalarMode
};

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
var {
  ScalarMappingTarget: ScalarMappingTarget2,
  Scale: Scale2,
  VectorMode: VectorMode2
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes2
} = vtkDataArray$1;
var {
  ColorMode: ColorMode2
} = Constants2;
var {
  vtkErrorMacro: vtkErrorMacro2
} = macro;
function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255 + 0.5);
}
function vtkScalarsToColors2(publicAPI, model) {
  model.classHierarchy.push("vtkScalarsToColors");
  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode2.MAGNITUDE);
  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode2.COMPONENT);
  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode2.RGBCOLORS);
  publicAPI.build = () => {
  };
  publicAPI.isOpaque = () => true;
  publicAPI.setAnnotations = (values, annotations) => {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro2("Values and annotations do not have the same number of tuples so ignoring");
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      const num = annotations.length;
      for (let i = 0; i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };
  publicAPI.setAnnotation = (value, annotation) => {
    let i = publicAPI.checkForAnnotatedValue(value);
    let modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };
  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;
  publicAPI.getAnnotatedValue = (idx) => {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };
  publicAPI.getAnnotation = (idx) => {
    if (model.annotationArray[idx] === void 0) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };
  publicAPI.getAnnotatedValueIndex = (val) => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;
  publicAPI.removeAnnotation = (value) => {
    const i = publicAPI.checkForAnnotatedValue(value);
    const needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };
  publicAPI.resetAnnotations = () => {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };
  publicAPI.getAnnotationColor = (val, rgba) => {
    if (model.indexedLookup) {
      const i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1;
    }
  };
  publicAPI.checkForAnnotatedValue = (value) => publicAPI.getAnnotatedValueIndexInternal(value);
  publicAPI.getAnnotatedValueIndexInternal = (value) => {
    if (model.annotatedValueMap[value] !== void 0) {
      const na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    return -1;
  };
  publicAPI.getIndexedColor = (val, rgba) => {
    rgba[0] = 0;
    rgba[1] = 0;
    rgba[2] = 0;
    rgba[3] = 0;
  };
  publicAPI.updateAnnotatedValueMap = () => {
    model.annotatedValueMap = [];
    const na = model.annotationArray.length;
    for (let i = 0; i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };
  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
    const numberOfComponents = scalars.getNumberOfComponents();
    let newColors = null;
    if (colorMode === ColorMode2.DEFAULT && (scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode2.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      const newscalars = {
        type: "vtkDataArray",
        name: "temp",
        numberOfComponents: 4,
        dataType: VtkDataTypes2.UNSIGNED_CHAR
      };
      const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = vtkDataArray$1.newInstance(newscalars);
      let component = componentIn;
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    for (let i = 0; i < length; i++) {
      let sum = 0;
      for (let j = 0; j < compsToUse; j++) {
        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum);
    }
  };
  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
    let vectorMode = publicAPI.getVectorMode();
    let vectorSize = vectorSizeIn;
    let vectorComponent = vectorComponentIn;
    const inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode2.COMPONENT) {
      if (vectorComponent === -1) {
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      if (vectorSize === -1) {
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode2.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode2.COMPONENT;
      }
    }
    let inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }
    switch (vectorMode) {
      case VectorMode2.COMPONENT: {
        publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
        break;
      }
      case VectorMode2.RGBCOLORS: {
        break;
      }
      case VectorMode2.MAGNITUDE:
      default: {
        const magValues = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: new Float32Array(input.getNumberOfTuples())
        });
        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
        break;
      }
    }
  };
  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = convtFun(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 1;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count * 4] = l;
      newValues[count * 4 + 1] = l;
      newValues[count * 4 + 2] = l;
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 2;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count] = l;
      newValues[count + 1] = l;
      newValues[count + 2] = l;
      newValues[count + 3] = convtFun(values[i + 1]) * alpha;
      count += 4;
    }
  };
  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = floatColorToUChar(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 3;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 4;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count++;
    }
  };
  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
    let {
      alpha
    } = model;
    if (numComp === 4 && alpha >= 1 && colors.getDataType() === VtkDataTypes2.UNSIGNED_CHAR) {
      return colors;
    }
    const newColors = vtkDataArray$1.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes2.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    let convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes2.FLOAT || colors.getDataType() === VtkDataTypes2.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro2("Cannot convert colors");
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);
  publicAPI.getRange = () => publicAPI.getMappingRange();
  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
    if (!scalars) {
      return publicAPI.isOpaque();
    }
    const numberOfComponents = scalars.getNumberOfComponents();
    if (colorMode === ColorMode2.DEFAULT && scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR || colorMode === ColorMode2.DIRECT_SCALARS) {
      if (numberOfComponents === 3 || numberOfComponents === 1) {
        return model.alpha >= 1;
      }
      const range = scalars.getRange(numberOfComponents - 1);
      return range[0] === 255;
    }
    return true;
  };
}
var DEFAULT_VALUES3 = {
  alpha: 1,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode2.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false,
  scale: Scale2.LINEAR
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];
  macro.setGet(publicAPI, model, ["vectorSize", "vectorComponent", "vectorMode", "alpha", "indexedLookup"]);
  macro.setArray(publicAPI, model, ["mappingRange"], 2);
  macro.getArray(publicAPI, model, ["mappingRange"]);
  vtkScalarsToColors2(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend4, "vtkScalarsToColors");
var vtkScalarsToColors$1 = {
  newInstance: newInstance2,
  extend: extend4,
  ...vtkScalarsToColors
};

// node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
var {
  vtkErrorMacro: vtkErrorMacro3
} = macro;
var BELOW_RANGE_COLOR_INDEX = 0;
var ABOVE_RANGE_COLOR_INDEX = 1;
var NAN_COLOR_INDEX = 2;
function vtkLookupTable(publicAPI, model) {
  model.classHierarchy.push("vtkLookupTable");
  publicAPI.isOpaque = () => {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      let opaque = true;
      if (model.nanColor[3] < 1) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1) {
        opaque = 0;
      }
      for (let i = 3; i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => model.table.length / 4 - 3;
  publicAPI.linearIndexLookup = (v, p) => {
    let dIndex = 0;
    const nv = Number(v);
    if (nv < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (nv > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (nv + p.shift) * p.scale;
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = (v, table, p) => {
    let index = 0;
    if (isNan(v)) {
      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index = publicAPI.linearIndexLookup(v, p);
    }
    const offset = 4 * index;
    return table.slice(offset, offset + 4);
  };
  publicAPI.indexedLookupFunction = (v, table, p) => {
    let index = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index === -1) {
      index = model.numberOfColors + NAN_COLOR_INDEX;
    }
    const offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };
  publicAPI.lookupShiftAndScale = (range, p) => {
    p.shift = -range[0];
    p.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
    }
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    let lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    const trange = publicAPI.getMappingRange();
    const p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0,
      scale: 0
    };
    publicAPI.lookupShiftAndScale(trange, p);
    const alpha = publicAPI.getAlpha();
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    if (alpha >= 1) {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
        }
      }
    }
  };
  publicAPI.forceBuild = () => {
    let hinc = 0;
    let sinc = 0;
    let vinc = 0;
    let ainc = 0;
    const maxIndex = model.numberOfColors - 1;
    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }
    model.table.length = 4 * maxIndex + 16;
    const hsv = [];
    const rgba = [];
    for (let i = 0; i <= maxIndex; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;
      hsv2rgb(hsv, rgba);
      rgba[3] = model.alphaRange[0] + i * ainc;
      model.table[i * 4] = rgba[0] * 255 + 0.5;
      model.table[i * 4 + 1] = rgba[1] * 255 + 0.5;
      model.table[i * 4 + 2] = rgba[2] * 255 + 0.5;
      model.table[i * 4 + 3] = rgba[3] * 255 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = (table) => {
    if (Array.isArray(table)) {
      const nbComponents = table[0].length;
      model.numberOfColors = table.length;
      const colorOffset = 4 - nbComponents;
      let offset = 0;
      for (let i = 0; i < model.numberOfColors; i++) {
        model.table[i * 4] = 255;
        model.table[i * 4 + 1] = 255;
        model.table[i * 4 + 2] = 255;
        model.table[i * 4 + 3] = 255;
      }
      for (let i = 0; i < table.length; i++) {
        const color = table[i];
        for (let j = 0; j < nbComponents; j++) {
          model.table[offset++] = color[j];
        }
        offset += colorOffset;
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    }
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro3("Expected 4 components for RGBA colors");
      return false;
    }
    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {
      vtkErrorMacro3("Expected unsigned char values for RGBA colors");
      return false;
    }
    model.numberOfColors = table.getNumberOfTuples();
    const data = table.getData();
    model.table.length = data.length;
    for (let i = 0; i < data.length; i++) {
      model.table[i] = data[i];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
    return true;
  };
  publicAPI.buildSpecialColors = () => {
    const {
      numberOfColors
    } = model;
    const tptr = model.table;
    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255 + 0.5;
  };
  publicAPI.build = () => {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
  }
}
var DEFAULT_VALUES4 = {
  numberOfColors: 256,
  // table: null,
  hueRange: [0, 0.66667],
  saturationRange: [1, 1],
  valueRange: [1, 1],
  alphaRange: [1, 1],
  nanColor: [0.5, 0, 0, 1],
  belowRangeColor: [0, 0, 0, 1],
  aboveRangeColor: [1, 1, 1, 1],
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  alpha: 1
  // buildTime: null,
  // opaqueFlagBuildTime: null,
  // insertTime: null,
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  macro.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  macro.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  macro.obj(model.insertTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["buildTime"]);
  macro.setGet(publicAPI, model, ["numberOfColors", "useAboveRangeColor", "useBelowRangeColor"]);
  macro.setArray(publicAPI, model, ["alphaRange", "hueRange", "saturationRange", "valueRange"], 2);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["hueRange", "saturationRange", "valueRange", "alphaRange", "nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkLookupTable(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend5, "vtkLookupTable");
var vtkLookupTable$1 = {
  newInstance: newInstance3,
  extend: extend5
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var Resolve = {
  Off: 0,
  PolygonOffset: 1
};
var resolveCoincidentTopologyPolygonOffsetFaces = Resolve.PolygonOffset;
var resolveCoincidentTopology = Resolve.Off;
var RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  const changed = resolveCoincidentTopologyPolygonOffsetFaces === value;
  resolveCoincidentTopologyPolygonOffsetFaces = value;
  return changed;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  const changed = resolveCoincidentTopology === mode;
  resolveCoincidentTopology = mode;
  return changed;
}
function setResolveCoincidentTopologyToDefault() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToOff() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  return setResolveCoincidentTopology(Resolve.PolygonOffset);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods = {
  Resolve,
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach((item) => {
    publicAPI[`get${item.method}`] = () => model[item.key];
    publicAPI[`set${item.method}`] = macro.objectSetterMap.object(publicAPI, model, {
      name: item.key,
      params: ["factor", "offset"]
    });
  });
}
var CATEGORIES = ["Polygon", "Line", "Point"];
var staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
var noOp = () => void 0;
var staticOffsetAPI = {
  modified: noOp
};
addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map((key) => ({
  key,
  method: `ResolveCoincidentTopology${key}OffsetParameters`
})));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === void 0) {
    model.resolveCoincidentTopology = false;
  }
  macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };
  Object.keys(otherStaticMethods).forEach((methodName) => {
    publicAPI[methodName] = otherStaticMethods[methodName];
  });
  Object.keys(staticOffsetAPI).filter((methodName) => methodName !== "modified").forEach((methodName) => {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map((key) => ({
    key,
    method: `RelativeCoincidentTopology${key}OffsetParameters`
  })));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods,
  CATEGORIES,
  Resolve
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
var PassTypes = {
  MIN_KNOWN_PASS: 0,
  ACTOR_PASS: 0,
  COMPOSITE_INDEX_PASS: 1,
  ID_LOW24: 2,
  ID_HIGH24: 3,
  MAX_KNOWN_PASS: 3
};
var Constants3 = {
  PassTypes
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var {
  FieldAssociations
} = vtkDataSet$1;
var {
  staticOffsetAPI: staticOffsetAPI2,
  otherStaticMethods: otherStaticMethods2
} = CoincidentTopologyHelper;
var {
  ColorMode: ColorMode3,
  ScalarMode: ScalarMode2,
  GetArray: GetArray2
} = Constants2;
var {
  VectorMode: VectorMode3
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes3
} = vtkDataArray$1;
function notImplemented(method) {
  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
}
function updateZigzaggingCoordinates(coordinates, dimensions) {
  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;
  coordinates[0] += directionX;
  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {
    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;
    coordinates[0] -= directionX;
    coordinates[1] += directionY;
    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {
      coordinates[1] -= directionY;
      coordinates[2]++;
    }
  }
}
function getIndexFromCoordinates(coordinates, dimensions) {
  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);
}
function getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {
  const intTexelIndex = Math.floor(texelIndexPosition);
  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);
  let xDirection;
  let xEndFlag;
  if (xCoordBeforeWrap < dimensions[0]) {
    textureCoordinate[0] = xCoordBeforeWrap;
    xDirection = 1;
    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;
  } else {
    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;
    xDirection = -1;
    xEndFlag = textureCoordinate[0] === 0;
  }
  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);
  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);
  let yDirection;
  let yEndFlag;
  if (yCoordBeforeWrap < dimensions[1]) {
    textureCoordinate[1] = yCoordBeforeWrap;
    yDirection = 1;
    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;
  } else {
    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;
    yDirection = -1;
    yEndFlag = textureCoordinate[1] === 0;
  }
  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);
  const remainder = texelIndexPosition - intTexelIndex;
  if (xEndFlag) {
    if (yEndFlag) {
      textureCoordinate[2] += remainder;
    } else {
      textureCoordinate[1] += yDirection * remainder;
    }
  } else {
    textureCoordinate[0] += xDirection * remainder;
  }
  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];
  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];
  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];
}
var colorTextureCoordinatesCache = /* @__PURE__ */ new WeakMap();
function getOrCreateColorTextureCoordinates(input, component, range, useLogScale, numberOfColorsInRange, dimensions, useZigzagPattern) {
  var _a;
  const argStrings = new Array(arguments.length);
  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {
    const arg = arguments[argIndex];
    argStrings[argIndex] = ((_a = arg.getMTime) == null ? void 0 : _a.call(arg)) ?? arg;
  }
  const stringHash = argStrings.join("/");
  const cachedResult = colorTextureCoordinatesCache.get(input);
  if (cachedResult && cachedResult.stringHash === stringHash) {
    return cachedResult.textureCoordinates;
  }
  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);
  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];
  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;
  const textureSCoeff = 1 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);
  const texelIndexOrigin = paddedRangeMin;
  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);
  const inputV = input.getData();
  const numScalars = input.getNumberOfTuples();
  const numComps = input.getNumberOfComponents();
  const useMagnitude = component < 0 || component >= numComps;
  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;
  const output = vtkDataArray$1.newInstance({
    numberOfComponents: numberOfOutputComponents,
    values: new Float32Array(numScalars * numberOfOutputComponents)
  });
  const outputV = output.getData();
  const nanTextureCoordinate = [0, 0, 0];
  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);
  let inputIdx = 0;
  let outputIdx = 0;
  const textureCoordinate = [0.5, 0.5, 0.5];
  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
    let scalarValue;
    if (useMagnitude) {
      let sum = 0;
      for (let compIdx = 0; compIdx < numComps; ++compIdx) {
        const compValue = Number(inputV[inputIdx + compIdx]);
        sum += compValue * compValue;
      }
      scalarValue = Math.sqrt(sum);
    } else {
      scalarValue = Number(inputV[inputIdx + component]);
    }
    if (useLogScale) {
      scalarValue = Math.log10(scalarValue);
    }
    inputIdx += numComps;
    if (isNan(scalarValue)) {
      textureCoordinate[0] = nanTextureCoordinate[0];
      textureCoordinate[1] = nanTextureCoordinate[1];
      textureCoordinate[2] = nanTextureCoordinate[2];
    } else if (useZigzagPattern) {
      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;
      if (texelIndexPosition < 1) {
        texelIndexPosition = 0;
      } else if (texelIndexPosition > numberOfColorsInRange) {
        texelIndexPosition = numberOfColorsInRange + 1;
      }
      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);
    } else {
      textureCoordinate[1] = 0.49;
      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;
      if (textureS > 1e3) {
        textureCoordinate[0] = 1e3;
      } else if (textureS < -1e3) {
        textureCoordinate[0] = -1e3;
      } else {
        textureCoordinate[0] = textureS;
      }
    }
    for (let i = 0; i < numberOfOutputComponents; ++i) {
      outputV[outputIdx++] = textureCoordinate[i];
    }
  }
  colorTextureCoordinatesCache.set(input, {
    stringHash,
    textureCoordinates: output
  });
  return output;
}
function vtkMapper(publicAPI, model) {
  model.classHierarchy.push("vtkMapper");
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = (v) => {
    model.forceCompileOnly = v;
  };
  publicAPI.setSelectionWebGLIdsToVTKIds = (selectionWebGLIdsToVTKIds) => {
    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
  };
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode3, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode2, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFlag: false
      };
    }
    let scalars = null;
    let cellFlag = false;
    if (scalarMode === ScalarMode2.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode2.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode2.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode2.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = (input, alpha) => {
    const {
      scalars,
      cellFlag
    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    model.areScalarsMappedFromCells = cellFlag;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString) return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {
      model.mapScalarsToTexture(scalars, cellFlag, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      const lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {
    const range = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    const origAlpha = model.lookupTable.getAlpha();
    const scaledRange = useLogScale ? [Math.log10(range[0]), Math.log10(range[1])] : range;
    model.colorMapColors = null;
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;
      model.lookupTable.build();
      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();
      const maxTextureWidthForCells = 2048;
      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3;
      const maxTextureWidthForPoints = 4096;
      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2;
      const minColorsInRange = 2;
      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;
      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);
      const numberOfColorsForCells = model.numberOfColorsInRange + 3;
      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2;
      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];
      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];
      const scalarsArray = new Float64Array(textureSize);
      scalarsArray.fill(NaN);
      const numberOfNonSpecialColors = model.numberOfColorsInRange;
      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;
      const textureCoordinates = [0, 0, 0];
      const rangeMin = scaledRange[0];
      const rangeDifference = scaledRange[1] - scaledRange[0];
      for (let i = 0; i < numberOfNonNaNColors; ++i) {
        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);
        const intermediateValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);
        const scalarValue = useLogScale ? 10 ** intermediateValue : intermediateValue;
        scalarsArray[scalarsArrayIndex] = scalarValue;
        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);
      }
      const scalarsDataArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: scalarsArray
      });
      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);
      model.colorTextureMap = vtkImageData$1.newInstance();
      model.colorTextureMap.setDimensions(textureDimensions);
      model.colorTextureMap.getPointData().setScalars(colorsDataArray);
      model.lookupTable.setAlpha(origAlpha);
    }
    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode3.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();
    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, scaledRange, useLogScale, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), cellFlag);
  };
  publicAPI.getIsOpaque = () => {
    const input = publicAPI.getInputData();
    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    const scalars = gasResult.scalars;
    if (!model.scalarVisibility || scalars == null) {
      return true;
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      lut.build();
      return lut.areScalarsOpaque(scalars, model.colorMode, -1);
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {
    if (cellFlag && !(model.colorMode === ColorMode3.DIRECT_SCALARS)) {
      return true;
    }
    if (!model.interpolateScalarsBeforeMapping) {
      return false;
    }
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    if (!scalars) {
      return false;
    }
    if (model.colorMode === ColorMode3.DEFAULT && scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR || model.colorMode === ColorMode3.DIRECT_SCALARS) {
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = () => {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented("AcquireInvertibleLookupTable");
  publicAPI.valueToColor = notImplemented("ValueToColor");
  publicAPI.colorToValue = notImplemented("ColorToValue");
  publicAPI.useInvertibleColorFor = notImplemented("UseInvertibleColorFor");
  publicAPI.clearInvertibleColor = notImplemented("ClearInvertibleColor");
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
      return;
    }
    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);
    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);
    const currentPass = selector.getCurrentPass();
    const fieldAssociation = selector.getFieldAssociation();
    let idMap = null;
    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      idMap = model.selectionWebGLIdsToVTKIds.points;
    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {
      idMap = model.selectionWebGLIdsToVTKIds.cells;
    }
    if (!idMap) {
      return;
    }
    pixelOffsets.forEach((pos) => {
      if (currentPass === PassTypes.ID_LOW24) {
        let inValue = 0;
        if (rawHighData) {
          inValue += rawHighData[pos];
          inValue *= 256;
        }
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);
        lowData[pos] = outValue & 255;
        lowData[pos + 1] = (outValue & 65280) >> 8;
        lowData[pos + 2] = (outValue & 16711680) >> 16;
      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {
        let inValue = 0;
        inValue += rawHighData[pos];
        inValue *= 256;
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);
        highData[pos] = (outValue & 4278190080) >> 24;
      }
    });
  };
}
var DEFAULT_VALUES5 = {
  colorMapColors: null,
  // Same as this->Colors
  areScalarsMappedFromCells: false,
  static: false,
  lookupTable: null,
  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME
  renderTime: 0,
  colorByArrayName: null,
  fieldDataTupleId: -1,
  populateSelectionSettings: true,
  selectionWebGLIdsToVTKIds: null,
  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,
  numberOfColorsInRange: 0,
  forceCompileOnly: 0,
  useInvertibleColors: false,
  invertibleScalars: null,
  customShaderAttributes: []
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["areScalarsMappedFromCells", "colorCoordinates", "colorMapColors", "colorTextureMap", "numberOfColorsInRange", "selectionWebGLIdsToVTKIds"]);
  macro.setGet(publicAPI, model, [
    "colorByArrayName",
    "arrayAccessMode",
    "colorMode",
    "fieldDataTupleId",
    "interpolateScalarsBeforeMapping",
    "lookupTable",
    "populateSelectionSettings",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "static",
    "useLookupTableScalarRange",
    "customShaderAttributes"
    // point data array names that will be transferred to the VBO
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkMapper(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend6, "vtkMapper");
var vtkMapper$1 = {
  newInstance: newInstance4,
  extend: extend6,
  ...staticOffsetAPI2,
  ...otherStaticMethods2,
  ...Constants2
};

export {
  vtkScalarsToColors,
  ScalarMode,
  Constants2 as Constants,
  vtkScalarsToColors$1,
  vtkAbstractMapper$1,
  vtkAbstractMapper3D$1,
  vtkStructuredData,
  vtkImageData$1,
  vtkLookupTable$1,
  Resolve,
  CATEGORIES,
  CoincidentTopologyHelper,
  PassTypes,
  Constants3 as Constants2,
  extend6 as extend,
  newInstance4 as newInstance,
  vtkMapper$1
};
//# sourceMappingURL=chunk-2MLCEZ25.js.map
