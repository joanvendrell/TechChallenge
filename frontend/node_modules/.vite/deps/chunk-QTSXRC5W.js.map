{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/Core/DataArray/Constants.js", "../../@kitware/vtk.js/Common/Core/DataArray.js", "../../@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js", "../../@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js", "../../@kitware/vtk.js/Common/DataModel/DataSetAttributes.js", "../../@kitware/vtk.js/Common/DataModel/DataSet/Constants.js", "../../@kitware/vtk.js/Common/DataModel/DataSet.js"],
  "sourcesContent": ["const DataTypeByteSize = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\nconst VtkDataTypes = {\n  VOID: '',\n  // not sure to know what that should be\n  CHAR: 'Int8Array',\n  SIGNED_CHAR: 'Int8Array',\n  UNSIGNED_CHAR: 'Uint8Array',\n  UNSIGNED_CHAR_CLAMPED: 'Uint8ClampedArray',\n  // should be used for VTK.js internal purpose only\n  SHORT: 'Int16Array',\n  UNSIGNED_SHORT: 'Uint16Array',\n  INT: 'Int32Array',\n  UNSIGNED_INT: 'Uint32Array',\n  FLOAT: 'Float32Array',\n  DOUBLE: 'Float64Array'\n};\nconst DefaultDataType = VtkDataTypes.FLOAT;\nvar Constants = {\n  DefaultDataType,\n  DataTypeByteSize,\n  VtkDataTypes\n};\n\nexport { DataTypeByteSize, DefaultDataType, VtkDataTypes, Constants as default };\n", "import Constants from './DataArray/Constants.js';\nimport { n as newInstance$1, a as newTypedArray, b as newTypedArrayFrom, o as obj, s as set, c as macro } from '../../macros2.js';\nimport { n as norm } from './Math/index.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  DefaultDataType\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst EPSILON = 1e-6;\n\n// Original source from https://www.npmjs.com/package/compute-range\n// Modified to accept type arrays\nfunction fastComputeRange(arr, offset, numberOfComponents) {\n  const len = arr.length;\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let x;\n  let i;\n\n  // find first non-NaN value\n  for (i = offset; i < len; i += numberOfComponents) {\n    if (!Number.isNaN(arr[i])) {\n      min = arr[i];\n      max = min;\n      break;\n    }\n  }\n  for (; i < len; i += numberOfComponents) {\n    x = arr[i];\n    if (x < min) {\n      min = x;\n    } else if (x > max) {\n      max = x;\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\n\n/**\n * @deprecated please use fastComputeRange instead\n */\nfunction createRangeHelper() {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let count = 0;\n  let sum = 0;\n  return {\n    add(value) {\n      if (min > value) {\n        min = value;\n      }\n      if (max < value) {\n        max = value;\n      }\n      count++;\n      sum += value;\n    },\n    get() {\n      return {\n        min,\n        max,\n        count,\n        sum,\n        mean: sum / count\n      };\n    },\n    getRange() {\n      return {\n        min,\n        max\n      };\n    }\n  };\n}\nfunction computeRange(values) {\n  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (component < 0 && numberOfComponents > 1) {\n    // Compute magnitude\n    const size = values.length;\n    const numberOfValues = size / numberOfComponents;\n    const data = new Float64Array(numberOfValues);\n    for (let i = 0, j = 0; i < numberOfValues; ++i) {\n      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {\n        data[i] += values[j] * values[j];\n      }\n      data[i] **= 0.5;\n    }\n    return fastComputeRange(data, 0, 1);\n  }\n  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);\n}\nfunction ensureRangeSize(rangeArray) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ranges = rangeArray || [];\n  // Pad ranges with null value to get the\n  while (ranges.length <= size) {\n    ranges.push(null);\n  }\n  return ranges;\n}\nfunction getDataType(typedArray) {\n  // Expects toString() to return \"[object ...Array]\"\n  return Object.prototype.toString.call(typedArray).slice(8, -1);\n}\nfunction getMaxNorm(normArray) {\n  const numComps = normArray.getNumberOfComponents();\n  let maxNorm = 0.0;\n  const tuple = new Array(numComps);\n  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {\n    normArray.getTuple(i, tuple);\n    const norm$1 = norm(tuple, numComps);\n    if (norm$1 > maxNorm) {\n      maxNorm = norm$1;\n    }\n  }\n  return maxNorm;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeRange,\n  createRangeHelper,\n  fastComputeRange,\n  getDataType,\n  getMaxNorm\n};\n\n// ----------------------------------------------------------------------------\n// vtkDataArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataArray');\n\n  /**\n   * Resize model.values and copy the old values to the new array.\n   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0\n   * @returns {Boolean} True if a resize occured, false otherwise\n   */\n  function resize(requestedNumTuples) {\n    if (requestedNumTuples < 0) {\n      return false;\n    }\n    const numComps = publicAPI.getNumberOfComponents();\n    const numAllocatedTuples = model.values.length / (numComps > 0 ? numComps : 1);\n    if (requestedNumTuples === numAllocatedTuples) {\n      return true;\n    }\n    if (requestedNumTuples > numAllocatedTuples) {\n      // Requested size is bigger than current size.  Allocate enough\n      // memory to fit the requested size and be more than double the\n      // currently allocated memory.\n      const oldValues = model.values;\n      model.values = newTypedArray(model.dataType, (requestedNumTuples + numAllocatedTuples) * numComps);\n      model.values.set(oldValues);\n      // The actual number of tuples is not increased, only memory is allocated.\n      return true;\n    }\n\n    // Requested size is smaller than currently allocated size\n    if (model.size > requestedNumTuples * numComps) {\n      model.size = requestedNumTuples * numComps;\n      publicAPI.dataChange();\n    }\n    return true;\n  }\n  publicAPI.dataChange = () => {\n    model.ranges = null;\n    publicAPI.modified();\n  };\n  publicAPI.allocate = extraNumTuples => {\n    resize(publicAPI.getNumberOfTuples() + extraNumTuples);\n  };\n  publicAPI.resize = requestedNumTuples => {\n    resize(requestedNumTuples);\n    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();\n    if (model.size !== newSize) {\n      model.size = newSize;\n      publicAPI.dataChange();\n      return true;\n    }\n    return false;\n  };\n\n  // Restore the array to initial state\n  publicAPI.initialize = () => {\n    publicAPI.resize(0);\n    return publicAPI;\n  };\n  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;\n\n  // Description:\n  // Return the data component at the location specified by tupleIdx and\n  // compIdx.\n  publicAPI.getComponent = function (tupleIdx) {\n    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return model.values[tupleIdx * model.numberOfComponents + compIdx];\n  };\n\n  // Description:\n  // Set the data component at the location specified by tupleIdx and compIdx\n  // to value.\n  // Note that i is less than NumberOfTuples and j is less than\n  //  NumberOfComponents. Make sure enough memory has been allocated\n  // (use SetNumberOfTuples() and SetNumberOfComponents()).\n  publicAPI.setComponent = (tupleIdx, compIdx, value) => {\n    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {\n      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;\n      publicAPI.dataChange();\n    }\n  };\n  publicAPI.getValue = valueIdx => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    return publicAPI.getComponent(idx, comp);\n  };\n  publicAPI.setValue = (valueIdx, value) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    publicAPI.setComponent(idx, comp, value);\n  };\n  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);\n  publicAPI.getRange = function () {\n    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    let rangeIdx = componentIndex;\n    if (rangeIdx < 0) {\n      // If scalar data, then store in slot 0 (same as componentIndex = 0).\n      // If vector data, then store in last slot.\n      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;\n    }\n    let range = null;\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    range = model.ranges[rangeIdx];\n    if (range) {\n      model.rangeTuple[0] = range.min;\n      model.rangeTuple[1] = range.max;\n      return model.rangeTuple;\n    }\n\n    // Need to compute ranges...\n    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);\n    model.ranges[rangeIdx] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setRange = (rangeValue, componentIndex) => {\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    const range = {\n      min: rangeValue.min,\n      max: rangeValue.max\n    };\n    model.ranges[componentIndex] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.getRanges = function () {\n    let computeRanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!computeRanges) {\n      return structuredClone(model.ranges);\n    }\n    /** @type {import('../../../interfaces').vtkRange[]} */\n    const ranges = [];\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      const [min, max] = publicAPI.getRange(i);\n      /** @type {import('../../../interfaces').vtkRange} */\n      const range = {\n        min,\n        max\n      };\n      ranges.push(range);\n    }\n    // where the number of components is greater than 1, the last element in\n    // the range array is the min,max magnitude of the entire dataset.\n    if (model.numberOfComponents > 1) {\n      const [min, max] = publicAPI.getRange(-1);\n      /** @type {import('../../../interfaces').vtkRange} */\n      const range = {\n        min,\n        max\n      };\n      ranges.push(range);\n    }\n    return ranges;\n  };\n  publicAPI.setTuple = (idx, tuple) => {\n    const offset = idx * model.numberOfComponents;\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      model.values[offset + i] = tuple[i];\n    }\n  };\n  publicAPI.setTuples = (idx, tuples) => {\n    let i = idx * model.numberOfComponents;\n    const last = Math.min(tuples.length, model.size - i);\n    for (let j = 0; j < last;) {\n      model.values[i++] = tuples[j++];\n    }\n  };\n  publicAPI.insertTuple = (idx, tuple) => {\n    if (model.size <= idx * model.numberOfComponents) {\n      model.size = (idx + 1) * model.numberOfComponents;\n      resize(idx + 1);\n    }\n    publicAPI.setTuple(idx, tuple);\n    return idx;\n  };\n  publicAPI.insertTuples = (idx, tuples) => {\n    const end = idx + tuples.length / model.numberOfComponents;\n    if (model.size < end * model.numberOfComponents) {\n      model.size = end * model.numberOfComponents;\n      resize(end);\n    }\n    publicAPI.setTuples(idx, tuples);\n    return end;\n  };\n  publicAPI.insertNextTuple = tuple => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuple(idx, tuple);\n  };\n  publicAPI.insertNextTuples = tuples => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuples(idx, tuples);\n  };\n  publicAPI.findTuple = function (tuple) {\n    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;\n    for (let i = 0; i < model.size; i += model.numberOfComponents) {\n      if (Math.abs(tuple[0] - model.values[i]) <= precision) {\n        let match = true;\n        for (let j = 1; j < model.numberOfComponents; ++j) {\n          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {\n            match = false;\n            break;\n          }\n        }\n        if (match) {\n          return i / model.numberOfComponents;\n        }\n      }\n    }\n    return -1;\n  };\n  publicAPI.getTuple = function (idx) {\n    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const numberOfComponents = model.numberOfComponents || 1;\n    const offset = idx * numberOfComponents;\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        tupleToFill[3] = model.values[offset + 3];\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        tupleToFill[2] = model.values[offset + 2];\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        tupleToFill[1] = model.values[offset + 1];\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        tupleToFill[0] = model.values[offset];\n        break;\n      default:\n        for (let i = numberOfComponents - 1; i >= 0; --i) {\n          tupleToFill[i] = model.values[offset + i];\n        }\n    }\n    return tupleToFill;\n  };\n  publicAPI.getTuples = (fromId, toId) => {\n    const from = (fromId ?? 0) * model.numberOfComponents;\n    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;\n    const arr = publicAPI.getData().subarray(from, to);\n    return arr.length > 0 ? arr : null;\n  };\n  publicAPI.getTupleLocation = function () {\n    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return idx * model.numberOfComponents;\n  };\n  publicAPI.getNumberOfComponents = () => model.numberOfComponents;\n  publicAPI.getNumberOfValues = () => model.size;\n  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;\n  publicAPI.getDataType = () => model.dataType;\n  /* eslint-disable no-use-before-define */\n  publicAPI.newClone = () => newInstance({\n    empty: true,\n    name: model.name,\n    dataType: model.dataType,\n    numberOfComponents: model.numberOfComponents\n  });\n  /* eslint-enable no-use-before-define */\n\n  publicAPI.getName = () => {\n    if (!model.name) {\n      publicAPI.modified();\n      model.name = `vtkDataArray${publicAPI.getMTime()}`;\n    }\n    return model.name;\n  };\n  publicAPI.setData = (typedArray, numberOfComponents) => {\n    model.values = typedArray;\n    model.size = typedArray.length;\n    model.dataType = getDataType(typedArray);\n    if (numberOfComponents) {\n      model.numberOfComponents = numberOfComponents;\n    }\n    if (model.size % model.numberOfComponents !== 0) {\n      model.numberOfComponents = 1;\n    }\n    publicAPI.dataChange();\n  };\n\n  // Override serialization support\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n    const jsonArchive = {\n      ...model,\n      vtkClass: publicAPI.getClassName()\n    };\n\n    // Convert typed array to regular array\n    jsonArchive.values = Array.from(jsonArchive.values);\n    delete jsonArchive.buffer;\n\n    // Clean any empty data\n    Object.keys(jsonArchive).forEach(keyName => {\n      if (!jsonArchive[keyName]) {\n        delete jsonArchive[keyName];\n      }\n    });\n\n    // Sort resulting object by key name\n    const sortedObj = {};\n    Object.keys(jsonArchive).sort().forEach(name => {\n      sortedObj[name] = jsonArchive[name];\n    });\n\n    // Remove mtime\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n    return sortedObj;\n  };\n\n  /**\n   * @param {import(\"./index\").vtkDataArray} other\n   */\n  publicAPI.deepCopy = other => {\n    // Retain current dataType and array reference before shallowCopy call.\n    const currentType = publicAPI.getDataType();\n    const currentArray = model.values;\n    publicAPI.shallowCopy(other);\n\n    // set the ranges\n    model.ranges = structuredClone(other.getRanges());\n\n    // Avoid array reallocation if size already sufficient\n    // and dataTypes match.\n    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {\n      currentArray.set(other.getData());\n      model.values = currentArray;\n      publicAPI.dataChange();\n    } else {\n      publicAPI.setData(other.getData().slice());\n    }\n  };\n  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {\n      vtkErrorMacro('numberOfComponents must match');\n    }\n    const tuple1 = source1.getTuple(source1Idx);\n    const tuple2 = source2.getTuple(source2Idx);\n    const out = [];\n    out.length = numberOfComponents;\n\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;\n        break;\n      default:\n        for (let i = 0; i < numberOfComponents; i++) {\n          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;\n        }\n    }\n    return publicAPI.insertTuple(idx, out);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n// size: The current size of the dataArray.\n// NOTE: The underlying typed array may be larger than 'size'.\nconst DEFAULT_VALUES = {\n  name: '',\n  numberOfComponents: 1,\n  dataType: DefaultDataType,\n  rangeTuple: [0, 0]\n  // size: undefined,\n  // values: null,\n  // ranges: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  if (Array.isArray(initialValues.values) && initialValues.dataType === undefined) {\n    console.warn('vtkDataArray.newInstance: no dataType provided, converting to Float32Array');\n  }\n  if (!model.empty && !model.values && !model.size) {\n    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');\n  }\n  if (!model.values) {\n    model.values = newTypedArray(model.dataType, model.size);\n  } else if (Array.isArray(model.values)) {\n    model.values = newTypedArrayFrom(model.dataType, model.values);\n  }\n  if (model.values) {\n    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.\n    model.size = model.size ?? model.values.length;\n    model.dataType = getDataType(model.values);\n  }\n\n  // Object methods\n  obj(publicAPI, model);\n  set(publicAPI, model, ['name', 'numberOfComponents']);\n  if (model.size % model.numberOfComponents !== 0) {\n    throw new RangeError('model.size is not a multiple of model.numberOfComponents');\n  }\n\n  // Object specific methods\n  vtkDataArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkDataArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkDataArray$1 as default, extend, newInstance };\n", "import vtk from '../../../vtk.js';\nimport { m as macro } from '../../../macros2.js';\nimport vtkDataArray from '../../Core/DataArray.js';\n\nconst {\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkFieldData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkFieldData(publicAPI, model) {\n  model.classHierarchy.push('vtkFieldData');\n  const superGetState = publicAPI.getState;\n\n  // Decode serialized data if any\n  if (model.arrays) {\n    model.arrays = model.arrays.map(item => ({\n      data: vtk(item.data)\n    }));\n  }\n  publicAPI.initialize = () => {\n    publicAPI.initializeFields();\n    publicAPI.copyAllOn();\n    publicAPI.clearFieldFlags();\n  };\n  publicAPI.initializeFields = () => {\n    model.arrays = [];\n    model.copyFieldFlags = {};\n    publicAPI.modified();\n  };\n  publicAPI.copyStructure = other => {\n    publicAPI.initializeFields();\n    model.copyFieldFlags = other.getCopyFieldFlags().map(x => x); // Deep-copy\n    model.arrays = other.getArrays().map(x => ({\n      data: x\n    })); // Deep-copy\n    // TODO: Copy array information objects (once we support information objects)\n  };\n\n  publicAPI.getNumberOfArrays = () => model.arrays.length;\n  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;\n  publicAPI.addArray = arr => {\n    const name = arr.getName();\n    const {\n      array,\n      index\n    } = publicAPI.getArrayWithIndex(name);\n    if (array != null) {\n      model.arrays[index] = {\n        data: arr\n      };\n      return index;\n    }\n    model.arrays = [].concat(model.arrays, {\n      data: arr\n    });\n    return model.arrays.length - 1;\n  };\n  publicAPI.removeAllArrays = () => {\n    model.arrays = [];\n  };\n  publicAPI.removeArray = arrayName => {\n    const index = model.arrays.findIndex(array => array.data.getName() === arrayName);\n    return publicAPI.removeArrayByIndex(index);\n  };\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {\n      model.arrays.splice(arrayIdx, 1);\n      // TBD modified() ?\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getArrays = () => model.arrays.map(entry => entry.data);\n  publicAPI.getArray = arraySpec => typeof arraySpec === 'number' ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);\n  publicAPI.getArrayByName = arrayName => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);\n  publicAPI.getArrayWithIndex = arrayName => {\n    const index = model.arrays.findIndex(array => array.data.getName() === arrayName);\n    return {\n      array: index !== -1 ? model.arrays[index].data : null,\n      index\n    };\n  };\n  publicAPI.getArrayByIndex = idx => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;\n  publicAPI.hasArray = arrayName => publicAPI.getArrayWithIndex(arrayName).index >= 0;\n  publicAPI.getArrayName = idx => {\n    const arr = model.arrays[idx];\n    return arr ? arr.data.getName() : '';\n  };\n  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;\n  publicAPI.getFlag = arrayName => model.copyFieldFlags[arrayName];\n  publicAPI.passData = function (other) {\n    let fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let toId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    other.getArrays().forEach(arr => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n        if (!destArr) {\n          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues();\n            const tId = toId > -1 ? toId : fromId;\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0\n            });\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {\n          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId;\n            destArr.insertTuple(tId, arr.getTuple(fromId));\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(0, arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in passData');\n        }\n      }\n    });\n  };\n  publicAPI.interpolateData = function (other) {\n    let fromId1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    let fromId2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    let toId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n    let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    other.getArrays().forEach(arr => {\n      const copyFlag = publicAPI.getFlag(arr.getName());\n      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {\n        let destArr = publicAPI.getArrayByName(arr.getName());\n        if (!destArr) {\n          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {\n            // TBD: should this be a deep or a shallow copy?\n            publicAPI.addArray(arr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(arr, attrType);\n            });\n          } else {\n            const ncomps = arr.getNumberOfComponents();\n            let newSize = arr.getNumberOfValues();\n            // TODO: Is this supposed to happen?\n            const tId = toId > -1 ? toId : fromId1;\n            if (newSize <= tId * ncomps) {\n              newSize = (tId + 1) * ncomps;\n            }\n            destArr = vtkDataArray.newInstance({\n              name: arr.getName(),\n              dataType: arr.getDataType(),\n              numberOfComponents: ncomps,\n              values: macro.newTypedArray(arr.getDataType(), newSize),\n              size: 0\n            });\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            publicAPI.addArray(destArr);\n            other.getAttributes(arr).forEach(attrType => {\n              publicAPI.setAttribute(destArr, attrType);\n            });\n          }\n        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {\n          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {\n            const tId = toId > -1 ? toId : fromId1;\n            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);\n            vtkWarningMacro('Unexpected case in interpolateData');\n          } else {\n            // if `fromId` is not provided, just copy all (or as much possible)\n            // from `arr` to `destArr`.\n            destArr.insertTuples(arr.getTuples());\n          }\n        } else {\n          vtkErrorMacro('Unhandled case in interpolateData');\n        }\n      }\n    });\n  };\n  publicAPI.copyFieldOn = arrayName => {\n    model.copyFieldFlags[arrayName] = true;\n  };\n  publicAPI.copyFieldOff = arrayName => {\n    model.copyFieldFlags[arrayName] = false;\n  };\n  publicAPI.copyAllOn = () => {\n    if (!model.doCopyAllOn || model.doCopyAllOff) {\n      model.doCopyAllOn = true;\n      model.doCopyAllOff = false;\n      publicAPI.modified();\n    }\n  };\n  publicAPI.copyAllOff = () => {\n    if (model.doCopyAllOn || !model.doCopyAllOff) {\n      model.doCopyAllOn = false;\n      model.doCopyAllOff = true;\n      publicAPI.modified();\n    }\n  };\n  publicAPI.clearFieldFlags = () => {\n    model.copyFieldFlags = {};\n  };\n  publicAPI.deepCopy = other => {\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.deepCopy(arr);\n      return {\n        data: arrNew\n      };\n    });\n  };\n  publicAPI.copyFlags = other => other.getCopyFieldFlags().map(x => x);\n  // TODO: publicAPI.squeeze = () => model.arrays.forEach(entry => entry.data.squeeze());\n  publicAPI.reset = () => model.arrays.forEach(entry => entry.data.reset());\n  // TODO: getActualMemorySize\n  publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime);\n  // TODO: publicAPI.getField = (ids, other) => { copy ids from other into this model's arrays }\n  // TODO: publicAPI.getArrayContainingComponent = (component) => ...\n  publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);\n  publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;\n  publicAPI.getState = () => {\n    const result = superGetState();\n    if (result) {\n      result.arrays = model.arrays.map(item => ({\n        data: item.data.getState()\n      }));\n    }\n    return result;\n  };\n}\nconst DEFAULT_VALUES = {\n  arrays: [],\n  copyFieldFlags: [],\n  // fields not to copy\n  doCopyAllOn: true,\n  doCopyAllOff: false\n};\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkFieldData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkFieldData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkFieldData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkFieldData$1 as default, extend, newInstance };\n", "const AttributeTypes = {\n  SCALARS: 0,\n  VECTORS: 1,\n  NORMALS: 2,\n  TCOORDS: 3,\n  TENSORS: 4,\n  GLOBALIDS: 5,\n  PEDIGREEIDS: 6,\n  EDGEFLAG: 7,\n  NUM_ATTRIBUTES: 8\n};\nconst AttributeLimitTypes = {\n  MAX: 0,\n  EXACT: 1,\n  NOLIMIT: 2\n};\nconst CellGhostTypes = {\n  DUPLICATECELL: 1,\n  // the cell is present on multiple processors\n  HIGHCONNECTIVITYCELL: 2,\n  // the cell has more neighbors than in a regular mesh\n  LOWCONNECTIVITYCELL: 4,\n  // the cell has less neighbors than in a regular mesh\n  REFINEDCELL: 8,\n  // other cells are present that refines it.\n  EXTERIORCELL: 16,\n  // the cell is on the exterior of the data set\n  HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst PointGhostTypes = {\n  DUPLICATEPOINT: 1,\n  // the cell is present on multiple processors\n  HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst AttributeCopyOperations = {\n  COPYTUPLE: 0,\n  INTERPOLATE: 1,\n  PASSDATA: 2,\n  ALLCOPY: 3 // all of the above\n};\n\nconst ghostArrayName = 'vtkGhostType';\nconst DesiredOutputPrecision = {\n  DEFAULT: 0,\n  // use the point type that does not truncate any data\n  SINGLE: 1,\n  // use Float32Array\n  DOUBLE: 2 // use Float64Array\n};\n\nvar Constants = {\n  AttributeCopyOperations,\n  AttributeLimitTypes,\n  AttributeTypes,\n  CellGhostTypes,\n  DesiredOutputPrecision,\n  PointGhostTypes,\n  ghostArrayName\n};\n\nexport { AttributeCopyOperations, AttributeLimitTypes, AttributeTypes, CellGhostTypes, DesiredOutputPrecision, PointGhostTypes, Constants as default, ghostArrayName };\n", "import { m as macro } from '../../macros2.js';\nimport vtkFieldData from './DataSetAttributes/FieldData.js';\nimport Constants from './DataSetAttributes/Constants.js';\nimport vtkDataArray from '../Core/DataArray.js';\n\nconst {\n  AttributeTypes,\n  AttributeCopyOperations\n} = Constants;\nconst {\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkDataSetAttributes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSetAttributes(publicAPI, model) {\n  const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n  function cleanAttributeType(attType) {\n    // Given an integer or string, convert the result to one of the\n    // strings in the \"attrTypes\" array above or null (if\n    // no match is found)\n    let cleanAttType = attrTypes.find(ee => AttributeTypes[ee.toUpperCase()] === attType || typeof attType !== 'number' && ee.toLowerCase() === attType.toLowerCase());\n    if (typeof cleanAttType === 'undefined') {\n      cleanAttType = null;\n    }\n    return cleanAttType;\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkDataSetAttributes');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.checkNumberOfComponents = x => true; // TODO\n\n  publicAPI.setAttribute = (arr, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arr && attType.toUpperCase() === 'PEDIGREEIDS' && !arr.isA('vtkDataArray')) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);\n      return -1;\n    }\n    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {\n      vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n      return -1;\n    }\n    if (arr) {\n      const currentAttribute = publicAPI.addArray(arr);\n      model[`active${attType}`] = currentAttribute;\n    } else {\n      model[`active${attType}`] = -1;\n    }\n    publicAPI.modified();\n    return model[`active${attType}`];\n  };\n  publicAPI.getAttributes = arr => attrTypes.filter(attrType => publicAPI[`get${attrType}`]() === arr);\n  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);\n  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {\n    const attType = cleanAttributeType(uncleanAttType);\n    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {\n      if (attType.toUpperCase() !== 'PEDIGREEIDS') {\n        const arr = publicAPI.getArrayByIndex(arrayIdx);\n        if (!arr.isA('vtkDataArray')) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);\n          return -1;\n        }\n        if (!publicAPI.checkNumberOfComponents(arr, attType)) {\n          vtkWarningMacro(`Cannot set attribute ${attType}. Incorrect number of components.`);\n          return -1;\n        }\n      }\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n      return arrayIdx;\n    }\n    if (arrayIdx === -1) {\n      model[`active${attType}`] = arrayIdx;\n      publicAPI.modified();\n    }\n    return -1;\n  };\n  publicAPI.getActiveAttribute = attType => {\n    // Given an integer enum value or a string (with random capitalization),\n    // find the matching string in attrTypes.\n    const cleanAttType = cleanAttributeType(attType);\n    return publicAPI[`get${cleanAttType}`]();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeAllArrays = () => {\n    attrTypes.forEach(attType => {\n      model[`active${attType}`] = -1;\n    });\n    superClass.removeAllArrays();\n  };\n\n  // Override to allow proper handling of active attributes\n  publicAPI.removeArrayByIndex = arrayIdx => {\n    if (arrayIdx !== -1) {\n      attrTypes.forEach(attType => {\n        if (arrayIdx === model[`active${attType}`]) {\n          model[`active${attType}`] = -1;\n        } else if (arrayIdx < model[`active${attType}`]) {\n          model[`active${attType}`] -= 1;\n        }\n      });\n    }\n    return superClass.removeArrayByIndex(arrayIdx);\n  };\n  attrTypes.forEach(value => {\n    const activeVal = `active${value}`;\n    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);\n    publicAPI[`set${value}`] = da => publicAPI.setAttribute(da, value);\n    publicAPI[`setActive${value}`] = arrayName => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);\n    publicAPI[`copy${value}Off`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = false;\n    };\n    publicAPI[`copy${value}On`] = () => {\n      const attType = value.toUpperCase();\n      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = true;\n    };\n  });\n  publicAPI.initializeAttributeCopyFlags = () => {\n    // Default to copying all attributes in every circumstance:\n    model.copyAttributeFlags = [];\n    Object.keys(AttributeCopyOperations).filter(op => op !== 'ALLCOPY').forEach(attCopyOp => {\n      model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] = Object.keys(AttributeTypes).filter(ty => ty !== 'NUM_ATTRIBUTES').reduce((a, b) => {\n        a[AttributeTypes[b]] = true;\n        return a;\n      }, []);\n    });\n    // Override some operations where we don't want to copy:\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][AttributeTypes.GLOBALIDS] = false;\n    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.PEDIGREEIDS] = false;\n  };\n  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);\n\n  // Process dataArrays if any\n  if (model.dataArrays && Object.keys(model.dataArrays).length) {\n    Object.keys(model.dataArrays).forEach(name => {\n      if (!model.dataArrays[name].ref && model.dataArrays[name].type === 'vtkDataArray') {\n        publicAPI.addArray(vtkDataArray.newInstance(model.dataArrays[name]));\n      }\n    });\n  }\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = (other, debug) => {\n    superShallowCopy(other, debug);\n    model.arrays = other.getArrays().map(arr => {\n      const arrNew = arr.newClone();\n      arrNew.shallowCopy(arr, debug);\n      return {\n        data: arrNew\n      };\n    });\n  };\n  publicAPI.initializeAttributeCopyFlags();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  activeScalars: -1,\n  activeVectors: -1,\n  activeTensors: -1,\n  activeNormals: -1,\n  activeTCoords: -1,\n  activeGlobalIds: -1,\n  activePedigreeIds: -1\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkFieldData.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['activeScalars', 'activeNormals', 'activeTCoords', 'activeVectors', 'activeTensors', 'activeGlobalIds', 'activePedigreeIds']);\n  if (!model.arrays) {\n    model.arrays = {};\n  }\n\n  // Object specific methods\n  vtkDataSetAttributes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkDataSetAttributes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataSetAttributes$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkDataSetAttributes$1 as default, extend, newInstance };\n", "// Specify how data arrays can be used by data objects\nconst FieldDataTypes = {\n  UNIFORM: 0,\n  // data that does not vary over points/cells/etc.\n  DATA_OBJECT_FIELD: 0,\n  // to match VTK\n\n  COORDINATE: 1,\n  // data that specifies the location of each point\n  POINT_DATA: 1,\n  // to match VTK\n\n  POINT: 2,\n  // data defined at each point, but that does not specify the point location\n  POINT_FIELD_DATA: 2,\n  // to match VTK\n\n  CELL: 3,\n  // data defined at each cell, but that does not specify the cell\n  CELL_FIELD_DATA: 3,\n  // to match VTK\n\n  VERTEX: 4,\n  // data defined at each graph vertex, but that does not specify the graph vertex\n  VERTEX_FIELD_DATA: 4,\n  // to match VTK\n\n  EDGE: 5,\n  // data defined at each graph edge, but that does not specify the graph edge\n  EDGE_FIELD_DATA: 5,\n  // to match VTK\n\n  ROW: 6,\n  // data specifying a table row\n  ROW_DATA: 6 // to match VTK\n};\n\nconst FieldAssociations = {\n  FIELD_ASSOCIATION_POINTS: 0,\n  FIELD_ASSOCIATION_CELLS: 1,\n  FIELD_ASSOCIATION_NONE: 2,\n  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,\n  FIELD_ASSOCIATION_VERTICES: 4,\n  FIELD_ASSOCIATION_EDGES: 5,\n  FIELD_ASSOCIATION_ROWS: 6,\n  NUMBER_OF_ASSOCIATIONS: 7\n};\nvar Constants = {\n  FieldDataTypes,\n  FieldAssociations\n};\n\nexport { FieldAssociations, FieldDataTypes, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtk from '../../vtk.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSetAttributes from './DataSetAttributes.js';\nimport { b as vtkMath } from '../Core/Math/index.js';\nimport Constants from './DataSet/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nconst DATASET_FIELDS = ['pointData', 'cellData', 'fieldData'];\n\n// ----------------------------------------------------------------------------\n// vtkDataSet methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataSet(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataSet');\n\n  // Add dataset attributes\n  DATASET_FIELDS.forEach(fieldName => {\n    if (!model[fieldName]) {\n      model[fieldName] = vtkDataSetAttributes.newInstance();\n    } else {\n      model[fieldName] = vtk(model[fieldName]);\n    }\n  });\n\n  //------------------------------------------------------------------------------\n  // Compute the data bounding box from data points.\n  publicAPI.computeBounds = () => {\n    if (model.modifiedTime && model.computeTime && model.modifiedTime > model.computeTime || !model.computeTime) {\n      const points = publicAPI.getPoints();\n      if (points?.getNumberOfPoints()) {\n        // Compute bounds from points\n        vtkBoundingBox.setBounds(model.bounds, points.getBoundsByReference());\n      } else {\n        model.bounds = vtkMath.createUninitializedBounds();\n      }\n      // Update computeTime\n      model.computeTime = macro.getCurrentGlobalMTime();\n    }\n  };\n\n  /**\n   * Returns the squared length of the diagonal of the bounding box\n   */\n  publicAPI.getLength2 = () => {\n    const bounds = publicAPI.getBoundsByReference();\n    if (!bounds || bounds.length !== 6) return 0;\n    return vtkBoundingBox.getDiagonalLength2(bounds);\n  };\n\n  /**\n   * Returns the length of the diagonal of the bounding box\n   */\n  publicAPI.getLength = () => Math.sqrt(publicAPI.getLength2());\n\n  /**\n   * Returns the center of the bounding box as [x, y, z]\n   */\n  publicAPI.getCenter = () => {\n    const bounds = publicAPI.getBoundsByReference();\n    if (!bounds || bounds.length !== 6) return [0, 0, 0];\n    return vtkBoundingBox.getCenter(bounds);\n  };\n\n  /**\n   * Get the bounding box of a cell with the given cellId\n   * @param {Number} cellId - The id of the cell\n   * @returns {Number[]} - The bounds as [xmin, xmax, ymin, ymax, zmin, zmax]\n   */\n  publicAPI.getCellBounds = cellId => {\n    const cell = publicAPI.getCell(cellId);\n    if (cell) {\n      return cell.getBounds();\n    }\n    return vtkMath.createUninitializedBounds();\n  };\n  publicAPI.getBounds = macro.chain(() => publicAPI.computeBounds, publicAPI.getBounds);\n  publicAPI.getBoundsByReference = macro.chain(() => publicAPI.computeBounds, publicAPI.getBoundsByReference);\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    DATASET_FIELDS.forEach(fieldName => {\n      model[fieldName] = vtkDataSetAttributes.newInstance();\n      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));\n    });\n  };\n  const superGetMTime = publicAPI.getMTime;\n  publicAPI.getMTime = () => DATASET_FIELDS.reduce((mTime, fieldName) => Math.max(mTime, model[fieldName]?.getMTime() ?? mTime), superGetMTime());\n  publicAPI.initialize = () => {\n    DATASET_FIELDS.forEach(fieldName => model[fieldName]?.initialize());\n    return publicAPI;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // pointData: null,\n  // cellData: null,\n  // fieldData: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, DATASET_FIELDS);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n  // Object specific methods\n  vtkDataSet(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkDataSet');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataSet$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkDataSet$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["DefaultDataType", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "Constants", "AttributeTypes", "AttributeCopyOperations", "Constants", "vtkWarningMacro", "DEFAULT_VALUES", "extend", "newInstance", "Constants", "DEFAULT_VALUES", "extend", "newInstance", "Constants"]
}
