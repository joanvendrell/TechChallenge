import {
  vtkActor,
  vtkActor2D,
  vtkCamera,
  vtkCubeAxesActor$1,
  vtkOpenGLPolyDataMapper$1,
  vtkPixelSpaceCallbackMapper,
  vtkPolyDataFS,
  vtkPolyDataMapper2D,
  vtkPolyDataVS,
  vtkProperty2D$1,
  vtkRenderer,
  vtkReplacementShaderMapper,
  vtkSkybox,
  vtkWebGPUCellArrayMapper$1,
  vtkWebGPUPolyDataMapper$1
} from "./chunk-X35NBDZJ.js";
import {
  vtkScalarBarActor$1
} from "./chunk-GVGJFJN3.js";
import {
  Base64,
  BinaryHelper,
  DataAccessHelper,
  Endian,
  decompressSync,
  fromArrayBuffer,
  registerType,
  require_xmlbuilder2_min,
  strFromU8,
  strToU8,
  unzipSync,
  vtkStringArray$1,
  vtkXMLPolyDataReader$1,
  vtkXMLReader$1,
  zipSync,
  zlibSync
} from "./chunk-WMW7HCMN.js";
import {
  BlendMode,
  Constants as Constants2,
  Device,
  GET_UNDERLYING_CONTEXT,
  Input,
  MouseButton,
  States,
  vtkCamera$1,
  vtkForwardPass$1,
  vtkGenericRenderWindow$1,
  vtkHardwareSelector,
  vtkHardwareSelector$1,
  vtkInteractorObserver$1,
  vtkInteractorStyle$1,
  vtkInteractorStyleConstants,
  vtkInteractorStyleTrackballCamera$1,
  vtkLight$1,
  vtkOpenGLFramebuffer,
  vtkRenderPass$1,
  vtkRenderWindow,
  vtkRenderWindow$1,
  vtkRenderWindow2,
  vtkRenderWindowInteractor$1,
  vtkRenderWindowViewNode$1,
  vtkRenderer$1,
  vtkSelectionNode$1,
  vtkShaderCache$1,
  vtkTextureUnitManager,
  vtkURLExtract,
  vtkViewport$1
} from "./chunk-4PMBHKM2.js";
import {
  Filter,
  HalfFloat,
  ObjectType,
  Wrap,
  computeCoordShiftAndScale,
  computeInverseShiftAndScaleMatrix,
  primTypes,
  registerOverride,
  registerOverride2,
  vtkBufferObject,
  vtkCellArrayBufferObject,
  vtkHelper,
  vtkOpenGLTexture$1,
  vtkShader$1,
  vtkShaderProgram$1,
  vtkVertexArrayObject,
  vtkViewNode$1,
  vtkViewNodeFactory,
  vtkViewNodeFactory$1,
  vtkWebGPUBufferManager$1,
  vtkWebGPUFullScreenQuad$1,
  vtkWebGPUSampler$1,
  vtkWebGPUShaderCache$1,
  vtkWebGPUStorageBuffer$1,
  vtkWebGPUUniformBuffer$1
} from "./chunk-IC7NYLFI.js";
import {
  vtkTexture$1
} from "./chunk-ZYJT6S5S.js";
import {
  CATEGORIES,
  CoincidentTopologyHelper,
  Constants,
  Resolve,
  ScalarMode,
  vtkAbstractMapper$1,
  vtkAbstractMapper3D$1,
  vtkImageData$1,
  vtkLookupTable$1,
  vtkMapper$1,
  vtkScalarsToColors,
  vtkScalarsToColors$1,
  vtkStructuredData
} from "./chunk-2MLCEZ25.js";
import {
  PropertyConst,
  Representation,
  vtkActor$1,
  vtkProp$1,
  vtkProp3D$1,
  vtkProperty$1
} from "./chunk-KHTNCV3C.js";
import {
  CellType,
  POLYDATA_FIELDS,
  PolygonWithPointIntersectionState,
  vtkCell$1,
  vtkCellArray$1,
  vtkCellTypes$1,
  vtkLine$1,
  vtkPointSet$1,
  vtkPoints$1,
  vtkPolyData$1,
  vtkPolyLine$1,
  vtkPolygon$1,
  vtkQuad$1,
  vtkTriangle$1,
  vtkTriangleStrip$1
} from "./chunk-3WRJRU3H.js";
import {
  AttributeTypes,
  DataTypeByteSize,
  DesiredOutputPrecision,
  FieldAssociations,
  FieldDataTypes,
  VtkDataTypes,
  vtkDataArray$1,
  vtkDataSet$1,
  vtkDataSetAttributes$1
} from "./chunk-QTSXRC5W.js";
import {
  EPSILON,
  IDENTITY,
  STATIC,
  TYPED_ARRAYS,
  add,
  algo,
  angleBetweenVectors,
  areEquals,
  areMatricesEqual,
  arrayRange,
  capitalize,
  chain,
  clampValue,
  common_exports,
  createUninitializedBounds,
  cross,
  degreesFromRadians,
  determinant3x3,
  distance2BetweenPoints,
  dot,
  event,
  floatRGB2HexCode,
  floor,
  get,
  getMajorAxisIndex,
  getSparseOrthogonalMatrix,
  hsv2rgb,
  isInf,
  isNan,
  jacobi,
  jacobiN,
  lab2rgb,
  macro,
  macro$1,
  mat3_exports,
  mat4_exports,
  moveToProtected,
  multiply3x3_vect3,
  multiplyAccumulate,
  multiplyScalar,
  newInstance,
  newTypedArray,
  newTypedArrayFrom,
  norm,
  normalize,
  obj,
  perpendiculars,
  proxy,
  proxyPropertyMapping,
  quat_exports,
  radiansFromDegrees,
  random,
  require_fast_deep_equal,
  rgb2hsv,
  rgb2lab,
  round,
  rowsToMat3,
  setGet,
  setGetArray,
  signedAngleBetweenVectors,
  subtract,
  traverseInstanceTree,
  vec3_exports,
  vec4_exports,
  vtk,
  vtkBoundingBox,
  vtkErrorMacro,
  vtkImplicitFunction$1,
  vtkMath,
  vtkMath$1,
  vtkPlane$1,
  vtkWarningMacro
} from "./chunk-UJ7GCCMN.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/webworker-promise/src/tiny-emitter.js
var require_tiny_emitter = __commonJS({
  "node_modules/webworker-promise/src/tiny-emitter.js"(exports, module) {
    var TinyEmitter = class {
      constructor() {
        Object.defineProperty(this, "__listeners", {
          value: {},
          enumerable: false,
          writable: false
        });
      }
      emit(eventName, ...args) {
        if (!this.__listeners[eventName])
          return this;
        for (const handler of this.__listeners[eventName]) {
          handler(...args);
        }
        return this;
      }
      once(eventName, handler) {
        const once = (...args) => {
          this.off(eventName, once);
          handler(...args);
        };
        return this.on(eventName, once);
      }
      on(eventName, handler) {
        if (!this.__listeners[eventName])
          this.__listeners[eventName] = [];
        this.__listeners[eventName].push(handler);
        return this;
      }
      off(eventName, handler) {
        if (handler)
          this.__listeners[eventName] = this.__listeners[eventName].filter((h) => h !== handler);
        else
          this.__listeners[eventName] = [];
        return this;
      }
    };
    module.exports = TinyEmitter;
  }
});

// node_modules/webworker-promise/src/index.js
var require_src = __commonJS({
  "node_modules/webworker-promise/src/index.js"(exports, module) {
    var TinyEmitter = require_tiny_emitter();
    var MESSAGE_RESULT = 0;
    var MESSAGE_EVENT = 1;
    var RESULT_SUCCESS = 1;
    var Worker2 = class extends TinyEmitter {
      /**
       *
       * @param worker {Worker}
       */
      constructor(worker) {
        super();
        this._messageId = 1;
        this._messages = /* @__PURE__ */ new Map();
        this._worker = worker;
        this._worker.onmessage = this._onMessage.bind(this);
        this._id = Math.ceil(Math.random() * 1e7);
      }
      terminate() {
        this._worker.terminate();
      }
      /**
       * return true if there is no unresolved jobs
       * @returns {boolean}
       */
      isFree() {
        return this._messages.size === 0;
      }
      jobsLength() {
        return this._messages.size;
      }
      /**
       * @param operationName string
       * @param data any
       * @param transferable array
       * @param onEvent function
       * @returns {Promise}
       */
      exec(operationName, data2 = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data2, operationName], transferable || []);
        });
      }
      /**
       *
       * @param data any
       * @param transferable array
       * @param onEvent function
       * @returns {Promise}
       */
      postMessage(data2 = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data2], transferable || []);
        });
      }
      emit(eventName, ...args) {
        this._worker.postMessage({ eventName, args });
      }
      _onMessage(e2) {
        if (!Array.isArray(e2.data) && e2.data.eventName) {
          return super.emit(e2.data.eventName, ...e2.data.args);
        }
        const [type, ...args] = e2.data;
        if (type === MESSAGE_EVENT)
          this._onEvent(...args);
        else if (type === MESSAGE_RESULT)
          this._onResult(...args);
        else
          throw new Error(`Wrong message type '${type}'`);
      }
      _onResult(messageId, success, payload) {
        const [res, rej] = this._messages.get(messageId);
        this._messages.delete(messageId);
        return success === RESULT_SUCCESS ? res(payload) : rej(payload);
      }
      _onEvent(messageId, eventName, data2) {
        const [, , onEvent] = this._messages.get(messageId);
        if (onEvent) {
          onEvent(eventName, data2);
        }
      }
    };
    module.exports = Worker2;
  }
});

// node_modules/@kitware/vtk.js/Common/Core/ImageHelper.js
function canvasToImageData(canvas) {
  let boundingBox = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0];
  const [top, left, width2, height2] = boundingBox;
  const ctxt = canvas.getContext("2d");
  const idata = ctxt.getImageData(top, left, width2 || canvas.width, height2 || canvas.height);
  const imageData = vtkImageData$1.newInstance({
    type: "vtkImageData"
  });
  imageData.setOrigin(0, 0, 0);
  imageData.setSpacing(1, 1, 1);
  imageData.setExtent(0, (width2 || canvas.width) - 1, 0, (height2 || canvas.height) - 1, 0, 0);
  const scalars = vtkDataArray$1.newInstance({
    numberOfComponents: 4,
    values: new Uint8Array(idata.data.buffer)
  });
  scalars.setName("scalars");
  imageData.getPointData().setScalars(scalars);
  return imageData;
}
function imageToImageData(image) {
  let transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    flipX: false,
    flipY: false,
    rotate: 0
  };
  const canvas = document.createElement("canvas");
  canvas.width = image.width;
  canvas.height = image.height;
  const ctx = canvas.getContext("2d");
  const {
    flipX,
    flipY,
    rotate
  } = transform;
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
  ctx.rotate(rotate * Math.PI / 180);
  ctx.drawImage(image, -image.width / 2, -image.height / 2);
  return canvasToImageData(canvas);
}
var ImageHelper = {
  canvasToImageData,
  imageToImageData
};

// node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var NoOp = (v) => v;
var EPSILON2 = 1e-6;
var Transform = class {
  constructor() {
    let useDegree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.matrix = mat4_exports.identity(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? common_exports.toRadian : NoOp;
  }
  rotateFromDirections(originDirection, targetDirection) {
    const src = new Float64Array(3);
    const dst = new Float64Array(3);
    const transf = new Float64Array(16);
    vec3_exports.set(src, originDirection[0], originDirection[1], originDirection[2]);
    vec3_exports.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
    vec3_exports.normalize(src, src);
    vec3_exports.normalize(dst, dst);
    const cosAlpha = vec3_exports.dot(src, dst);
    if (cosAlpha >= 1) {
      return this;
    }
    vec3_exports.cross(this.tmp, src, dst);
    if (vec3_exports.length(this.tmp) < EPSILON2) {
      vec3_exports.cross(this.tmp, [1, 0, 0], originDirection);
      if (vec3_exports.length(this.tmp) < EPSILON2) {
        vec3_exports.cross(this.tmp, [0, 1, 0], originDirection);
      }
    }
    mat4_exports.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
    mat4_exports.multiply(this.matrix, this.matrix, transf);
    return this;
  }
  rotate(angle, axis) {
    vec3_exports.set(this.tmp, ...axis);
    vec3_exports.normalize(this.tmp, this.tmp);
    mat4_exports.rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
    return this;
  }
  rotateX(angle) {
    mat4_exports.rotateX(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  rotateY(angle) {
    mat4_exports.rotateY(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  rotateZ(angle) {
    mat4_exports.rotateZ(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  translate(x, y, z) {
    vec3_exports.set(this.tmp, x, y, z);
    mat4_exports.translate(this.matrix, this.matrix, this.tmp);
    return this;
  }
  scale(sx, sy, sz) {
    vec3_exports.set(this.tmp, sx, sy, sz);
    mat4_exports.scale(this.matrix, this.matrix, this.tmp);
    return this;
  }
  multiply(mat4x4) {
    mat4_exports.multiply(this.matrix, this.matrix, mat4x4);
    return this;
  }
  multiply3x3(mat3x3) {
    mat4_exports.multiply(this.matrix, this.matrix, [mat3x3[0], mat3x3[1], mat3x3[2], 0, mat3x3[3], mat3x3[4], mat3x3[5], 0, mat3x3[6], mat3x3[7], mat3x3[8], 0, 0, 0, 0, 1]);
    return this;
  }
  invert() {
    mat4_exports.invert(this.matrix, this.matrix);
    return this;
  }
  identity() {
    mat4_exports.identity(this.matrix);
    return this;
  }
  //-----------
  apply(typedArray) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let nbIterations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    if (areMatricesEqual(IDENTITY, this.matrix)) {
      return this;
    }
    const size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
    for (let i = offset; i < size; i += 3) {
      vec3_exports.set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
      vec3_exports.transformMat4(this.tmp, this.tmp, this.matrix);
      typedArray[i] = this.tmp[0];
      typedArray[i + 1] = this.tmp[1];
      typedArray[i + 2] = this.tmp[2];
    }
    return this;
  }
  getMatrix() {
    return this.matrix;
  }
  setMatrix(mat4x4) {
    if (!!mat4x4 && mat4x4.length === 16) {
      mat4_exports.copy(this.matrix, mat4x4);
    }
    return this;
  }
};
function buildFromDegree() {
  return new Transform(true);
}
function buildFromRadian() {
  return new Transform(false);
}
var vtkMatrixBuilder = {
  buildFromDegree,
  buildFromRadian
};

// node_modules/@kitware/vtk.js/Common/Core/ProgressHandler.js
function vtkProgressHandler(publicAPI, model) {
  model.classHierarchy.push("vtkProgressHandler");
  publicAPI.startWork = () => {
    model.workCount += 1;
    if (model.workCount === 1) {
      publicAPI.invokeChange(true);
    }
  };
  publicAPI.stopWork = () => {
    model.workCount -= 1;
    if (model.workCount === 0) {
      publicAPI.invokeChange(false);
    }
  };
  publicAPI.isWorking = () => !!model.workCount;
  publicAPI.wrapPromise = (promise) => {
    publicAPI.startWork();
    return new Promise((resolve, reject) => {
      promise.then(function() {
        publicAPI.stopWork();
        resolve(...arguments);
      }, (rejectError) => {
        publicAPI.stopWork();
        reject(rejectError);
      });
    });
  };
  publicAPI.wrapPromiseFunction = (fn) => function() {
    return publicAPI.wrapPromise(fn(...arguments));
  };
}
var DEFAULT_VALUES = {
  workCount: 0
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "change");
  macro.get(publicAPI, model, ["workCount"]);
  vtkProgressHandler(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkProgressHandler");
var vtkProgressHandler$1 = {
  newInstance: newInstance2,
  extend
};

// node_modules/@kitware/vtk.js/Common/Core/VariantArray.js
function vtkVariantArray(publicAPI, model) {
  model.classHierarchy.push("vtkVariantArray");
  publicAPI.getComponent = function(tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.modified();
    }
  };
  publicAPI.getData = () => model.values;
  publicAPI.getTuple = function(idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    if (tupleToFill.length) {
      tupleToFill.length = numberOfComponents;
    }
    const offset = idx * numberOfComponents;
    for (let i = 0; i < numberOfComponents; i++) {
      tupleToFill[i] = model.values[offset + i];
    }
    return tupleToFill;
  };
  publicAPI.getTupleLocation = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.values.length;
  publicAPI.getNumberOfTuples = () => model.values.length / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  publicAPI.newClone = () => newInstance3({
    name: model.name,
    numberOfComponents: model.numberOfComponents
  });
  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.modified();
      model.name = `vtkVariantArray${publicAPI.getMTime()}`;
    }
    return model.name;
  };
  publicAPI.setData = (array, numberOfComponents) => {
    model.values = array;
    model.size = array.length;
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.modified();
  };
}
var DEFAULT_VALUES2 = {
  name: "",
  numberOfComponents: 1,
  size: 0,
  // values: null,
  dataType: "JSON"
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError("Cannot create vtkVariantArray object without: size > 0, values");
  }
  if (!model.values) {
    model.values = [];
  } else if (Array.isArray(model.values)) {
    model.values = [...model.values];
  }
  if (model.values) {
    model.size = model.values.length;
  }
  macro.obj(publicAPI, model);
  macro.set(publicAPI, model, ["name"]);
  vtkVariantArray(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkVariantArray");
var vtkVariantArray$1 = {
  newInstance: newInstance3,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Common/Core.js
var Core = {
  vtkBase64: Base64,
  vtkCellArray: vtkCellArray$1,
  vtkDataArray: vtkDataArray$1,
  vtkEndian: Endian,
  vtkHalfFloat: HalfFloat,
  vtkImageHelper: ImageHelper,
  vtkLookupTable: vtkLookupTable$1,
  vtkMath: vtkMath$1,
  vtkMatrixBuilder,
  vtkPoints: vtkPoints$1,
  vtkProgressHandler: vtkProgressHandler$1,
  vtkScalarsToColors: vtkScalarsToColors$1,
  vtkStringArray: vtkStringArray$1,
  vtkURLExtract,
  vtkVariantArray: vtkVariantArray$1
};

// node_modules/@kitware/vtk.js/Common/DataModel/Box.js
function intersectWithLine(bounds2, p1, p2) {
  let plane1 = -1;
  let plane2 = -1;
  let t1 = 0;
  let t2 = 1;
  for (let j = 0; j < 3; j++) {
    for (let k = 0; k < 2; k++) {
      const i = 2 * j + k;
      const d1 = (bounds2[i] - p1[j]) * (1 - 2 * k);
      const d2 = (bounds2[i] - p2[j]) * (1 - 2 * k);
      if (d1 > 0 && d2 > 0) {
        return;
      }
      if (d1 > 0 || d2 > 0) {
        let t = 0;
        if (d1 !== 0) {
          t = d1 / (d1 - d2);
        }
        if (d1 > 0) {
          if (t >= t1) {
            t1 = t;
            plane1 = i;
          }
        } else if (t <= t2) {
          t2 = t;
          plane2 = i;
        }
        if (t1 > t2) {
          if (plane1 < 0 || plane2 < 0) {
            return;
          }
        }
      }
    }
  }
  function getValues(plane, t) {
    const x = [0, 0, 0];
    for (let count = 0; count < 2; count++) {
      for (let i = 0; i < 3; i++) {
        if (plane === 2 * i || plane === 2 * i + 1) {
          x[i] = bounds2[plane];
        } else {
          x[i] = p1[i] * (1 - t) + p2[i] * t;
          if (x[i] < bounds2[2 * i]) {
            x[i] = bounds2[2 * i];
          }
          if (x[i] > bounds2[2 * i + 1]) {
            x[i] = bounds2[2 * i + 1];
          }
        }
      }
    }
    return x;
  }
  const x1 = getValues(plane1, t1);
  const x2 = getValues(plane2, t2);
  const outObject = {
    t1,
    t2,
    x1,
    x2
  };
  return outObject;
}
var STATIC2 = {};
function vtkBox(publicAPI, model) {
  model.classHierarchy.push("vtkBox");
  publicAPI.setBounds = function() {
    let boundsArray = [];
    for (var _len = arguments.length, bounds2 = new Array(_len), _key = 0; _key < _len; _key++) {
      bounds2[_key] = arguments[_key];
    }
    if (Array.isArray(bounds2[0])) {
      boundsArray = bounds2[0];
    } else {
      for (let i = 0; i < bounds2.length; i++) {
        boundsArray.push(bounds2[i]);
      }
    }
    if (boundsArray.length !== 6) {
      console.log("vtkBox.setBounds", boundsArray, bounds2);
      return;
    }
    vtkBoundingBox.setBounds(model.bbox, boundsArray);
  };
  publicAPI.getBounds = () => model.bbox;
  publicAPI.evaluateFunction = (x, y, z) => {
    const point = Array.isArray(x) ? x : [x, y, z];
    let diff;
    let dist;
    let t;
    let minDistance = -Number.MAX_VALUE;
    let distance = 0;
    const minPoint = vtkBoundingBox.getMinPoint(model.bbox);
    const maxPoint = vtkBoundingBox.getMaxPoint(model.bbox);
    let inside = 1;
    for (let i = 0; i < 3; i++) {
      diff = vtkBoundingBox.getLength(model.bbox, i);
      if (diff !== 0) {
        t = (point[i] - minPoint[i]) / diff;
        if (t < 0) {
          inside = 0;
          dist = minPoint[i] - point[i];
        } else if (t > 1) {
          inside = 0;
          dist = point[i] - maxPoint[i];
        } else {
          if (t <= 0.5) {
            dist = minPoint[i] - point[i];
          } else {
            dist = point[i] - maxPoint[i];
          }
          if (dist > minDistance) {
            minDistance = dist;
          }
        }
      } else {
        dist = Math.abs(point[i] - minPoint[i]);
        if (dist > 0) {
          inside = 0;
        }
      }
      if (dist > 0) {
        distance += dist * dist;
      }
    }
    distance = Math.sqrt(distance);
    if (inside) {
      return minDistance;
    }
    return distance;
  };
  publicAPI.addBounds = function() {
    let boundsArray = [];
    if (Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      boundsArray = arguments.length <= 0 ? void 0 : arguments[0];
    } else {
      for (let i = 0; i < arguments.length; i++) {
        boundsArray.push(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
      }
    }
    if (boundsArray.length !== 6) {
      return;
    }
    vtkBoundingBox.addBounds(model.bbox, ...boundsArray);
    publicAPI.modified();
  };
  publicAPI.addBox = (other) => publicAPI.addBounds(other.getBounds());
  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(model.bbox, p1, p2);
}
var DEFAULT_VALUES3 = {
  bbox: [...vtkBoundingBox.INIT_BOUNDS]
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  vtkBox(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkBox");
var vtkBox$1 = {
  newInstance: newInstance4,
  extend: extend3,
  intersectWithLine,
  ...STATIC2
};

// node_modules/@kitware/vtk.js/Common/DataModel/Cone.js
function vtkCone(publicAPI, model) {
  model.classHierarchy.push("vtkCone");
  publicAPI.evaluateFunction = (x) => {
    const tanTheta = Math.tan(radiansFromDegrees(model.angle));
    const retVal = x[1] * x[1] + x[2] * x[2] - x[0] * x[0] * tanTheta * tanTheta;
    return retVal;
  };
  publicAPI.evaluateGradient = (x) => {
    const tanTheta = Math.tan(radiansFromDegrees(model.angle));
    const retVal = [-2 * x[0] * tanTheta * tanTheta, 2 * x[1], 2 * x[2]];
    return retVal;
  };
}
var DEFAULT_VALUES4 = {
  angle: 15
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["angle"]);
  vtkCone(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend4, "vtkCone");
var vtkCone$1 = {
  newInstance: newInstance5,
  extend: extend4
};

// node_modules/@kitware/vtk.js/Common/DataModel/Cylinder.js
function evaluate(radius, center, axis, x) {
  const x2C = new Float32Array(3);
  x2C[0] = x[0] - center[0];
  x2C[1] = x[1] - center[1];
  x2C[2] = x[2] - center[2];
  const proj = dot(axis, x2C);
  const retVal = dot(x2C, x2C) - proj * proj - radius * radius;
  return retVal;
}
var STATIC3 = {
  evaluate
};
function vtkCylinder(publicAPI, model) {
  model.classHierarchy.push("vtkCylinder");
  publicAPI.evaluateFunction = (xyz) => {
    const x2C = [xyz[0] - model.center[0], xyz[1] - model.center[1], xyz[2] - model.center[2]];
    const proj = dot(model.axis, x2C);
    const retVal = dot(x2C, x2C) - proj * proj - model.radius * model.radius;
    return retVal;
  };
  publicAPI.evaluateGradient = (xyz) => {
    const t = model.axis[0] * (xyz[0] - model.center[0]) + model.axis[1] * (xyz[1] - model.center[1]) + model.axis[2] * (xyz[2] - model.center[2]);
    const cp = [model.center[0] + t * model.axis[0], model.center[1] + t * model.axis[1], model.center[2] + t * model.axis[2]];
    const retVal = [2 * (xyz[0] - cp[0]), 2 * (xyz[1] - cp[1]), 2 * (xyz[2] - cp[2])];
    return retVal;
  };
}
var DEFAULT_VALUES5 = {
  radius: 0.5,
  center: [0, 0, 0],
  axis: [0, 1, 0]
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["radius"]);
  macro.setGetArray(publicAPI, model, ["center", "axis"], 3);
  vtkCylinder(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend5, "vtkCylinder");
var vtkCylinder$1 = {
  newInstance: newInstance6,
  extend: extend5,
  ...STATIC3
};

// node_modules/@kitware/vtk.js/Common/DataModel/ITKHelper.js
var {
  vtkErrorMacro: vtkErrorMacro2
} = macro;
var ITKJSPixelTypes = {
  Unknown: 0,
  Scalar: 1,
  RGB: 2,
  RGBA: 3,
  Offset: 4,
  Vector: 5,
  Point: 6,
  CovariantVector: 7,
  SymmetricSecondRankTensor: 8,
  DiffusionTensor3D: 9,
  Complex: 10,
  FixedArray: 11,
  Array: 12,
  Matrix: 13,
  VariableLengthVector: 14,
  VariableSizeMatrix: 15
};
var ITKWASMPixelTypes = {
  Unknown: "Unknown",
  Scalar: "Scalar",
  RGB: "RGB",
  RGBA: "RGBA",
  Offset: "Offset",
  Vector: "Vector",
  Point: "Point",
  CovariantVector: "CovariantVector",
  SymmetricSecondRankTensor: "SymmetricSecondRankTensor",
  DiffusionTensor3D: "DiffusionTensor3D",
  Complex: "Complex",
  FixedArray: "FixedArray",
  Array: "Array",
  Matrix: "Matrix",
  VariableLengthVector: "VariableLengthVector",
  VariableSizeMatrix: "VariableSizeMatrix"
};
var vtkArrayTypeToItkComponentType = /* @__PURE__ */ new Map([["Uint8Array", "uint8"], ["Int8Array", "int8"], ["Uint16Array", "uint16"], ["Int16Array", "int16"], ["Uint32Array", "uint32"], ["Int32Array", "int32"], ["Float32Array", "float32"], ["Float64Array", "float64"]]);
var itkComponentTypeToVtkArrayType = /* @__PURE__ */ new Map([["uint8", "Uint8Array"], ["int8", "Int8Array"], ["uint16", "Uint16Array"], ["int16", "Int16Array"], ["uint32", "Uint32Array"], ["int32", "Int32Array"], ["float32", "Float32Array"], ["float64", "Float64Array"]]);
function convertItkToVtkImage(itkImage) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const vtkImage = {
    origin: [0, 0, 0],
    spacing: [1, 1, 1]
  };
  const dimensions = [1, 1, 1];
  const direction3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  const isITKWasm = itkImage.direction.data === void 0;
  const ITKPixelTypes = isITKWasm ? ITKWASMPixelTypes : ITKJSPixelTypes;
  for (let idx = 0; idx < itkImage.imageType.dimension; ++idx) {
    vtkImage.origin[idx] = itkImage.origin[idx];
    vtkImage.spacing[idx] = itkImage.spacing[idx];
    dimensions[idx] = itkImage.size[idx];
    for (let col = 0; col < itkImage.imageType.dimension; ++col) {
      if (isITKWasm) {
        direction3[col + idx * 3] = itkImage.direction[idx + col * itkImage.imageType.dimension];
      } else {
        direction3[col + idx * 3] = itkImage.direction.data[idx + col * itkImage.imageType.dimension];
      }
    }
  }
  const imageData = vtkImageData$1.newInstance(vtkImage);
  const pointData = vtkDataArray$1.newInstance({
    name: options.scalarArrayName || "Scalars",
    values: itkImage.data,
    numberOfComponents: itkImage.imageType.components
  });
  imageData.setDirection(direction3);
  imageData.setDimensions(...dimensions);
  imageData.getPointData().setScalars(pointData);
  switch (isITKWasm ? ITKPixelTypes[itkImage.imageType.pixelType] : itkImage.imageType.pixelType) {
    case ITKPixelTypes.Scalar:
      break;
    case ITKPixelTypes.RGB:
      break;
    case ITKPixelTypes.RGBA:
      break;
    case ITKPixelTypes.Offset:
      break;
    case ITKPixelTypes.Vector:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 3) {
        imageData.getPointData().setVectors(pointData);
      }
      break;
    case ITKPixelTypes.Point:
      break;
    case ITKPixelTypes.CovariantVector:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 3) {
        imageData.getPointData().setVectors(pointData);
      }
      break;
    case ITKPixelTypes.SymmetricSecondRankTensor:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 6) {
        imageData.getPointData().setTensors(pointData);
      }
      break;
    case ITKPixelTypes.DiffusionTensor3D:
      if (itkImage.imageType.dimension === 3 && itkImage.imageType.components === 6) {
        imageData.getPointData().setTensors(pointData);
      }
      break;
    case ITKPixelTypes.Complex:
      break;
    case ITKPixelTypes.FixedArray:
      break;
    case ITKPixelTypes.Array:
      break;
    case ITKPixelTypes.Matrix:
      break;
    case ITKPixelTypes.VariableLengthVector:
      break;
    case ITKPixelTypes.VariableSizeMatrix:
      break;
    default:
      vtkErrorMacro2(`Cannot handle unexpected itk-wasm pixel type ${itkImage.imageType.pixelType}`);
      return null;
  }
  return imageData;
}
function convertVtkToItkImage(vtkImage) {
  let copyData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const dimension = 3;
  const itkImage = {
    imageType: {
      dimension,
      pixelType: ITKWASMPixelTypes.Scalar,
      componentType: "",
      components: 1
    },
    name: "vtkImageData",
    origin: vtkImage.getOrigin(),
    spacing: vtkImage.getSpacing(),
    direction: new Float64Array(9),
    size: vtkImage.getDimensions()
  };
  const direction3 = vtkImage.getDirection();
  for (let idx = 0; idx < dimension; ++idx) {
    for (let idy = 0; idy < dimension; ++idy) {
      itkImage.direction[idx + idy * dimension] = direction3[idy + idx * dimension];
    }
  }
  const pointData = vtkImage.getPointData();
  let vtkArray;
  if (pointData.getTensors() !== null) {
    itkImage.imageType.pixelType = ITKWASMPixelTypes.DiffusionTensor3D;
    vtkArray = pointData.getTensors();
  } else if (pointData.getVectors() != null) {
    itkImage.imageType.pixelType = ITKWASMPixelTypes.Vector;
    vtkArray = pointData.getVectors();
  } else {
    vtkArray = pointData.getScalars();
  }
  itkImage.imageType.componentType = vtkArrayTypeToItkComponentType.get(vtkArray.getDataType());
  if (copyData) {
    itkImage.data = vtkArray.getData().slice(0);
  } else {
    itkImage.data = vtkArray.getData();
  }
  return itkImage;
}
function convertItkToVtkPolyData(itkPolyData) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pointDataArrays = [];
  if (itkPolyData.pointData.length) {
    pointDataArrays.push({
      data: {
        vtkClass: "vtkDataArray",
        name: options.pointDataName || "PointData",
        numberOfComponents: itkPolyData.polyDataType.pointPixelComponents,
        size: itkPolyData.pointData.length,
        dataType: itkComponentTypeToVtkArrayType.get(itkPolyData.polyDataType.pointPixelComponentType),
        buffer: itkPolyData.pointData.buffer,
        values: itkPolyData.pointData
      }
    });
  }
  const cellDataArrays = [];
  if (itkPolyData.cellData.length) {
    cellDataArrays.push({
      data: {
        vtkClass: "vtkDataArray",
        name: options.cellDataName || "CellData",
        numberOfComponents: itkPolyData.polyDataType.pointPixelComponents,
        size: itkPolyData.cellData.length,
        dataType: itkComponentTypeToVtkArrayType.get(itkPolyData.polyDataType.pointPixelComponentType),
        buffer: itkPolyData.cellData.buffer,
        values: itkPolyData.cellData
      }
    });
  }
  const vtkPolyDataModel = {
    points: {
      vtkClass: "vtkPoints",
      name: "_points",
      numberOfComponents: 3,
      size: itkPolyData.points.length,
      dataType: "Float32Array",
      buffer: itkPolyData.points.buffer,
      values: itkPolyData.points
    },
    verts: {
      vtkClass: "vtkCellArray",
      name: "_verts",
      numberOfComponents: 1,
      size: itkPolyData.verticesBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.vertices.buffer,
      values: itkPolyData.vertices
    },
    lines: {
      vtkClass: "vtkCellArray",
      name: "_lines",
      numberOfComponents: 1,
      size: itkPolyData.linesBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.lines.buffer,
      values: itkPolyData.lines
    },
    polys: {
      vtkClass: "vtkCellArray",
      name: "_polys",
      numberOfComponents: 1,
      size: itkPolyData.polygonsBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.polygons.buffer,
      values: itkPolyData.polygons
    },
    strips: {
      vtkClass: "vtkCellArray",
      name: "_strips",
      numberOfComponents: 1,
      size: itkPolyData.triangleStripsBufferSize,
      dataType: "Uint32Array",
      buffer: itkPolyData.triangleStrips.buffer,
      values: itkPolyData.triangleStrips
    },
    pointData: {
      vtkClass: "vtkDataSetAttributes",
      activeGlobalIds: -1,
      activeNormals: -1,
      activePedigreeIds: -1,
      activeScalars: -1,
      activeTCoords: -1,
      activeTensors: -1,
      activeVectors: -1,
      copyFieldFlags: [],
      doCopyAllOff: false,
      doCopyAllOn: true,
      arrays: pointDataArrays
    },
    cellData: {
      vtkClass: "vtkDataSetAttributes",
      activeGlobalIds: -1,
      activeNormals: -1,
      activePedigreeIds: -1,
      activeScalars: -1,
      activeTCoords: -1,
      activeTensors: -1,
      activeVectors: -1,
      copyFieldFlags: [],
      doCopyAllOff: false,
      doCopyAllOn: true,
      arrays: cellDataArrays
    }
  };
  const polyData = vtkPolyData$1.newInstance(vtkPolyDataModel);
  const pd = polyData.getPointData();
  const cd = polyData.getCellData();
  if (itkPolyData.pointData.length) {
    switch (ITKWASMPixelTypes[itkPolyData.polyDataType.pointPixelType]) {
      case ITKWASMPixelTypes.Scalar:
        pd.setScalars(pd.getArrayByIndex(0));
        break;
      case ITKWASMPixelTypes.RGB:
        break;
      case ITKWASMPixelTypes.RGBA:
        break;
      case ITKWASMPixelTypes.Offset:
        break;
      case ITKWASMPixelTypes.Vector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          pd.setVectors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Point:
        break;
      case ITKWASMPixelTypes.CovariantVector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          pd.setVectors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.SymmetricSecondRankTensor:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          pd.setTensors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.DiffusionTensor3D:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          pd.setTensors(pd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Complex:
        break;
      case ITKWASMPixelTypes.FixedArray:
        break;
      case ITKWASMPixelTypes.Array:
        break;
      case ITKWASMPixelTypes.Matrix:
        break;
      case ITKWASMPixelTypes.VariableLengthVector:
        break;
      case ITKWASMPixelTypes.VariableSizeMatrix:
        break;
      default:
        vtkErrorMacro2(`Cannot handle unexpected itk-wasm pixel type ${itkPolyData.polyDataType.pointPixelType}`);
        return null;
    }
  }
  if (itkPolyData.cellData.length) {
    switch (ITKWASMPixelTypes[itkPolyData.polyDataType.cellPixelType]) {
      case ITKWASMPixelTypes.Scalar:
        cd.setScalars(cd.getArrayByIndex(0));
        break;
      case ITKWASMPixelTypes.RGB:
        break;
      case ITKWASMPixelTypes.RGBA:
        break;
      case ITKWASMPixelTypes.Offset:
        break;
      case ITKWASMPixelTypes.Vector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          cd.setVectors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Point:
        break;
      case ITKWASMPixelTypes.CovariantVector:
        if (itkPolyData.polyDataType.pointPixelComponents === 3) {
          cd.setVectors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.SymmetricSecondRankTensor:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          cd.setTensors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.DiffusionTensor3D:
        if (itkPolyData.polyDataType.pointPixelComponents === 6) {
          cd.setTensors(cd.getArrayByIndex(0));
        }
        break;
      case ITKWASMPixelTypes.Complex:
        break;
      case ITKWASMPixelTypes.FixedArray:
        break;
      case ITKWASMPixelTypes.Array:
        break;
      case ITKWASMPixelTypes.Matrix:
        break;
      case ITKWASMPixelTypes.VariableLengthVector:
        break;
      case ITKWASMPixelTypes.VariableSizeMatrix:
        break;
      default:
        vtkErrorMacro2(`Cannot handle unexpected itk-wasm pixel type ${itkPolyData.polyDataType.pointPixelType}`);
        return null;
    }
  }
  return polyData;
}
function convertVtkToItkPolyData(polyData) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const itkPolyData = {
    polyDataType: {
      pointPixelComponentType: "float32",
      pointPixelComponents: 1,
      pointPixelType: "Scalar",
      cellPixelComponentType: "float32",
      cellPixelComponents: 1,
      cellPixelType: "Scalar"
    },
    numberOfPoints: polyData.getNumberOfPoints(),
    points: polyData.getPoints().getData(),
    verticesBufferSize: polyData.getVerts().getNumberOfValues(),
    vertices: polyData.getVerts().getData(),
    linesBufferSize: polyData.getLines().getNumberOfValues(),
    lines: polyData.getLines().getData(),
    polygonsBufferSize: polyData.getPolys().getNumberOfValues(),
    polygons: polyData.getPolys().getData(),
    triangleStripsBufferSize: polyData.getStrips().getNumberOfValues(),
    triangleStrips: polyData.getStrips().getData(),
    numberOfPointPixels: 0,
    pointData: new Float32Array(),
    numberOfCellPixels: 0,
    cellData: new Float32Array()
  };
  const pd = polyData.getPointData();
  if (pd.getNumberOfArrays()) {
    const pdArray = options.pointDataName ? pd.getArrayByName(options.pointDataName) : pd.getArrayByIndex(0);
    itkPolyData.numberOfPointPixels = pdArray.getNumberOfTuples();
    itkPolyData.pointData = pdArray.getData();
    itkPolyData.polyDataType.pointPixelComponentType = vtkArrayTypeToItkComponentType.get(pdArray.getDataType());
    itkPolyData.polyDataType.cellPixelComponentType = itkPolyData.polyDataType.pointPixelComponentType;
    itkPolyData.polyDataType.pointPixelComponents = pdArray.getNumberOfComponents();
    itkPolyData.polyDataType.cellPixelComponents = itkPolyData.polyDataType.pointPixelComponents;
    if (pd.getTensors() === pdArray) {
      itkPolyData.polyDataType.pointPixelType = ITKWASMPixelTypes.SymmetricSecondRankTensor;
    } else if (pd.getVectors() === pdArray) {
      itkPolyData.polyDataType.pointPixelType = ITKWASMPixelTypes.Vector;
    }
    itkPolyData.polyDataType.cellPixelType = itkPolyData.polyDataType.pointPixelType;
  }
  const cd = polyData.getCellData();
  if (cd.getNumberOfArrays()) {
    const cdArray = options.cellDataName ? pd.getArrayByName(options.cellDataName) : pd.getArrayByIndex(0);
    itkPolyData.numberOfCellPixels = cdArray.getNumberOfTuples();
    itkPolyData.cellData = cdArray.getData();
    itkPolyData.polyDataType.cellPixelComponentType = vtkArrayTypeToItkComponentType.get(cdArray.getDataType());
    itkPolyData.polyDataType.cellPixelComponents = cdArray.getNumberOfComponents();
    if (cd.getTensors() === cdArray) {
      itkPolyData.polyDataType.cellPixelType = ITKWASMPixelTypes.SymmetricSecondRankTensor;
    } else if (cd.getVectors() === cdArray) {
      itkPolyData.polyDataType.cellPixelType = ITKWASMPixelTypes.Vector;
    } else {
      itkPolyData.polyDataType.cellPixelType = ITKWASMPixelTypes.Scalar;
    }
  }
  return itkPolyData;
}
var ITKHelper = {
  convertItkToVtkImage,
  convertVtkToItkImage,
  convertItkToVtkPolyData,
  convertVtkToItkPolyData
};

// node_modules/@kitware/vtk.js/Common/DataModel/ImplicitBoolean/Constants.js
var Operation = {
  UNION: 0,
  INTERSECTION: 1,
  DIFFERENCE: 2
};
var Constants3 = {
  Operation
};

// node_modules/@kitware/vtk.js/Common/DataModel/ImplicitBoolean.js
var {
  Operation: Operation2
} = Constants3;
function vtkImplicitBoolean(publicAPI, model) {
  model.classHierarchy.push("vtkImplicitBoolean");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    let mTime = superClass.getMTime();
    if (!model.functions || model.functions.length <= 0) {
      return mTime;
    }
    for (let i = 0; i < model.functions.length; ++i) {
      mTime = Math.max(mTime, model.functions[i].getMTime());
    }
    return mTime;
  };
  publicAPI.getOperationAsString = () => macro.enumToString(Operation2, model.operation);
  publicAPI.setOperationToUnion = () => publicAPI.setOperation(0);
  publicAPI.setOperationToIntersection = () => publicAPI.setOperation(1);
  publicAPI.setOperationToDifference = () => publicAPI.setOperation(2);
  publicAPI.getFunctions = () => model.functions;
  publicAPI.hasFunction = (f2) => !!model.functions.filter((item) => item === f2).length;
  publicAPI.addFunction = (f2) => {
    if (f2 && !publicAPI.hasFunction(f2)) {
      model.functions = model.functions.concat(f2);
    }
  };
  publicAPI.removeFunction = (f2) => {
    const newFunctionList = model.functions.filter((item) => item !== f2);
    if (model.functions.length !== newFunctionList.length) {
      model.functions = newFunctionList;
    }
  };
  publicAPI.removeAllFunctions = () => {
    model.functions = [];
  };
  publicAPI.evaluateFunction = (xyz) => {
    let value = 0;
    if (model.functions.length <= 0) {
      return value;
    }
    if (model.operation === Operation2.UNION) {
      value = Number.MAX_VALUE;
      for (let i = 0; i < model.functions.length; ++i) {
        const f2 = model.functions[i];
        const v = f2.functionValue(xyz);
        if (v < value) {
          value = v;
        }
      }
    } else if (model.operation === Operation2.INTERSECTION) {
      value = -Number.MAX_VALUE;
      for (let i = 0; i < model.functions.length; ++i) {
        const f2 = model.functions[i];
        const v = f2.functionValue(xyz);
        if (v > value) {
          value = v;
        }
      }
    } else {
      const firstF = model.functions[0];
      value = firstF.functionValue(xyz);
      for (let i = 1; i < model.functions.length; ++i) {
        const f2 = model.functions[i];
        const v = -1 * f2.evaluateFunction(xyz);
        if (v > value) {
          value = v;
        }
      }
    }
    return value;
  };
  publicAPI.evaluateGradient = (xyz) => {
    const t = model.axis[0] * (xyz[0] - model.center[0]) + model.axis[1] * (xyz[1] - model.center[1]) + model.axis[2] * (xyz[2] - model.center[2]);
    const cp = new Float32Array(3);
    cp[0] = model.center[0] + t * model.axis[0];
    cp[1] = model.center[1] + t * model.axis[1];
    cp[2] = model.center[2] + t * model.axis[2];
    const retVal = [2 * (xyz[0] - cp[0]), 2 * (xyz[1] - cp[1]), 2 * (xyz[2] - cp[2])];
    return retVal;
  };
}
var DEFAULT_VALUES6 = {
  operation: 0,
  functions: []
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["operation"]);
  vtkImplicitBoolean(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend6, "vtkImplicitBoolean");
var vtkImplicitBoolean$1 = {
  newInstance: newInstance7,
  extend: extend6,
  ...Constants3
};

// node_modules/@kitware/vtk.js/Common/DataModel/Molecule.js
var MOLECULE_FIELDS = ["chemical json", "name", "inchi", "formula", "atoms", "bonds", "properties"];
function vtkMolecule(publicAPI, model) {
  model.classHierarchy.push("vtkMolecule");
}
var DEFAULT_VALUES7 = {
  "chemical json": 0,
  name: "",
  inchi: "",
  formula: "",
  atoms: null,
  bonds: null,
  properties: null
};
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  macro.obj(publicAPI, model);
  if (!model.atoms) {
    model.atoms = {};
  }
  if (!model.bonds) {
    model.bonds = {};
  }
  if (!model.properties) {
    model.properties = {};
  }
  macro.setGet(publicAPI, model, MOLECULE_FIELDS);
  vtkMolecule(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend7, "vtkMolecule");
var vtkMolecule$1 = {
  newInstance: newInstance8,
  extend: extend7
};

// node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js
var {
  vtkErrorMacro: vtkErrorMacro3
} = macro;
function vtkPiecewiseFunction(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseFunction");
  publicAPI.getSize = () => model.nodes.length;
  publicAPI.getType = () => {
    let value;
    let prevValue = 0;
    let functionType = 0;
    if (model.nodes.length > 0) {
      prevValue = model.nodes[0].y;
    }
    for (let i = 1; i < model.nodes.length; i++) {
      value = model.nodes[i].y;
      if (value !== prevValue) {
        if (value > prevValue) {
          switch (functionType) {
            case 0:
            case 1:
              functionType = 1;
              break;
            case 2:
            default:
              functionType = 3;
              break;
          }
        } else {
          switch (functionType) {
            case 0:
            case 2:
              functionType = 2;
              break;
            case 1:
            default:
              functionType = 3;
              break;
          }
        }
      }
      prevValue = value;
      if (functionType === 3) {
        break;
      }
    }
    switch (functionType) {
      case 0:
        return "Constant";
      case 1:
        return "NonDecreasing";
      case 2:
        return "NonIncreasing";
      case 3:
      default:
        return "Varied";
    }
  };
  publicAPI.getDataPointer = () => {
    const size = model.nodes.length;
    model.function = null;
    if (size > 0) {
      model.function = [];
      for (let i = 0; i < size; i++) {
        model.function[2 * i] = model.nodes[i].x;
        model.function[2 * i + 1] = model.nodes[i].y;
      }
    }
    return model.function;
  };
  publicAPI.getFirstNonZeroValue = () => {
    if (model.nodes.length === 0) {
      return 0;
    }
    let allZero = 1;
    let x = 0;
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].y !== 0) {
        allZero = 0;
        break;
      }
    }
    if (allZero) {
      x = Number.MAX_VALUE;
    } else if (i > 0) {
      x = model.nodes[i - 1].x;
    } else if (model.clamping) {
      x = -Number.MAX_VALUE;
    } else {
      x = model.nodes[0].x;
    }
    return x;
  };
  publicAPI.getNodeValue = (index, val) => {
    const size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro3("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].y;
    val[2] = model.nodes[index].midpoint;
    val[3] = model.nodes[index].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = (index, val) => {
    const size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro3("Index out of range!");
      return -1;
    }
    const oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].y = val[1];
    model.nodes[index].midpoint = val[2];
    model.nodes[index].sharpness = val[3];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0);
  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro3("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro3("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    const node = {
      x,
      y,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    let i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.setNodes = (nodes) => {
    if (model.nodes !== nodes) {
      model.nodes = nodes;
      publicAPI.sortAndUpdateRange();
    }
  };
  publicAPI.sortAndUpdateRange = () => {
    model.nodes.sort((a2, b2) => a2.x - b2.x);
    const modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
  };
  publicAPI.updateRange = () => {
    const oldRange = model.range.slice();
    const size = model.nodes.length;
    if (size) {
      model.range[0] = model.nodes[0].x;
      model.range[1] = model.nodes[size - 1].x;
    } else {
      model.range[0] = 0;
      model.range[1] = 0;
    }
    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = (x) => {
    let i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i >= model.nodes.length) {
      return -1;
    }
    const retVal = i;
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addSegment = (x1, y1, x2, y2) => {
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addPoint(x1, y1, 0.5, 0);
    publicAPI.addPoint(x2, y2, 0.5, 0);
  };
  publicAPI.getValue = (x) => {
    const table = [];
    publicAPI.getTable(x, x, 1, table);
    return table[0];
  };
  publicAPI.adjustRange = (range) => {
    if (range.length < 2) {
      return 0;
    }
    const functionRange = publicAPI.getRange();
    if (functionRange[0] < range[0]) {
      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));
    } else {
      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));
    }
    if (functionRange[1] > range[1]) {
      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));
    } else {
      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));
    }
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    publicAPI.sortAndUpdateRange();
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d2 = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d2);
  };
  publicAPI.findMinimumXDistance = () => {
    const size = model.nodes.length;
    if (size < 2) {
      return -1;
    }
    let distance = model.nodes[1].x - model.nodes[0].x;
    for (let i = 0; i < size - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.getTable = function(xStart, xEnd, size, table) {
    let stride = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
    let i;
    let idx = 0;
    const numNodes = model.nodes.length;
    let lastValue = 0;
    if (numNodes !== 0) {
      lastValue = model.nodes[numNodes - 1].y;
    }
    let x = 0;
    let x1 = 0;
    let x2 = 0;
    let y1 = 0;
    let y2 = 0;
    let midpoint = 0;
    let sharpness = 0;
    for (i = 0; i < size; i++) {
      const tidx = stride * i;
      if (size > 1) {
        x = xStart + i / (size - 1) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          y1 = model.nodes[idx - 1].y;
          y2 = model.nodes[idx].y;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (idx >= numNodes) {
        table[tidx] = model.clamping ? lastValue : 0;
      } else if (idx === 0) {
        table[tidx] = model.clamping ? model.nodes[0].y : 0;
      } else {
        let s = (x - x1) / (x2 - x1);
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = y1;
            continue;
          } else {
            table[tidx] = y2;
            continue;
          }
        }
        if (sharpness < 0.01) {
          table[tidx] = (1 - s) * y1 + s * y2;
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * (s * 2) ** (1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * ((1 - s) * 2) ** (1 + 10 * sharpness);
        }
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;
        const slope = y2 - y1;
        const t = (1 - sharpness) * slope;
        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;
        const min = y1 < y2 ? y1 : y2;
        const max2 = y1 > y2 ? y1 : y2;
        table[tidx] = table[tidx] < min ? min : table[tidx];
        table[tidx] = table[tidx] > max2 ? max2 : table[tidx];
      }
    }
  };
}
var DEFAULT_VALUES8 = {
  // model.function = NULL;
  range: [0, 0],
  clamping: true,
  allowDuplicateScalars: false
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  model.nodes = [];
  macro.setGet(publicAPI, model, ["allowDuplicateScalars", "clamping"]);
  macro.setArray(publicAPI, model, ["range"], 2);
  macro.getArray(publicAPI, model, ["range"]);
  vtkPiecewiseFunction(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend8, "vtkPiecewiseFunction");
var vtkPiecewiseFunction$1 = {
  newInstance: newInstance9,
  extend: extend8
};

// node_modules/@kitware/vtk.js/Common/DataModel/Planes.js
var {
  vtkErrorMacro: vtkErrorMacro4,
  vtkWarningMacro: vtkWarningMacro2
} = macro;
function vtkPlanes(publicAPI, model) {
  model.classHierarchy.push("vtkPlanes");
  model.planes = model.planes || macro.newTypedArray(TYPED_ARRAYS.Float64Array, 24);
  model.bounds = model.bounds || macro.newTypedArray(TYPED_ARRAYS.Float64Array, 6);
  model.plane = vtkPlane$1.newInstance();
  publicAPI.setNormals = (normals) => {
    if (normals && normals.getNumberOfComponents() !== 3) {
      vtkWarningMacro2("This array does not have 3 components. Ignoring normals.");
    }
    model.normals = normals;
    publicAPI.modified();
    return true;
  };
  publicAPI.evaluateFunction = (x) => {
    if (!model.points || !model.normals) {
      vtkErrorMacro4("Please define points and/or normals!");
      return Number.MAX_VALUE;
    }
    const numPlanes = model.points.getNumberOfPoints();
    if (numPlanes !== model.normals.getNumberOfTuples()) {
      vtkErrorMacro4("Number of normals/points inconsistent!");
      return Number.MAX_VALUE;
    }
    let maxVal = -Number.MAX_VALUE;
    const normal = [];
    const point = [];
    for (let i = 0; i < numPlanes; i++) {
      model.normals.getTuple(i, normal);
      model.points.getPoint(i, point);
      const val = vtkPlane$1.evaluate(normal, point, x);
      if (val > maxVal) {
        maxVal = val;
      }
    }
    return maxVal;
  };
  publicAPI.evaluateGradient = (x) => {
    const retVal = [0, 0, 0];
    if (!model.points || !model.normals) {
      vtkErrorMacro4("Define points and/or normals first!");
      return retVal;
    }
    const numPlanes = model.points.getNumberOfPoints();
    if (numPlanes !== model.normals.getNumberOfTuples()) {
      vtkErrorMacro4("The number of normals/points is inconsistent!");
      return retVal;
    }
    let maxVal = -Number.MAX_VALUE;
    const nTemp = [];
    const pTemp = [];
    for (let i = 0; i < numPlanes; i++) {
      model.normals.getTuple(i, nTemp);
      model.points.getPoint(i, pTemp);
      const val = vtkPlane$1.evaluate(nTemp, pTemp, x);
      if (val > maxVal) {
        maxVal = val;
        retVal[0] = nTemp[0];
        retVal[1] = nTemp[1];
        retVal[2] = nTemp[2];
      }
    }
    return retVal;
  };
  publicAPI.setFrustumPlanes = (planes) => {
    if (vtkMath.areEquals(model.planes, planes)) {
      return false;
    }
    model.planes = [...planes];
    const pts = vtkPoints$1.newInstance({
      dataType: VtkDataTypes.DOUBLE
    });
    const normals = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      size: 6 * 3,
      // 6 planes, each with a normal
      dataType: VtkDataTypes.DOUBLE
    });
    pts.setNumberOfPoints(6);
    publicAPI.setPoints(pts);
    publicAPI.setNormals(normals);
    const n = [];
    const x = [];
    for (let i = 0; i < 6; i++) {
      const planeOffset = 4 * i;
      n[0] = -planes[planeOffset];
      n[1] = -planes[planeOffset + 1];
      n[2] = -planes[planeOffset + 2];
      x[0] = 0;
      x[1] = 0;
      x[2] = 0;
      if (n[0] !== 0) {
        x[0] = planes[planeOffset + 3] / n[0];
      } else if (n[1] !== 0) {
        x[1] = planes[planeOffset + 3] / n[1];
      } else {
        x[2] = planes[planeOffset + 3] / n[2];
      }
      pts.setPoint(i, ...x);
      normals.setTuple(i, n);
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.setBounds = (bounds2) => {
    if (vtkMath.areEquals(model.bounds, bounds2)) {
      return false;
    }
    model.bounds = [...bounds2];
    const pts = vtkPoints$1.newInstance();
    const normals = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      size: 6 * 3,
      // 6 planes, each with a normal
      dataType: VtkDataTypes.DOUBLE
    });
    pts.setNumberOfPoints(6);
    publicAPI.setPoints(pts);
    publicAPI.setNormals(normals);
    const n = [];
    const x = [];
    n[0] = -1;
    n[1] = 0;
    n[2] = 0;
    x[0] = bounds2[0];
    x[1] = 0;
    x[2] = 0;
    pts.setPoint(0, ...x);
    normals.setTuple(0, n);
    n[0] = 1;
    x[0] = bounds2[1];
    pts.setPoint(1, ...x);
    normals.setTuple(1, n);
    n[0] = 0;
    n[1] = -1;
    n[2] = 0;
    x[0] = 0;
    x[1] = bounds2[2];
    x[2] = 0;
    pts.setPoint(2, ...x);
    normals.setTuple(2, n);
    n[1] = 1;
    x[1] = bounds2[3];
    pts.setPoint(3, ...x);
    normals.setTuple(3, n);
    n[0] = 0;
    n[1] = 0;
    n[2] = -1;
    x[0] = 0;
    x[1] = 0;
    x[2] = bounds2[4];
    pts.setPoint(4, ...x);
    normals.setTuple(4, n);
    n[2] = 1;
    x[2] = bounds2[5];
    pts.setPoint(5, ...x);
    normals.setTuple(5, n);
    publicAPI.modified();
    return true;
  };
  publicAPI.getNumberOfPlanes = () => {
    if (model.points && model.normals) {
      const npts = model.points.getNumberOfPoints();
      const nnormals = model.normals.getNumberOfTuples();
      return Math.min(npts, nnormals);
    }
    return 0;
  };
  publicAPI.getPlane = function(i) {
    let plane = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : model.plane;
    if (i >= 0 && i < publicAPI.getNumberOfPlanes()) {
      const normal = model.normals.getTuple(i);
      const point = model.points.getPoint(i);
      plane.setNormal(normal);
      plane.setOrigin(point);
    }
    return plane;
  };
}
var DEFAULT_VALUES9 = {
  points: null,
  normals: null,
  planes: null,
  bounds: null
};
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points", "normals"]);
  macro.get(publicAPI, model, ["bounds", "planes"]);
  vtkPlanes(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend9, "vtkPlanes");
var vtkPlanes$1 = {
  newInstance: newInstance10,
  extend: extend9
};

// node_modules/@kitware/vtk.js/Common/DataModel/Sphere.js
function evaluate2(radius, center, xyz) {
  if (!Array.isArray(radius)) {
    const retVal = (xyz[0] - center[0]) * (xyz[0] - center[0]) + (xyz[1] - center[1]) * (xyz[1] - center[1]) + (xyz[2] - center[2]) * (xyz[2] - center[2]) - radius * radius;
    return retVal;
  }
  const r = [(xyz[0] - center[0]) / radius[0], (xyz[1] - center[1]) / radius[1], (xyz[2] - center[2]) / radius[2]];
  return r[0] * r[0] + r[1] * r[1] + r[2] * r[2] - 1;
}
var STATIC4 = {
  evaluate: evaluate2
};
function vtkSphere(publicAPI, model) {
  model.classHierarchy.push("vtkSphere");
  publicAPI.evaluateFunction = (xyz) => evaluate2(model.radius, model.center, xyz);
  publicAPI.evaluateGradient = (xyz) => {
    const retVal = [2 - (xyz[0] - model.center[0]), 2 - (xyz[1] - model.center[1]), 2 - (xyz[2] - model.center[2])];
    return retVal;
  };
}
var DEFAULT_VALUES10 = {
  radius: 0.5,
  center: [0, 0, 0]
};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["radius"]);
  macro.setGetArray(publicAPI, model, ["center"], 3);
  vtkSphere(publicAPI, model);
}
var newInstance11 = macro.newInstance(extend10, "vtkSphere");
var vtkSphere$1 = {
  newInstance: newInstance11,
  extend: extend10,
  ...STATIC4
};

// node_modules/@kitware/vtk.js/Common/DataModel.js
var DataModel = {
  vtkBoundingBox,
  vtkBox: vtkBox$1,
  vtkCell: vtkCell$1,
  vtkCone: vtkCone$1,
  vtkCylinder: vtkCylinder$1,
  vtkDataSet: vtkDataSet$1,
  vtkDataSetAttributes: vtkDataSetAttributes$1,
  vtkITKHelper: ITKHelper,
  vtkImageData: vtkImageData$1,
  vtkImplicitBoolean: vtkImplicitBoolean$1,
  vtkLine: vtkLine$1,
  vtkMolecule: vtkMolecule$1,
  vtkPiecewiseFunction: vtkPiecewiseFunction$1,
  vtkPlane: vtkPlane$1,
  vtkPlanes: vtkPlanes$1,
  vtkPointSet: vtkPointSet$1,
  vtkPolyData: vtkPolyData$1,
  vtkSelectionNode: vtkSelectionNode$1,
  vtkSphere: vtkSphere$1,
  vtkStructuredData,
  vtkTriangle: vtkTriangle$1,
  vtkTriangleStrip: vtkTriangleStrip$1
};

// node_modules/@kitware/vtk.js/Common/Transform/LandmarkTransform/Constants.js
var Mode = {
  RIGID_BODY: 0,
  SIMILARITY: 1,
  AFFINE: 2
};
var Constants4 = {
  Mode
};

// node_modules/@kitware/vtk.js/Common/Transform/LandmarkTransform.js
var {
  Mode: Mode2
} = Constants4;
function vtkLandmarkTransform(publicAPI, model) {
  model.classHierarchy.push("vtkLandmarkTransform");
  function update2() {
    mat4_exports.identity(model.matrix);
    const N_PTS = model.sourceLandmark.getNumberOfPoints();
    if (model.targetLandmark.getNumberOfPoints() !== N_PTS || model.sourceLandmark === null || model.targetLandmark === null || N_PTS === 0) {
      console.error("Error : Bad inputs of vtkLandmarkTransform");
      return model.matrix;
    }
    const sourceCentroid = [0, 0, 0];
    const targetCentroid = [0, 0, 0];
    const p = [0, 0, 0];
    for (let i = 0; i < N_PTS; i++) {
      model.sourceLandmark.getPoint(i, p);
      sourceCentroid[0] += p[0];
      sourceCentroid[1] += p[1];
      sourceCentroid[2] += p[2];
      model.targetLandmark.getPoint(i, p);
      targetCentroid[0] += p[0];
      targetCentroid[1] += p[1];
      targetCentroid[2] += p[2];
    }
    sourceCentroid[0] /= N_PTS;
    sourceCentroid[1] /= N_PTS;
    sourceCentroid[2] /= N_PTS;
    targetCentroid[0] /= N_PTS;
    targetCentroid[1] /= N_PTS;
    targetCentroid[2] /= N_PTS;
    if (N_PTS === 1) {
      mat4_exports.identity(model.matrix);
      model.matrix[12] = targetCentroid[0] - sourceCentroid[0];
      model.matrix[13] = targetCentroid[1] - sourceCentroid[1];
      model.matrix[14] = targetCentroid[2] - sourceCentroid[2];
      return model.matrix;
    }
    const M = new Float64Array(9);
    const AAT = new Float64Array(9);
    const a2 = [0, 0, 0];
    const b2 = [0, 0, 0];
    let sa = 0;
    let sb = 0;
    for (let pt = 0; pt < N_PTS; pt++) {
      model.sourceLandmark.getPoint(pt, a2);
      a2[0] -= sourceCentroid[0];
      a2[1] -= sourceCentroid[1];
      a2[2] -= sourceCentroid[2];
      model.targetLandmark.getPoint(pt, b2);
      b2[0] -= targetCentroid[0];
      b2[1] -= targetCentroid[1];
      b2[2] -= targetCentroid[2];
      for (let i = 0; i < 3; i++) {
        M[3 * 0 + i] += a2[i] * b2[0];
        M[3 * 1 + i] += a2[i] * b2[1];
        M[3 * 2 + i] += a2[i] * b2[2];
        if (model.mode === Mode2.AFFINE) {
          AAT[3 * 0 + i] += a2[i] * a2[0];
          AAT[3 * 1 + i] += a2[i] * a2[1];
          AAT[3 * 2 + i] += a2[i] * a2[2];
        }
      }
      sa += a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2];
      sb += b2[0] * b2[0] + b2[1] * b2[1] + b2[2] * b2[2];
    }
    if (model.mode === Mode2.AFFINE) {
      mat3_exports.invert(AAT, AAT);
      mat3_exports.multiply(M, AAT, M);
      for (let i = 0; i < 3; ++i) {
        for (let j = 0; j < 3; ++j) {
          model.matrix[4 * j + i] = M[4 * i + j];
        }
      }
    } else {
      const scale = Math.sqrt(sb / sa);
      const N2 = new Float64Array(16);
      N2[0] = M[0] + M[4] + M[8];
      N2[5] = M[0] - M[4] - M[8];
      N2[10] = -M[0] + M[4] - M[8];
      N2[15] = -M[0] - M[4] + M[8];
      N2[4] = N2[1] = M[7] - M[5];
      N2[8] = N2[2] = M[2] - M[6];
      N2[12] = N2[3] = M[3] - M[1];
      N2[9] = N2[6] = M[3] + M[1];
      N2[13] = N2[7] = M[2] + M[6];
      N2[14] = N2[11] = M[7] + M[5];
      const eigenVectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      const eigenValues = [0, 0, 0, 0];
      jacobiN(N2, 4, eigenValues, eigenVectors);
      let w;
      let x;
      let y;
      let z;
      if (eigenValues[0] === eigenValues[1] || N_PTS === 2) {
        const s0 = [0, 0, 0];
        const t0 = [0, 0, 0];
        const s1 = [0, 0, 0];
        const t1 = [0, 0, 0];
        model.sourceLandmark.getPoint(0, s0);
        model.targetLandmark.getPoint(0, t0);
        model.sourceLandmark.getPoint(1, s1);
        model.targetLandmark.getPoint(1, t1);
        const ds = [0, 0, 0];
        const dt = [0, 0, 0];
        let rs = 0;
        let rt = 0;
        for (let i = 0; i < 3; i++) {
          ds[i] = s1[i] - s0[i];
          rs = ds[i] * ds[i] + rs;
          dt[i] = t1[i] - t0[i];
          rt = dt[i] * dt[i] + rt;
        }
        rs = Math.sqrt(rs);
        ds[0] /= rs;
        ds[1] /= rs;
        ds[2] /= rs;
        rt = Math.sqrt(rt);
        dt[0] /= rt;
        dt[1] /= rt;
        dt[2] /= rt;
        w = ds[0] * dt[0] + ds[1] * dt[1] + ds[2] * dt[2];
        x = ds[1] * dt[2] - ds[2] * dt[1];
        y = ds[2] * dt[0] - ds[0] * dt[2];
        z = ds[0] * dt[1] - ds[1] * dt[0];
        let r = Math.sqrt(x * x + y * y + z * z);
        const theta = Math.atan2(r, w);
        w = Math.cos(theta / 2);
        if (r !== 0) {
          r = Math.sin(theta / 2) / r;
          x *= r;
          y *= r;
          z *= r;
        } else {
          perpendiculars(ds, dt, 0, 0);
          r = Math.sin(theta / 2);
          x = dt[0] * r;
          y = dt[1] * r;
          z = dt[2] * r;
        }
      } else {
        w = eigenVectors[0];
        x = eigenVectors[4];
        y = eigenVectors[8];
        z = eigenVectors[12];
      }
      const ww = w * w;
      const wx = w * x;
      const wy = w * y;
      const wz = w * z;
      const xx = x * x;
      const yy = y * y;
      const zz = z * z;
      const xy = x * y;
      const xz = x * z;
      const yz = y * z;
      model.matrix[0] = ww + xx - yy - zz;
      model.matrix[1] = 2 * (wz + xy);
      model.matrix[2] = 2 * (-wy + xz);
      model.matrix[4] = 2 * (-wz + xy);
      model.matrix[5] = ww - xx + yy - zz;
      model.matrix[6] = 2 * (wx + yz);
      model.matrix[8] = 2 * (wy + xz);
      model.matrix[9] = 2 * (-wx + yz);
      model.matrix[10] = ww - xx - yy + zz;
      if (model.mode !== Mode2.RIGID_BODY) {
        for (let i = 0; i < 3; i++) {
          model.matrix[4 * 0 + i] = model.matrix[4 * 0 + i] * scale;
          model.matrix[4 * 1 + i] = model.matrix[4 * 1 + i] * scale;
          model.matrix[4 * 2 + i] = model.matrix[4 * 2 + i] * scale;
        }
      }
    }
    const sx = model.matrix[0] * sourceCentroid[0] + model.matrix[4] * sourceCentroid[1] + model.matrix[8] * sourceCentroid[2];
    const sy = model.matrix[1] * sourceCentroid[0] + model.matrix[5] * sourceCentroid[1] + model.matrix[9] * sourceCentroid[2];
    const sz = model.matrix[2] * sourceCentroid[0] + model.matrix[6] * sourceCentroid[1] + model.matrix[10] * sourceCentroid[2];
    model.matrix[12] = targetCentroid[0] - sx;
    model.matrix[13] = targetCentroid[1] - sy;
    model.matrix[14] = targetCentroid[2] - sz;
    model.matrix[3] = 0;
    model.matrix[7] = 0;
    model.matrix[11] = 0;
    model.matrix[15] = 1;
    return model.matrix;
  }
  publicAPI.update = update2;
}
var DEFAULT_VALUES11 = {
  mode: Mode2.SIMILARITY
};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  macro.obj(publicAPI, model);
  model.matrix = mat4_exports.identity(new Float64Array(16));
  macro.setGet(publicAPI, model, ["sourceLandmark", "targetLandmark", "mode"]);
  macro.get(publicAPI, model, ["matrix"]);
  vtkLandmarkTransform(publicAPI, model);
}
var newInstance12 = macro.newInstance(extend11, "vtkLandmarkTransform");
var vtkLandmarkTransform$1 = {
  newInstance: newInstance12,
  extend: extend11,
  ...Constants4
};

// node_modules/@kitware/vtk.js/Common/Transform/Transform.js
var {
  vtkWarningMacro: vtkWarningMacro3
} = macro;
var newInstance13;
function vtkTransform(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractTransform", "vtkHomogeneousTransform", "vtkTransform");
  publicAPI.transformPoint = (point, out) => {
    vec3_exports.transformMat4(out, point, model.matrix);
    return out;
  };
  publicAPI.transformPoints = (points, out) => {
    const inPoint = new Float64Array(3);
    const outPoint = new Float64Array(3);
    for (let i = 0; i < points.length; i += 3) {
      inPoint[0] = points[i];
      inPoint[1] = points[i + 1];
      inPoint[2] = points[i + 2];
      vec3_exports.transformMat4(outPoint, inPoint, model.matrix);
      out[i] = outPoint[0];
      out[i + 1] = outPoint[1];
      out[i + 2] = outPoint[2];
    }
    return out;
  };
  publicAPI.preMultiply = () => {
    publicAPI.setPreMultiplyFlag(true);
  };
  publicAPI.postMultiply = () => {
    publicAPI.setPreMultiplyFlag(false);
  };
  publicAPI.transformMatrix = (matrix, out) => {
    if (model.preMultiplyFlag) {
      mat4_exports.multiply(out, model.matrix, matrix);
    } else {
      mat4_exports.multiply(out, matrix, model.matrix);
    }
    return out;
  };
  publicAPI.transformMatrices = (matrices, out) => {
    const inMat = new Float64Array(16);
    const outMat = new Float64Array(16);
    const transform = model.preMultiplyFlag ? () => mat4_exports.multiply(outMat, model.matrix, inMat) : () => mat4_exports.multiply(outMat, inMat, model.matrix);
    for (let i = 0; i < matrices.length; i += 16) {
      for (let j = 0; j < 16; ++j) {
        inMat[j] = matrices[i + j];
      }
      transform();
      for (let j = 0; j < 16; ++j) {
        out[i + j] = outMat[j];
      }
    }
    return out;
  };
  publicAPI.getInverse = () => newInstance13({
    matrix: vtkMath.invertMatrix(Array.from(model.matrix), [], 4),
    preMultiplyFlag: model.preMultiplyFlag
  });
  publicAPI.translate = (x, y, z) => {
    if (x === 0 && y === 0 && z === 0) {
      return;
    }
    const tMat = mat4_exports.create();
    mat4_exports.fromTranslation(tMat, [x, y, z]);
    if (model.preMultiplyFlag) {
      mat4_exports.multiply(model.matrix, model.matrix, tMat);
    } else {
      mat4_exports.multiply(model.matrix, tMat, model.matrix);
    }
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees, x, y, z) => {
    if (x === 0 && y === 0 && z === 0) {
      vtkWarningMacro3("No rotation applied, axis is zero vector.");
      return;
    }
    if (degrees === 0) {
      return;
    }
    const angle = vtkMath.radiansFromDegrees(degrees);
    const q = quat_exports.create();
    quat_exports.setAxisAngle(q, [x, y, z], angle);
    const quatMat = new Float64Array(16);
    mat4_exports.fromQuat(quatMat, q);
    if (model.preMultiplyFlag) {
      mat4_exports.multiply(model.matrix, model.matrix, quatMat);
    } else {
      mat4_exports.multiply(model.matrix, quatMat, model.matrix);
    }
    publicAPI.modified();
  };
  publicAPI.rotateX = (angle) => {
    publicAPI.rotateWXYZ(angle, 1, 0, 0);
  };
  publicAPI.rotateY = (angle) => {
    publicAPI.rotateWXYZ(angle, 0, 1, 0);
  };
  publicAPI.rotateZ = (angle) => {
    publicAPI.rotateWXYZ(angle, 0, 0, 1);
  };
  publicAPI.scale = (x, y, z) => {
    if (x === 1 && y === 1 && z === 1) {
      return;
    }
    const sMat = mat4_exports.create();
    mat4_exports.fromScaling(sMat, [x, y, z]);
    if (model.preMultiplyFlag) {
      mat4_exports.multiply(model.matrix, model.matrix, sMat);
    } else {
      mat4_exports.multiply(model.matrix, sMat, model.matrix);
    }
    publicAPI.modified();
  };
  publicAPI.transformNormal = function(inNormal) {
    let outNormal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const matrix3x3 = mat3_exports.fromMat4(mat3_exports.create(), model.matrix);
    const invMat3 = mat3_exports.create();
    mat3_exports.invert(invMat3, matrix3x3);
    const tMat3 = mat3_exports.create();
    mat3_exports.transpose(tMat3, invMat3);
    publicAPI.transformVector(inNormal, outNormal, tMat3);
    vtkMath.normalize(outNormal);
    return outNormal;
  };
  publicAPI.transformNormals = (inNormals, outNormals) => {
    const inArr = inNormals.getData();
    const outArr = outNormals.getData();
    const tmp = [0, 0, 0];
    const matrix3x3 = mat3_exports.fromMat4(mat3_exports.create(), model.matrix);
    const invMat3 = mat3_exports.create();
    mat3_exports.invert(invMat3, matrix3x3);
    const tMat3 = mat3_exports.create();
    mat3_exports.transpose(tMat3, invMat3);
    for (let i = 0; i < inArr.length; i += 3) {
      tmp[0] = inArr[i];
      tmp[1] = inArr[i + 1];
      tmp[2] = inArr[i + 2];
      publicAPI.transformVector(tmp, tmp, tMat3);
      vtkMath.normalize(tmp);
      outArr[i] = tmp[0];
      outArr[i + 1] = tmp[1];
      outArr[i + 2] = tmp[2];
    }
  };
  publicAPI.transformVector = function(inVector) {
    let outVector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let matrix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const matrix3x3 = matrix || mat3_exports.fromMat4(mat3_exports.create(), model.matrix);
    vec3_exports.transformMat3(outVector, inVector, matrix3x3);
    return outVector;
  };
  publicAPI.transformVectors = (inVectors, outVectors) => {
    const inArr = inVectors.getData();
    const outArr = outVectors.getData();
    const tmp = [0, 0, 0];
    for (let i = 0; i < inArr.length; i += 3) {
      tmp[0] = inArr[i];
      tmp[1] = inArr[i + 1];
      tmp[2] = inArr[i + 2];
      publicAPI.transformVector(tmp, tmp);
      vtkMath.normalize(tmp);
      outArr[i] = tmp[0];
      outArr[i + 1] = tmp[1];
      outArr[i + 2] = tmp[2];
    }
  };
  publicAPI.transformPointsNormalsVectors = function(inPoints, outPoints, inNormals, outNormals, inVectors, outVectors) {
    let inVectorsArr = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
    let outVectorsArr = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
    const n = inPoints.getNumberOfPoints();
    const nOptionalVectors = (inVectorsArr == null ? void 0 : inVectorsArr.length) ?? 0;
    const point = new Float64Array(3);
    const oldPoint = new Float64Array(3);
    const oldVector = new Float64Array(3);
    const oldNormal = new Float64Array(3);
    let modifiedPoint = false;
    let modifiedVector = false;
    let modifiedNormal = false;
    const modifiedVectorsArr = [];
    for (let ptId = 0; ptId < n; ptId++) {
      inPoints.getPoint(ptId, point);
      oldPoint.set(point);
      publicAPI.transformPoint(point, point);
      outPoints.setPoint(ptId, ...point);
      if (!vtkMath.areEquals(oldPoint, point)) {
        modifiedPoint = true;
      }
      if (inVectors) {
        const inData = inVectors.getData();
        const outData = outVectors.getData();
        point[0] = inData[ptId * 3];
        point[1] = inData[ptId * 3 + 1];
        point[2] = inData[ptId * 3 + 2];
        oldVector.set(point);
        publicAPI.transformVector(point, point);
        outData[ptId * 3] = point[0];
        outData[ptId * 3 + 1] = point[1];
        outData[ptId * 3 + 2] = point[2];
        if (!vtkMath.areEquals(oldVector, point)) {
          modifiedVector = true;
        }
      }
      if (inNormals) {
        const inData = inNormals.getData();
        const outData = outNormals.getData();
        point[0] = inData[ptId * 3];
        point[1] = inData[ptId * 3 + 1];
        point[2] = inData[ptId * 3 + 2];
        oldNormal.set(point);
        publicAPI.transformNormal(point, point);
        outData[ptId * 3] = point[0];
        outData[ptId * 3 + 1] = point[1];
        outData[ptId * 3 + 2] = point[2];
        if (!vtkMath.areEquals(oldNormal, point)) {
          modifiedNormal = true;
        }
      }
      if (inVectorsArr) {
        for (let iArr = 0; iArr < nOptionalVectors; iArr++) {
          const inData = inVectorsArr[iArr].getData();
          const outData = outVectorsArr[iArr].getData();
          point[0] = inData[ptId * 3];
          point[1] = inData[ptId * 3 + 1];
          point[2] = inData[ptId * 3 + 2];
          oldVector.set(point);
          publicAPI.transformVector(point, point);
          outData[ptId * 3] = point[0];
          outData[ptId * 3 + 1] = point[1];
          outData[ptId * 3 + 2] = point[2];
          if (!vtkMath.arrayEqual(oldVector, point) && !modifiedVectorsArr.includes(iArr)) {
            modifiedVectorsArr.push(iArr);
          }
        }
      }
    }
    if (modifiedPoint) {
      outPoints.modified();
    }
    if (modifiedVector) {
      outVectors.modified();
    }
    if (modifiedNormal) {
      outNormals.modified();
    }
    modifiedVectorsArr.forEach((idx) => outVectorsArr[idx].modified());
  };
}
var DEFAULT_VALUES12 = {
  preMultiplyFlag: false,
  matrix: [...IDENTITY]
};
function extend12(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["preMultiplyFlag"]);
  macro.setGetArray(publicAPI, model, ["matrix"], 16);
  vtkTransform(publicAPI, model);
}
newInstance13 = macro.newInstance(extend12, "vtkTransform");
var vtkTransform$1 = {
  newInstance: newInstance13,
  extend: extend12
};

// node_modules/@kitware/vtk.js/Common/Transform.js
var Transform2 = {
  vtkLandmarkTransform: vtkLandmarkTransform$1,
  vtkTransform: vtkTransform$1
};

// node_modules/@kitware/vtk.js/Common/System/MobileVR/dpdb.json.js
var format = 1;
var last_updated = "2018-02-20T22:55:10Z";
var devices = [
  {
    type: "android",
    rules: [
      {
        mdmh: "asus/*/Nexus 7/*"
      },
      {
        ua: "Nexus 7"
      }
    ],
    dpi: [
      320.8,
      323
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "asus/*/ASUS_Z00AD/*"
      },
      {
        ua: "ASUS_Z00AD"
      }
    ],
    dpi: [
      403,
      404.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Google/*/Pixel XL/*"
      },
      {
        ua: "Pixel XL"
      }
    ],
    dpi: [
      537.9,
      533
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Google/*/Pixel/*"
      },
      {
        ua: "Pixel"
      }
    ],
    dpi: [
      432.6,
      436.7
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "HTC/*/HTC6435LVW/*"
      },
      {
        ua: "HTC6435LVW"
      }
    ],
    dpi: [
      449.7,
      443.3
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "HTC/*/HTC One XL/*"
      },
      {
        ua: "HTC One XL"
      }
    ],
    dpi: [
      315.3,
      314.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "htc/*/Nexus 9/*"
      },
      {
        ua: "Nexus 9"
      }
    ],
    dpi: 289,
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "HTC/*/HTC One M9/*"
      },
      {
        ua: "HTC One M9"
      }
    ],
    dpi: [
      442.5,
      443.3
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "HTC/*/HTC One_M8/*"
      },
      {
        ua: "HTC One_M8"
      }
    ],
    dpi: [
      449.7,
      447.4
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "HTC/*/HTC One/*"
      },
      {
        ua: "HTC One"
      }
    ],
    dpi: 472.8,
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Huawei/*/Nexus 6P/*"
      },
      {
        ua: "Nexus 6P"
      }
    ],
    dpi: [
      515.1,
      518
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LENOVO/*/Lenovo PB2-690Y/*"
      },
      {
        ua: "Lenovo PB2-690Y"
      }
    ],
    dpi: [
      457.2,
      454.713
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/Nexus 5X/*"
      },
      {
        ua: "Nexus 5X"
      }
    ],
    dpi: [
      422,
      419.9
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/LGMS345/*"
      },
      {
        ua: "LGMS345"
      }
    ],
    dpi: [
      221.7,
      219.1
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/LG-D800/*"
      },
      {
        ua: "LG-D800"
      }
    ],
    dpi: [
      422,
      424.1
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/LG-D850/*"
      },
      {
        ua: "LG-D850"
      }
    ],
    dpi: [
      537.9,
      541.9
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/VS985 4G/*"
      },
      {
        ua: "VS985 4G"
      }
    ],
    dpi: [
      537.9,
      535.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/Nexus 5/*"
      },
      {
        ua: "Nexus 5 B"
      }
    ],
    dpi: [
      442.4,
      444.8
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/Nexus 4/*"
      },
      {
        ua: "Nexus 4"
      }
    ],
    dpi: [
      319.8,
      318.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/LG-P769/*"
      },
      {
        ua: "LG-P769"
      }
    ],
    dpi: [
      240.6,
      247.5
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/LGMS323/*"
      },
      {
        ua: "LGMS323"
      }
    ],
    dpi: [
      206.6,
      204.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "LGE/*/LGLS996/*"
      },
      {
        ua: "LGLS996"
      }
    ],
    dpi: [
      403.4,
      401.5
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Micromax/*/4560MMX/*"
      },
      {
        ua: "4560MMX"
      }
    ],
    dpi: [
      240,
      219.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Micromax/*/A250/*"
      },
      {
        ua: "Micromax A250"
      }
    ],
    dpi: [
      480,
      446.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Micromax/*/Micromax AQ4501/*"
      },
      {
        ua: "Micromax AQ4501"
      }
    ],
    dpi: 240,
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/G5/*"
      },
      {
        ua: "Moto G (5) Plus"
      }
    ],
    dpi: [
      403.4,
      403
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/DROID RAZR/*"
      },
      {
        ua: "DROID RAZR"
      }
    ],
    dpi: [
      368.1,
      256.7
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT830C/*"
      },
      {
        ua: "XT830C"
      }
    ],
    dpi: [
      254,
      255.9
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1021/*"
      },
      {
        ua: "XT1021"
      }
    ],
    dpi: [
      254,
      256.7
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1023/*"
      },
      {
        ua: "XT1023"
      }
    ],
    dpi: [
      254,
      256.7
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1028/*"
      },
      {
        ua: "XT1028"
      }
    ],
    dpi: [
      326.6,
      327.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1034/*"
      },
      {
        ua: "XT1034"
      }
    ],
    dpi: [
      326.6,
      328.4
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1053/*"
      },
      {
        ua: "XT1053"
      }
    ],
    dpi: [
      315.3,
      316.1
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1562/*"
      },
      {
        ua: "XT1562"
      }
    ],
    dpi: [
      403.4,
      402.7
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/Nexus 6/*"
      },
      {
        ua: "Nexus 6 B"
      }
    ],
    dpi: [
      494.3,
      489.7
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1063/*"
      },
      {
        ua: "XT1063"
      }
    ],
    dpi: [
      295,
      296.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1064/*"
      },
      {
        ua: "XT1064"
      }
    ],
    dpi: [
      295,
      295.6
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1092/*"
      },
      {
        ua: "XT1092"
      }
    ],
    dpi: [
      422,
      424.1
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/XT1095/*"
      },
      {
        ua: "XT1095"
      }
    ],
    dpi: [
      422,
      423.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "motorola/*/G4/*"
      },
      {
        ua: "Moto G (4)"
      }
    ],
    dpi: 401,
    bw: 4,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "OnePlus/*/A0001/*"
      },
      {
        ua: "A0001"
      }
    ],
    dpi: [
      403.4,
      401
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "OnePlus/*/ONE E1005/*"
      },
      {
        ua: "ONE E1005"
      }
    ],
    dpi: [
      442.4,
      441.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "OnePlus/*/ONE A2005/*"
      },
      {
        ua: "ONE A2005"
      }
    ],
    dpi: [
      391.9,
      405.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "OnePlus/*/ONEPLUS A5000/*"
      },
      {
        ua: "ONEPLUS A5000 "
      }
    ],
    dpi: [
      403.411,
      399.737
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "OnePlus/*/ONE A5010/*"
      },
      {
        ua: "ONEPLUS A5010"
      }
    ],
    dpi: [
      403,
      400
    ],
    bw: 2,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "OPPO/*/X909/*"
      },
      {
        ua: "X909"
      }
    ],
    dpi: [
      442.4,
      444.1
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-I9082/*"
      },
      {
        ua: "GT-I9082"
      }
    ],
    dpi: [
      184.7,
      185.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G360P/*"
      },
      {
        ua: "SM-G360P"
      }
    ],
    dpi: [
      196.7,
      205.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/Nexus S/*"
      },
      {
        ua: "Nexus S"
      }
    ],
    dpi: [
      234.5,
      229.8
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-I9300/*"
      },
      {
        ua: "GT-I9300"
      }
    ],
    dpi: [
      304.8,
      303.9
    ],
    bw: 5,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-T230NU/*"
      },
      {
        ua: "SM-T230NU"
      }
    ],
    dpi: 216,
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SGH-T399/*"
      },
      {
        ua: "SGH-T399"
      }
    ],
    dpi: [
      217.7,
      231.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SGH-M919/*"
      },
      {
        ua: "SGH-M919"
      }
    ],
    dpi: [
      440.8,
      437.7
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-N9005/*"
      },
      {
        ua: "SM-N9005"
      }
    ],
    dpi: [
      386.4,
      387
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SAMSUNG-SM-N900A/*"
      },
      {
        ua: "SAMSUNG-SM-N900A"
      }
    ],
    dpi: [
      386.4,
      387.7
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-I9500/*"
      },
      {
        ua: "GT-I9500"
      }
    ],
    dpi: [
      442.5,
      443.3
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-I9505/*"
      },
      {
        ua: "GT-I9505"
      }
    ],
    dpi: 439.4,
    bw: 4,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G900F/*"
      },
      {
        ua: "SM-G900F"
      }
    ],
    dpi: [
      415.6,
      431.6
    ],
    bw: 5,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G900M/*"
      },
      {
        ua: "SM-G900M"
      }
    ],
    dpi: [
      415.6,
      431.6
    ],
    bw: 5,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G800F/*"
      },
      {
        ua: "SM-G800F"
      }
    ],
    dpi: 326.8,
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G906S/*"
      },
      {
        ua: "SM-G906S"
      }
    ],
    dpi: [
      562.7,
      572.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-I9300/*"
      },
      {
        ua: "GT-I9300"
      }
    ],
    dpi: [
      306.7,
      304.8
    ],
    bw: 5,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-T535/*"
      },
      {
        ua: "SM-T535"
      }
    ],
    dpi: [
      142.6,
      136.4
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-N920C/*"
      },
      {
        ua: "SM-N920C"
      }
    ],
    dpi: [
      515.1,
      518.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-N920P/*"
      },
      {
        ua: "SM-N920P"
      }
    ],
    dpi: [
      386.3655,
      390.144
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-N920W8/*"
      },
      {
        ua: "SM-N920W8"
      }
    ],
    dpi: [
      515.1,
      518.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-I9300I/*"
      },
      {
        ua: "GT-I9300I"
      }
    ],
    dpi: [
      304.8,
      305.8
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-I9195/*"
      },
      {
        ua: "GT-I9195"
      }
    ],
    dpi: [
      249.4,
      256.7
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SPH-L520/*"
      },
      {
        ua: "SPH-L520"
      }
    ],
    dpi: [
      249.4,
      255.9
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SAMSUNG-SGH-I717/*"
      },
      {
        ua: "SAMSUNG-SGH-I717"
      }
    ],
    dpi: 285.8,
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SPH-D710/*"
      },
      {
        ua: "SPH-D710"
      }
    ],
    dpi: [
      217.7,
      204.2
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/GT-N7100/*"
      },
      {
        ua: "GT-N7100"
      }
    ],
    dpi: 265.1,
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SCH-I605/*"
      },
      {
        ua: "SCH-I605"
      }
    ],
    dpi: 265.1,
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/Galaxy Nexus/*"
      },
      {
        ua: "Galaxy Nexus"
      }
    ],
    dpi: [
      315.3,
      314.2
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-N910H/*"
      },
      {
        ua: "SM-N910H"
      }
    ],
    dpi: [
      515.1,
      518
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-N910C/*"
      },
      {
        ua: "SM-N910C"
      }
    ],
    dpi: [
      515.2,
      520.2
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G130M/*"
      },
      {
        ua: "SM-G130M"
      }
    ],
    dpi: [
      165.9,
      164.8
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G928I/*"
      },
      {
        ua: "SM-G928I"
      }
    ],
    dpi: [
      515.1,
      518.4
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G920F/*"
      },
      {
        ua: "SM-G920F"
      }
    ],
    dpi: 580.6,
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G920P/*"
      },
      {
        ua: "SM-G920P"
      }
    ],
    dpi: [
      522.5,
      577
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G925F/*"
      },
      {
        ua: "SM-G925F"
      }
    ],
    dpi: 580.6,
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G925V/*"
      },
      {
        ua: "SM-G925V"
      }
    ],
    dpi: [
      522.5,
      576.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G930F/*"
      },
      {
        ua: "SM-G930F"
      }
    ],
    dpi: 576.6,
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G935F/*"
      },
      {
        ua: "SM-G935F"
      }
    ],
    dpi: 533,
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G950F/*"
      },
      {
        ua: "SM-G950F"
      }
    ],
    dpi: [
      562.707,
      565.293
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "samsung/*/SM-G955U/*"
      },
      {
        ua: "SM-G955U"
      }
    ],
    dpi: [
      522.514,
      525.762
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Sony/*/C6903/*"
      },
      {
        ua: "C6903"
      }
    ],
    dpi: [
      442.5,
      443.3
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Sony/*/D6653/*"
      },
      {
        ua: "D6653"
      }
    ],
    dpi: [
      428.6,
      427.6
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Sony/*/E6653/*"
      },
      {
        ua: "E6653"
      }
    ],
    dpi: [
      428.6,
      425.7
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Sony/*/E6853/*"
      },
      {
        ua: "E6853"
      }
    ],
    dpi: [
      403.4,
      401.9
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Sony/*/SGP321/*"
      },
      {
        ua: "SGP321"
      }
    ],
    dpi: [
      224.7,
      224.1
    ],
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*"
      },
      {
        ua: "ALCATEL ONE TOUCH Fierce"
      }
    ],
    dpi: [
      240,
      247.5
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "THL/*/thl 5000/*"
      },
      {
        ua: "thl 5000"
      }
    ],
    dpi: [
      480,
      443.3
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "Fly/*/IQ4412/*"
      },
      {
        ua: "IQ4412"
      }
    ],
    dpi: 307.9,
    bw: 3,
    ac: 1e3
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "ZTE/*/ZTE Blade L2/*"
      },
      {
        ua: "ZTE Blade L2"
      }
    ],
    dpi: 240,
    bw: 3,
    ac: 500
  },
  {
    type: "android",
    rules: [
      {
        mdmh: "BENEVE/*/VR518/*"
      },
      {
        ua: "VR518"
      }
    ],
    dpi: 480,
    bw: 3,
    ac: 500
  },
  {
    type: "ios",
    rules: [
      {
        res: [
          640,
          960
        ]
      }
    ],
    dpi: [
      325.1,
      328.4
    ],
    bw: 4,
    ac: 1e3
  },
  {
    type: "ios",
    rules: [
      {
        res: [
          640,
          1136
        ]
      }
    ],
    dpi: [
      317.1,
      320.2
    ],
    bw: 3,
    ac: 1e3
  },
  {
    type: "ios",
    rules: [
      {
        res: [
          750,
          1334
        ]
      }
    ],
    dpi: 326.4,
    bw: 4,
    ac: 1e3
  },
  {
    type: "ios",
    rules: [
      {
        res: [
          1242,
          2208
        ]
      }
    ],
    dpi: [
      453.6,
      458.4
    ],
    bw: 4,
    ac: 1e3
  },
  {
    type: "ios",
    rules: [
      {
        res: [
          1125,
          2001
        ]
      }
    ],
    dpi: [
      410.9,
      415.4
    ],
    bw: 4,
    ac: 1e3
  },
  {
    type: "ios",
    rules: [
      {
        res: [
          1125,
          2436
        ]
      }
    ],
    dpi: 458,
    bw: 4,
    ac: 1e3
  }
];
var dpdb = {
  format,
  last_updated,
  devices
};

// node_modules/@kitware/vtk.js/Common/System/MobileVR/headsets.js
var headsets = [{
  label: "Choose a headset"
}, {
  id: "CardboardV1",
  label: "Cardboard I/O 2014",
  fov: 40,
  interLensDistance: 0.06,
  baselineLensDistance: 0.035,
  screenLensDistance: 0.042,
  distortionCoefficients: [0.441, 0.156],
  inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
}, {
  id: "CardboardV2",
  label: "Cardboard I/O 2015",
  fov: 60,
  interLensDistance: 0.064,
  baselineLensDistance: 0.035,
  screenLensDistance: 0.039,
  distortionCoefficients: [0.34, 0.55],
  inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
}];

// node_modules/@kitware/vtk.js/Common/System/MobileVR.js
var userAgent = navigator.userAgent || navigator.vendor || window.opera;
var isMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4));
var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
var isWebViewAndroid = userAgent.indexOf("Version") !== -1 && userAgent.indexOf("Android") !== -1 && userAgent.indexOf("Chrome") !== -1;
var isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
var isFirefoxAndroid = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Android") !== -1;
var width = Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
var height = Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
var hardware = {
  width,
  height
};
function matchRules(rule, ua, screenWidth, screenHeight) {
  if (!rule.ua && !rule.res) return false;
  if (rule.ua && ua.indexOf(rule.ua) < 0) return false;
  if (rule.res) {
    if (!rule.res[0] || !rule.res[1]) return false;
    const [resX, resY] = rule.res;
    if (Math.min(screenWidth, screenHeight) !== Math.min(resX, resY) || Math.max(screenWidth, screenHeight) !== Math.max(resX, resY)) {
      return false;
    }
  }
  return true;
}
function extractDeviceParameters() {
  for (let i = 0; i < dpdb.devices.length; i++) {
    const device = dpdb.devices[i];
    if (!device.rules) {
      console.warn(`Device[${i}] has no rules section.`);
      continue;
    }
    if (device.type !== "ios" && device.type !== "android") {
      console.warn(`Device[${i}] has invalid type.`);
      continue;
    }
    if (isIOS !== (device.type === "ios")) {
      continue;
    }
    let matched = false;
    for (let j = 0; j < device.rules.length; j++) {
      const rule = device.rules[j];
      if (matchRules(rule, userAgent, width, height)) {
        matched = true;
        break;
      }
    }
    if (!matched) {
      continue;
    }
    hardware.xdpi = device.dpi[0] || device.dpi;
    hardware.ydpi = device.dpi[1] || device.dpi;
    hardware.bevelMm = device.bw;
  }
}
extractDeviceParameters();
function getVRHeadset() {
  return new Promise((resolve, reject) => {
    const body = document.querySelector("body");
    const selector = document.createElement("select");
    selector.innerHTML = headsets.map((headset, idx) => `<option value="${idx}">${headset.label}</option>`).join("");
    selector.style.zIndex = 1e3;
    selector.style.position = "absolute";
    selector.style.left = "50%";
    selector.style.top = "50%";
    selector.style.transform = "translate(-50%, -50%)";
    selector.addEventListener("change", (e2) => {
      body.removeChild(selector);
      resolve(headsets[Number(e2.target.value)]);
    });
    body.appendChild(selector);
  });
}
var vtkMobileVR = {
  isMobile,
  isIOS,
  isWebViewAndroid,
  isSafari,
  isFirefoxAndroid,
  hardware,
  getVRHeadset
};

// node_modules/@kitware/vtk.js/Common/System/TimerLog.js
function getUniversalTime() {
  return +/* @__PURE__ */ new Date();
}
var vtkTimerLog = {
  getUniversalTime
};

// node_modules/@kitware/vtk.js/Common/System.js
var System = {
  vtkMobileVR,
  vtkTimerLog
};

// node_modules/@kitware/vtk.js/Common/index.js
var Common = {
  Core,
  DataModel,
  Transform: Transform2,
  System
};

// node_modules/@kitware/vtk.js/Filters/Cornerstone/ImageDataToCornerstoneImage.js
var {
  vtkErrorMacro: vtkErrorMacro5
} = macro;
function vtkImageDataToCornerstoneImage(publicAPI, model) {
  model.classHierarchy.push("vtkImageDataToCornerstoneImage");
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input) {
      vtkErrorMacro5("Invalid or missing input");
      return;
    }
    const spacing = input.getSpacing();
    const dims = input.getDimensions();
    const scalars = input.getPointData().getScalars();
    const dataRange = scalars.getRange(0);
    const rawData = scalars.getData();
    let pixelData = null;
    if (dims[2] === 1) {
      pixelData = !scalars.data ? rawData : scalars.data;
    } else {
      const offset = model.sliceIndex * dims[0] * dims[1] * rawData.BYTES_PER_ELEMENT;
      pixelData = macro.newTypedArray(scalars.getDataType(), rawData.buffer, offset, dims[0] * dims[1]);
    }
    const cornerstoneImage = {
      imageId: model.imageId,
      color: scalars.getNumberOfComponents() > 1,
      columnPixelSpacing: spacing[0],
      columns: dims[0],
      width: dims[0],
      rowPixelSpacing: spacing[1],
      rows: dims[1],
      height: dims[1],
      intercept: 0,
      invert: false,
      minPixelValue: dataRange[0],
      maxPixelValue: dataRange[1],
      sizeInBytes: pixelData.length * pixelData.BYTES_PER_ELEMENT,
      slope: 1,
      windowCenter: Math.round((dataRange[0] + dataRange[1]) / 2),
      windowWidth: dataRange[1] - dataRange[0],
      decodeTimeInMS: 0,
      getPixelData() {
        return pixelData;
      }
    };
    outData[0] = cornerstoneImage;
  };
}
var DEFAULT_VALUES13 = {
  imageId: "default-image-id",
  sliceIndex: 0
};
function extend13(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["imageId", "sliceIndex"]);
  macro.algo(publicAPI, model, 1, 1);
  vtkImageDataToCornerstoneImage(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend13, "vtkImageDataToCornerstoneImage");
var vtkImageDataToCornerstoneImage$1 = {
  newInstance: newInstance14,
  extend: extend13
};

// node_modules/@kitware/vtk.js/Filters/Cornerstone.js
var Cornerstone = {
  vtkImageDataToCornerstoneImage: vtkImageDataToCornerstoneImage$1
};

// node_modules/@kitware/vtk.js/Common/DataModel/Locator.js
function vtkLocator(publicAPI, model) {
  model.classHierarchy.push("vtkLocator");
}
var DEFAULT_VALUES14 = {
  dataSet: null,
  maxLevel: 8,
  // TODO: clamp 0, Number.MAX_VALUE
  level: 8,
  automatic: false,
  tolerance: 0,
  // TODO: clamp 0.0, Number.MAX_VALUE
  useExistingSearchStructure: false
};
function extend14(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["level"]);
  macro.setGet(publicAPI, model, ["dataSet", "maxLevel", "automatic", "tolerance", "useExistingSearchStructure"]);
  vtkLocator(publicAPI, model);
}
var vtkLocator$1 = {
  extend: extend14
};

// node_modules/@kitware/vtk.js/Common/DataModel/AbstractPointLocator.js
function vtkAbstractPointLocator(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractPointLocator");
}
function defaultValues(initialValues) {
  return {
    bounds: null,
    numberOfBuckets: 0,
    ...initialValues
  };
}
function extend15(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkLocator$1.extend(publicAPI, model, defaultValues(initialValues));
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["numberOfBuckets"]);
  macro.setGetArray(publicAPI, model, ["bounds"], 6);
  vtkAbstractPointLocator(publicAPI, model);
}
var vtkAbstractPointLocator$1 = {
  extend: extend15
};

// node_modules/@kitware/vtk.js/Common/DataModel/PointLocator.js
var {
  vtkErrorMacro: vtkErrorMacro6
} = macro;
function vtkPointLocator(publicAPI, model) {
  model.classHierarchy.push("vtkPointLocator");
  function distance2ToBucket(x, nei) {
    const bounds2 = [nei[0] * model.HX + model.BX, (nei[0] + 1) * model.HX + model.BX, nei[1] * model.HY + model.BY, (nei[1] + 1) * model.HY + model.BY, nei[2] * model.HZ + model.BZ, (nei[2] + 1) * model.HZ + model.BZ];
    return vtkBoundingBox.distance2ToBounds(x, bounds2);
  }
  function getBucketNeighbors(ijk, ndivs, level) {
    const buckets = [];
    if (level === 0) {
      buckets.push([...ijk]);
      return buckets;
    }
    const minLevel = [];
    const maxLevel = [];
    for (let i = 0; i < 3; i++) {
      const min = ijk[i] - level;
      const max2 = ijk[i] + level;
      minLevel[i] = min > 0 ? min : 0;
      maxLevel[i] = max2 < ndivs[i] - 1 ? max2 : ndivs[i] - 1;
    }
    for (let i = minLevel[0]; i <= maxLevel[0]; i++) {
      for (let j = minLevel[1]; j <= maxLevel[1]; j++) {
        for (let k = minLevel[2]; k <= maxLevel[2]; k++) {
          if (i === ijk[0] + level || i === ijk[0] - level || j === ijk[1] + level || j === ijk[1] - level || k === ijk[2] + level || k === ijk[2] - level) {
            buckets.push([i, j, k]);
          }
        }
      }
    }
    return buckets;
  }
  function getOverlappingBuckets(x, ijk, dist, level) {
    const buckets = [];
    const xBounds = [x[0], x[0], x[1], x[1], x[2], x[2]];
    const bbox = vtkBoundingBox.newInstance();
    bbox.setBounds(xBounds);
    bbox.inflate(dist);
    const ijkBounds = [ijk[0], ijk[0], ijk[1], ijk[1], ijk[2], ijk[2]];
    const ijkBox = vtkBoundingBox.newInstance();
    ijkBox.setBounds(ijkBounds);
    ijkBox.inflate(level);
    const minLevel = publicAPI.getBucketIndices([bbox.getBounds()[0], bbox.getBounds()[2], bbox.getBounds()[4]]);
    const maxLevel = publicAPI.getBucketIndices([bbox.getBounds()[1], bbox.getBounds()[3], bbox.getBounds()[5]]);
    for (let i = minLevel[0]; i <= maxLevel[0]; i++) {
      for (let j = minLevel[1]; j <= maxLevel[1]; j++) {
        for (let k = minLevel[2]; k <= maxLevel[2]; k++) {
          if (!ijkBox.containsPoint(i, j, k)) {
            buckets.push([i, j, k]);
          }
        }
      }
    }
    return buckets;
  }
  function getBucketIndex(ijk) {
    return ijk[0] + ijk[1] * model.XD + ijk[2] * model.sliceSize;
  }
  publicAPI.getBucketIndices = (point) => {
    const ix = Math.floor((point[0] - model.BX) * model.FX);
    const iy = Math.floor((point[1] - model.BY) * model.FY);
    const iz = Math.floor((point[2] - model.BZ) * model.FZ);
    const ijk = [];
    ijk[0] = Math.max(0, Math.min(ix, model.XD - 1));
    ijk[1] = Math.max(0, Math.min(iy, model.YD - 1));
    ijk[2] = Math.max(0, Math.min(iz, model.ZD - 1));
    return ijk;
  };
  publicAPI.getBucketIndex = (point) => {
    const ijk = publicAPI.getBucketIndices(point);
    return getBucketIndex(ijk);
  };
  publicAPI.buildLocator = () => {
    model.level = 1;
    const bounds2 = model.dataSet.getBounds();
    const numPts = model.dataSet.getNumberOfPoints();
    let numBuckets = Math.ceil(numPts / model.numberOfPointsPerBucket);
    const ndivs = [0, 0, 0];
    const bbox = vtkBoundingBox.newInstance();
    bbox.setBounds(bounds2);
    if (model.automatic) {
      bbox.computeDivisions(numBuckets, ndivs, model.bounds);
    } else {
      model.bounds = bbox.inflate();
      for (let i = 0; i < 3; i++) {
        ndivs[i] = Math.max(1, model.divisions[i]);
      }
    }
    model.divisions = ndivs;
    numBuckets = ndivs[0] * ndivs[1] * ndivs[2];
    model.numberOfBuckets = numBuckets;
    for (let i = 0; i < 3; ++i) {
      model.H[i] = (model.bounds[2 * i + 1] - model.bounds[2 * i]) / ndivs[i];
    }
    model.hashTable.clear();
    publicAPI.computePerformanceFactors();
    for (let i = 0; i < numPts; ++i) {
      const pt = model.dataSet.getPoints().getPoint(i);
      const key = publicAPI.getBucketIndex(pt);
      if (!model.hashTable.has(key)) {
        model.hashTable.set(key, []);
      }
      const bucket = model.hashTable.get(key);
      bucket.push(i);
    }
  };
  publicAPI.initialize = () => {
    model.points = null;
    publicAPI.freeSearchStructure();
  };
  publicAPI.initPointInsertion = function(points, bounds2) {
    let estNumPts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (points == null) {
      vtkErrorMacro6("A valid vtkPoints object is required for point insertion");
      return false;
    }
    if (!bounds2 || bounds2.length !== 6) {
      vtkErrorMacro6("A valid bounds array of length 6 is required");
      return false;
    }
    if (!points) {
      vtkErrorMacro6("A valid vtkPoints is required for point insertion");
      return false;
    }
    publicAPI.freeSearchStructure();
    model.insertionPointId = 0;
    model.points = points;
    model.points.setNumberOfComponents(3);
    model.points.initialize();
    let numBuckets = 0;
    const ndivs = [0, 0, 0];
    const bbox = vtkBoundingBox.newInstance();
    bbox.setBounds(bounds2);
    if (model.automatic && estNumPts > 0) {
      numBuckets = Math.ceil(estNumPts / model.numberOfPointsPerBucket);
      bbox.computeDivisions(numBuckets, ndivs, model.bounds);
    } else {
      model.bounds = bbox.inflate();
      for (let i = 0; i < 3; i++) {
        ndivs[i] = Math.max(1, model.divisions[i]);
      }
    }
    model.divisions = ndivs;
    numBuckets = ndivs[0] * ndivs[1] * ndivs[2];
    model.numberOfBuckets = numBuckets;
    for (let i = 0; i < 3; ++i) {
      model.H[i] = (model.bounds[2 * i + 1] - model.bounds[2 * i]) / ndivs[i];
    }
    model.insertionTol2 = model.tolerance * model.tolerance;
    let maxDivs = 0;
    let hmin = Number.MAX_VALUE;
    for (let i = 0; i < 3; i++) {
      hmin = model.H[i] < hmin ? model.H[i] : hmin;
      maxDivs = maxDivs > model.divisions[i] ? maxDivs : model.divisions[i];
    }
    model.insertionLevel = Math.ceil(model.tolerance / hmin);
    model.insertionLevel = model.insertionLevel > maxDivs ? maxDivs : model.insertionLevel;
    publicAPI.computePerformanceFactors();
    return true;
  };
  publicAPI.insertPoint = (ptId, x) => {
    const key = publicAPI.getBucketIndex(x);
    if (!model.hashTable.has(key)) {
      model.hashTable.set(key, []);
    }
    const bucket = model.hashTable.get(key);
    bucket.push(ptId);
    model.points.insertPoint(ptId, x);
    return {
      inserted: true,
      id: ptId
    };
  };
  publicAPI.insertNextPoint = (x) => {
    const key = publicAPI.getBucketIndex(x);
    if (!model.hashTable.has(key)) {
      model.hashTable.set(key, []);
    }
    const bucket = model.hashTable.get(key);
    bucket.push(model.insertionPointId);
    model.points.insertPoint(model.insertionPointId, x);
    return {
      inserted: true,
      id: model.insertionPointId++
    };
  };
  publicAPI.insertUniquePoint = (x) => {
    const ptId = publicAPI.isInsertedPoint(x);
    if (ptId > -1) {
      return {
        inserted: false,
        id: ptId
      };
    }
    const ret = publicAPI.insertNextPoint(x);
    return ret;
  };
  publicAPI.isInsertedPoint = (x) => {
    const ijk = publicAPI.getBucketIndices(x);
    const insertionLevel = model.insertionLevel ?? 1;
    const numDivs = model.divisions;
    for (let lvtk = 0; lvtk <= insertionLevel; lvtk++) {
      const buckets = getBucketNeighbors(ijk, numDivs, lvtk);
      for (let i = 0; i < buckets.length; i++) {
        const nei = buckets[i];
        const key = getBucketIndex(nei);
        const bucket = model.hashTable.get(key);
        if (bucket) {
          for (let j = 0; j < bucket.length; j++) {
            const ptId = bucket[j];
            const pt = model.points.getPoint(ptId);
            if (vtkMath.distance2BetweenPoints(x, pt) <= model.insertionTol2) {
              return ptId;
            }
          }
        }
      }
    }
    return -1;
  };
  publicAPI.findClosestPoint = (x) => {
    publicAPI.buildLocator();
    const ijk = publicAPI.getBucketIndices(x);
    const numDivs = model.divisions;
    let minDist2 = Number.MAX_VALUE;
    let closest = -1;
    const maxLevel = Math.max(...numDivs);
    for (let level = 0; level < maxLevel && closest === -1; level++) {
      const neighbors = getBucketNeighbors(ijk, numDivs, level);
      for (let n = 0; n < neighbors.length; n++) {
        const key = getBucketIndex(neighbors[n]);
        const bucket = model.hashTable.get(key);
        if (bucket) {
          for (let b2 = 0; b2 < bucket.length; b2++) {
            const ptId = bucket[b2];
            const pt = model.dataSet.getPoints().getPoint(ptId);
            const dist2 = vtkMath.distance2BetweenPoints(x, pt);
            if (dist2 < minDist2) {
              minDist2 = dist2;
              closest = ptId;
            }
          }
        }
      }
    }
    return closest;
  };
  publicAPI.findClosestPointWithinRadius = function(radius, x) {
    let inputDataLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    publicAPI.buildLocator();
    let closest = -1;
    const radius2 = radius * radius;
    let minDist2 = 1.01 * radius2;
    let dist2 = -1;
    const ijk = publicAPI.getBucketIndices(x);
    const key = getBucketIndex(ijk);
    const bucket = model.hashTable.get(key);
    if (bucket) {
      for (let j = 0; j < bucket.length; j++) {
        const ptId = bucket[j];
        const pt = model.dataSet.getPoints().getPoint(ptId);
        const d2 = vtkMath.distance2BetweenPoints(x, pt);
        if (d2 < minDist2) {
          closest = ptId;
          minDist2 = d2;
          dist2 = d2;
        }
      }
    }
    let refinedRadius;
    let refinedRadius2;
    if (minDist2 < radius2) {
      refinedRadius = Math.sqrt(dist2);
      refinedRadius2 = dist2;
    } else {
      refinedRadius = radius;
      refinedRadius2 = radius2;
    }
    if (inputDataLength !== 0) {
      const distance2ToDataBounds = vtkBoundingBox.distance2ToBounds(x, model.bounds);
      const maxDistance = Math.sqrt(distance2ToDataBounds) + inputDataLength;
      if (refinedRadius > maxDistance) {
        refinedRadius = maxDistance;
        refinedRadius2 = maxDistance * maxDistance;
      }
    }
    const radiusLevels = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      radiusLevels[i] = Math.floor(refinedRadius / model.H[i]);
      if (radiusLevels[i] > model.divisions[i] / 2) {
        radiusLevels[i] = Math.floor(model.divisions[i] / 2);
      }
    }
    let radiusLevel = Math.max(...radiusLevels);
    if (radiusLevel === 0) {
      radiusLevel = 1;
    }
    for (let ii = radiusLevel; ii >= 1; ii--) {
      const currentRadius = refinedRadius;
      const buckets = getOverlappingBuckets(x, ijk, refinedRadius / ii, ii);
      for (let i = 0; i < buckets.length; i++) {
        const nei = buckets[i];
        const d2ToBucket = distance2ToBucket(x, nei);
        if (d2ToBucket < refinedRadius2) {
          const key1 = getBucketIndex(nei);
          const bucket1 = model.hashTable.get(key1);
          if (bucket1) {
            for (let j = 0; j < bucket1.length; j++) {
              const ptId = bucket1[j];
              const pt = model.dataSet.getPoints().getPoint(ptId);
              if (pt) {
                const d2 = vtkMath.distance2BetweenPoints(x, pt);
                if (d2 < minDist2) {
                  closest = ptId;
                  minDist2 = d2;
                  refinedRadius = Math.sqrt(minDist2);
                  refinedRadius2 = minDist2;
                  dist2 = d2;
                }
              }
            }
          }
        }
      }
      if (refinedRadius < currentRadius && ii > 2) {
        ii = Math.floor(ii * (refinedRadius / currentRadius)) + 1;
        if (ii < 2) {
          ii = 2;
        }
      }
    }
    if (closest !== -1 && minDist2 <= radius * radius) {
      dist2 = minDist2;
    } else {
      closest = -1;
    }
    return {
      id: closest,
      dist2
    };
  };
  publicAPI.findClosestInsertedPoint = (x) => {
    for (let i = 0; i < 3; i++) {
      if (x[i] < model.bounds[2 * i] || x[i] > model.bounds[2 * i + 1]) {
        return -1;
      }
    }
    const ijk = publicAPI.getBucketIndices(x);
    const numDivs = model.divisions;
    let closest = -1;
    let minDist2 = Number.MAX_VALUE;
    let level = 0;
    const maxLevel = Math.max(numDivs[0], numDivs[1], numDivs[2]);
    const points = model.points;
    for (; closest === -1 && level < maxLevel; level++) {
      const neighbors = getBucketNeighbors(ijk, numDivs, level);
      for (let i = 0; i < neighbors.length; i++) {
        const nei = neighbors[i];
        const cno = nei[0] + nei[1] * model.XD + nei[2] * model.sliceSize;
        const bucket = model.hashTable.get(cno);
        if (bucket) {
          for (let j = 0; j < bucket.length; j++) {
            const ptId = bucket[j];
            const pt = points.getPoint(ptId);
            const dist2 = vtkMath.distance2BetweenPoints(x, pt);
            if (dist2 < minDist2) {
              closest = ptId;
              minDist2 = dist2;
            }
          }
        }
      }
    }
    const refineNeighbors = getBucketNeighbors(ijk, numDivs, level);
    for (let i = 0; i < refineNeighbors.length; i++) {
      const nei = refineNeighbors[i];
      let dist2 = 0;
      for (let j = 0; j < 3; j++) {
        if (ijk[j] !== nei[j]) {
          const MULTIPLES = ijk[j] > nei[j] ? nei[j] + 1 : nei[j];
          const diff = model.bounds[2 * j] + MULTIPLES * model.H[j] - x[j];
          dist2 += diff * diff;
        }
      }
      if (dist2 < minDist2) {
        const cno = nei[0] + nei[1] * model.XD + nei[2] * model.sliceSize;
        const bucket = model.hashTable.get(cno);
        if (bucket) {
          for (let j = 0; j < bucket.length; j++) {
            const ptId = bucket[j];
            const pt = points.getPoint(ptId);
            const d2 = vtkMath.distance2BetweenPoints(x, pt);
            if (d2 < minDist2) {
              closest = ptId;
              minDist2 = d2;
            }
          }
        }
      }
    }
    return closest;
  };
  publicAPI.getPointsInBucket = (x) => {
    publicAPI.buildLocator();
    const key = publicAPI.getBucketIndex(x);
    const bucket = model.hashTable.get(key);
    if (!bucket) return [];
    return bucket;
  };
  publicAPI.freeSearchStructure = () => {
    model.hashTable.clear();
    model.points = vtkPoints$1.newInstance();
    model.divisions = [50, 50, 50];
    vtkMath.uninitializeBounds(model.bounds);
  };
  publicAPI.computePerformanceFactors = () => {
    model.HX = model.H[0];
    model.HY = model.H[1];
    model.HZ = model.H[2];
    model.FX = 1 / model.H[0];
    model.FY = 1 / model.H[1];
    model.FZ = 1 / model.H[2];
    model.BX = model.bounds[0];
    model.BY = model.bounds[2];
    model.BZ = model.bounds[4];
    model.XD = model.divisions[0];
    model.YD = model.divisions[1];
    model.ZD = model.divisions[2];
    model.sliceSize = model.divisions[0] * model.divisions[1];
  };
  publicAPI.generateRepresentation = (polydata) => {
    if (!model.hashTable || model.hashTable.size === 0) {
      vtkErrorMacro6("Can't build representation, no data provided!");
      return;
    }
    const facePts = [];
    facePts.length = 4;
    function generateFace(face, i, j, k, pts2, polys2) {
      const x0 = model.bounds[0] + i * model.HX;
      const y0 = model.bounds[2] + j * model.HY;
      const z0 = model.bounds[4] + k * model.HZ;
      const x1 = x0 + model.HX;
      const y1 = y0 + model.HY;
      const z1 = z0 + model.HZ;
      if (face === 0) {
        facePts[0] = [x0, y0, z0];
        facePts[1] = [x0, y1, z0];
        facePts[2] = [x0, y1, z1];
        facePts[3] = [x0, y0, z1];
      } else if (face === 1) {
        facePts[0] = [x0, y0, z0];
        facePts[1] = [x1, y0, z0];
        facePts[2] = [x1, y0, z1];
        facePts[3] = [x0, y0, z1];
      } else if (face === 2) {
        facePts[0] = [x0, y0, z0];
        facePts[1] = [x1, y0, z0];
        facePts[2] = [x1, y1, z0];
        facePts[3] = [x0, y1, z0];
      }
      const ptIds = facePts.map((pt) => pts2.insertNextPoint(...pt));
      polys2.insertNextCell([ptIds[0], ptIds[1], ptIds[2], ptIds[3]]);
    }
    const pts = vtkPoints$1.newInstance();
    pts.allocate(5e3);
    const polys = vtkCellArray$1.newInstance();
    polys.allocate(2048);
    const divisions = model.divisions;
    const sliceSize = divisions[0] * divisions[1];
    function hasBucket(i, j, k) {
      if (i < 0 || i >= divisions[0] || j < 0 || j >= divisions[1] || k < 0 || k >= divisions[2]) {
        return false;
      }
      const idx = i + j * divisions[0] + k * sliceSize;
      return model.hashTable.has(idx);
    }
    for (let k = 0; k < divisions[2]; k++) {
      for (let j = 0; j < divisions[1]; j++) {
        for (let i = 0; i < divisions[0]; i++) {
          const idx = i + j * divisions[0] + k * sliceSize;
          const inside = model.hashTable.has(idx);
          for (let axis = 0; axis < 3; axis++) {
            let ni = i;
            let nj = j;
            let nk = k;
            if (axis === 0) ni = i - 1;
            if (axis === 1) nj = j - 1;
            if (axis === 2) nk = k - 1;
            const neighborInside = hasBucket(ni, nj, nk);
            if (ni < 0 || nj < 0 || nk < 0) {
              if (inside) {
                generateFace(axis, i, j, k, pts, polys);
              }
            } else if (neighborInside && !inside || !neighborInside && inside) {
              generateFace(axis, i, j, k, pts, polys);
            }
          }
          if (i + 1 >= divisions[0] && inside) {
            generateFace(0, i + 1, j, k, pts, polys);
          }
          if (j + 1 >= divisions[1] && inside) {
            generateFace(1, i, j + 1, k, pts, polys);
          }
          if (k + 1 >= divisions[2] && inside) {
            generateFace(2, i, j, k + 1, pts, polys);
          }
        }
      }
    }
    polydata.setPoints(pts);
    polydata.setPolys(polys);
  };
}
function defaultValues2(initialValues) {
  return {
    divisions: [50, 50, 50],
    numberOfPointsPerBucket: 3,
    bounds: [0, 0, 0, 0, 0, 0],
    tolerance: 1e-3,
    automatic: true,
    ...initialValues
  };
}
function extend16(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkAbstractPointLocator$1.extend(publicAPI, model, defaultValues2(initialValues));
  macro.setGet(publicAPI, model, ["numberOfPointsPerBucket", "points"]);
  macro.setGetArray(publicAPI, model, ["divisions"], 3);
  vtkMath.uninitializeBounds(model.bounds);
  model.points = model.points || vtkPoints$1.newInstance();
  model.hashTable = /* @__PURE__ */ new Map();
  model.H = [0, 0, 0];
  model.insertionPointId = 0;
  model.insertionTol2 = 1e-4;
  model.insertionLevel = 0;
  vtkPointLocator(publicAPI, model);
}
var newInstance15 = macro.newInstance(extend16, "vtkPointLocator");
var vtkPointLocator$1 = {
  newInstance: newInstance15,
  extend: extend16
};

// node_modules/@kitware/vtk.js/Common/DataModel/MergePoints.js
var {
  vtkErrorMacro: vtkErrorMacro7
} = macro;
function findPointInBucket(bucketIds, points, x) {
  const data2 = points.getData();
  for (let i = 0; i < bucketIds.length; ++i) {
    const ptId = bucketIds[i];
    const idx = ptId * 3;
    if (x[0] === data2[idx] && x[1] === data2[idx + 1] && x[2] === data2[idx + 2]) {
      return ptId;
    }
  }
  return -1;
}
function vtkMergePoints(publicAPI, model) {
  model.classHierarchy.push("vtkMergePoints");
  publicAPI.isInsertedPoint = (x) => {
    const idx = publicAPI.getBucketIndex(x);
    const bucketIds = model.hashTable.get(idx);
    if (bucketIds) {
      return findPointInBucket(bucketIds, model.points, x);
    }
    return -1;
  };
  publicAPI.insertUniquePoint = (x) => {
    if (!x || x.length !== 3) {
      vtkErrorMacro7("Point must be a Vector3.");
      return {
        inserted: false,
        id: -1
      };
    }
    const idx = publicAPI.getBucketIndex(x);
    let bucketIds = model.hashTable.get(idx);
    let id = null;
    if (bucketIds !== void 0) {
      const ptId = findPointInBucket(bucketIds, model.points, x);
      if (ptId !== -1) {
        id = ptId;
        return {
          inserted: false,
          id
        };
      }
    } else {
      bucketIds = [];
      model.hashTable.set(idx, bucketIds);
    }
    bucketIds.push(model.insertionPointId);
    model.points.insertNextPoint(...x);
    id = model.insertionPointId++;
    return {
      inserted: true,
      id
    };
  };
}
function defaultValues3(initialValues) {
  return {
    // points: null,
    // hashTable: null,
    ...initialValues
  };
}
function extend17(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkPointLocator$1.extend(publicAPI, model, defaultValues3(initialValues));
  macro.obj(publicAPI, model);
  vtkMergePoints(publicAPI, model);
}
var newInstance16 = macro.newInstance(extend17, "vtkMergePoints");
var vtkMergePoints$1 = {
  newInstance: newInstance16,
  extend: extend17
};

// node_modules/@kitware/vtk.js/Filters/Core/CleanPolyData.js
function vtkCleanPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkCleanPolyData");
  const tempX = [];
  function processPoint(ptId, inPts, newPts, inputPD, outputPD, pointMap, numUsedPts) {
    const newX = [0, 0, 0];
    inPts.getPoint(ptId, tempX);
    publicAPI.operateOnPoint(tempX, newX);
    if (!model.pointMerging) {
      if (pointMap[ptId] === -1) {
        pointMap[ptId] = numUsedPts.value++;
        newPts.setPoint(pointMap[ptId], newX);
        outputPD.passData(inputPD, ptId, pointMap[ptId]);
      }
      return pointMap[ptId];
    }
    const newPtId = model._locator.insertUniquePoint(newX).id;
    if (!model.copiedPoints.has(newPtId)) {
      model.copiedPoints.add(newPtId);
      outputPD.passData(inputPD, ptId, newPtId);
    }
    return newPtId;
  }
  publicAPI.operateOnPoint = (inPt, outPt) => {
    outPt[0] = inPt[0];
    outPt[1] = inPt[1];
    outPt[2] = inPt[2];
  };
  publicAPI.operateOnBounds = (inBounds, outBounds) => {
    vtkBoundingBox.setBounds(outBounds, inBounds);
  };
  publicAPI.createDefaultLocator = (input) => {
    var _a, _b;
    let tol;
    if (model.toleranceIsAbsolute) {
      tol = model.absoluteTolerance;
    } else if (input) {
      tol = model.tolerance * input.getLength();
    } else {
      tol = model.tolerance;
    }
    if (!model._locator) {
      model._locator = tol === 0 ? vtkMergePoints$1.newInstance() : vtkPointLocator$1.newInstance();
      return;
    }
    if (tol === 0 && ((_a = model._locator) == null ? void 0 : _a.getTolerance()) !== 0) {
      model._locator = vtkMergePoints$1.newInstance();
    } else if (tol > 0 && !(((_b = model._locator) == null ? void 0 : _b.getTolerance()) > 0)) {
      model._locator = vtkPointLocator$1.newInstance();
    }
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    outData[0] = output;
    const inPts = input.getPoints();
    const numPts = input.getNumberOfPoints();
    if (!inPts || numPts < 1) {
      return;
    }
    const updatedPts = new Array(input.getMaxCellSize());
    const numUsedPts = {
      value: 0
    };
    const precision = model.outputPointsPrecision;
    let pointType = inPts.getDataType();
    if (precision) {
      pointType = precision === DesiredOutputPrecision.DOUBLE ? VtkDataTypes.DOUBLE : VtkDataTypes.FLOAT;
    }
    const newPts = vtkPoints$1.newInstance({
      dataType: pointType
    });
    const inVerts = input.getVerts();
    const inLines = input.getLines();
    const inPolys = input.getPolys();
    const inStrips = input.getStrips();
    let newVerts = null;
    let newLines = null;
    let newPolys = null;
    let newStrips = null;
    const inputPD = input.getPointData();
    const inputCD = input.getCellData();
    const outputPD = output.getPointData();
    const outputCD = output.getCellData();
    let pointMap = null;
    if (model.pointMerging) {
      publicAPI.createDefaultLocator(input);
      if (model.toleranceIsAbsolute) {
        model._locator.setTolerance(model.absoluteTolerance);
      } else {
        model._locator.setTolerance(model.tolerance * input.getLength());
      }
      const originalBounds = input.getBounds();
      const mappedBounds = [];
      publicAPI.operateOnBounds(originalBounds, mappedBounds);
      model._locator.initPointInsertion(newPts, mappedBounds);
    } else {
      pointMap = new Array(numPts).fill(-1);
    }
    outputPD.copyStructure(inputPD);
    outputCD.copyStructure(inputCD);
    model.copiedPoints.clear();
    let outLineData = null;
    let outPolyData = null;
    let outStrpData = null;
    let vertIDcounter = 0;
    let lineIDcounter = 0;
    let polyIDcounter = 0;
    let strpIDcounter = 0;
    let inCellID = 0;
    if (inVerts && inVerts.getNumberOfCells() > 0) {
      newVerts = vtkCellArray$1.newInstance();
      let currentIdx = 0;
      const cellData = inVerts.getData();
      while (currentIdx < cellData.length) {
        const npts = cellData[currentIdx++];
        const inputPointIds = cellData.slice(currentIdx, currentIdx + npts);
        currentIdx += npts;
        let numNewPts = 0;
        for (let i = 0; i < inputPointIds.length; i++) {
          const ptId = inputPointIds[i];
          const newPtId = processPoint(ptId, inPts, newPts, inputPD, outputPD, pointMap, numUsedPts);
          updatedPts[numNewPts++] = newPtId;
        }
        if (numNewPts > 0) {
          newVerts.insertNextCell(updatedPts.slice(0, numNewPts));
          outputCD.passData(inputCD, inCellID, vertIDcounter);
          vertIDcounter++;
        }
        inCellID++;
      }
    }
    if (inLines && inLines.getNumberOfCells() > 0) {
      newLines = vtkCellArray$1.newInstance();
      let currentIdx = 0;
      const cellData = inLines.getData();
      while (currentIdx < cellData.length) {
        const npts = cellData[currentIdx++];
        const inputPointIds = cellData.slice(currentIdx, currentIdx + npts);
        currentIdx += npts;
        let numNewPts = 0;
        for (let i = 0; i < inputPointIds.length; i++) {
          const ptId = inputPointIds[i];
          const newPtId = processPoint(ptId, inPts, newPts, inputPD, outputPD, pointMap, numUsedPts);
          if (i === 0 || newPtId !== updatedPts[numNewPts - 1]) {
            updatedPts[numNewPts++] = newPtId;
          }
        }
        if (numNewPts >= 2) {
          newLines.insertNextCell(updatedPts.slice(0, numNewPts));
          if (!outLineData) {
            outLineData = [];
          }
          outLineData.push({
            inputId: inCellID,
            outputId: lineIDcounter
          });
          lineIDcounter++;
        } else if (numNewPts === 1 && (inputPointIds.length === numNewPts || model.convertLinesToPoints)) {
          if (!newVerts) {
            newVerts = vtkCellArray$1.newInstance();
          }
          newVerts.insertNextCell(updatedPts.slice(0, numNewPts));
          outputCD.passData(inputCD, inCellID, vertIDcounter);
          vertIDcounter++;
        }
        inCellID++;
      }
    }
    if (inPolys && inPolys.getNumberOfCells() > 0) {
      newPolys = vtkCellArray$1.newInstance();
      let currentIdx = 0;
      const cellData = inPolys.getData();
      while (currentIdx < cellData.length) {
        const npts = cellData[currentIdx++];
        const inputPointIds = cellData.slice(currentIdx, currentIdx + npts);
        currentIdx += npts;
        let numNewPts = 0;
        for (let i = 0; i < inputPointIds.length; i++) {
          const ptId = inputPointIds[i];
          const newPtId = processPoint(ptId, inPts, newPts, inputPD, outputPD, pointMap, numUsedPts);
          if (i === 0 || newPtId !== updatedPts[numNewPts - 1]) {
            updatedPts[numNewPts++] = newPtId;
          }
        }
        if (numNewPts > 2 && updatedPts[0] === updatedPts[numNewPts - 1]) {
          numNewPts--;
        }
        if (numNewPts > 2) {
          newPolys.insertNextCell(updatedPts.slice(0, numNewPts));
          if (!outPolyData) {
            outPolyData = [];
          }
          outPolyData.push({
            inputId: inCellID,
            outputId: polyIDcounter
          });
          polyIDcounter++;
        } else if (numNewPts === 2 && (inputPointIds.length === numNewPts || model.convertPolysToLines)) {
          if (!newLines) {
            newLines = vtkCellArray$1.newInstance();
            outLineData = [];
          }
          newLines.insertNextCell(updatedPts.slice(0, numNewPts));
          outLineData.push({
            inputId: inCellID,
            outputId: lineIDcounter
          });
          lineIDcounter++;
        } else if (numNewPts === 1 && (inputPointIds.length === numNewPts || model.convertLinesToPoints)) {
          if (!newVerts) {
            newVerts = vtkCellArray$1.newInstance();
          }
          newVerts.insertNextCell(updatedPts.slice(0, numNewPts));
          outputCD.passData(inputCD, inCellID, vertIDcounter);
          vertIDcounter++;
        }
        inCellID++;
      }
    }
    if (inStrips && inStrips.getNumberOfCells() > 0) {
      newStrips = vtkCellArray$1.newInstance();
      let currentIdx = 0;
      const cellData = inStrips.getData();
      while (currentIdx < cellData.length) {
        const npts = cellData[currentIdx++];
        const inputPointIds = cellData.slice(currentIdx, currentIdx + npts);
        currentIdx += npts;
        let numNewPts = 0;
        for (let i = 0; i < inputPointIds.length; i++) {
          const ptId = inputPointIds[i];
          const newPtId = processPoint(ptId, inPts, newPts, inputPD, outputPD, pointMap, numUsedPts);
          if (i === 0 || newPtId !== updatedPts[numNewPts - 1]) {
            updatedPts[numNewPts++] = newPtId;
          }
        }
        if (numNewPts > 1 && updatedPts[0] === updatedPts[numNewPts - 1]) {
          numNewPts--;
        }
        if (numNewPts > 3) {
          newStrips.insertNextCell(updatedPts.slice(0, numNewPts));
          if (!outStrpData) {
            outStrpData = [];
          }
          outStrpData.push({
            inputId: inCellID,
            outputId: strpIDcounter
          });
          strpIDcounter++;
        } else if (numNewPts === 3 && (inputPointIds.length === numNewPts || model.convertStripsToPolys)) {
          if (!newPolys) {
            newPolys = vtkCellArray$1.newInstance();
            outPolyData = [];
          }
          newPolys.insertNextCell(updatedPts.slice(0, numNewPts));
          outPolyData.push({
            inputId: inCellID,
            outputId: polyIDcounter
          });
          polyIDcounter++;
        } else if (numNewPts === 2 && (inputPointIds.length === numNewPts || model.convertPolysToLines)) {
          if (!newLines) {
            newLines = vtkCellArray$1.newInstance();
            outLineData = [];
          }
          newLines.insertNextCell(updatedPts.slice(0, numNewPts));
          outLineData.push({
            inputId: inCellID,
            outputId: lineIDcounter
          });
          lineIDcounter++;
        } else if (numNewPts === 1 && (inputPointIds.length === numNewPts || model.convertLinesToPoints)) {
          if (!newVerts) {
            newVerts = vtkCellArray$1.newInstance();
          }
          newVerts.insertNextCell(updatedPts.slice(0, numNewPts));
          outputCD.passData(inputCD, inCellID, vertIDcounter);
          vertIDcounter++;
        }
        inCellID++;
      }
    }
    if (model.pointMerging) {
      model._locator.initialize();
    } else {
      newPts.setNumberOfPoints(numUsedPts.value);
    }
    let combinedCellID = vertIDcounter;
    if (outLineData) {
      outLineData.forEach((item) => {
        outputCD.passData(inputCD, item.inputId, combinedCellID);
        combinedCellID++;
      });
    }
    if (outPolyData) {
      outPolyData.forEach((item) => {
        outputCD.passData(inputCD, item.inputId, combinedCellID);
        combinedCellID++;
      });
    }
    if (outStrpData) {
      outStrpData.forEach((item) => {
        outputCD.passData(inputCD, item.inputId, combinedCellID);
        combinedCellID++;
      });
    }
    output.setPoints(newPts);
    if (newVerts) output.setVerts(newVerts);
    if (newLines) output.setLines(newLines);
    if (newPolys) output.setPolys(newPolys);
    if (newStrips) output.setStrips(newStrips);
  };
}
var DEFAULT_VALUES15 = {
  pointMerging: true,
  toleranceIsAbsolute: false,
  tolerance: 0,
  absoluteTolerance: 1,
  convertLinesToPoints: true,
  convertPolysToLines: true,
  convertStripsToPolys: true,
  locator: null,
  outputPointsPrecision: DesiredOutputPrecision.DEFAULT
};
function extend18(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["pointMerging", "toleranceIsAbsolute", "tolerance", "absoluteTolerance", "convertPolysToLines", "convertLinesToPoints", "convertStripsToPolys", "outputPointsPrecision"]);
  model.copiedPoints = /* @__PURE__ */ new Set();
  vtkCleanPolyData(publicAPI, model);
}
var newInstance17 = macro.newInstance(extend18, "vtkCleanPolyData");
var vtkCleanPolyData$1 = {
  newInstance: newInstance17,
  extend: extend18
};

// node_modules/@kitware/vtk.js/Filters/Core/Cutter.js
var {
  vtkErrorMacro: vtkErrorMacro8
} = macro$1;
function initPolyIterator(pd) {
  const polys = pd.getPolys().getData();
  const strips = pd.getStrips().getData();
  const it = {
    cellSize: 0,
    cell: [],
    done: false,
    polyIdx: 0,
    stripIdx: 0,
    remainingStripLength: 0,
    // returns a single poly cell
    next() {
      if (it.polyIdx < polys.length) {
        it.cellSize = polys[it.polyIdx];
        const start = it.polyIdx + 1;
        const end2 = start + it.cellSize;
        it.polyIdx = end2;
        let p = 0;
        for (let i = start; i < end2; ++i) {
          it.cell[p++] = polys[i];
        }
      } else if (it.stripIdx < strips.length) {
        it.cellSize = 3;
        if (it.remainingStripLength === 0) {
          it.remainingStripLength = strips[it.stripIdx] - 2;
          it.stripIdx += 3;
        }
        const start = it.stripIdx - 2;
        const end2 = it.stripIdx + 1;
        it.stripIdx++;
        it.remainingStripLength--;
        let p = 0;
        for (let i = start; i < end2; ++i) {
          it.cell[p++] = strips[i];
        }
      } else if (!it.done) {
        it.done = true;
      } else {
        throw new Error("Iterator is done");
      }
    }
  };
  it.next();
  return it;
}
function vtkCutter(publicAPI, model) {
  model.classHierarchy.push("vtkCutter");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    let mTime = superClass.getMTime();
    if (!model.cutFunction) {
      return mTime;
    }
    mTime = Math.max(mTime, model.cutFunction.getMTime());
    return mTime;
  };
  function dataSetCutter(input, output) {
    const points = input.getPoints();
    const pointsData = points.getData();
    const pointData = input.getPointData();
    const numPts = points.getNumberOfPoints();
    const newPointsData = [];
    const newLinesData = [];
    const newPolysData = [];
    const newPointData = {};
    const numberOfArrays = pointData.getNumberOfArrays();
    for (let arrayIdx = 0; arrayIdx < numberOfArrays; arrayIdx++) {
      newPointData[pointData.getArrayName(arrayIdx)] = [];
    }
    if (!model.cutScalars || model.cutScalars.length < numPts) {
      model.cutScalars = new Float32Array(numPts);
    }
    let inOffset = 0;
    let outOffset = 0;
    while (inOffset < pointsData.length) {
      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);
    }
    const crossedEdges = [];
    const x1 = new Array(3);
    const x2 = new Array(3);
    const cellPointsScalars = [];
    for (const it = initPolyIterator(input); !it.done; it.next()) {
      if (it.cellSize <= 2) {
        continue;
      }
      for (let i = 0; i < it.cellSize; ) {
        cellPointsScalars[i] = model.cutScalars[it.cell[i++]];
      }
      const sideFirstPoint = cellPointsScalars[0] > 0;
      let allPointsSameSide = true;
      for (let i = 1; i < it.cell.length; i++) {
        const sideCurrentPoint = cellPointsScalars[i] > 0;
        if (sideCurrentPoint !== sideFirstPoint) {
          allPointsSameSide = false;
          break;
        }
      }
      if (allPointsSameSide) {
        continue;
      }
      const intersectedEdgesList = [];
      for (let i = 0; i < it.cellSize; i++) {
        const idNext = i + 1 === it.cellSize ? 0 : i + 1;
        const signPoint0 = cellPointsScalars[i] > 0;
        const signPoint1 = cellPointsScalars[idNext] > 0;
        if (signPoint1 === signPoint0) {
          continue;
        }
        let e1 = i;
        let e2 = idNext;
        let deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];
        if (deltaScalar <= 0) {
          e1 = idNext;
          e2 = i;
          deltaScalar *= -1;
        }
        let t = 0;
        if (deltaScalar !== 0) {
          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;
        }
        const pointID1 = it.cell[e1];
        const pointID2 = it.cell[e2];
        x1[0] = pointsData[pointID1 * 3];
        x1[1] = pointsData[pointID1 * 3 + 1];
        x1[2] = pointsData[pointID1 * 3 + 2];
        x2[0] = pointsData[pointID2 * 3];
        x2[1] = pointsData[pointID2 * 3 + 1];
        x2[2] = pointsData[pointID2 * 3 + 2];
        const computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])];
        const computedIntersectedArrays = {};
        for (let arrayIdx = 0; arrayIdx < numberOfArrays; arrayIdx++) {
          const array = pointData.getArrayByIndex(arrayIdx);
          const name2 = pointData.getArrayName(arrayIdx);
          const data2 = array.getData();
          const n = array.getNumberOfComponents();
          const computedIntersectedArray = new Array(n);
          for (let j = 0; j < n; j++) {
            const scalar1 = data2[n * pointID1 + j];
            const scalar2 = data2[n * pointID2 + j];
            computedIntersectedArray.push(scalar1 + t * (scalar2 - scalar1));
          }
          computedIntersectedArrays[name2] = computedIntersectedArray;
        }
        intersectedEdgesList.push({
          pointEdge1: pointID1,
          // id of one point of the edge
          pointEdge2: pointID2,
          // id of one point of the edge
          intersectedPoint: computedIntersectedPoint,
          // 3D coordinate of points that intersected edge
          intersectedArrays: computedIntersectedArrays,
          // value(s) of the intersected arrays
          newPointID: -1
          // id of the intersected point when it will be added into vtkPoints
        });
      }
      for (let i = 0; i < intersectedEdgesList.length; i++) {
        const intersectedEdge = intersectedEdgesList[i];
        let alreadyAdded = false;
        for (let j = 0; j < crossedEdges.length; j++) {
          const crossedEdge = crossedEdges[j];
          const sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;
          const samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];
          if (sameEdge || samePoint) {
            alreadyAdded = true;
            intersectedEdgesList[i].newPointID = crossedEdges[j].newPointID;
            break;
          }
        }
        if (!alreadyAdded) {
          newPointsData.push(intersectedEdge.intersectedPoint[0]);
          newPointsData.push(intersectedEdge.intersectedPoint[1]);
          newPointsData.push(intersectedEdge.intersectedPoint[2]);
          Object.keys(intersectedEdge.intersectedArrays).forEach((name2) => {
            newPointData[name2].push(...intersectedEdge.intersectedArrays[name2]);
          });
          intersectedEdgesList[i].newPointID = newPointsData.length / 3 - 1;
          crossedEdges.push(intersectedEdgesList[i]);
        }
      }
      const cellSize = intersectedEdgesList.length;
      if (cellSize === 2) {
        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);
      } else if (cellSize > 2) {
        newPolysData.push(cellSize);
        intersectedEdgesList.forEach((edge) => {
          newPolysData.push(edge.newPointID);
        });
      }
    }
    const outputPoints = output.getPoints();
    outputPoints.setData(newTypedArrayFrom(points.getDataType(), newPointsData), 3);
    const outputPointData = output.getPointData();
    for (let arrayIdx = 0; arrayIdx < numberOfArrays; arrayIdx++) {
      const name2 = pointData.getArrayName(arrayIdx);
      const array = vtkDataArray$1.newInstance({
        name: name2,
        dataType: pointData.getArrayByIndex(arrayIdx).getDataType(),
        values: newPointData[name2],
        numberOfComponents: pointData.getArrayByIndex(arrayIdx).getNumberOfComponents()
      });
      outputPointData.addArray(array);
    }
    if (newLinesData.length !== 0) {
      output.getLines().setData(Uint16Array.from(newLinesData));
    }
    if (newPolysData.length !== 0) {
      output.getPolys().setData(Uint16Array.from(newPolysData));
    }
  }
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro8("Invalid or missing input");
      return;
    }
    if (!model.cutFunction) {
      vtkErrorMacro8("Missing cut function");
      return;
    }
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    dataSetCutter(input, output);
    outData[0] = output;
  };
}
var DEFAULT_VALUES16 = {
  cutFunction: null,
  // support method with evaluateFunction method
  cutScalars: null,
  cutValue: 0
};
function extend19(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  obj(publicAPI, model);
  algo(publicAPI, model, 1, 1);
  setGet(publicAPI, model, ["cutFunction", "cutValue"]);
  vtkCutter(publicAPI, model);
}
var newInstance18 = newInstance(extend19, "vtkCutter");
var vtkCutter$1 = {
  newInstance: newInstance18,
  extend: extend19
};

// node_modules/@kitware/vtk.js/Filters/Core/PolyDataNormals.js
function vtkPolyDataNormals(publicAPI, model) {
  model.classHierarchy.push("vtkPolyDataNormals");
  publicAPI.vtkPolyDataNormalsExecute = (numberOfPolys, polysData, pointsData) => {
    if (!pointsData) {
      return null;
    }
    const pointNormals = new Float32Array(pointsData.length);
    const cellNormals = new Float32Array(3 * numberOfPolys);
    let cellNormalComponent = 0;
    let numberOfPoints = 0;
    const polysDataLength = polysData.length;
    const cellPointIds = [0, 0, 0];
    const cellNormal = [0, 0, 0];
    for (let c2 = 0; c2 < polysDataLength; c2 += numberOfPoints + 1) {
      numberOfPoints = polysData[c2];
      if (numberOfPoints < 3) {
        continue;
      }
      for (let i = 1; i <= 3; ++i) {
        cellPointIds[i - 1] = 3 * polysData[c2 + i];
      }
      vtkTriangle$1.computeNormal(pointsData.slice(cellPointIds[0], cellPointIds[0] + 3), pointsData.slice(cellPointIds[1], cellPointIds[1] + 3), pointsData.slice(cellPointIds[2], cellPointIds[2] + 3), cellNormal);
      cellNormals[cellNormalComponent++] = cellNormal[0];
      cellNormals[cellNormalComponent++] = cellNormal[1];
      cellNormals[cellNormalComponent++] = cellNormal[2];
      if (model.computePointNormals) {
        for (let i = 1; i <= numberOfPoints; ++i) {
          let pointId = 3 * polysData[c2 + i];
          pointNormals[pointId] += cellNormal[0];
          pointNormals[++pointId] += cellNormal[1];
          pointNormals[++pointId] += cellNormal[2];
        }
      }
    }
    if (model.computePointNormals) {
      const pointNormal = [0, 0, 0];
      for (let i = 0; i < pointsData.length; ) {
        pointNormal[0] = pointNormals[i];
        pointNormal[1] = pointNormals[i + 1];
        pointNormal[2] = pointNormals[i + 2];
        vtkMath.normalize(pointNormal);
        pointNormals[i++] = pointNormal[0];
        pointNormals[i++] = pointNormal[1];
        pointNormals[i++] = pointNormal[2];
      }
    }
    return [cellNormals, pointNormals];
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const numberOfInputs = publicAPI.getNumberOfInputPorts();
    if (!numberOfInputs) {
      return;
    }
    const input = inData[0];
    if (!input) {
      return;
    }
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    output.setPoints(input.getPoints());
    output.setVerts(input.getVerts());
    output.setLines(input.getLines());
    output.setPolys(input.getPolys());
    output.setStrips(input.getStrips());
    output.getPointData().passData(input.getPointData());
    output.getCellData().passData(input.getCellData());
    output.getFieldData().passData(input.getFieldData());
    const [cellNormals, pointNormals] = publicAPI.vtkPolyDataNormalsExecute(input.getNumberOfPolys(), input.getPolys().getData(), input.getPoints().getData());
    if (model.computePointNormals) {
      const outputPointNormals = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        name: "Normals",
        values: pointNormals
      });
      output.getPointData().setNormals(outputPointNormals);
    }
    if (model.computeCellNormals) {
      const outputCellNormals = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        name: "Normals",
        values: cellNormals
      });
      output.getCellData().setNormals(outputCellNormals);
    }
    outData[0] = output;
  };
}
function defaultValues4(initialValues) {
  return {
    computeCellNormals: false,
    computePointNormals: true,
    ...initialValues
  };
}
function extend20(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues4(initialValues));
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["computeCellNormals", "computePointNormals"]);
  vtkPolyDataNormals(publicAPI, model);
}
var newInstance19 = macro.newInstance(extend20, "vtkPolyDataNormals");
var vtkPolyDataNormals$1 = {
  newInstance: newInstance19,
  extend: extend20
};

// node_modules/@kitware/vtk.js/Filters/Core/ThresholdPoints.js
var {
  vtkErrorMacro: vtkErrorMacro9
} = macro;
var OperationType = {
  Below: "Below",
  Above: "Above"
};
function binarySearch(items, value) {
  let firstIndex = 0;
  let lastIndex = items.length - 1;
  let middleIndex = Math.floor((lastIndex + firstIndex) / 2);
  while (items[middleIndex] !== value && firstIndex < lastIndex) {
    if (value < items[middleIndex]) {
      lastIndex = middleIndex - 1;
    } else if (value > items[middleIndex]) {
      firstIndex = middleIndex + 1;
    }
    middleIndex = Math.floor((lastIndex + firstIndex) / 2);
  }
  return {
    found: items[middleIndex] === value,
    index: Math.max(items[middleIndex] < value ? middleIndex + 1 : middleIndex, 0)
  };
}
function camelize(str) {
  return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
}
function vtkThresholdPoints(publicAPI, model) {
  model.classHierarchy.push("vtkThresholdPoints");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    outData[0] = output;
    if (model.criterias.length === 0) {
      output.shallowCopy(input);
      return;
    }
    const oldPoints = input.getPoints();
    const oldPointCount = oldPoints.getNumberOfPoints();
    const oldPointData = input.getPointData();
    const oldPointsData = oldPoints.getData();
    const newPointsData = macro.newTypedArray(input.getPoints().getDataType(), 3 * oldPointCount);
    const oldArrays = [];
    const newArraysData = [];
    const numArrays = oldPointData.getNumberOfArrays();
    for (let i = 0; i < numArrays; ++i) {
      const oldArray = oldPointData.getArrayByIndex(i);
      oldArrays.push(oldArray);
      newArraysData.push(macro.newTypedArray(oldArray.getDataType(), oldPointCount * oldArray.getNumberOfComponents()));
    }
    const pointAcceptanceFunctions = model.criterias.map((criteria) => {
      let inputArray = null;
      let component = 0;
      let numberOfComponents = 1;
      if (criteria.fieldAssociation === "PointData") {
        inputArray = oldArrays.find((oldArray) => oldArray.getName() === criteria.arrayName);
        numberOfComponents = inputArray.getNumberOfComponents();
      } else if (criteria.fieldAssociation === "Points") {
        inputArray = oldPoints;
        if (criteria.arrayName === "z") {
          component = 2;
        } else {
          component = criteria.arrayName === "y" ? 1 : 0;
        }
        numberOfComponents = 3;
      } else {
        vtkErrorMacro9("No field association");
      }
      const inputArrayData = inputArray.getData();
      const operation = criteria.operation === OperationType.Below ? (a2, b2) => a2 < b2 : (a2, b2) => a2 > b2;
      const pointAcceptanceFunction = (pointId) => operation(inputArrayData[numberOfComponents * pointId + component], criteria.value);
      return pointAcceptanceFunction;
    });
    const thresholdedPointIds = [];
    let newI = 0;
    for (let i = 0; i < oldPointCount; ++i) {
      const keepPoint = pointAcceptanceFunctions.reduce((keep, pointAcceptanceFunction) => keep && pointAcceptanceFunction(i), true);
      if (keepPoint) {
        let ii = 3 * i;
        let newII = 3 * newI;
        for (let c2 = 0; c2 < 3; ++c2) {
          newPointsData[newII++] = oldPointsData[ii++];
        }
        for (let j = 0; j < numArrays; ++j) {
          const oldArrayData = oldArrays[j].getData();
          const newArrayData = newArraysData[j];
          const cc = oldArrays[j].getNumberOfComponents();
          ii = cc * i;
          newII = cc * newI;
          for (let c2 = 0; c2 < cc; ++c2) {
            newArrayData[newII++] = oldArrayData[ii++];
          }
        }
        ++newI;
      } else {
        thresholdedPointIds.push(i);
      }
    }
    if (thresholdedPointIds.length === 0) {
      output.shallowCopy(input);
      return;
    }
    output.setPoints(vtkPoints$1.newInstance({
      values: newPointsData,
      size: 3 * newI
    }));
    for (let i = 0; i < numArrays; ++i) {
      const oldArray = oldArrays[i];
      const newArray = vtkDataArray$1.newInstance({
        name: oldArray.getName(),
        values: newArraysData[i],
        dataType: oldArray.getDataType(),
        numberOfComponents: oldArray.getNumberOfComponents(),
        size: newI * oldArray.getNumberOfComponents()
      });
      output.getPointData().addArray(newArray);
      oldPointData.getAttributes(oldArray).forEach((attrType) => {
        output.getPointData().setAttribute(newArray, attrType);
      });
    }
    POLYDATA_FIELDS.forEach((cellType) => {
      const oldPolysData = input[`get${camelize(cellType)}`]().getData();
      const newCellData = macro.newTypedArray(input.getPolys().getDataType(), oldPolysData.length);
      const newPointIds = [];
      const firstPointIndex = cellType === "verts" ? 0 : 1;
      let numberOfPoints = 1;
      let newP = 0;
      for (let c2 = 0; c2 < oldPolysData.length; c2 += numberOfPoints + firstPointIndex) {
        if (firstPointIndex === 1) {
          numberOfPoints = oldPolysData[c2];
        }
        let keepCell = true;
        for (let p = firstPointIndex; p <= numberOfPoints; ++p) {
          const {
            found,
            index
          } = binarySearch(thresholdedPointIds, oldPolysData[c2 + p]);
          if (found) {
            keepCell = false;
            break;
          }
          newPointIds[p] = oldPolysData[c2 + p] - index;
        }
        if (keepCell) {
          newCellData[newP++] = numberOfPoints;
          for (let p = firstPointIndex; p <= numberOfPoints; ) {
            newCellData[newP++] = newPointIds[p++];
          }
        }
      }
      output[`set${camelize(cellType)}`](vtkCellArray$1.newInstance({
        values: newCellData,
        size: newP,
        // it may shorter than original array if cells are not kept
        dataType: input.getPolys().getDataType()
      }));
    });
  };
}
function defaultValues5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return {
    criterias: [],
    // arrayName: string, fieldAssociation: string, operation: string, value: number
    ...initialValues
  };
}
function extend21(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues5(publicAPI, model, initialValues));
  macro.setGet(publicAPI, model, []);
  macro.get(publicAPI, model, []);
  macro.setGetArray(publicAPI, model, ["criterias"]);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkThresholdPoints(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend21, "vtkThresholdPoints");
var vtkThresholdPoints$1 = {
  newInstance: newInstance20,
  extend: extend21,
  OperationType
};

// node_modules/@kitware/vtk.js/Filters/Core.js
var Core2 = {
  vtkCleanPolyData: vtkCleanPolyData$1,
  vtkCutter: vtkCutter$1,
  vtkPolyDataNormals: vtkPolyDataNormals$1,
  vtkThresholdPoints: vtkThresholdPoints$1
};

// node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js
var {
  vtkErrorMacro: vtkErrorMacro10
} = macro;
function offsetCellArray(typedArray, offset) {
  let currentIdx = 0;
  return typedArray.map((value, index) => {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return value;
    }
    return value + offset;
  });
}
function appendCellData(dest, src, ptOffset, cellOffset) {
  dest.set(offsetCellArray(src, ptOffset), cellOffset);
}
function vtkAppendPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkAppendPolyData");
  publicAPI.requestData = (inData, outData) => {
    const numberOfInputs = publicAPI.getNumberOfInputPorts();
    if (!numberOfInputs) {
      vtkErrorMacro10("No input specified.");
      return;
    }
    if (numberOfInputs === 1) {
      outData[0] = inData[0];
      return;
    }
    const output = outData[0] && inData[0] !== outData[0] ? outData[0].initialize() : vtkPolyData$1.newInstance();
    let numPts = 0;
    let pointType = 0;
    let ttype = 1;
    let firstType = 1;
    let numVerts = 0;
    let numLines = 0;
    let numStrips = 0;
    let numPolys = 0;
    let hasPtNormals = true;
    let hasPtTCoords = true;
    let hasPtScalars = true;
    for (let i = 0; i < numberOfInputs; i++) {
      const ds = inData[i];
      if (!ds) {
        continue;
      }
      const dsNumPts = ds.getPoints().getNumberOfPoints();
      numPts += dsNumPts;
      numVerts += ds.getVerts().getNumberOfValues();
      numLines += ds.getLines().getNumberOfValues();
      numStrips += ds.getStrips().getNumberOfValues();
      numPolys += ds.getPolys().getNumberOfValues();
      if (dsNumPts) {
        if (firstType) {
          firstType = 0;
          pointType = ds.getPoints().getDataType();
        }
        ttype = ds.getPoints().getDataType();
        pointType = pointType > ttype ? pointType : ttype;
      }
      const ptD = ds.getPointData();
      if (ptD) {
        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;
        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;
        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;
      } else {
        hasPtNormals = false;
        hasPtTCoords = false;
        hasPtScalars = false;
      }
    }
    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
      pointType = VtkDataTypes.FLOAT;
    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
      pointType = VtkDataTypes.DOUBLE;
    }
    const points = vtkPoints$1.newInstance({
      dataType: pointType
    });
    points.setNumberOfPoints(numPts);
    const pointData = points.getData();
    const vertData = new Uint32Array(numVerts);
    const lineData = new Uint32Array(numLines);
    const stripData = new Uint32Array(numStrips);
    const polyData = new Uint32Array(numPolys);
    let newPtNormals = null;
    let newPtTCoords = null;
    let newPtScalars = null;
    const lds = inData[numberOfInputs - 1];
    if (hasPtNormals) {
      const dsNormals = lds.getPointData().getNormals();
      newPtNormals = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        numberOfTuples: numPts,
        size: 3 * numPts,
        dataType: dsNormals.getDataType(),
        name: dsNormals.getName()
      });
    }
    if (hasPtTCoords) {
      const dsTCoords = lds.getPointData().getTCoords();
      newPtTCoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        numberOfTuples: numPts,
        size: 2 * numPts,
        dataType: dsTCoords.getDataType(),
        name: dsTCoords.getName()
      });
    }
    if (hasPtScalars) {
      const dsScalars = lds.getPointData().getScalars();
      newPtScalars = vtkDataArray$1.newInstance({
        numberOfComponents: dsScalars.getNumberOfComponents(),
        numberOfTuples: numPts,
        size: numPts * dsScalars.getNumberOfComponents(),
        dataType: dsScalars.getDataType(),
        name: dsScalars.getName()
      });
    }
    numPts = 0;
    numVerts = 0;
    numLines = 0;
    numStrips = 0;
    numPolys = 0;
    for (let i = 0; i < numberOfInputs; i++) {
      const ds = inData[i];
      pointData.set(ds.getPoints().getData(), numPts * 3);
      appendCellData(vertData, ds.getVerts().getData(), numPts, numVerts);
      numVerts += ds.getVerts().getNumberOfValues();
      appendCellData(lineData, ds.getLines().getData(), numPts, numLines);
      numLines += ds.getLines().getNumberOfValues();
      appendCellData(stripData, ds.getStrips().getData(), numPts, numStrips);
      numStrips += ds.getStrips().getNumberOfValues();
      appendCellData(polyData, ds.getPolys().getData(), numPts, numPolys);
      numPolys += ds.getPolys().getNumberOfValues();
      const dsPD = ds.getPointData();
      if (hasPtNormals) {
        const ptNorms = dsPD.getNormals();
        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);
      }
      if (hasPtTCoords) {
        const ptTCoords = dsPD.getTCoords();
        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);
      }
      if (hasPtScalars) {
        const ptScalars = dsPD.getScalars();
        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());
      }
      numPts += ds.getPoints().getNumberOfPoints();
    }
    output.setPoints(points);
    output.getVerts().setData(vertData);
    output.getLines().setData(lineData);
    output.getStrips().setData(stripData);
    output.getPolys().setData(polyData);
    if (newPtNormals) {
      output.getPointData().setNormals(newPtNormals);
    }
    if (newPtTCoords) {
      output.getPointData().setTCoords(newPtTCoords);
    }
    if (newPtScalars) {
      output.getPointData().setScalars(newPtScalars);
    }
    outData[0] = output;
  };
}
var DEFAULT_VALUES17 = {
  outputPointsPrecision: DesiredOutputPrecision.DEFAULT
};
function extend22(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  macro.setGet(publicAPI, model, ["outputPointsPrecision"]);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkAppendPolyData(publicAPI, model);
}
var newInstance21 = macro.newInstance(extend22, "vtkAppendPolyData");
var vtkAppendPolyData$1 = {
  newInstance: newInstance21,
  extend: extend22
};

// node_modules/@kitware/vtk.js/Filters/General/Calculator.js
var {
  vtkWarningMacro: vtkWarningMacro4
} = macro;
function vtkCalculator(publicAPI, model) {
  model.classHierarchy.push("vtkCalculator");
  publicAPI.setFormula = (formula) => {
    if (formula === model.formula) {
      return false;
    }
    model.formula = formula;
    publicAPI.modified();
    return true;
  };
  publicAPI.getFormula = () => model.formula;
  publicAPI.augmentInputArrays = (locn, arraysIn) => {
    const arraysOut = arraysIn.slice(0);
    if (locn === FieldDataTypes.POINT || locn === FieldDataTypes.VERTEX) {
      arraysOut.push({
        location: FieldDataTypes.COORDINATE
      });
    }
    return arraysOut;
  };
  publicAPI.createSimpleFormulaObject = function(locn, arrNames, resultName, singleValueFormula) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    return {
      getArrays: (inData) => {
        var _a;
        return {
          // don't augment input data array in case of structured input dataset
          input: ((_a = inData[0]) == null ? void 0 : _a.isA("vtkImageData")) ? arrNames.map((x) => ({
            location: locn,
            name: x
          })) : publicAPI.augmentInputArrays(locn, arrNames.map((x) => ({
            location: locn,
            name: x
          }))),
          output: [{
            location: locn,
            name: resultName,
            attribute: "outputAttributeType" in options ? options.outputAttributeType : AttributeTypes.SCALARS,
            numberOfComponents: "numberOfOutputComponents" in options ? options.numberOfOutputComponents : 1
          }]
        };
      },
      evaluate: (arraysIn, arraysOut) => {
        const tuples = new Array(arraysIn.length);
        const arrayInAccessors = arraysIn.map((x, jj) => {
          const nc2 = x.getNumberOfComponents();
          const rawData = x.getData();
          return nc2 === 1 ? (ii) => rawData[ii] : (ii) => x.getTuple(ii, tuples[jj]);
        });
        const arrayOut = arraysOut[0];
        const arrayOutRaw = arrayOut.getData();
        const nc = arrayOut.getNumberOfComponents();
        let tupleOut = new Array(nc);
        if (nc === 1) {
          arrayOutRaw.forEach((xxx, ii) => {
            arrayOutRaw[ii] = singleValueFormula(...arrayInAccessors.map((x) => x(ii)), ii, tupleOut);
          });
        } else {
          const nt = arrayOut.getNumberOfTuples();
          for (let ii = 0; ii < nt; ++ii) {
            tupleOut = singleValueFormula(...arrayInAccessors.map((x) => x(ii)), ii, tupleOut);
            arrayOut.setTuple(ii, tupleOut);
          }
        }
      }
    };
  };
  publicAPI.setFormulaSimple = function(locn, arrNames, resultName, formula) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    return publicAPI.setFormula(publicAPI.createSimpleFormulaObject(locn, arrNames, resultName, formula, options));
  };
  publicAPI.prepareArrays = (arraySpec, inData, outData) => {
    const arraysIn = [];
    const arraysOut = [];
    arraySpec.input.forEach((spec) => {
      if (spec.location === FieldDataTypes.COORDINATE) {
        arraysIn.push(inData.getPoints());
      } else {
        const fetchArrayContainer = [[FieldDataTypes.UNIFORM, (x) => x.getFieldData()], [FieldDataTypes.POINT, (x) => x.getPointData()], [FieldDataTypes.CELL, (x) => x.getCellData()], [FieldDataTypes.VERTEX, (x) => x.getVertexData()], [FieldDataTypes.EDGE, (x) => x.getEdgeData()], [FieldDataTypes.ROW, (x) => x.getRowData()]].reduce((result, value) => {
          result[value[0]] = value[1];
          return result;
        }, {});
        const dsa = "location" in spec && spec.location in fetchArrayContainer ? fetchArrayContainer[spec.location](inData) : null;
        if (dsa) {
          if (spec.name) {
            arraysIn.push(dsa.getArrayByName(spec.name));
          } else if ("index" in spec) {
            arraysIn.push(dsa.getArrayByIndex(spec.index));
          } else if ("attribute" in spec && spec.location !== FieldDataTypes.UNIFORM) {
            arraysIn.push(dsa.getActiveAttribute(spec.attribute));
          } else {
            vtkWarningMacro4(`No matching array for specifier "${JSON.stringify(spec)}".`);
            arraysIn.push(null);
          }
        } else {
          vtkWarningMacro4(`Specifier "${JSON.stringify(spec)}" did not provide a usable location.`);
          arraysIn.push(null);
        }
      }
    });
    arraySpec.output.forEach((spec) => {
      const fullSpec = {
        ...spec
      };
      const ncomp = "numberOfComponents" in fullSpec ? fullSpec.numberOfComponents : 1;
      if (spec.location === FieldDataTypes.UNIFORM && "tuples" in fullSpec) {
        fullSpec.size = ncomp * fullSpec.tuples;
      }
      if (spec.location === FieldDataTypes.COORDINATE) {
        const inPts = inData.getPoints();
        const pts = vtkPoints$1.newInstance({
          dataType: inPts.getDataType()
        });
        pts.setNumberOfPoints(inPts.getNumberOfPoints(), inPts.getNumberOfComponents());
        outData.setPoints(pts);
        arraysOut.push(pts);
      } else {
        const fetchArrayContainer = [[FieldDataTypes.UNIFORM, (x) => x.getFieldData(), (x, y) => "tuples" in y ? y.tuples : 0], [FieldDataTypes.POINT, (x) => x.getPointData(), (x) => x.getNumberOfPoints()], [FieldDataTypes.CELL, (x) => x.getCellData(), (x) => x.getNumberOfCells()], [FieldDataTypes.VERTEX, (x) => x.getVertexData(), (x) => x.getNumberOfVertices()], [FieldDataTypes.EDGE, (x) => x.getEdgeData(), (x) => x.getNumberOfEdges()], [FieldDataTypes.ROW, (x) => x.getRowData(), (x) => x.getNumberOfRows()]].reduce((result, value) => {
          result[value[0]] = {
            getData: value[1],
            getSize: value[2]
          };
          return result;
        }, {});
        let dsa = null;
        let tuples = 0;
        if ("location" in spec && spec.location in fetchArrayContainer) {
          dsa = fetchArrayContainer[spec.location].getData(outData);
          tuples = fetchArrayContainer[spec.location].getSize(inData, fullSpec);
        }
        if (tuples <= 0) {
          vtkWarningMacro4(`Output array size could not be determined for ${JSON.stringify(spec)}.`);
          arraysOut.push(null);
        } else if (dsa) {
          fullSpec.size = ncomp * tuples;
          const arrOut = vtkDataArray$1.newInstance(fullSpec);
          const arrIdx = dsa.addArray(arrOut);
          if ("attribute" in fullSpec && spec.location !== FieldDataTypes.UNIFORM) {
            dsa.setActiveAttributeByIndex(arrIdx, fullSpec.attribute);
          }
          arraysOut.push(arrOut);
        } else {
          vtkWarningMacro4(`Specifier "${JSON.stringify(spec)}" did not provide a usable location.`);
          arraysOut.push(null);
        }
      }
    });
    return {
      arraysIn,
      arraysOut
    };
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    if (!model.formula) {
      return 0;
    }
    const arraySpec = model.formula.getArrays(inData);
    const newDataSet = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtk({
      vtkClass: inData[0].getClassName()
    });
    newDataSet.shallowCopy(inData[0]);
    outData[0] = newDataSet;
    const arrays = publicAPI.prepareArrays(arraySpec, inData[0], outData[0]);
    model.formula.evaluate(arrays.arraysIn, arrays.arraysOut);
    return 1;
  };
}
var DEFAULT_VALUES18 = {
  formula: {
    getArrays: () => ({
      input: [],
      output: []
    }),
    evaluate: () => null
  }
};
function extend23(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkCalculator(publicAPI, model);
}
var newInstance22 = macro.newInstance(extend23, "vtkCalculator");
var vtkCalculator$1 = {
  newInstance: newInstance22,
  extend: extend23
};

// node_modules/@kitware/vtk.js/Common/DataModel/IncrementalOctreeNode.js
var {
  vtkErrorMacro: vtkErrorMacro11
} = macro;
var OCTREENODE_INSERTPOINT = [(points, pointIdx, coords) => pointIdx, (points, pointIdx, coords) => {
  points.setTuple(pointIdx, coords);
  return pointIdx;
}, (points, pointIdx, coords) => points.insertNextTuple(coords)];
var OCTREE_CHILD_BOUNDS_LUT = [[[0, 1], [0, 1], [0, 1]], [[1, 2], [0, 1], [0, 1]], [[0, 1], [1, 2], [0, 1]], [[1, 2], [1, 2], [0, 1]], [[0, 1], [0, 1], [1, 2]], [[1, 2], [0, 1], [1, 2]], [[0, 1], [1, 2], [1, 2]], [[1, 2], [1, 2], [1, 2]]];
function vtkIncrementalOctreeNode(publicAPI, model) {
  model.classHierarchy.push("vtkIncrementalOctreeNode");
  publicAPI.createPointIdSet = (initSize, growSize) => {
    if (model.pointIdSet == null) {
      model.pointIdSet = [];
    }
  };
  publicAPI.setBounds = (x1, x2, y1, y2, z1, z2) => {
    if (model.minBounds == null) model.minBounds = [];
    if (model.maxBounds == null) model.maxBounds = [];
    if (model.minDataBounds == null) model.minDataBounds = [];
    if (model.maxDataBounds == null) model.maxDataBounds = [];
    model.minBounds[0] = x1;
    model.maxBounds[0] = x2;
    model.minBounds[1] = y1;
    model.maxBounds[1] = y2;
    model.minBounds[2] = z1;
    model.maxBounds[2] = z2;
    model.minDataBounds[0] = x2;
    model.maxDataBounds[0] = x1;
    model.minDataBounds[1] = y2;
    model.maxDataBounds[1] = y1;
    model.minDataBounds[2] = z2;
    model.maxDataBounds[2] = z1;
  };
  publicAPI.getBounds = (bounds2) => {
    bounds2[0] = model.minBounds[0];
    bounds2[1] = model.maxBounds[0];
    bounds2[2] = model.minBounds[1];
    bounds2[3] = model.maxBounds[1];
    bounds2[4] = model.minBounds[2];
    bounds2[5] = model.maxBounds[2];
  };
  publicAPI.getChildIndex = (point) => Number(point[0] > model.children[0].getMaxBoundsByReference()[0]) + // eslint-disable-next-line no-bitwise
  (Number(point[1] > model.children[0].getMaxBoundsByReference()[1]) << 1) + // eslint-disable-next-line no-bitwise
  (Number(point[2] > model.children[0].getMaxBoundsByReference()[2]) << 2);
  publicAPI.containsPoint = (pnt) => model.minBounds[0] < pnt[0] && pnt[0] <= model.maxBounds[0] && model.minBounds[1] < pnt[1] && pnt[1] <= model.maxBounds[1] && model.minBounds[2] < pnt[2] && pnt[2] <= model.maxBounds[2] ? 1 : 0;
  publicAPI.containsPointByData = (pnt) => model.minDataBounds[0] <= pnt[0] && pnt[0] <= model.maxDataBounds[0] && model.minDataBounds[1] <= pnt[1] && pnt[1] <= model.maxDataBounds[1] && model.minDataBounds[2] <= pnt[2] && pnt[2] <= model.maxDataBounds[2] ? 1 : 0;
  publicAPI.updateCounterAndDataBounds = (point, nHits, updateData) => {
    model.numberOfPoints += nHits;
    if (!updateData) return false;
    let updated = false;
    if (point[0] < model.minDataBounds[0]) {
      updated = true;
      model.minDataBounds[0] = point[0];
    }
    if (point[0] > model.maxDataBounds[0]) {
      updated = true;
      model.maxDataBounds[0] = point[0];
    }
    if (point[1] < model.minDataBounds[1]) {
      updated = true;
      model.minDataBounds[1] = point[1];
    }
    if (point[1] > model.maxDataBounds[1]) {
      updated = true;
      model.maxDataBounds[1] = point[1];
    }
    if (point[2] < model.minDataBounds[2]) {
      updated = true;
      model.minDataBounds[2] = point[2];
    }
    if (point[2] > model.maxDataBounds[2]) {
      updated = true;
      model.maxDataBounds[2] = point[2];
    }
    return updated;
  };
  publicAPI.updateCounterAndDataBoundsRecursively = (point, nHits, updateData, endNode) => {
    const updated = publicAPI.updateCounterAndDataBounds(point, nHits, updateData);
    return model.parent === endNode ? updated : model.parent.updateCounterAndDataBoundsRecursively(point, nHits, updated, endNode);
  };
  publicAPI.containsDuplicatePointsOnly = (point) => model.minDataBounds[0] === point[0] && point[0] === model.maxDataBounds[0] && model.minDataBounds[1] === point[1] && point[1] === model.maxDataBounds[1] && model.minDataBounds[2] === point[2] && point[2] === model.maxDataBounds[2];
  publicAPI.isLeaf = () => model.children == null;
  publicAPI.getChild = (i) => model.children[i];
  publicAPI.separateExactlyDuplicatePointsFromNewInsertion = (points, pntIds, newPnt, pntIdx, maxPts, ptMode) => {
    let pointIdx = pntIdx;
    let i;
    const dupPnt = [0, 0, 0];
    const octMin = [0, 0, 0];
    const octMid = [0, 0, 0];
    const octMax = [0, 0, 0];
    const boxPtr = [null, null, null];
    let ocNode = null;
    let duplic = publicAPI;
    let single = publicAPI;
    points.getPoint(pntIds[0], dupPnt);
    while (duplic === single) {
      ocNode = duplic;
      octMid[0] = (ocNode.minBounds[0] + ocNode.maxBounds[0]) * 0.5;
      octMid[1] = (ocNode.minBounds[1] + ocNode.maxBounds[1]) * 0.5;
      octMid[2] = (ocNode.minBounds[2] + ocNode.maxBounds[2]) * 0.5;
      boxPtr[0] = ocNode.minBounds;
      boxPtr[1] = octMid;
      boxPtr[2] = ocNode.maxBounds;
      ocNode.children = [newInstance23(), newInstance23(), newInstance23(), newInstance23(), newInstance23(), newInstance23(), newInstance23(), newInstance23()];
      for (i = 0; i < 8; i++) {
        octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];
        octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0];
        octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];
        octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1];
        octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];
        octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];
        ocNode.children[i] = newInstance23();
        ocNode.children[i].setParent(ocNode);
        ocNode.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);
      }
      duplic = ocNode.children[ocNode.getChildIndex(dupPnt)];
      single = ocNode.children[ocNode.getChildIndex(newPnt)];
    }
    pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);
    single.createPointIdSet(maxPts >> 2, maxPts >> 1);
    single.getPointIdSet().push(pointIdx);
    single.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);
    duplic.setPointIdSet(pntIds);
    duplic.updateCounterAndDataBoundsRecursively(dupPnt, pntIds.length, 1, publicAPI);
    return pointIdx;
  };
  publicAPI.createChildNodes = (points, pntIds, newPnt, pntIdx, maxPts, ptMode, numberOfNodes) => {
    let nbNodes = numberOfNodes;
    let pointIdx = pntIdx;
    const sample = [];
    points.getPoint(pntIds[0], sample);
    if (publicAPI.containsDuplicatePointsOnly(sample)) {
      pointIdx = publicAPI.separateExactlyDuplicatePointsFromNewInsertion(points, pntIds, newPnt, pointIdx, maxPts, ptMode);
      return {
        success: false,
        nbNodes,
        pointIdx
      };
    }
    let i;
    let target;
    let dvidId = -1;
    let fullId = -1;
    const numIds = [0, 0, 0, 0, 0, 0, 0, 0];
    const octMin = [];
    const octMax = [];
    const tempPt = [];
    let tempId;
    const octMid = [(model.minBounds[0] + model.maxBounds[0]) * 0.5, (model.minBounds[1] + model.maxBounds[1]) * 0.5, (model.minBounds[2] + model.maxBounds[2]) * 0.5];
    const boxPtr = [model.minBounds, octMid, model.maxBounds];
    model.children = [];
    for (i = 0; i < 8; i++) {
      octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];
      octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0];
      octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];
      octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1];
      octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];
      octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];
      model.children[i] = newInstance23();
      model.children[i].setParent(publicAPI);
      model.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);
      model.children[i].createPointIdSet(maxPts >> 2, maxPts >> 1);
    }
    boxPtr[0] = null;
    boxPtr[1] = null;
    boxPtr[2] = null;
    for (i = 0; i < maxPts; i++) {
      tempId = pntIds[i];
      points.getPoint(tempId, tempPt);
      target = publicAPI.getChildIndex(tempPt);
      model.children[target].getPointIdSet().push(tempId);
      model.children[target].updateCounterAndDataBounds(tempPt);
      numIds[target]++;
    }
    for (i = 0; i < 8; i++) {
      if (numIds[i] === maxPts) {
        fullId = i;
        break;
      }
    }
    target = publicAPI.getChildIndex(newPnt);
    if (fullId === target) {
      ({
        numberOfNodes: nbNodes,
        pointIdx
      } = model.children[target].createChildNodes(points, pntIds, newPnt, pointIdx, maxPts, ptMode, nbNodes));
      dvidId = fullId;
    } else {
      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);
      model.children[target].getPointIdSet().push(pointIdx);
      model.children[target].updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);
      numIds[target]++;
    }
    for (i = 0; i < 8; i++) {
      if (numIds[i] === 0 || i === dvidId) {
        model.children[i].getPointIdSet().length = 0;
      }
    }
    return {
      success: true,
      numberOfNodes: nbNodes,
      pointIdx
    };
  };
  publicAPI.insertPoint = (points, newPnt, maxPts, pntId, ptMode, numberOfNodes) => {
    let nbNodes = 0;
    let pointIdx = pntId;
    if (model.pointIdSet) {
      if (model.pointIdSet.length < maxPts || publicAPI.containsDuplicatePointsOnly(newPnt)) {
        pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);
        model.pointIdSet.push(pointIdx);
        publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);
      } else {
        ({
          numberOfNodes: nbNodes,
          pointIdx
        } = publicAPI.createChildNodes(points, model.pointIdSet, newPnt, pointIdx, maxPts, ptMode, numberOfNodes));
        model.pointIdSet = null;
      }
    } else {
      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);
      model.pointIdSet = [];
      model.pointIdSet.push(pointIdx);
      publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);
    }
    return {
      numberOfNodes: numberOfNodes + nbNodes,
      pointIdx
    };
  };
  publicAPI.getDistance2ToBoundary = (point, closest, innerOnly, rootNode, checkData) => {
    let thisMin = null;
    let thisMax = null;
    let rootMin = null;
    let rootMax = null;
    let minDist = Number.MAX_VALUE;
    if (checkData) {
      thisMin = publicAPI.getMinDataBounds();
      thisMax = publicAPI.getMaxDataBounds();
      rootMin = rootNode.getMinDataBounds();
      rootMax = rootNode.getMaxDataBounds();
    } else {
      thisMin = model.minBounds;
      thisMax = model.maxBounds;
      rootMin = rootNode.getMinBounds();
      rootMax = rootNode.getMaxBounds();
    }
    let minFace = 0;
    const beXless = Number(point[0] < thisMin[0]);
    const beXmore = Number(point[0] > thisMax[0]);
    const beYless = Number(point[1] < thisMin[1]);
    const beYmore = Number(point[1] > thisMax[1]);
    const beZless = Number(point[2] < thisMin[2]);
    const beZmore = Number(point[2] > thisMax[2]);
    const withinX = Number(!beXless && !beXmore);
    const withinY = Number(!beYless && !beYmore);
    const withinZ = Number(!beZless && !beZmore);
    const xyzFlag = (withinZ << 2) + (withinY << 1) + withinX;
    switch (xyzFlag) {
      case 0: {
        closest[0] = beXless ? thisMin[0] : thisMax[0];
        closest[1] = beYless ? thisMin[1] : thisMax[1];
        closest[2] = beZless ? thisMin[2] : thisMax[2];
        minDist = distance2BetweenPoints(point, closest);
        break;
      }
      case 1: {
        closest[0] = point[0];
        closest[1] = beYless ? thisMin[1] : thisMax[1];
        closest[2] = beZless ? thisMin[2] : thisMax[2];
        minDist = distance2BetweenPoints(point, closest);
        break;
      }
      case 2: {
        closest[0] = beXless ? thisMin[0] : thisMax[0];
        closest[1] = point[1];
        closest[2] = beZless ? thisMin[2] : thisMax[2];
        minDist = distance2BetweenPoints(point, closest);
        break;
      }
      case 3: {
        if (beZless) {
          minDist = thisMin[2] - point[2];
          closest[2] = thisMin[2];
        } else {
          minDist = point[2] - thisMax[2];
          closest[2] = thisMax[2];
        }
        minDist *= minDist;
        closest[0] = point[0];
        closest[1] = point[1];
        break;
      }
      case 4: {
        closest[0] = beXless ? thisMin[0] : thisMax[0];
        closest[1] = beYless ? thisMin[1] : thisMax[1];
        closest[2] = point[2];
        minDist = distance2BetweenPoints(point, closest);
        break;
      }
      case 5: {
        if (beYless) {
          minDist = thisMin[1] - point[1];
          closest[1] = thisMin[1];
        } else {
          minDist = point[1] - thisMax[1];
          closest[1] = thisMax[1];
        }
        minDist *= minDist;
        closest[0] = point[0];
        closest[2] = point[2];
        break;
      }
      case 6: {
        if (beXless) {
          minDist = thisMin[0] - point[0];
          closest[0] = thisMin[0];
        } else {
          minDist = point[0] - thisMax[0];
          closest[0] = thisMax[0];
        }
        minDist *= minDist;
        closest[1] = point[1];
        closest[2] = point[2];
        break;
      }
      case 7: {
        if (innerOnly) {
          let faceDst;
          faceDst = point[0] - thisMin[0];
          if (thisMin[0] !== rootMin[0] && faceDst < minDist) {
            minFace = 0;
            minDist = faceDst;
          }
          faceDst = thisMax[0] - point[0];
          if (thisMax[0] !== rootMax[0] && faceDst < minDist) {
            minFace = 1;
            minDist = faceDst;
          }
          faceDst = point[1] - thisMin[1];
          if (thisMin[1] !== rootMin[1] && faceDst < minDist) {
            minFace = 2;
            minDist = faceDst;
          }
          faceDst = thisMax[1] - point[1];
          if (thisMax[1] !== rootMax[1] && faceDst < minDist) {
            minFace = 3;
            minDist = faceDst;
          }
          faceDst = point[2] - thisMin[2];
          if (thisMin[2] !== rootMin[2] && faceDst < minDist) {
            minFace = 4;
            minDist = faceDst;
          }
          faceDst = thisMax[2] - point[2];
          if (thisMax[2] !== rootMax[2] && faceDst < minDist) {
            minFace = 5;
            minDist = faceDst;
          }
        } else {
          const tmpDist = [point[0] - thisMin[0], thisMax[0] - point[0], point[1] - thisMin[1], thisMax[1] - point[1], point[2] - thisMin[2], thisMax[2] - point[2]];
          for (let i = 0; i < 6; i++) {
            if (tmpDist[i] < minDist) {
              minFace = i;
              minDist = tmpDist[i];
            }
          }
        }
        if (minDist !== Number.MAX_VALUE) {
          minDist *= minDist;
        }
        closest[0] = point[0];
        closest[1] = point[1];
        closest[2] = point[2];
        const pMinMax = [thisMin, thisMax];
        const xyzIndx = minFace >> 1;
        closest[xyzIndx] = pMinMax[minFace & 1][xyzIndx];
        break;
      }
      default:
        vtkErrorMacro11("unexpected case in getDistance2ToBoundary");
    }
    return minDist;
  };
  publicAPI.getDistance2ToInnerBoundary = (point, rootNode) => {
    const dummy = [];
    return publicAPI.getDistance2ToBoundary(point, dummy, 0, rootNode, 0);
  };
}
var DEFAULT_VALUES19 = {
  pointIdSet: null,
  minBounds: null,
  maxBounds: null,
  minDataBounds: null,
  maxDataBounds: null,
  parent: null,
  children: null
};
function extend24(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  macro.obj(publicAPI, model);
  macro.setGetArray(publicAPI, model, ["minBounds", "maxBounds", "minDataBounds", "maxDataBounds"], 6);
  macro.get(publicAPI, model, ["pointIdSet", "numberOfPoints"]);
  macro.set(publicAPI, model, ["parent"]);
  vtkIncrementalOctreeNode(publicAPI, model);
}
var newInstance23 = macro.newInstance(extend24, "vtkIncrementalOctreeNode");
var vtkIncrementalOctreeNode$1 = {
  newInstance: newInstance23,
  extend: extend24
};

// node_modules/@kitware/vtk.js/Common/DataModel/IncrementalOctreePointLocator.js
var {
  vtkErrorMacro: vtkErrorMacro12
} = macro;
function vtkIncrementalOctreePointLocator(publicAPI, model) {
  model.classHierarchy.push("vtkIncrementalOctreePointLocator");
  function getLeafContainer(node, pnt) {
    return node.isLeaf() ? node : getLeafContainer(node.getChild(node.getChildIndex(pnt)), pnt);
  }
  publicAPI.freeSearchStructure = () => {
    model.octreeRootNode = null;
    model.numberOfNodes = 0;
    model.locatorPoints = null;
  };
  publicAPI.findClosestPointInLeafNode = (leafNode, point) => {
    let dist2 = Number.MAX_VALUE;
    if (leafNode.getPointIdSet() == null) {
      return [-1, dist2];
    }
    let numPts = 0;
    let tmpDst = 0;
    const tmpPnt = [];
    let tmpIdx = -1;
    let pntIdx = -1;
    let idList = leafNode.getPointIdSet();
    numPts = idList.length;
    for (let i = 0; i < numPts; i++) {
      tmpIdx = idList[i];
      model.locatorPoints.getPoint(tmpIdx, tmpPnt);
      tmpDst = vtkMath.distance2BetweenPoints(tmpPnt, point);
      if (tmpDst < dist2) {
        dist2 = tmpDst;
        pntIdx = tmpIdx;
      }
      if (dist2 === 0) {
        break;
      }
    }
    idList = null;
    return [pntIdx, dist2];
  };
  publicAPI.findClosestPointInSphere = (point, radius2, maskNode, refDist2) => {
    let pointIndx = -1;
    let minDist2 = Number.MAX_VALUE;
    const nodesBase = [];
    nodesBase.push(model.octreeRootNode);
    let checkNode;
    let childNode;
    let distToData;
    let tempDist2;
    let tempPntId;
    while (!nodesBase.length === 0 && minDist2 > 0) {
      checkNode = nodesBase.top();
      nodesBase.pop();
      if (!checkNode.isLeaf()) {
        for (let i = 0; i < 8; i++) {
          childNode = checkNode.getChild(i);
          distToData = childNode.getNumberOfPoints() ? childNode.getDistance2ToBoundary(point, model.octreeRootNode, 1) : radius2 + radius2;
          if (childNode !== maskNode && (distToData <= refDist2 || childNode.containsPoint(point) === 1)) {
            nodesBase.push(childNode);
          }
          childNode = null;
        }
      } else {
        [tempPntId, tempDist2] = publicAPI.findClosestPointInLeafNode(checkNode, point);
        if (tempDist2 < minDist2) {
          minDist2 = tempDist2;
          pointIndx = tempPntId;
        }
      }
      checkNode = null;
    }
    return [minDist2 <= radius2 ? pointIndx : -1, minDist2];
  };
  publicAPI.initPointInsertion = function(points, bounds2) {
    let i = 0;
    let bbIndex = 0;
    if (points == null) {
      vtkErrorMacro12("a valid vtkPoints object required for point insertion");
      return false;
    }
    publicAPI.freeSearchStructure();
    model.locatorPoints = points;
    model.insertTolerance2 = model.tolerance * model.tolerance;
    model.octreeMaxDimSize = 0;
    const tmpBbox = [...bounds2];
    const dimDiff = vtkBoundingBox.getLengths(bounds2);
    model.octreeMaxDimSize = Math.max(...dimDiff);
    if (model.buildCubicOctree) {
      for (i = 0; i < 3; i++) {
        if (dimDiff[i] !== model.octreeMaxDimSize) {
          const delta = model.octreeMaxDimSize - dimDiff[i];
          tmpBbox[2 * i] -= 0.5 * delta;
          tmpBbox[2 * i + 1] += 0.5 * delta;
          dimDiff[i] = model.octreeMaxDimSize;
        }
      }
    }
    model.fudgeFactor = model.octreeMaxDimSize * 1e-5;
    const minSideSize = model.octreeMaxDimSize * 0.1;
    for (i = 0; i < 3; i++) {
      if (dimDiff[i] < minSideSize) {
        bbIndex = 2 * i;
        const tempVal = tmpBbox[bbIndex];
        tmpBbox[bbIndex] = tmpBbox[bbIndex + 1] - minSideSize;
        tmpBbox[bbIndex + 1] = tempVal + minSideSize;
      } else {
        tmpBbox[2 * i] -= model.fudgeFactor;
      }
    }
    model.octreeRootNode = vtkIncrementalOctreeNode$1.newInstance();
    ++model.numberOfNodes;
    model.octreeRootNode.setBounds(...tmpBbox);
    return true;
  };
  publicAPI.findClosestPointInSphereWithTolerance = (point, radius2, maskNode) => publicAPI.findClosestPointInSphere(point, radius2, maskNode, model.octreeMaxDimSize * model.octreeMaxDimSize * 4, radius2);
  publicAPI.findDuplicateFloatTypePointInVisitedLeafNode = (leafNode, point) => {
    let tmpPnt;
    let tmpIdx = -1;
    let pntIdx = -1;
    const idList = leafNode.getPointIdSet();
    const values = model.locatorPoints.getData();
    for (let i = 0; i < idList.length; i++) {
      tmpIdx = idList[i];
      tmpPnt = (tmpIdx << 1) + tmpIdx;
      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {
        pntIdx = tmpIdx;
        break;
      }
    }
    return pntIdx;
  };
  publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode = (leafNode, point) => {
    let tmpPnt;
    let tmpIdx = -1;
    let pntIdx = -1;
    const idList = leafNode.getPointIdSet();
    const values = model.locatorPoints.getData();
    for (let i = 0; i < idList.length; i++) {
      tmpIdx = idList[i];
      tmpPnt = (tmpIdx << 1) + tmpIdx;
      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {
        pntIdx = tmpIdx;
        break;
      }
    }
    return pntIdx;
  };
  publicAPI.findDuplicatePointInLeafNode = (leafNode, point) => {
    if (leafNode.getPointIdSet() == null) {
      return -1;
    }
    return model.locatorPoints.getDataType() === VtkDataTypes.FLOAT ? publicAPI.findDuplicateFloatTypePointInVisitedLeafNode(leafNode, point) : publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode(leafNode, point);
  };
  publicAPI.insertPoint = (ptId, x) => {
    const leafcontainer = getLeafContainer(model.octreeRootNode, x);
    ({
      numberOfNodes: model.numberOfNodes
    } = leafcontainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, ptId, 1, model.numberOfNodes));
  };
  publicAPI.insertUniquePoint = (point) => {
    let {
      pointIdx,
      leafContainer
    } = publicAPI.isInsertedPoint(point);
    if (pointIdx > -1) {
      return {
        success: false,
        idx: pointIdx
      };
    }
    let numberOfNodes;
    ({
      numberOfNodes,
      pointIdx
    } = leafContainer.insertPoint(model.locatorPoints, point, model.maxPointsPerLeaf, pointIdx, 2, model.numberOfNodes));
    model.numberOfNodes = numberOfNodes;
    return {
      success: true,
      idx: pointIdx
    };
  };
  publicAPI.insertNextPoint = (x) => {
    const leafContainer = getLeafContainer(model.octreeRootNode, x);
    const {
      numberOfNodes,
      pointIdx
    } = leafContainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, -1, 2, model.numberOfNodes);
    model.numberOfNodes = numberOfNodes;
    return pointIdx;
  };
  publicAPI.isInsertedPointForZeroTolerance = (x) => {
    const leafContainer = getLeafContainer(model.octreeRootNode, x);
    const pointIdx = publicAPI.findDuplicatePointInLeafNode(leafContainer, x);
    return {
      pointIdx,
      leafContainer
    };
  };
  publicAPI.isInsertedPointForNonZeroTolerance = (x) => {
    let dist2Ext;
    let pntIdExt;
    const leafContainer = getLeafContainer(model.octreeRootNode, x);
    let [pointIdx, minDist2] = publicAPI.findClosestPointInLeafNode(leafContainer, x);
    if (minDist2 === 0) {
      return {
        pointIdx,
        leafContainer
      };
    }
    const elseDst2 = leafContainer.getDistance2ToInnerBoundary(x, model.octreeRootNode);
    if (elseDst2 < model.insertTolerance2) {
      pntIdExt = publicAPI.findClosestPointInSphereWithTolerance(x, model.insertTolerance2, leafContainer, dist2Ext);
      if (dist2Ext < minDist2) {
        minDist2 = dist2Ext;
        pointIdx = pntIdExt;
      }
    }
    pointIdx = minDist2 <= model.insertTolerance2 ? pointIdx : -1;
    return {
      pointIdx,
      leafContainer
    };
  };
  publicAPI.isInsertedPoint = (x, leafContainer) => model.insertTolerance2 === 0 ? publicAPI.isInsertedPointForZeroTolerance(x, leafContainer) : publicAPI.isInsertedPointForNonZeroTolerance(x, leafContainer);
}
function defaultValues6(initialValues) {
  return {
    fudgeFactor: 0,
    octreeMaxDimSize: 0,
    buildCubicOctree: false,
    maxPointsPerLeaf: 128,
    insertTolerance2: 1e-6,
    locatorPoints: null,
    octreeRootNode: null,
    numberOfNodes: 0,
    ...initialValues
  };
}
function extend25(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkAbstractPointLocator$1.extend(publicAPI, model, defaultValues6(initialValues));
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["fudgeFactor", "octreeMaxDimSize", "buildCubicOctree", "maxPointsPerLeaf", "insertTolerance2", "locatorPoints", "octreeRootNode", "numberOfNodes"]);
  vtkIncrementalOctreePointLocator(publicAPI, model);
}
var newInstance24 = macro.newInstance(extend25, "vtkIncrementalOctreePointLocator");
var vtkIncrementalOctreePointLocator$1 = {
  newInstance: newInstance24,
  extend: extend25
};

// node_modules/@kitware/vtk.js/Filters/General/ContourTriangulator/Constants.js
var CCS_POLYGON_TOLERANCE = 1e-5;

// node_modules/@kitware/vtk.js/Filters/General/ContourTriangulator/helper.js
var {
  vtkErrorMacro: vtkErrorMacro13
} = macro;
function reverseElements(arr) {
  let firstIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
  let lastIdx = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
  const first = firstIdx ?? 0;
  const last = lastIdx ?? arr.length - 1;
  const mid = first + Math.floor((last - first) / 2);
  for (let i = first; i <= mid; ++i) {
    [arr[i], arr[last - (i - first)]] = [arr[last - (i - first)], arr[i]];
  }
}
function vtkCCSTriangleQuality(p0, p1, p2, normal) {
  const u = [];
  const v = [];
  const w = [];
  subtract(p1, p0, u);
  subtract(p2, p1, v);
  subtract(p0, p2, w);
  const area2 = (u[1] * v[2] - u[2] * v[1]) * normal[0] + (u[2] * v[0] - u[0] * v[2]) * normal[1] + (u[0] * v[1] - u[1] * v[0]) * normal[2];
  let perim = Math.sqrt(u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) + Math.sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]);
  perim *= perim;
  perim = perim !== 0 ? perim : 1;
  return area2 / perim * 10.392304845413264;
}
function vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges) {
  const nextVert = [1, 2, 0];
  let edgeCount = 0;
  const edgeLocs = [-1, -1, -1];
  for (let vert = 0; vert < 3; vert++) {
    const currId = trids[vert];
    const edgeLoc = polyEdges[currId];
    if (edgeLoc >= 0) {
      let nextId = currId + 1;
      if (nextId === poly.length) {
        nextId = 0;
      }
      if (nextId === trids[nextVert[vert]]) {
        edgeLocs[vert] = edgeLoc;
        edgeCount++;
      }
    }
  }
  if (edgeCount === 0) {
    polys.insertNextCell([poly[trids[0]], poly[trids[1]], poly[trids[2]]]);
  } else {
    const edgePts = [[poly[trids[0]], poly[trids[1]]], [poly[trids[1]], poly[trids[2]]], [poly[trids[2]], poly[trids[0]]]];
    let maxPoints = 0;
    let currSide = 0;
    for (let i = 0; i < 3; i++) {
      if (edgeLocs[i] >= 0) {
        const edgeLoc = edgeLocs[i];
        const npts = originalEdges[edgeLoc];
        const pts = originalEdges.slice(edgeLoc + 1, edgeLoc + 1 + npts);
        if (!(edgePts[i][0] === pts[0] || edgePts[i][1] === pts[npts - 1])) {
          vtkErrorMacro13("assertion error in vtkCCSInsertTriangle");
        }
        if (npts > maxPoints) {
          maxPoints = npts;
          currSide = i;
        }
        edgePts[i] = pts;
      }
    }
    const prevSide = (currSide + 2) % 3;
    const nextSide = (currSide + 1) % 3;
    const prevNeeded = edgePts[prevSide].length > 2;
    const nextNeeded = edgePts[nextSide].length > 2;
    const tailPtIds = [];
    tailPtIds[prevSide] = edgePts[currSide][1];
    tailPtIds[currSide] = edgePts[prevSide][0];
    tailPtIds[nextSide] = edgePts[currSide][edgePts[currSide].length - 2];
    for (let side = 0; side < 3; side++) {
      if ((side !== prevSide || prevNeeded) && (side !== nextSide || nextNeeded)) {
        let m = 0;
        let n = edgePts[side].length - 1;
        if (side === currSide) {
          m += prevNeeded;
          n -= nextNeeded;
        }
        for (let k = m; k < n; k++) {
          polys.insertNextCell([edgePts[side][k], edgePts[side][k + 1], tailPtIds[side]]);
        }
      }
    }
  }
}
function vtkCCSTriangulate(poly, points, polyEdges, originalEdges, polys, normal) {
  let n = poly.length;
  if (n < 3) {
    return true;
  }
  if (n === 3) {
    const trids = [0, 1, 2];
    vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);
    return true;
  }
  let triangulationFailure = false;
  let ppoint = [];
  let point = [];
  let npoint = [];
  let i = 0;
  let j = 0;
  let k = 0;
  const verts = [];
  verts.length = n;
  for (i = 0; i < n; i++) {
    verts[i] = [i, 0];
  }
  k = n - 2;
  points.getPoint(poly[verts[k][0]], point);
  i = n - 1;
  points.getPoint(poly[verts[i][0]], npoint);
  let concave = 0;
  let maxq = 0;
  let maxi = 0;
  for (j = 0; j < n; j++) {
    [ppoint, point, npoint] = [point, npoint, ppoint];
    points.getPoint(poly[verts[j][0]], npoint);
    const q = vtkCCSTriangleQuality(ppoint, point, npoint, normal);
    if (q > maxq) {
      maxi = i;
      maxq = q;
    }
    concave += q < 0;
    verts[i][1] = q;
    i = j;
  }
  let foundEar;
  for (; ; ) {
    if (maxq <= Number.MIN_VALUE) {
      triangulationFailure = true;
      break;
    }
    i = maxi;
    j = i + 1 !== n ? i + 1 : 0;
    k = i !== 0 ? i - 1 : n - 1;
    if (verts[i][1] > 0) {
      foundEar = true;
      points.getPoint(poly[verts[j][0]], npoint);
      points.getPoint(poly[verts[k][0]], ppoint);
      if (concave) {
        const v = [];
        const u = [];
        subtract(npoint, ppoint, v);
        cross(v, normal, u);
        const d2 = dot(ppoint, u);
        let jj = j + 1 !== n ? j + 1 : 0;
        let x = [];
        points.getPoint(poly[verts[jj][0]], x);
        let side = dot(x, u) < d2;
        let foundNegative = side;
        jj = jj + 1 !== n ? jj + 1 : 0;
        let y = [];
        const s = [];
        const t = [];
        for (; foundEar && jj !== k; jj = jj + 1 !== n ? jj + 1 : 0) {
          [x, y] = [y, x];
          points.getPoint(poly[verts[jj][0]], x);
          const sside = dot(x, u) < d2;
          if (side ? !sside : sside) {
            side = !side;
            foundNegative = true;
            foundEar = vtkLine$1.intersection(ppoint, npoint, x, y, s, t) === vtkLine$1.IntersectionState.NO_INTERSECTION;
          }
        }
        foundEar && (foundEar = foundNegative);
      }
      if (!foundEar) {
        verts[i][1] = Number.MIN_VALUE;
      } else {
        const trids = [verts[i][0], verts[j][0], verts[k][0]];
        vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);
        verts.splice(i, 1);
        k -= i === 0;
        j -= j !== 0;
        if (--n < 3) {
          break;
        }
        const kk = k !== 0 ? k - 1 : n - 1;
        points.getPoint(poly[verts[kk][0]], point);
        const kq = vtkCCSTriangleQuality(point, ppoint, npoint, normal);
        concave -= verts[k][1] < 0 && kq >= 0;
        verts[k][1] = kq;
        const jj = j + 1 !== n ? j + 1 : 0;
        points.getPoint(poly[verts[jj][0]], point);
        const jq = vtkCCSTriangleQuality(ppoint, npoint, point, normal);
        concave -= verts[j][1] < 0 && jq >= 0;
        verts[j][1] = jq;
      }
    }
    maxi = 0;
    maxq = verts[0][1];
    for (i = 1; i < n; i++) {
      const q = verts[i][1];
      if (q > maxq) {
        maxi = i;
        maxq = q;
      }
    }
  }
  return !triangulationFailure;
}
function vtkCCSMakePolysFromLines(polyData, firstLine, endLine, oriented, newPolys, incompletePolys) {
  let npts = 0;
  let pts = [];
  const usedLines = new Uint8Array(endLine - firstLine);
  polyData.buildLinks(polyData.getPoints().getNumberOfPoints());
  let numNewPolys = 0;
  let remainingLines = endLine - firstLine;
  while (remainingLines > 0) {
    const polyId = numNewPolys++;
    const poly = [];
    newPolys.push(poly);
    let lineId = 0;
    let completePoly = false;
    for (lineId = firstLine; lineId < endLine; lineId++) {
      if (!usedLines[lineId - firstLine]) {
        pts = polyData.getCellPoints(lineId).cellPointIds;
        npts = pts.length;
        let n = npts;
        if (npts > 2 && pts[0] === pts[npts - 1]) {
          n = npts - 1;
          completePoly = true;
        }
        poly.length = n;
        for (let i = 0; i < n; i++) {
          poly[i] = pts[i];
        }
        break;
      }
    }
    usedLines[lineId - firstLine] = 1;
    remainingLines--;
    let noLinesMatch = remainingLines === 0 && !completePoly;
    while (!completePoly && !noLinesMatch && remainingLines > 0) {
      noLinesMatch = true;
      const npoly = poly.length;
      const lineEndPts = [];
      const endPts = [poly[npoly - 1], poly[0]];
      for (let endIdx = 0; endIdx < 2; endIdx++) {
        const matches = [];
        const cells = polyData.getPointCells(endPts[endIdx]);
        for (let icell = 0; icell < cells.length; icell++) {
          lineId = cells[icell];
          if (lineId >= firstLine && lineId < endLine && !usedLines[lineId - firstLine]) {
            pts = polyData.getCellPoints(lineId).cellPointIds;
            npts = pts.length;
            lineEndPts[0] = pts[0];
            lineEndPts[1] = pts[npts - 1];
            if (endPts[endIdx] === lineEndPts[endIdx] || !oriented && endPts[endIdx] === lineEndPts[1 - endIdx]) {
              matches.push(lineId);
            }
          }
        }
        if (matches.length > 0) {
          if (matches.length > 1) {
            let k = matches.length;
            do {
              lineId = matches[--k];
              pts = polyData.getCellPoints(lineId).cellPointIds;
              npts = pts.length;
              lineEndPts[0] = pts[0];
              lineEndPts[1] = pts[npts - 1];
              const r = endPts[endIdx] !== lineEndPts[endIdx];
              if (!r && (endIdx === 0 && poly[npoly - 2] === pts[1] || endIdx === 1 && poly[1] === pts[npts - 2]) || r && (endIdx === 0 && poly[npoly - 2] === pts[npts - 2] || endIdx === 1 && poly[1] === pts[1])) {
                matches.splice(k, 1);
              }
            } while (k > 0 && matches.length > 1);
          }
          lineId = matches[0];
          pts = polyData.getCellPoints(lineId).cellPointIds;
          npts = pts.length;
          lineEndPts[0] = pts[0];
          lineEndPts[1] = pts[npts - 1];
          if (endPts[endIdx] === lineEndPts[endIdx]) {
            completePoly = endPts[1 - endIdx] === lineEndPts[1 - endIdx];
          } else {
            completePoly = endPts[1 - endIdx] === lineEndPts[endIdx];
          }
          if (endIdx === 0) {
            for (let i = 1; i < npts - (completePoly ? 1 : 0); i++) {
              poly.push(pts[i]);
            }
          } else {
            for (let i = completePoly ? 1 : 0; i < npts - 1; i++) {
              poly.unshift(pts[i]);
            }
          }
          if (endPts[endIdx] !== lineEndPts[endIdx]) {
            let pit = poly.length;
            let ptsIt = completePoly ? 1 : 0;
            let ptsEnd = npts - 1;
            if (endIdx === 1) {
              pit = npts - 1 - (completePoly ? 1 : 0);
              ptsIt = 1;
              ptsEnd = npts - (completePoly ? 1 : 0);
            }
            while (ptsIt !== ptsEnd) {
              poly[--pit] = poly[ptsIt++];
            }
          }
          usedLines[lineId - firstLine] = 1;
          remainingLines--;
          noLinesMatch = false;
        }
      }
    }
    if (noLinesMatch) {
      incompletePolys.push(polyId);
    }
  }
}
function vtkCCSJoinLooseEnds(polys, incompletePolys, points, normal) {
  const tol = CCS_POLYGON_TOLERANCE;
  const removePolys = [];
  const p1 = [];
  const p2 = [];
  let poly1;
  let poly2;
  let pt1;
  let pt2;
  let dMin;
  let iMin;
  let v;
  let d2;
  let n = incompletePolys.length;
  while (n !== 0) {
    poly1 = polys[incompletePolys[n - 1]];
    pt1 = poly1[poly1.length - 1];
    points.getPoint(pt1, p1);
    dMin = Number.MAX_VALUE;
    iMin = 0;
    for (let i2 = 0; i2 < n; i2++) {
      poly2 = polys[incompletePolys[i2]];
      pt2 = poly2[0];
      points.getPoint(pt2, p2);
      v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      d2 = norm(v);
      if (d2 !== 0) {
        v[0] /= d2;
        v[1] /= d2;
        v[2] /= d2;
      }
      const pm = [0.5 * (p1[0] + p2[0]), 0.5 * (p1[1] + p2[1]), 0.5 * (p1[2] + p2[2])];
      const pc = [];
      cross(normal, v, pc);
      pc[3] = -dot(pc, pm);
      let badPoint = false;
      const m = polys.length;
      const p = [];
      for (let j = 0; j < m && !badPoint; j++) {
        const poly = polys[j];
        const npts = poly.length;
        for (let k = 0; k < npts; k++) {
          const ptId = poly[k];
          if (ptId !== pt1 && ptId !== pt2) {
            points.getPoint(ptId, p);
            const val = p[0] * pc[0] + p[1] * pc[1] + p[2] * pc[2] + pc[3];
            const r2 = distance2BetweenPoints(p, pm);
            if (val < 0 && val * val > tol * tol * r2) {
              badPoint = true;
              break;
            }
          }
        }
        if (!badPoint && d2 < dMin) {
          dMin = d2;
          iMin = i2;
        }
      }
    }
    if (dMin < Number.MAX_VALUE) {
      if (iMin === n - 1) {
        incompletePolys.pop();
      } else {
        const id2 = incompletePolys[iMin];
        poly1.push(...polys[id2]);
        removePolys.push(id2);
        incompletePolys.splice(iMin, 1);
      }
    } else {
      removePolys.push(incompletePolys[n - 1]);
      incompletePolys.pop();
    }
    n = incompletePolys.length;
  }
  removePolys.sort((a2, b2) => a2 - b2);
  let i = removePolys.length;
  while (i > 0) {
    polys.splice(removePolys[--i], 1);
  }
  incompletePolys.length = 0;
}
function vtkCCSVectorProgression(p, p1, p2, p3, normal) {
  const v1 = [p1[0] - p[0], p1[1] - p[1], p1[2] - p[2]];
  const v2 = [p2[0] - p[0], p2[1] - p[1], p2[2] - p[2]];
  const v3 = [p3[0] - p[0], p3[1] - p[1], p3[2] - p[2]];
  const w1 = [];
  const w2 = [];
  cross(v2, v1, w1);
  cross(v2, v3, w2);
  const s1 = dot(w1, normal);
  const s2 = dot(w2, normal);
  if (s1 !== 0 && s2 !== 0) {
    const sb1 = s1 < 0;
    const sb2 = s2 < 0;
    if (sb1 ? !sb2 : sb2) {
      return 1 - 2 * sb2;
    }
    const c1 = dot(v2, v1);
    const l1 = norm(v1);
    const c2 = dot(v2, v3);
    const l2 = norm(v3);
    const ck = (c2 * l2 - c1 * l1) * (1 - sb1 * 2);
    if (ck !== 0) {
      return 1 - 2 * (ck < 0);
    }
  }
  return 0;
}
function vtkCCSSplitAtPinchPoints(polys, points, polyGroups, polyEdges, normal, oriented) {
  const tryPoints = vtkPoints$1.newInstance({
    dataType: VtkDataTypes.DOUBLE,
    empty: true
  });
  const locator = vtkIncrementalOctreePointLocator$1.newInstance();
  let splitCount = 0;
  let poly;
  let n;
  let bounds2;
  let tol;
  for (let i = 0; i < polys.length; i++) {
    poly = polys[i];
    n = poly.length;
    bounds2 = [];
    tol = CCS_POLYGON_TOLERANCE * Math.sqrt(vtkPolygon$1.getBounds(poly, points, bounds2));
    if (tol === 0) {
      continue;
    }
    tryPoints.initialize();
    locator.setTolerance(tol);
    locator.initPointInsertion(tryPoints, bounds2);
    let foundMatch = false;
    let idx1 = 0;
    let idx2 = 0;
    let unique = 0;
    const point = [];
    const p1 = [];
    const p2 = [];
    const p3 = [];
    for (idx2 = 0; idx2 < n; idx2++) {
      points.getPoint(poly[idx2], point);
      const {
        success,
        pointIdx
      } = locator.insertUniquePoint(point, 0);
      if (!success) {
        locator.insertNextPoint(point);
        idx1 = pointIdx;
        unique = poly[idx2] !== poly[idx1];
        if (idx2 > idx1 + 2 - unique && n + idx1 > idx2 + 2 - unique) {
          if (oriented) {
            let prevIdx = n + idx1 - 1;
            let midIdx = idx1 + 1;
            let nextIdx = idx2 + 1;
            if (prevIdx >= n) {
              prevIdx -= n;
            }
            if (midIdx >= n) {
              midIdx -= n;
            }
            if (nextIdx >= n) {
              nextIdx -= n;
            }
            points.getPoint(poly[prevIdx], p1);
            points.getPoint(poly[midIdx], p2);
            points.getPoint(poly[nextIdx], p3);
            if (vtkCCSVectorProgression(point, p1, p2, p3, normal) > 0) {
              foundMatch = true;
              break;
            }
          } else {
            foundMatch = true;
            break;
          }
        }
      }
    }
    if (foundMatch) {
      splitCount++;
      const m = idx2 - idx1;
      const oldPoly = polys[i];
      const oldEdges = polyEdges[i];
      const newPoly1 = oldPoly.slice(idx1, idx1 + m + unique);
      const newEdges1 = oldEdges.slice(idx1, idx1 + m + unique);
      const newPoly2 = new Array(n - m + unique);
      const newEdges2 = new Array(n - m + unique);
      if (unique) {
        newEdges1[m] = -1;
      }
      for (let j = 0; j < idx1 + unique; j++) {
        newPoly2[j] = oldPoly[j];
        newEdges2[j] = oldEdges[j];
      }
      if (unique) {
        newEdges2[idx1] = -1;
      }
      for (let k = idx2; k < n; k++) {
        newPoly2[k - m + unique] = oldPoly[k];
        newEdges2[k - m + unique] = oldEdges[k];
      }
      polys[i] = newPoly1;
      polyEdges[i] = newEdges1;
      polys.push(newPoly2);
      polyEdges.push(newEdges2);
      polyGroups.length = polys.length;
      if (polyGroups[i].length > 0) {
        polyGroups[polys.length - 1].push(polys.length - 1);
      }
    }
  }
  return splitCount;
}
function vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges) {
  const atol2 = CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE;
  const p0 = [];
  const p1 = [];
  const p2 = [];
  const v1 = [];
  const v2 = [];
  let l1;
  let l2;
  for (let polyId = 0; polyId < polys.length; polyId++) {
    const oldPoly = polys[polyId];
    const n = oldPoly.length;
    const newEdges = [];
    polyEdges.push(newEdges);
    if (n < 4) {
      newEdges[0] = -1;
      newEdges[1] = -1;
      newEdges[2] = -1;
      continue;
    }
    let m = n;
    const bounds2 = [];
    const tol2 = vtkPolygon$1.getBounds(oldPoly, points, bounds2) * atol2;
    const newPoly = [];
    let cornerPointId = 0;
    let oldOriginalId = -1;
    const partialEdge = [];
    let cellCount = 0;
    points.getPoint(oldPoly[n - 1], p0);
    points.getPoint(oldPoly[0], p1);
    subtract(p1, p0, v1);
    l1 = dot(v1, v1);
    for (let j = 0; j < n; j++) {
      let k = j + 1;
      if (k >= n) {
        k -= n;
      }
      points.getPoint(oldPoly[k], p2);
      subtract(p2, p1, v2);
      l2 = dot(v2, v2);
      const c2 = dot(v1, v2);
      const s2 = l1 * l2 - c2 * c2;
      const pointId = oldPoly[j];
      if (m <= 3 || l1 > tol2 && (c2 < 0 || l1 < tol2 || l2 < tol2 || s2 > l1 * l2 * atol2)) {
        if (cellCount > 1) {
          if (pointId !== oldOriginalId) {
            originalEdges.push(pointId);
            cellCount++;
          }
          const countLocation = originalEdges.length - cellCount - 1;
          originalEdges[countLocation] = cellCount;
          newEdges.push(countLocation);
        } else if (cellCount === 0) {
          partialEdge.push(pointId);
        } else {
          newEdges.push(-1);
        }
        newPoly.push(pointId);
        cornerPointId = pointId;
        oldOriginalId = pointId;
        cellCount = 1;
        p0[0] = p2[0];
        p0[1] = p2[1];
        p0[2] = p2[2];
        p1[0] = p2[0];
        p1[1] = p2[1];
        p1[2] = p2[2];
        v1[0] = v2[0];
        v1[1] = v2[1];
        v1[2] = v2[2];
        l1 = l2;
      } else {
        if (cellCount > 0 && pointId !== oldOriginalId) {
          if (cellCount === 1) {
            originalEdges.push(1);
            originalEdges.push(cornerPointId);
          }
          originalEdges.push(pointId);
          oldOriginalId = pointId;
          cellCount++;
        } else {
          partialEdge.push(pointId);
        }
        m--;
        p1[0] = p2[0];
        p1[1] = p2[1];
        p1[2] = p2[2];
        subtract(p2, p0, v1);
        l1 = dot(v1, v1);
      }
    }
    for (let ii = 0; ii < partialEdge.length; ii++) {
      const pointId = partialEdge[ii];
      if (pointId !== oldOriginalId) {
        if (cellCount === 1) {
          originalEdges.push(1);
          originalEdges.push(cornerPointId);
        }
        originalEdges.push(pointId);
        oldOriginalId = pointId;
        cellCount++;
      }
    }
    if (cellCount > 1) {
      const countLocation = originalEdges.length - cellCount - 1;
      originalEdges[countLocation] = cellCount;
      newEdges.push(countLocation);
    }
    polys[polyId] = newPoly;
  }
}
function vtkCCSReversePoly(poly, edges, originalEdges) {
  reverseElements(poly, 1, poly.length - 1);
  edges.reverse();
  for (let i = 0; i < edges.length; i++) {
    if (edges[i] >= 0) {
      const firstPtsIdx = edges[i] + 1;
      const npts = originalEdges[edges[i]];
      reverseElements(originalEdges, firstPtsIdx, firstPtsIdx + npts - 1);
    }
  }
}
function vtkCCSCheckPolygonSense(poly, points, normal) {
  const pnormal = [0, 0, 0];
  const p0 = [];
  const p1 = [];
  const p2 = [];
  const v1 = [];
  const v2 = [];
  const v = [];
  points.getPoint(poly[0], p0);
  points.getPoint(poly[1], p1);
  subtract(p1, p0, v1);
  for (let jj = 2; jj < poly.length; jj++) {
    points.getPoint(poly[jj], p2);
    subtract(p2, p0, v2);
    cross(v1, v2, v);
    add(pnormal, v, pnormal);
    p1[0] = p2[0];
    p1[1] = p2[1];
    p1[2] = p2[2];
    v1[0] = v2[0];
    v1[1] = v2[1];
    v1[2] = v2[2];
  }
  const d2 = dot(pnormal, normal);
  return {
    isNormalNotZero: d2 !== 0,
    sense: d2 > 0
  };
}
function vtkCCSPolyInPoly(outerPoly, innerPoly, points, normal, pp, bounds2, tol2) {
  const n = outerPoly.length;
  const m = innerPoly.length;
  const p = [];
  const q1 = [];
  const q2 = [];
  for (let jj = 0; jj < m; jj++) {
    const kk = (jj >> 1) + (jj & 1) * (m + 1 >> 1);
    points.getPoint(innerPoly[kk], p);
    const intersectionState = vtkPolygon$1.pointInPolygon(p, pp, bounds2, normal);
    if (intersectionState === PolygonWithPointIntersectionState.FAILURE) {
      vtkErrorMacro13("Error finding point in polygon in vtkCCSPolyInPoly");
    }
    if (intersectionState !== PolygonWithPointIntersectionState.OUTSIDE) {
      let pointOnEdge = 0;
      points.getPoint(outerPoly[n - 1], q1);
      for (let ii = 0; ii < n; ii++) {
        points.getPoint(outerPoly[ii], q2);
        const {
          distance
        } = vtkLine$1.distanceToLine(p, q1, q2);
        if (distance < tol2) {
          pointOnEdge = 1;
          break;
        }
        q1[0] = q2[0];
        q1[1] = q2[1];
        q1[2] = q2[2];
      }
      if (!pointOnEdge) {
        return true;
      }
    }
  }
  return false;
}
function vtkCCSPrepareForPolyInPoly(outerPoly, points, pp, bounds2) {
  const n = outerPoly.length;
  if (n === 0) {
    return 0;
  }
  const point = [];
  let j = 0;
  for (let i = 0; i < n; i++) {
    points.getPoint(outerPoly[i], point);
    pp[j++] = point[0];
    pp[j++] = point[1];
    pp[j++] = point[2];
  }
  return vtkPolygon$1.getBounds(outerPoly, points, bounds2) * (CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE);
}
function vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, normal, oriented) {
  const numNewPolys = newPolys.length;
  if (numNewPolys <= 1) {
    return;
  }
  const polyReversed = [];
  const innerPolys = [];
  let groupCount;
  if (!oriented) {
    groupCount = new Int32Array(numNewPolys);
  }
  let nmax = 1;
  for (let kk = 0; kk < numNewPolys; kk++) {
    nmax = Math.max(nmax, newPolys[kk].length);
  }
  const pp = new Float64Array(3 * nmax);
  const bounds2 = [0, 0, 0, 0, 0, 0];
  let tol2;
  for (let i = 0; i < numNewPolys; i++) {
    const n = newPolys[i].length;
    if (n < 3) {
      continue;
    }
    const {
      isNormalNotZero,
      sense
    } = vtkCCSCheckPolygonSense(newPolys[i], points, normal);
    if (isNormalNotZero) {
      polyReversed[i] = !sense;
    }
    tol2 = vtkCCSPrepareForPolyInPoly(newPolys[i], points, pp, bounds2);
    for (let j = 0; j < numNewPolys; j++) {
      if (j !== i && newPolys[j].length >= 3) {
        const pg = polyGroups[j];
        if (!pg.includes(i)) {
          if (vtkCCSPolyInPoly(newPolys[i], newPolys[j], points, normal, pp.subarray(3 * n), bounds2, tol2)) {
            polyGroups[i].push(j);
            if (groupCount) {
              groupCount[j] += 1;
            }
          }
        }
      }
    }
  }
  if (!oriented) {
    const outerPolyStack = [];
    for (let ll = 0; ll < numNewPolys; ll++) {
      if (groupCount[ll] === 0) {
        outerPolyStack.push(ll);
      }
    }
    let j;
    while (outerPolyStack.length > 0) {
      j = outerPolyStack.length - 1;
      outerPolyStack.pop();
      if (polyReversed[j]) {
        vtkCCSReversePoly(newPolys[j], polyEdges[j], originalEdges);
        polyReversed[j] = false;
      }
      if (polyGroups[j].length > 1) {
        innerPolys.length = 0;
        for (let k = 1; k < polyGroups[j].length; k++) {
          const jj = polyGroups[j][k];
          if (groupCount[jj] > 1) {
            groupCount[jj] -= 2;
            if (groupCount[jj] === 0) {
              outerPolyStack.push(jj);
            }
          } else {
            innerPolys[jj] = 1;
            polyGroups[jj].length = 0;
            if (!polyReversed[jj]) {
              vtkCCSReversePoly(newPolys[jj], polyEdges[jj], originalEdges);
              polyReversed[jj] = false;
            }
          }
        }
        polyGroups[j].length = 0;
        polyGroups[j].push(j);
        for (let jj = 0; jj < numNewPolys; jj++) {
          if (innerPolys[jj]) {
            polyGroups[j].push(jj);
          }
        }
      }
    }
  } else {
    for (let j = 0; j < numNewPolys; j++) {
      if (polyReversed[j]) {
        polyGroups[j].length = 0;
      } else if (polyGroups[j].length > 1) {
        innerPolys.length = 0;
        for (let k = 1; k < polyGroups[j].length; k++) {
          innerPolys[polyGroups[j][k]] = true;
        }
        for (let kk = 1; kk < polyGroups[j].length; kk++) {
          const jj = polyGroups[j][kk];
          if (!polyReversed[jj]) {
            for (let ii = 0; ii < polyGroups[jj].length; ii++) {
              innerPolys[polyGroups[jj][ii]] = false;
            }
          }
        }
        polyGroups[j].length = 0;
        polyGroups[j].push(j);
        for (let jj = 0; jj < numNewPolys; jj++) {
          if (innerPolys[jj]) {
            polyGroups[j].push(jj);
          }
        }
      }
    }
  }
}
function vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, outerIdx, innerIdx) {
  const ptId1 = polys[outerPolyId][outerIdx];
  const ptId2 = polys[innerPolyId][innerIdx];
  const tol = CCS_POLYGON_TOLERANCE;
  const p1 = [];
  const p2 = [];
  points.getPoint(ptId1, p1);
  points.getPoint(ptId2, p2);
  const w = [];
  subtract(p2, p1, w);
  const l = normalize(w);
  if (l === 0) {
    return true;
  }
  const tol2 = l * l * tol * tol;
  let polyId = outerPolyId;
  let polyIdx = outerIdx;
  let r = p1;
  const r1 = [];
  let r2 = p2;
  const r3 = [];
  for (let ii = 0; ii < 2; ii++) {
    const poly = polys[polyId];
    const n = poly.length;
    let prevIdx = n - polyIdx - 1;
    let nextIdx = polyIdx + 1;
    if (prevIdx >= n) {
      prevIdx -= n;
    }
    if (nextIdx >= n) {
      nextIdx -= n;
    }
    points.getPoint(poly[prevIdx], r1);
    points.getPoint(poly[nextIdx], r3);
    if (vtkCCSVectorProgression(r, r1, r2, r3, normal) > 0) {
      return false;
    }
    polyId = innerPolyId;
    polyIdx = innerIdx;
    r = p2;
    r2 = p1;
  }
  const pc = [];
  cross(normal, w, pc);
  pc[3] = -dot(pc, p1);
  for (let i = 0; i < polyGroup.length; i++) {
    const poly = polys[polyGroup[i]];
    const n = poly.length;
    const q1 = [];
    const q2 = [];
    let qtId1 = poly[n - 1];
    points.getPoint(qtId1, q1);
    let v1 = pc[0] * q1[0] + pc[1] * q1[1] + pc[2] * q1[2] + pc[3];
    let c1 = v1 > 0;
    for (let j = 0; j < n; j++) {
      const qtId2 = poly[j];
      points.getPoint(qtId2, q2);
      const v2 = pc[0] * q2[0] + pc[1] * q2[1] + pc[2] * q2[2] + pc[3];
      const c2 = v2 > 0;
      if (ptId1 !== qtId1 && ptId1 !== qtId2 && ptId2 !== qtId1 && ptId2 !== qtId2) {
        if ((c1 ? !c2 : c2) || v1 * v1 < tol2 || v2 * v2 < tol2) {
          subtract(q2, q1, w);
          if (dot(w, w) > 0) {
            const qc = [];
            cross(w, normal, qc);
            qc[3] = -dot(qc, q1);
            const u1 = qc[0] * p1[0] + qc[1] * p1[1] + qc[2] * p1[2] + qc[3];
            const u2 = qc[0] * p2[0] + qc[1] * p2[1] + qc[2] * p2[2] + qc[3];
            const d1 = u1 > 0;
            const d2 = u2 > 0;
            if (d1 ? !d2 : d2) {
              let p = p1;
              let q = q1;
              if (v2 * v2 < v1 * v1) {
                p = p2;
              }
              if (u2 * u2 < u1 * u1) {
                q = q2;
              }
              if (distance2BetweenPoints(p, q) > tol2) {
                return false;
              }
            }
          }
        }
      }
      qtId1 = qtId2;
      q1[0] = q2[0];
      q1[1] = q2[1];
      q1[2] = q2[2];
      v1 = v2;
      c1 = c2;
    }
  }
  return true;
}
function vtkCCSCutQuality(outerPoly, innerPoly, i, j, points) {
  const n = outerPoly.length;
  const m = innerPoly.length;
  const a2 = i > 0 ? i - 1 : n - 1;
  const b2 = i < n - 1 ? i + 1 : 0;
  const c2 = j > 0 ? j - 1 : m - 1;
  const d2 = j < m - 1 ? j + 1 : 0;
  const p0 = [];
  const p1 = [];
  const p2 = [];
  points.getPoint(outerPoly[i], p1);
  points.getPoint(innerPoly[j], p2);
  const v1 = [];
  const v2 = [];
  subtract(p2, p1, v1);
  const l1 = dot(v1, v1);
  let l2;
  let qmax = 0;
  let q;
  points.getPoint(outerPoly[a2], p0);
  subtract(p0, p1, v2);
  l2 = dot(v2, v2);
  if (l2 > 0) {
    q = dot(v1, v2);
    q *= q / l2;
    if (q > qmax) {
      qmax = q;
    }
  }
  points.getPoint(outerPoly[b2], p0);
  subtract(p0, p1, v2);
  l2 = dot(v2, v2);
  if (l2 > 0) {
    q = dot(v1, v2);
    q *= q / l2;
    if (q > qmax) {
      qmax = q;
    }
  }
  points.getPoint(innerPoly[c2], p0);
  subtract(p2, p0, v2);
  l2 = dot(v2, v2);
  if (l2 > 0) {
    q = dot(v1, v2);
    q *= q / l2;
    if (q > qmax) {
      qmax = q;
    }
  }
  points.getPoint(innerPoly[d2], p0);
  subtract(p2, p0, v2);
  l2 = dot(v2, v2);
  if (l2 > 0) {
    q = dot(v1, v2);
    q *= q / l2;
    if (q > qmax) {
      qmax = q;
    }
  }
  if (l1 > 0) {
    return qmax / l1;
  }
  return Number.MAX_VALUE;
}
function vtkCCSFindSharpestVerts(poly, points, normal, verts) {
  const p1 = [];
  const p2 = [];
  const v1 = [];
  const v2 = [];
  const v = [];
  let l1;
  let l2;
  const minVal = [0, 0];
  verts[0] = 0;
  verts[1] = 0;
  const n = poly.length;
  points.getPoint(poly[n - 1], p2);
  points.getPoint(poly[0], p1);
  subtract(p1, p2, v1);
  l1 = Math.sqrt(dot(v1, v1));
  for (let j = 0; j < n; j++) {
    let k = j + 1;
    if (k === n) {
      k = 0;
    }
    points.getPoint(poly[k], p2);
    subtract(p2, p1, v2);
    l2 = Math.sqrt(dot(v2, v2));
    cross(v1, v2, v);
    const b2 = dot(v, normal);
    if (b2 < 0 && l1 * l2 > 0) {
      const val = dot(v1, v2) / (l1 * l2);
      if (val < minVal[0]) {
        minVal[1] = minVal[0];
        minVal[0] = val;
        verts[1] = verts[0];
        verts[0] = j;
      }
    }
    p1[0] = p2[0];
    p1[1] = p2[1];
    p1[2] = p2[2];
    v1[0] = v2[0];
    v1[1] = v2[1];
    v1[2] = v2[2];
    l1 = l2;
  }
}
function vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive) {
  const outerPoly = polys[outerPolyId];
  const innerPoly = polys[innerPolyId];
  const innerSize = innerPoly.length;
  const verts = [];
  vtkCCSFindSharpestVerts(innerPoly, points, normal, verts);
  const cutlist = [];
  cutlist.length = outerPoly.length;
  let cutId = 0;
  cuts[0][0] = 0;
  cuts[0][1] = 0;
  cuts[1][0] = 0;
  cuts[1][1] = 0;
  let foundCut = false;
  for (cutId = 0; cutId < 2; cutId++) {
    const count = exhaustive ? innerSize : 3;
    for (let i = 0; i < count && !foundCut; i++) {
      let j = (i >> 1) + (i & 1) * (innerSize + 1 >> 1);
      j = (j + verts[cutId]) % innerSize;
      for (let kk = 0; kk < outerPoly.length; kk++) {
        const q = vtkCCSCutQuality(outerPoly, innerPoly, kk, j, points);
        cutlist[kk] = [q, kk];
      }
      cutlist.sort((a2, b2) => a2[0] - b2[0]);
      for (let lid = 0; lid < cutlist.length; lid++) {
        const k = cutlist[lid][1];
        if (cutId > 0) {
          if (j === cuts[0][1] || k === cuts[0][0]) {
            continue;
          }
          const p1 = [];
          const p2 = [];
          points.getPoint(outerPoly[cuts[0][0]], p1);
          points.getPoint(innerPoly[cuts[0][1]], p2);
          const q1 = [];
          const q2 = [];
          points.getPoint(outerPoly[k], q1);
          points.getPoint(innerPoly[j], q2);
          let u;
          let v;
          if (vtkLine$1.intersection(p1, p2, q1, q2, u, v) === vtkLine$1.IntersectionState.YES_INTERSECTION) {
            continue;
          }
        }
        if (vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, k, j)) {
          cuts[cutId][0] = k;
          cuts[cutId][1] = j;
          foundCut = true;
          break;
        }
      }
    }
    if (!foundCut) {
      return false;
    }
  }
  return true;
}
function vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts) {
  const q = [];
  const r = [];
  for (let bb = 0; bb < 2; bb++) {
    const ptId1 = polys[outerPolyId][cuts[bb][0]];
    const ptId2 = polys[innerPolyId][cuts[bb][1]];
    points.getPoint(ptId1, q);
    points.getPoint(ptId2, r);
  }
  const outerPoly = polys[outerPolyId];
  const innerPoly = polys[innerPolyId];
  const outerEdges = polyEdges[outerPolyId];
  const innerEdges = polyEdges[innerPolyId];
  const n = outerPoly.length;
  const m = innerPoly.length;
  let idx;
  const n1 = n * (cuts[1][0] < cuts[0][0]) + cuts[1][0] - cuts[0][0] + 1;
  const n2 = n1 + m * (cuts[0][1] < cuts[1][1]) + cuts[0][1] - cuts[1][1] + 1;
  const poly1 = [];
  poly1.length = n2;
  const edges1 = new Array(n2);
  idx = cuts[0][0];
  for (let i1 = 0; i1 < n1; i1++) {
    const k = idx++;
    poly1[i1] = outerPoly[k];
    edges1[i1] = outerEdges[k];
    idx *= idx !== n;
  }
  edges1[n1 - 1] = -1;
  idx = cuts[1][1];
  for (let i2 = n1; i2 < n2; i2++) {
    const k = idx++;
    poly1[i2] = innerPoly[k];
    edges1[i2] = innerEdges[k];
    idx *= idx !== m;
  }
  edges1[n2 - 1] = -1;
  const m1 = n * (cuts[0][0] < cuts[1][0]) + cuts[0][0] - cuts[1][0] + 1;
  const m2 = m1 + m * (cuts[1][1] < cuts[0][1]) + cuts[1][1] - cuts[0][1] + 1;
  const poly2 = [];
  poly2.length = m2;
  const edges2 = new Array(m2);
  idx = cuts[1][0];
  for (let j1 = 0; j1 < m1; j1++) {
    const k = idx++;
    poly2[j1] = outerPoly[k];
    edges2[j1] = outerEdges[k];
    idx *= idx !== n;
  }
  edges2[m1 - 1] = -1;
  idx = cuts[0][1];
  for (let j2 = m1; j2 < m2; j2++) {
    const k = idx++;
    poly2[j2] = innerPoly[k];
    edges2[j2] = innerEdges[k];
    idx *= idx !== m;
  }
  edges2[m2 - 1] = -1;
  polys[outerPolyId] = poly1;
  polys[innerPolyId] = poly2;
  polyEdges[outerPolyId] = edges1;
  polyEdges[innerPolyId] = edges2;
}
function vtkCCSCutHoleyPolys(polys, points, polyGroups, polyEdges, normal) {
  let cutFailure = 0;
  let groupId = 0;
  while (groupId < polyGroups.length) {
    const polyGroup = polyGroups[groupId];
    if (polyGroup.length > 1) {
      const outerPolyId = polyGroup[0];
      let innerPolyId = polyGroup[1];
      let innerBySize = new Array(polyGroup.length);
      for (let i = 1; i < polyGroup.length; i++) {
        innerBySize[i] = [polys[polyGroup[i]].length, i];
      }
      innerBySize = [innerBySize[0], ...innerBySize.splice(1).sort((a2, b2) => a2[0] - b2[0])];
      reverseElements(innerBySize, 1, innerBySize.length - 1);
      let madeCut = 0;
      let inner = 0;
      const cuts = [[0, 0], [0, 0]];
      for (let exhaustive = 0; exhaustive < 2 && !madeCut; exhaustive++) {
        for (let j = 1; j < polyGroup.length; j++) {
          inner = innerBySize[j][1];
          innerPolyId = polyGroup[inner];
          if (vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive)) {
            vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts);
            madeCut = 1;
            break;
          }
        }
      }
      if (madeCut) {
        polyGroup.splice(inner, 1);
        if (polyGroups[innerPolyId].length === 0) {
          polyGroups[innerPolyId].push(innerPolyId);
        }
      } else {
        for (let k = 1; k < polyGroup.length; k++) {
          innerPolyId = polyGroup[k];
          if (polyGroups[innerPolyId].length === 0) {
            polyGroups[innerPolyId].push(innerPolyId);
          }
        }
        polyGroup.length = 1;
        cutFailure = 1;
      }
      if (polyGroup.length > 1) {
        const poly1 = polys[outerPolyId];
        const pp = new Float64Array(3 * poly1.length);
        const bounds2 = [0, 0, 0, 0, 0, 0];
        const tol2 = vtkCCSPrepareForPolyInPoly(poly1, points, pp, bounds2);
        let nextGroupId = groupId;
        let ii = 1;
        while (ii < polyGroup.length) {
          if (vtkCCSPolyInPoly(poly1, polys[polyGroup[ii]], points, normal, pp, bounds2, tol2)) {
            ii++;
          } else {
            polyGroups[innerPolyId].push(polyGroup[ii]);
            polyGroup.splice(ii, 1);
            if (innerPolyId < nextGroupId) {
              nextGroupId = innerPolyId;
            }
          }
        }
        groupId = nextGroupId;
        continue;
      }
    }
    groupId++;
  }
  return !cutFailure;
}

// node_modules/@kitware/vtk.js/Filters/General/ContourTriangulator.js
var {
  vtkErrorMacro: vtkErrorMacro14
} = macro;
var TRIANGULATION_ERROR_DISPLAY = false;
function triangulateContours(polyData, firstLine, numLines, polys, normal) {
  let triangulatePolys = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
  let triangulationFailure = false;
  if (numLines <= 0) {
    return false;
  }
  const points = polyData.getPoints();
  const newPolys = [];
  const incompletePolys = [];
  const oriented = (normal == null ? void 0 : normal.length) < 3;
  vtkCCSMakePolysFromLines(polyData, firstLine, firstLine + numLines, oriented, newPolys, incompletePolys);
  let computedNormal = normal;
  if (!oriented) {
    computedNormal = [0, 0, 1];
    let maxnorm = 0;
    const n = [];
    for (let i = 0; i < newPolys.length; i++) {
      const norm2 = vtkPolygon$1.getNormal(newPolys[i], points, n);
      if (norm2 > maxnorm) {
        maxnorm = norm2;
        computedNormal[0] = n[0];
        computedNormal[1] = n[1];
        computedNormal[2] = n[2];
      }
    }
  }
  vtkCCSJoinLooseEnds(newPolys, incompletePolys, points, computedNormal);
  const polyEdges = [];
  const originalEdges = [];
  vtkCCSFindTrueEdges(newPolys, points, polyEdges, originalEdges);
  const numNewPolys = newPolys.length;
  const polyGroups = new Array(numNewPolys);
  for (let i = 0; i < numNewPolys; i++) {
    polyGroups[i] = [i];
  }
  vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, computedNormal, oriented);
  if (!vtkCCSCutHoleyPolys(newPolys, points, polyGroups, polyEdges, computedNormal)) {
    triangulationFailure = true;
  }
  vtkCCSSplitAtPinchPoints(newPolys, points, polyGroups, polyEdges, computedNormal, oriented);
  for (let polyId = 0; polyId < polyGroups.length; polyId++) {
    if (polyGroups[polyId].length === 0) {
      continue;
    }
    if (!triangulatePolys) {
      polys.insertNextCell(originalEdges.slice(1, originalEdges.length));
    } else if (!vtkCCSTriangulate(newPolys[polyId], points, polyEdges[polyId], originalEdges, polys, computedNormal)) {
      triangulationFailure = false;
    }
  }
  return !triangulationFailure;
}
function triangulatePolygon(polygon, points, triangles) {
  const poly = [...polygon];
  const polys = [poly];
  const originalEdges = [];
  const polyEdges = [];
  vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges);
  const edges = polyEdges[0];
  let success = true;
  const normal = [];
  const norm2 = vtkPolygon$1.getNormal(poly, points, normal);
  if (norm2 !== 0) {
    success = vtkCCSTriangulate(poly, points, edges, originalEdges, triangles, normal);
  }
  return success;
}
var STATIC5 = {
  triangulateContours,
  triangulatePolygon
};
function vtkContourTriangulator(publicAPI, model) {
  model.classHierarchy.push("vtkContourTriangulator");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    outData[0] = output;
    if (!input) {
      vtkErrorMacro14("Invalid or missing input");
      return false;
    }
    let triangulationError = false;
    const lines = input.getLines();
    if (lines == null || lines.getNumberOfCells() === 0) {
      return true;
    }
    input.buildCells();
    const polysArray = vtkCellArray$1.newInstance({
      dataType: VtkDataTypes.DOUBLE,
      empty: true
    });
    output.setPolys(polysArray);
    output.setPoints(input.getPoints());
    output.getPointData().passData(input.getPointData());
    triangulationError = !triangulateContours(input, input.getNumberOfVerts(), lines.getNumberOfCells(), polysArray, null, model.triangulatePolys);
    if (triangulationError && TRIANGULATION_ERROR_DISPLAY) {
      vtkErrorMacro14("Triangulation failed, output might have holes.");
    }
    return true;
  };
}
var DEFAULT_VALUES20 = {
  triangulatePolys: true
};
function extend26(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["triangulatePolys"]);
  vtkContourTriangulator(publicAPI, model);
}
var newInstance25 = macro.newInstance(extend26, "vtkContourTriangulator");
var vtkContourTriangulator$1 = {
  newInstance: newInstance25,
  extend: extend26,
  ...STATIC5
};

// node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js
var EdgeLocator = class {
  constructor() {
    let oriented = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    this.oriented = oriented;
    this.edgeMap = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.edgeMap.clear();
  }
  computeEdgeKey(pointId0, pointId1) {
    return this.oriented || pointId0 < pointId1 ? (
      // Cantor pairing function:
      0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1
    ) : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;
  }
  insertUniqueEdge(pointId0, pointId1, newEdgeValue) {
    const key = this.computeEdgeKey(pointId0, pointId1);
    let node = this.edgeMap.get(key);
    if (!node) {
      node = {
        key,
        edgeId: this.edgeMap.size,
        value: newEdgeValue
      };
      this.edgeMap.set(key, node);
    }
    return node;
  }
  insertEdge(pointId0, pointId1, newEdgeValue) {
    const key = this.computeEdgeKey(pointId0, pointId1);
    const node = {
      key,
      edgeId: this.edgeMap.size,
      value: newEdgeValue
    };
    this.edgeMap.set(key, node);
    return node;
  }
  isInsertedEdge(pointId0, pointId1) {
    const key = this.computeEdgeKey(pointId0, pointId1);
    return this.edgeMap.get(key);
  }
  static getEdgePointIds(node) {
    const n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));
    const pointId0 = node.key - 0.5 * (n + 1) * n;
    const pointId1 = n - pointId0;
    return [pointId0, pointId1];
  }
};
function newInstance26() {
  let initialValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return new EdgeLocator(initialValues.oriented);
}
var vtkEdgeLocator = {
  newInstance: newInstance26
};

// node_modules/@kitware/vtk.js/Filters/General/ClipClosedSurface/Constants.js
var ScalarMode2 = {
  NONE: 0,
  COLORS: 1,
  LABELS: 2
};
var Constants5 = {
  ScalarMode: ScalarMode2
};

// node_modules/@kitware/vtk.js/Filters/General/ClipClosedSurface.js
var {
  vtkErrorMacro: vtkErrorMacro15,
  capitalize: capitalize2
} = macro;
var {
  ScalarMode: ScalarMode3
} = Constants5;
function vtkClipClosedSurface(publicAPI, model) {
  model.classHierarchy.push("vtkClipClosedSurface");
  publicAPI.getMTime = () => model.clippingPlanes.reduce((a2, b2) => b2.getMTime() > a2 ? b2.getMTime() : a2, model.mtime);
  function createColorValues(color1, color22, color33, colors) {
    const dcolors = [color1, color22, color33];
    const clamp2 = (n, min, max2) => Math.min(Math.max(n, min), max2);
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        colors[i][j] = Math.round(clamp2(dcolors[i][j], 0, 1) * 255);
      }
    }
  }
  function interpolateEdge(points, pointData, locator, tol, i0, i1, v0, v1) {
    if (v1 > 0) {
      [i0, i1] = [i1, i0];
      [v0, v1] = [v1, v0];
    }
    const edge = locator.insertUniqueEdge(i0, i1);
    if (edge.value != null) {
      return edge.value;
    }
    const p0 = points.getPoint(i0);
    const p1 = points.getPoint(i1);
    const f2 = v0 / (v0 - v1);
    const s = 1 - f2;
    const t = 1 - s;
    const p = [s * p0[0] + t * p1[0], s * p0[1] + t * p1[1], s * p0[2] + t * p1[2]];
    const tol2 = tol * tol;
    if (distance2BetweenPoints(p, p0) < tol2) {
      edge.value = i0;
      return i0;
    }
    if (distance2BetweenPoints(p, p1) < tol2) {
      edge.value = i1;
      return i1;
    }
    edge.value = points.insertNextTuple(p);
    pointData.interpolateData(pointData, i0, i1, edge.value, t);
    return edge.value;
  }
  function clipLines(points, pointScalars, pointData, edgeLocator, inputLines, outputLines, inLineData, outLineData) {
    let numPts;
    let i0;
    let i1;
    let v0;
    let v1;
    let c0;
    let c1;
    const linePts = [];
    const values = inputLines.getData();
    let cellId = 0;
    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {
      numPts = values[i];
      i1 = values[i + 1];
      v1 = pointScalars.getData()[i1];
      c1 = v1 > 0;
      for (let j = 2; j <= numPts; j++) {
        i0 = i1;
        v0 = v1;
        c0 = c1;
        i1 = values[i + j];
        v1 = pointScalars.getData()[i1];
        c1 = v1 > 0;
        if (c0 || c1) {
          if (c0 ? !c1 : c1) {
            linePts[c0 ? 1 : 0] = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);
          }
          if (i0 !== i1) {
            linePts[0] = i0;
            linePts[1] = i1;
            const newCellId = outputLines.insertNextCell(linePts);
            outLineData.passData(inLineData, cellId, newCellId);
          }
        }
      }
    }
  }
  function breakPolylines(inputLines, outputLines, inputScalars, firstLineScalar, scalars, color4) {
    const cellColor = [...color4];
    let cellId = 0;
    const values = inputLines.getData();
    let numPts;
    for (let i = 0; i < values.length; i += numPts + 1) {
      numPts = values[i];
      if (inputScalars) {
        inputScalars.getTuple(firstLineScalar + cellId++, cellColor);
      }
      for (let j = 1; j < numPts; j++) {
        outputLines.insertNextCell([values[i + j], values[i + j + 1]]);
        if (scalars) {
          scalars.insertNextTuple(cellColor);
        }
      }
    }
  }
  function copyPolygons(inputPolys, outputPolys, inputScalars, firstPolyScalar, polyScalars, color4) {
    if (!inputPolys) {
      return;
    }
    outputPolys.deepCopy(inputPolys);
    if (polyScalars) {
      const scalarValue = [...color4];
      const n = outputPolys.getNumberOfCells();
      polyScalars.insertTuple(n - 1, scalarValue);
      if (inputScalars) {
        for (let i = 0; i < n; i++) {
          inputScalars.getTuple(i + firstPolyScalar, scalarValue);
          polyScalars.setTuple(i, scalarValue);
        }
      } else {
        for (let i = 0; i < n; i++) {
          polyScalars.setTuple(i, scalarValue);
        }
      }
    }
  }
  function breakTriangleStrips(inputStrips, polys, inputScalars, firstStripScalar, polyScalars, color4) {
    if (inputStrips.getNumberOfCells() === 0) {
      return;
    }
    const values = inputStrips.getData();
    let cellId = firstStripScalar;
    let numPts;
    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {
      numPts = values[i];
      let p1 = values[i + 1];
      let p2 = values[i + 2];
      for (let j = 0; j < numPts - 2; j++) {
        const p3 = values[i + j + 3];
        if (j % 2) {
          polys.insertNextCell([p2, p1, p3]);
        } else {
          polys.insertNextCell([p1, p2, p3]);
        }
        p1 = p2;
        p2 = p3;
      }
      if (polyScalars) {
        const scalarValue = [...color4];
        if (inputScalars) {
          inputScalars.getTuple(cellId, scalarValue);
        }
        const n = numPts - 3;
        const m = polyScalars.getNumberOfTuples();
        if (n >= 0) {
          polyScalars.insertTuple(m + n, scalarValue);
          for (let k = 0; k < n; k++) {
            polyScalars.setTuple(m + k, scalarValue);
          }
        }
      }
    }
  }
  function triangulateContours2(polyData, firstLine, numLines, outputPolys, normal) {
    if (numLines <= 0) {
      return;
    }
    const triangulationError = !vtkContourTriangulator$1.triangulateContours(polyData, firstLine, numLines, outputPolys, [-normal[0], -normal[1], -normal[2]]);
    if (triangulationError && model.triangulationErrorDisplay) {
      vtkErrorMacro15("Triangulation failed, polyData may not be watertight.");
    }
  }
  function triangulatePolygon2(polygon, points, triangles) {
    return vtkContourTriangulator$1.triangulatePolygon(polygon, points, triangles);
  }
  function clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, inputPolys, outputPolys, outputLines, inCellData, outPolyData, outLineData) {
    const idList = model._idList;
    let polyMax = Number.MAX_VALUE;
    if (triangulate) {
      if (triangulate < 4) {
        polyMax = 3;
      } else if (triangulate === 4) {
        polyMax = 4;
      }
    }
    let triangulationFailure = false;
    const values = inputPolys.getData();
    const linePts = [];
    let cellId = 0;
    let numPts;
    for (let i = 0; i < values.length; i += numPts + 1, cellId++) {
      numPts = values[i];
      let i1 = values[i + numPts];
      let v1 = pointScalars.getData()[i1];
      let c1 = v1 > 0;
      let j0 = c1 ? i1 : -1;
      let j1 = 0;
      linePts[0] = 0;
      linePts[1] = 0;
      let idListIdx = 0;
      for (let j = 1; j <= numPts; j++) {
        const i0 = i1;
        const v0 = v1;
        const c0 = c1;
        i1 = values[i + j];
        v1 = pointScalars.getData()[i1];
        c1 = v1 > 0;
        if (c0 || c1) {
          if (c0 ? !c1 : c1) {
            j1 = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);
            if (j1 !== j0) {
              idList[idListIdx++] = j1;
              j0 = j1;
            }
            linePts[c0 ? 1 : 0] = j1;
          }
          if (c1) {
            j1 = i1;
            if (j1 !== j0) {
              idList[idListIdx++] = j1;
              j0 = j1;
            }
          }
        }
      }
      const numPoints = idListIdx;
      idList.length = numPoints;
      if (model.triangulatePolys && numPoints > polyMax) {
        let newCellId = outputPolys.getNumberOfCells();
        const success = triangulatePolygon2(idList, points, outputPolys);
        if (!success) {
          triangulationFailure = true;
        }
        const ncells = outputPolys.getNumberOfCells();
        for (; newCellId < ncells; newCellId++) {
          outPolyData.passData(inCellData, cellId, newCellId);
        }
      } else if (numPoints > 2) {
        const newCellId = outputPolys.insertNextCell(idList);
        outPolyData.passData(inCellData, cellId, newCellId);
      }
      if (linePts[0] !== linePts[1]) {
        const newCellId = outputLines.insertNextCell(linePts);
        outLineData.passData(inCellData, cellId, newCellId);
      }
    }
    if (triangulationFailure && model.triangulationErrorDisplay) {
      vtkErrorMacro15("Triangulation failed, output may not be watertight");
    }
  }
  function squeezeOutputPoints(output, points, pointData, outputPointDataType) {
    const n = points.getNumberOfPoints();
    let numNewPoints = 0;
    const outPointData = output.getPointData();
    const pointMap = [];
    pointMap.length = n;
    const cellArrays = [output.getVerts(), output.getLines(), output.getPolys(), output.getStrips()];
    cellArrays.forEach((cellArray) => {
      if (!cellArray) {
        return;
      }
      const values = cellArray.getData();
      let numPts;
      let pointId;
      for (let i = 0; i < values.length; i += numPts + 1) {
        numPts = values[i];
        for (let j = 1; j <= numPts; j++) {
          pointId = values[i + j];
          if (pointMap[pointId] === void 0) {
            pointMap[pointId] = numNewPoints++;
          }
        }
      }
    });
    const newPoints = vtkPoints$1.newInstance({
      size: numNewPoints * 3,
      dataType: outputPointDataType
    });
    const p = [];
    let newPointId;
    for (let pointId = 0; pointId < n; pointId++) {
      newPointId = pointMap[pointId];
      if (newPointId !== void 0) {
        points.getPoint(pointId, p);
        newPoints.setTuple(newPointId, p);
        outPointData.passData(pointData, pointId, newPointId);
      }
    }
    cellArrays.forEach((cellArray) => {
      if (!cellArray) {
        return;
      }
      const values = cellArray.getData();
      let numPts;
      let pointId;
      for (let i = 0; i < values.length; i += numPts + 1) {
        numPts = values[i];
        for (let j = 1; j <= numPts; j++) {
          pointId = values[i + j];
          values[i + j] = pointMap[pointId];
        }
      }
    });
    output.setPoints(newPoints);
  }
  publicAPI.requestData = (inData, outData) => {
    var _a, _b, _c;
    const input = inData[0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    outData[0] = output;
    if (!input) {
      vtkErrorMacro15("Invalid or missing input");
      return;
    }
    if (model._idList == null) {
      model._idList = [];
    } else {
      model._idList.length = 0;
    }
    const inputPoints = input.getPoints();
    let numPts = 0;
    let inputPointsType = VtkDataTypes.FLOAT;
    if (inputPoints) {
      numPts = inputPoints.getNumberOfPoints();
      inputPointsType = inputPoints.getDataType();
    }
    const points = vtkPoints$1.newInstance({
      size: numPts * 3,
      dataType: VtkDataTypes.DOUBLE
    });
    const pointData = vtkDataSetAttributes$1.newInstance();
    let inPointData = null;
    if (model.passPointData) {
      inPointData = input.getPointData();
    }
    const point = [];
    for (let ptId = 0; ptId < numPts; ptId++) {
      inputPoints.getPoint(ptId, point);
      points.setTuple(ptId, point);
      if (inPointData) {
        pointData.passData(inPointData, ptId, ptId);
      }
    }
    const edgeLocator = vtkEdgeLocator.newInstance();
    const tmpContourData = vtkPolyData$1.newInstance();
    let lineScalars;
    let polyScalars;
    let inputScalars;
    let firstLineScalar = 0;
    let firstPolyScalar = 0;
    let firstStripScalar = 0;
    let numberOfScalarComponents = 1;
    const colors = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    if (model.scalarMode === ScalarMode3.COLORS) {
      numberOfScalarComponents = 3;
      createColorValues(model.baseColor, model.clipColor, model.activePlaneColor, colors);
    } else if (model.scalarMode === ScalarMode3.LABELS) {
      colors[0][0] = 0;
      colors[1][0] = 1;
      colors[2][0] = 2;
    }
    const numVerts = ((_b = input.getVerts()) == null ? void 0 : _b.getNumberOfCells()) || 0;
    const inputLines = input.getLines();
    const numLines = (inputLines == null ? void 0 : inputLines.getNumberOfCells()) || 0;
    const inputPolys = input.getPolys();
    const numPolys = (inputPolys == null ? void 0 : inputPolys.getNumberOfCells()) || 0;
    const numStrips = ((_c = input.getStrips()) == null ? void 0 : _c.getNumberOfCells()) || 0;
    if (model.scalarMode !== ScalarMode3.NONE) {
      lineScalars = vtkDataArray$1.newInstance({
        dataType: VtkDataTypes.UNSIGNED_CHAR,
        empty: true,
        // size: 0,
        // values: new Uint8Array(numLines * 3),
        numberOfComponents: numberOfScalarComponents
      });
      const tryInputScalars = input.getCellData().getScalars();
      if (tryInputScalars && tryInputScalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR && numberOfScalarComponents === 3 && tryInputScalars.getNumberOfComponents() === 3) {
        inputScalars = input.getCellData().getScalars();
        firstLineScalar = numVerts;
        firstPolyScalar = numVerts + numLines;
        firstStripScalar = numVerts + numLines + numPolys;
      }
    }
    let lines;
    if (numLines > 0) {
      lines = vtkCellArray$1.newInstance({
        dataType: inputLines.getDataType(),
        values: new Uint8Array(numLines * 3),
        // we will have at least that amount of lines
        size: 0
      });
      breakPolylines(inputLines, lines, inputScalars, firstLineScalar, lineScalars, colors[0]);
    } else {
      lines = vtkCellArray$1.newInstance({
        empty: true
      });
    }
    let polys = null;
    let polyMax = 3;
    if (numPolys > 0 || numStrips > 0) {
      if (lineScalars) {
        polyScalars = vtkDataArray$1.newInstance({
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          empty: true,
          // size: 0,
          // values: new Uint8Array(inputPolys.getNumberOfCells(false) * 3),
          numberOfComponents: numberOfScalarComponents
        });
      }
      polys = vtkCellArray$1.newInstance();
      copyPolygons(inputPolys, polys, inputScalars, firstPolyScalar, polyScalars, colors[0]);
      breakTriangleStrips(input.getStrips(), polys, inputScalars, firstStripScalar, polyScalars, colors[0]);
      polyMax = inputPolys.getCellSizes().reduce((a2, b2) => a2 > b2 ? a2 : b2, 0);
    }
    let newLines = vtkCellArray$1.newInstance({
      dataType: lines.getDataType(),
      empty: true
    });
    let newPolys = null;
    if (polys) {
      newPolys = vtkCellArray$1.newInstance({
        dataType: polys.getDataType(),
        empty: true
      });
    }
    let inLineData = vtkDataSetAttributes$1.newInstance();
    inLineData.copyScalarsOn();
    inLineData.setScalars(lineScalars);
    let inPolyData = vtkDataSetAttributes$1.newInstance();
    inPolyData.copyScalarsOn();
    inPolyData.setScalars(polyScalars);
    let outLineData = vtkDataSetAttributes$1.newInstance();
    outLineData.copyScalarsOn();
    let outPolyData = vtkDataSetAttributes$1.newInstance();
    outPolyData.copyScalarsOn();
    const planes = model.clippingPlanes;
    for (let planeId = 0; planeId < planes.length; planeId++) {
      const plane = planes[planeId];
      let triangulate = 5;
      if (planeId === planes.length - 1) {
        triangulate = polyMax;
      }
      const active = planeId === model.activePlaneId;
      const pc = plane.getNormal();
      pc[3] = -dot(pc, plane.getOrigin());
      const numPoints = points.getNumberOfPoints();
      const pointScalars = vtkDataArray$1.newInstance({
        dataType: VtkDataTypes.DOUBLE,
        size: numPoints
      });
      const pointScalarsData = pointScalars.getData();
      const pointsData = points.getData();
      let i = 0;
      for (let pointId = 0; pointId < numPoints; pointId) {
        pointScalarsData[pointId++] = pointsData[i++] * pc[0] + pointsData[i++] * pc[1] + pointsData[i++] * pc[2] + pc[3];
      }
      edgeLocator.initialize();
      clipLines(points, pointScalars, pointData, edgeLocator, lines, newLines, inLineData, outLineData);
      if (polys) {
        const numClipLines = newLines.getNumberOfCells();
        clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, polys, newPolys, newLines, inPolyData, outPolyData, outLineData);
        let scalars2 = outLineData.getScalars();
        if (scalars2) {
          const color4 = colors[1 + (active ? 1 : 0)];
          const activeColor = colors[2];
          const numNewLines = newLines.getNumberOfCells();
          const oldColor = [];
          for (let lineId = numClipLines; lineId < numNewLines; lineId++) {
            scalars2.getTuple(lineId, oldColor);
            if (numberOfScalarComponents !== 3 || oldColor[0] !== activeColor[0] || oldColor[1] !== activeColor[1] || oldColor[2] !== activeColor[2]) {
              scalars2.setTuple(lineId, color4);
            }
          }
        }
        let cellId = newPolys.getNumberOfCells();
        const numClipAndContourLines = newLines.getNumberOfCells();
        tmpContourData.setPoints(points);
        tmpContourData.setLines(newLines);
        tmpContourData.buildCells();
        triangulateContours2(tmpContourData, numClipLines, numClipAndContourLines - numClipLines, newPolys, pc);
        scalars2 = outPolyData.getScalars();
        if (scalars2) {
          const color4 = colors[1 + (active ? 1 : 0)];
          const numCells = newPolys.getNumberOfCells();
          if (numCells > cellId) {
            scalars2.insertTuple(numCells - 1, color4);
            for (; cellId < numCells; cellId++) {
              scalars2.setTuple(cellId, color4);
            }
          }
        }
        scalars2 = outLineData.getScalars();
        if (scalars2) {
          const color4 = [0, 255, 255];
          const numCells = newLines.getNumberOfCells();
          if (numCells > numClipAndContourLines) {
            scalars2.insertTuple(numCells - 1, color4);
            for (let lineCellId = numClipAndContourLines; lineCellId < numCells; lineCellId++) {
              scalars2.setTuple(lineCellId, color4);
            }
          }
        }
      }
      [lines, newLines] = [newLines, lines];
      newLines.initialize();
      if (polys) {
        [polys, newPolys] = [newPolys, polys];
        newPolys.initialize();
      }
      [inLineData, outLineData] = [outLineData, inLineData];
      outLineData.initialize();
      [inPolyData, outPolyData] = [outPolyData, inPolyData];
      outPolyData.initialize();
    }
    const scalars = inLineData.getScalars();
    if (model.generateOutline) {
      output.setLines(lines);
    } else if (scalars) {
      scalars.initialize();
    }
    if (model.generateFaces) {
      output.setPolys(polys);
      if (polys && scalars) {
        const pScalars = inPolyData.getScalars();
        const m = scalars.getNumberOfTuples();
        const n = pScalars.getNumberOfTuples();
        if (n > 0) {
          const color4 = [0, 0, 0];
          scalars.insertTuple(n + m - 1, color4);
          for (let i = 0; i < n; i++) {
            pScalars.getTuple(i, color4);
            scalars.setTuple(i + m, color4);
          }
        }
      }
    }
    if (scalars && model.scalarMode === ScalarMode3.COLORS) {
      scalars.setName("Colors");
      output.getCellData().setScalars(scalars);
    } else if (model.scalarMode === ScalarMode3.LABELS) {
      const categories = scalars.newClone();
      categories.setData(scalars.getData().slice());
      categories.setName("Labels");
      output.getCellData().setScalars(categories);
    } else {
      output.getCellData().setScalars(null);
    }
    squeezeOutputPoints(output, points, pointData, inputPointsType);
  };
  Object.keys(ScalarMode3).forEach((key) => {
    const name2 = capitalize2(key.toLowerCase());
    publicAPI[`setScalarModeTo${name2}`] = () => {
      model.scalarMode = ScalarMode3[key];
    };
  });
}
var DEFAULT_VALUES21 = {
  clippingPlanes: null,
  tolerance: 1e-6,
  passPointData: false,
  triangulatePolys: false,
  scalarMode: ScalarMode3.NONE,
  generateOutline: false,
  generateFaces: true,
  activePlaneId: -1,
  baseColor: [255 / 255, 99 / 255, 71 / 255],
  // Tomato
  clipColor: [244 / 255, 164 / 255, 96 / 255],
  // Sandy brown
  activePlaneColor: [227 / 255, 207 / 255, 87 / 255],
  // Banana
  triangulationErrorDisplay: false
  // _idList: null,
};
function extend27(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["clippingPlanes", "tolerance", "passPointData", "triangulatePolys", "scalarMode", "generateOutline", "generateFaces", "activePlaneId", "triangulationErrorDisplay"]);
  macro.setGetArray(publicAPI, model, ["baseColor", "clipColor", "activePlaneColor"], 3);
  vtkClipClosedSurface(publicAPI, model);
}
var newInstance27 = macro.newInstance(extend27, "vtkClipClosedSurface");
var vtkClipClosedSurface$1 = {
  newInstance: newInstance27,
  extend: extend27,
  ...Constants5
};

// node_modules/@kitware/vtk.js/Filters/General/ClosedPolyLineToSurfaceFilter.js
var {
  vtkErrorMacro: vtkErrorMacro16
} = macro;
var SegmentAgregator = class {
  constructor() {
    this.segmentMapping = {};
    this.segments = [null];
    this.faces = [];
  }
  addSegment(segment) {
    const first = segment[0];
    const last = segment[segment.length - 1];
    if (first === last || segment.length < 2) {
      return;
    }
    const mappingFirst = this.segmentMapping[first];
    const mappingLast = this.segmentMapping[last];
    if (mappingFirst !== void 0 && mappingLast !== void 0) {
      if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {
        const idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;
        const seg = this.segments[idx];
        if (mappingFirst > 0) {
          for (let i = 1; i < segment.length - 1; i++) {
            seg.push(segment[i]);
          }
        } else {
          for (let i = 1; i < segment.length - 1; i++) {
            seg.unshift(segment[segment.length - 1 - i]);
          }
        }
        this.faces.push(seg);
        this.segments[idx] = null;
        this.segmentMapping[first] = void 0;
        this.segmentMapping[last] = void 0;
      } else {
        const idxHead = Math.abs(mappingFirst);
        const idxTail = Math.abs(mappingLast);
        const segHead = this.segments[idxHead];
        const segTail = this.segments[idxTail];
        this.segments[idxHead] = null;
        this.segments[idxTail] = null;
        this.segmentMapping[segHead[0]] = void 0;
        this.segmentMapping[segTail[0]] = void 0;
        this.segmentMapping[segHead[segHead.length - 1]] = void 0;
        this.segmentMapping[segTail[segTail.length - 1]] = void 0;
        this.addSegment(segment);
        this.addSegment(segHead);
        this.addSegment(segTail);
      }
    } else if (mappingFirst !== void 0) {
      if (mappingFirst > 0) {
        const seg = this.segments[mappingFirst];
        for (let i = 1; i < segment.length; i++) {
          seg.push(segment[i]);
        }
        this.segmentMapping[last] = mappingFirst;
      } else {
        const seg = this.segments[-mappingFirst];
        this.segmentMapping[last] = mappingFirst;
        for (let i = 1; i < segment.length; i++) {
          seg.unshift(segment[i]);
        }
      }
      this.segmentMapping[first] = void 0;
    } else if (mappingLast !== void 0) {
      if (mappingLast > 0) {
        const seg = this.segments[mappingLast];
        for (let i = 1; i < segment.length; i++) {
          seg.push(segment[segment.length - 1 - i]);
        }
        this.segmentMapping[first] = mappingLast;
      } else {
        const seg = this.segments[-mappingLast];
        this.segmentMapping[first] = mappingLast;
        for (let i = 1; i < segment.length; i++) {
          seg.unshift(segment[segment.length - i - 1]);
        }
      }
      this.segmentMapping[last] = void 0;
    } else {
      const id = this.segments.length;
      this.segments.push(segment);
      this.segmentMapping[first] = -id;
      this.segmentMapping[last] = id;
    }
  }
};
function vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {
  model.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro16("Invalid or missing input");
      return;
    }
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    output.shallowCopy(input);
    const agregator = new SegmentAgregator();
    const lines = input.getLines().getData();
    let offset = 0;
    while (offset < lines.length) {
      const lineSize = lines[offset++];
      const lineSegment = [];
      for (let i = 0; i < lineSize; i++) {
        lineSegment.push(lines[offset + i]);
      }
      agregator.addSegment(lineSegment);
      offset += lineSize;
    }
    const {
      faces
    } = agregator;
    let cellArraySize = faces.length;
    for (let i = 0; i < faces.length; i++) {
      cellArraySize += faces[i].length;
    }
    const cellArray = new Uint16Array(cellArraySize);
    offset = 0;
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      cellArray[offset++] = face.length;
      for (let j = 0; j < face.length; j++) {
        cellArray[offset++] = face[j];
      }
    }
    output.setPolys(vtkCellArray$1.newInstance({
      values: cellArray,
      name: "faces"
    }));
    outData[0] = output;
  };
}
var DEFAULT_VALUES22 = {};
function extend28(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES22, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);
}
var newInstance28 = macro.newInstance(extend28, "vtkClosedPolyLineToSurfaceFilter");
var vtkClosedPolyLineToSurfaceFilter$1 = {
  newInstance: newInstance28,
  extend: extend28
};

// node_modules/@kitware/vtk.js/Filters/General/ImageCropFilter.js
var {
  vtkErrorMacro: vtkErrorMacro17
} = macro;
function vtkImageCropFilter(publicAPI, model) {
  model.classHierarchy.push("vtkImageCropFilter");
  publicAPI.reset = () => {
    const data2 = publicAPI.getInputData();
    if (data2) {
      publicAPI.setCroppingPlanes(...data2.getExtent());
    }
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro17("Invalid or missing input");
      return;
    }
    const outImage = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkImageData$1.newInstance();
    outData[0] = outImage;
    const scalars = input.getPointData().getScalars();
    if (!scalars) {
      vtkErrorMacro17("No scalars from input");
      return;
    }
    const extent = input.getExtent();
    const cropped = model.croppingPlanes && model.croppingPlanes.length === 6 ? extent.map((e2, i) => {
      if (i % 2 === 0) {
        return Math.max(e2, Math.round(model.croppingPlanes[i]));
      }
      return Math.min(e2, Math.round(model.croppingPlanes[i]));
    }) : extent.slice();
    if (cropped[0] === extent[0] && cropped[1] === extent[1] && cropped[2] === extent[2] && cropped[3] === extent[3] && cropped[4] === extent[4] && cropped[5] === extent[5]) {
      outImage.shallowCopy(input);
      return;
    }
    for (let i = 0; i < 3; ++i) {
      if (cropped[i * 2] > cropped[i * 2 + 1]) {
        [cropped[i * 2], cropped[i * 2 + 1]] = [cropped[i * 2 + 1], cropped[i * 2]];
      }
    }
    for (let i = 0; i < 6; i += 2) {
      cropped[i] = Math.max(cropped[i], extent[i]);
      cropped[i + 1] = Math.min(cropped[i + 1], extent[i + 1]);
    }
    const numberOfComponents = scalars.getNumberOfComponents();
    const componentSize = (cropped[1] - cropped[0] + 1) * (cropped[3] - cropped[2] + 1) * (cropped[5] - cropped[4] + 1) * numberOfComponents;
    const scalarsData = scalars.getData();
    const dims = input.getDimensions();
    const jStride = numberOfComponents * dims[0];
    const kStride = numberOfComponents * dims[0] * dims[1];
    const beginOffset = (cropped[0] - extent[0]) * numberOfComponents;
    const stripSize = (cropped[1] - cropped[0] + 1) * numberOfComponents;
    const croppedArray = new scalarsData.constructor(componentSize);
    let index = 0;
    for (let k = cropped[4]; k <= cropped[5]; ++k) {
      for (let j = cropped[2]; j <= cropped[3]; ++j) {
        const begin2 = beginOffset + (j - extent[2]) * jStride + (k - extent[4]) * kStride;
        const end2 = begin2 + stripSize;
        const slice = scalarsData.subarray(begin2, end2);
        croppedArray.set(slice, index);
        index += slice.length;
      }
    }
    outImage.setExtent(cropped);
    outImage.setOrigin(input.getOrigin());
    outImage.setSpacing(input.getSpacing());
    outImage.setDirection(input.getDirection());
    const croppedScalars = vtkDataArray$1.newInstance({
      name: scalars.getName(),
      numberOfComponents,
      values: croppedArray
    });
    outImage.getPointData().setScalars(croppedScalars);
  };
  publicAPI.isResetAvailable = () => {
    if (model.croppingPlanes == null || model.croppingPlanes.length === 0) {
      return false;
    }
    const data2 = publicAPI.getInputData();
    if (data2) {
      const originalExtent = data2.getExtent();
      const findDifference = originalExtent.find((v, i) => Math.abs(model.croppingPlanes[i] - v) > Number.EPSILON);
      return findDifference !== void 0;
    }
    return false;
  };
}
var DEFAULT_VALUES23 = {
  // croppingPlanes: null,
};
function extend29(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES23, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGetArray(publicAPI, model, ["croppingPlanes"], 6);
  vtkImageCropFilter(publicAPI, model);
}
var newInstance29 = macro.newInstance(extend29, "vtkImageCropFilter");
var vtkImageCropFilter$1 = {
  newInstance: newInstance29,
  extend: extend29
};

// node_modules/@kitware/vtk.js/Filters/General/ImageMarchingCubes/caseTable.js
var MARCHING_CUBE_CASES = [
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 3, 8, 1, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [9, 11, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [2, 3, 8, 2, 8, 11, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
  [3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 2, 10, 8, 0, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 0, 9, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 2, 10, 1, 10, 9, 9, 10, 8, -1, -1, -1, -1, -1, -1, -1],
  [3, 1, 11, 10, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 1, 11, 0, 11, 8, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
  [3, 0, 9, 3, 9, 10, 10, 9, 11, -1, -1, -1, -1, -1, -1, -1],
  [9, 11, 8, 11, 10, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 9, 1, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
  [1, 11, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [3, 7, 4, 3, 4, 0, 1, 11, 2, -1, -1, -1, -1, -1, -1, -1],
  [9, 11, 2, 9, 2, 0, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1],
  [2, 9, 11, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
  [8, 7, 4, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [10, 7, 4, 10, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
  [9, 1, 0, 8, 7, 4, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1],
  [4, 10, 7, 9, 10, 4, 9, 2, 10, 9, 1, 2, -1, -1, -1, -1],
  [3, 1, 11, 3, 11, 10, 7, 4, 8, -1, -1, -1, -1, -1, -1, -1],
  [1, 11, 10, 1, 10, 4, 1, 4, 0, 7, 4, 10, -1, -1, -1, -1],
  [4, 8, 7, 9, 10, 0, 9, 11, 10, 10, 3, 0, -1, -1, -1, -1],
  [4, 10, 7, 4, 9, 10, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
  [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [9, 4, 5, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
  [1, 11, 2, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [3, 8, 0, 1, 11, 2, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1],
  [5, 11, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
  [2, 5, 11, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
  [9, 4, 5, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 2, 10, 0, 10, 8, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1],
  [0, 4, 5, 0, 5, 1, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1],
  [2, 5, 1, 2, 8, 5, 2, 10, 8, 4, 5, 8, -1, -1, -1, -1],
  [11, 10, 3, 11, 3, 1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1],
  [4, 5, 9, 0, 1, 8, 8, 1, 11, 8, 11, 10, -1, -1, -1, -1],
  [5, 0, 4, 5, 10, 0, 5, 11, 10, 10, 3, 0, -1, -1, -1, -1],
  [5, 8, 4, 5, 11, 8, 11, 10, 8, -1, -1, -1, -1, -1, -1, -1],
  [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
  [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
  [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [9, 8, 7, 9, 7, 5, 11, 2, 1, -1, -1, -1, -1, -1, -1, -1],
  [11, 2, 1, 9, 0, 5, 5, 0, 3, 5, 3, 7, -1, -1, -1, -1],
  [8, 2, 0, 8, 5, 2, 8, 7, 5, 11, 2, 5, -1, -1, -1, -1],
  [2, 5, 11, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
  [7, 5, 9, 7, 9, 8, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1],
  [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 10, 7, -1, -1, -1, -1],
  [2, 10, 3, 0, 8, 1, 1, 8, 7, 1, 7, 5, -1, -1, -1, -1],
  [10, 1, 2, 10, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
  [9, 8, 5, 8, 7, 5, 11, 3, 1, 11, 10, 3, -1, -1, -1, -1],
  [5, 0, 7, 5, 9, 0, 7, 0, 10, 1, 11, 0, 10, 0, 11, -1],
  [10, 0, 11, 10, 3, 0, 11, 0, 5, 8, 7, 0, 5, 0, 7, -1],
  [10, 5, 11, 7, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [11, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 3, 8, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [9, 1, 0, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 3, 8, 1, 8, 9, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1],
  [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 5, 6, 1, 6, 2, 3, 8, 0, -1, -1, -1, -1, -1, -1, -1],
  [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
  [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
  [2, 10, 3, 11, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [10, 8, 0, 10, 0, 2, 11, 5, 6, -1, -1, -1, -1, -1, -1, -1],
  [0, 9, 1, 2, 10, 3, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1],
  [5, 6, 11, 1, 2, 9, 9, 2, 10, 9, 10, 8, -1, -1, -1, -1],
  [6, 10, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
  [0, 10, 8, 0, 5, 10, 0, 1, 5, 5, 6, 10, -1, -1, -1, -1],
  [3, 6, 10, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
  [6, 9, 5, 6, 10, 9, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
  [5, 6, 11, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 0, 3, 4, 3, 7, 6, 11, 5, -1, -1, -1, -1, -1, -1, -1],
  [1, 0, 9, 5, 6, 11, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1],
  [11, 5, 6, 1, 7, 9, 1, 3, 7, 7, 4, 9, -1, -1, -1, -1],
  [6, 2, 1, 6, 1, 5, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1],
  [1, 5, 2, 5, 6, 2, 3, 4, 0, 3, 7, 4, -1, -1, -1, -1],
  [8, 7, 4, 9, 5, 0, 0, 5, 6, 0, 6, 2, -1, -1, -1, -1],
  [7, 9, 3, 7, 4, 9, 3, 9, 2, 5, 6, 9, 2, 9, 6, -1],
  [3, 2, 10, 7, 4, 8, 11, 5, 6, -1, -1, -1, -1, -1, -1, -1],
  [5, 6, 11, 4, 2, 7, 4, 0, 2, 2, 10, 7, -1, -1, -1, -1],
  [0, 9, 1, 4, 8, 7, 2, 10, 3, 5, 6, 11, -1, -1, -1, -1],
  [9, 1, 2, 9, 2, 10, 9, 10, 4, 7, 4, 10, 5, 6, 11, -1],
  [8, 7, 4, 3, 5, 10, 3, 1, 5, 5, 6, 10, -1, -1, -1, -1],
  [5, 10, 1, 5, 6, 10, 1, 10, 0, 7, 4, 10, 0, 10, 4, -1],
  [0, 9, 5, 0, 5, 6, 0, 6, 3, 10, 3, 6, 8, 7, 4, -1],
  [6, 9, 5, 6, 10, 9, 4, 9, 7, 7, 9, 10, -1, -1, -1, -1],
  [11, 9, 4, 6, 11, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 6, 11, 4, 11, 9, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1],
  [11, 1, 0, 11, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
  [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 11, 1, -1, -1, -1, -1],
  [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
  [3, 8, 0, 1, 9, 2, 2, 9, 4, 2, 4, 6, -1, -1, -1, -1],
  [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
  [11, 9, 4, 11, 4, 6, 10, 3, 2, -1, -1, -1, -1, -1, -1, -1],
  [0, 2, 8, 2, 10, 8, 4, 11, 9, 4, 6, 11, -1, -1, -1, -1],
  [3, 2, 10, 0, 6, 1, 0, 4, 6, 6, 11, 1, -1, -1, -1, -1],
  [6, 1, 4, 6, 11, 1, 4, 1, 8, 2, 10, 1, 8, 1, 10, -1],
  [9, 4, 6, 9, 6, 3, 9, 3, 1, 10, 3, 6, -1, -1, -1, -1],
  [8, 1, 10, 8, 0, 1, 10, 1, 6, 9, 4, 1, 6, 1, 4, -1],
  [3, 6, 10, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
  [6, 8, 4, 10, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [7, 6, 11, 7, 11, 8, 8, 11, 9, -1, -1, -1, -1, -1, -1, -1],
  [0, 3, 7, 0, 7, 11, 0, 11, 9, 6, 11, 7, -1, -1, -1, -1],
  [11, 7, 6, 1, 7, 11, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
  [11, 7, 6, 11, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
  [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
  [2, 9, 6, 2, 1, 9, 6, 9, 7, 0, 3, 9, 7, 9, 3, -1],
  [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
  [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [2, 10, 3, 11, 8, 6, 11, 9, 8, 8, 7, 6, -1, -1, -1, -1],
  [2, 7, 0, 2, 10, 7, 0, 7, 9, 6, 11, 7, 9, 7, 11, -1],
  [1, 0, 8, 1, 8, 7, 1, 7, 11, 6, 11, 7, 2, 10, 3, -1],
  [10, 1, 2, 10, 7, 1, 11, 1, 6, 6, 1, 7, -1, -1, -1, -1],
  [8, 6, 9, 8, 7, 6, 9, 6, 1, 10, 3, 6, 1, 6, 3, -1],
  [0, 1, 9, 10, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [7, 0, 8, 7, 6, 0, 3, 0, 10, 10, 0, 6, -1, -1, -1, -1],
  [7, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [7, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [3, 8, 0, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 9, 1, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [8, 9, 1, 8, 1, 3, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1],
  [11, 2, 1, 6, 7, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 11, 2, 3, 8, 0, 6, 7, 10, -1, -1, -1, -1, -1, -1, -1],
  [2, 0, 9, 2, 9, 11, 6, 7, 10, -1, -1, -1, -1, -1, -1, -1],
  [6, 7, 10, 2, 3, 11, 11, 3, 8, 11, 8, 9, -1, -1, -1, -1],
  [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
  [2, 6, 7, 2, 7, 3, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1],
  [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
  [11, 6, 7, 11, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
  [11, 6, 7, 1, 11, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
  [0, 7, 3, 0, 11, 7, 0, 9, 11, 6, 7, 11, -1, -1, -1, -1],
  [7, 11, 6, 7, 8, 11, 8, 9, 11, -1, -1, -1, -1, -1, -1, -1],
  [6, 4, 8, 10, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [3, 10, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
  [8, 10, 6, 8, 6, 4, 9, 1, 0, -1, -1, -1, -1, -1, -1, -1],
  [9, 6, 4, 9, 3, 6, 9, 1, 3, 10, 6, 3, -1, -1, -1, -1],
  [6, 4, 8, 6, 8, 10, 2, 1, 11, -1, -1, -1, -1, -1, -1, -1],
  [1, 11, 2, 3, 10, 0, 0, 10, 6, 0, 6, 4, -1, -1, -1, -1],
  [4, 8, 10, 4, 10, 6, 0, 9, 2, 2, 9, 11, -1, -1, -1, -1],
  [11, 3, 9, 11, 2, 3, 9, 3, 4, 10, 6, 3, 4, 3, 6, -1],
  [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
  [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 0, 9, 2, 4, 3, 2, 6, 4, 4, 8, 3, -1, -1, -1, -1],
  [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
  [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 11, -1, -1, -1, -1],
  [11, 0, 1, 11, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
  [4, 3, 6, 4, 8, 3, 6, 3, 11, 0, 9, 3, 11, 3, 9, -1],
  [11, 4, 9, 6, 4, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 5, 9, 7, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 3, 8, 4, 5, 9, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1],
  [5, 1, 0, 5, 0, 4, 7, 10, 6, -1, -1, -1, -1, -1, -1, -1],
  [10, 6, 7, 8, 4, 3, 3, 4, 5, 3, 5, 1, -1, -1, -1, -1],
  [9, 4, 5, 11, 2, 1, 7, 10, 6, -1, -1, -1, -1, -1, -1, -1],
  [6, 7, 10, 1, 11, 2, 0, 3, 8, 4, 5, 9, -1, -1, -1, -1],
  [7, 10, 6, 5, 11, 4, 4, 11, 2, 4, 2, 0, -1, -1, -1, -1],
  [3, 8, 4, 3, 4, 5, 3, 5, 2, 11, 2, 5, 10, 6, 7, -1],
  [7, 3, 2, 7, 2, 6, 5, 9, 4, -1, -1, -1, -1, -1, -1, -1],
  [9, 4, 5, 0, 6, 8, 0, 2, 6, 6, 7, 8, -1, -1, -1, -1],
  [3, 2, 6, 3, 6, 7, 1, 0, 5, 5, 0, 4, -1, -1, -1, -1],
  [6, 8, 2, 6, 7, 8, 2, 8, 1, 4, 5, 8, 1, 8, 5, -1],
  [9, 4, 5, 11, 6, 1, 1, 6, 7, 1, 7, 3, -1, -1, -1, -1],
  [1, 11, 6, 1, 6, 7, 1, 7, 0, 8, 0, 7, 9, 4, 5, -1],
  [4, 11, 0, 4, 5, 11, 0, 11, 3, 6, 7, 11, 3, 11, 7, -1],
  [7, 11, 6, 7, 8, 11, 5, 11, 4, 4, 11, 8, -1, -1, -1, -1],
  [6, 5, 9, 6, 9, 10, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
  [3, 10, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
  [0, 8, 10, 0, 10, 5, 0, 5, 1, 5, 10, 6, -1, -1, -1, -1],
  [6, 3, 10, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
  [1, 11, 2, 9, 10, 5, 9, 8, 10, 10, 6, 5, -1, -1, -1, -1],
  [0, 3, 10, 0, 10, 6, 0, 6, 9, 5, 9, 6, 1, 11, 2, -1],
  [10, 5, 8, 10, 6, 5, 8, 5, 0, 11, 2, 5, 0, 5, 2, -1],
  [6, 3, 10, 6, 5, 3, 2, 3, 11, 11, 3, 5, -1, -1, -1, -1],
  [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
  [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
  [1, 8, 5, 1, 0, 8, 5, 8, 6, 3, 2, 8, 6, 8, 2, -1],
  [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 6, 3, 1, 11, 6, 3, 6, 8, 5, 9, 6, 8, 6, 9, -1],
  [11, 0, 1, 11, 6, 0, 9, 0, 5, 5, 0, 6, -1, -1, -1, -1],
  [0, 8, 3, 5, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [11, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [10, 11, 5, 7, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [10, 11, 5, 10, 5, 7, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1],
  [5, 7, 10, 5, 10, 11, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1],
  [11, 5, 7, 11, 7, 10, 9, 1, 8, 8, 1, 3, -1, -1, -1, -1],
  [10, 2, 1, 10, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
  [0, 3, 8, 1, 7, 2, 1, 5, 7, 7, 10, 2, -1, -1, -1, -1],
  [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 10, -1, -1, -1, -1],
  [7, 2, 5, 7, 10, 2, 5, 2, 9, 3, 8, 2, 9, 2, 8, -1],
  [2, 11, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
  [8, 0, 2, 8, 2, 5, 8, 5, 7, 11, 5, 2, -1, -1, -1, -1],
  [9, 1, 0, 5, 3, 11, 5, 7, 3, 3, 2, 11, -1, -1, -1, -1],
  [9, 2, 8, 9, 1, 2, 8, 2, 7, 11, 5, 2, 7, 2, 5, -1],
  [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
  [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
  [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [5, 4, 8, 5, 8, 11, 11, 8, 10, -1, -1, -1, -1, -1, -1, -1],
  [5, 4, 0, 5, 0, 10, 5, 10, 11, 10, 0, 3, -1, -1, -1, -1],
  [0, 9, 1, 8, 11, 4, 8, 10, 11, 11, 5, 4, -1, -1, -1, -1],
  [11, 4, 10, 11, 5, 4, 10, 4, 3, 9, 1, 4, 3, 4, 1, -1],
  [2, 1, 5, 2, 5, 8, 2, 8, 10, 4, 8, 5, -1, -1, -1, -1],
  [0, 10, 4, 0, 3, 10, 4, 10, 5, 2, 1, 10, 5, 10, 1, -1],
  [0, 5, 2, 0, 9, 5, 2, 5, 10, 4, 8, 5, 10, 5, 8, -1],
  [9, 5, 4, 2, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [2, 11, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
  [5, 2, 11, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
  [3, 2, 11, 3, 11, 5, 3, 5, 8, 4, 8, 5, 0, 9, 1, -1],
  [5, 2, 11, 5, 4, 2, 1, 2, 9, 9, 2, 4, -1, -1, -1, -1],
  [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
  [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [8, 5, 4, 8, 3, 5, 9, 5, 0, 0, 5, 3, -1, -1, -1, -1],
  [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 7, 10, 4, 10, 9, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
  [0, 3, 8, 4, 7, 9, 9, 7, 10, 9, 10, 11, -1, -1, -1, -1],
  [1, 10, 11, 1, 4, 10, 1, 0, 4, 7, 10, 4, -1, -1, -1, -1],
  [3, 4, 1, 3, 8, 4, 1, 4, 11, 7, 10, 4, 11, 4, 10, -1],
  [4, 7, 10, 9, 4, 10, 9, 10, 2, 9, 2, 1, -1, -1, -1, -1],
  [9, 4, 7, 9, 7, 10, 9, 10, 1, 2, 1, 10, 0, 3, 8, -1],
  [10, 4, 7, 10, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
  [10, 4, 7, 10, 2, 4, 8, 4, 3, 3, 4, 2, -1, -1, -1, -1],
  [2, 11, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
  [9, 7, 11, 9, 4, 7, 11, 7, 2, 8, 0, 7, 2, 7, 0, -1],
  [3, 11, 7, 3, 2, 11, 7, 11, 4, 1, 0, 11, 4, 11, 0, -1],
  [1, 2, 11, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
  [4, 1, 9, 4, 7, 1, 0, 1, 8, 8, 1, 7, -1, -1, -1, -1],
  [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [9, 8, 11, 11, 8, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [3, 9, 0, 3, 10, 9, 10, 11, 9, -1, -1, -1, -1, -1, -1, -1],
  [0, 11, 1, 0, 8, 11, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
  [3, 11, 1, 10, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 10, 2, 1, 9, 10, 9, 8, 10, -1, -1, -1, -1, -1, -1, -1],
  [3, 9, 0, 3, 10, 9, 1, 9, 2, 2, 9, 10, -1, -1, -1, -1],
  [0, 10, 2, 8, 10, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [3, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [2, 8, 3, 2, 11, 8, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
  [9, 2, 11, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [2, 8, 3, 2, 11, 8, 0, 8, 1, 1, 8, 11, -1, -1, -1, -1],
  [1, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
  /* 255 0 */
];
var EDGES = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [2, 6], [3, 7]];
function getCase(index) {
  return MARCHING_CUBE_CASES[index];
}
function getEdge(eid) {
  return EDGES[eid];
}
var vtkCaseTable = {
  getCase,
  getEdge
};

// node_modules/@kitware/vtk.js/Filters/General/ImageMarchingCubes.js
var {
  vtkErrorMacro: vtkErrorMacro18,
  vtkDebugMacro
} = macro;
function vtkImageMarchingCubes(publicAPI, model) {
  model.classHierarchy.push("vtkImageMarchingCubes");
  const ids = [];
  const voxelScalars = [];
  const voxelGradients = [];
  const voxelPts = [];
  const edgeLocator = vtkEdgeLocator.newInstance();
  publicAPI.getVoxelScalars = (i, j, k, slice, dims, origin3, spacing, s) => {
    ids[0] = k * slice + j * dims[0] + i;
    ids[1] = ids[0] + 1;
    ids[2] = ids[0] + dims[0];
    ids[3] = ids[2] + 1;
    ids[4] = ids[0] + slice;
    ids[5] = ids[4] + 1;
    ids[6] = ids[4] + dims[0];
    ids[7] = ids[6] + 1;
    for (let ii = 0; ii < 8; ++ii) {
      voxelScalars[ii] = s[ids[ii]];
    }
  };
  publicAPI.getVoxelPoints = (i, j, k, origin3, spacing) => {
    voxelPts[0] = origin3[0] + i * spacing[0];
    voxelPts[1] = origin3[1] + j * spacing[1];
    voxelPts[2] = origin3[2] + k * spacing[2];
    voxelPts[3] = voxelPts[0] + spacing[0];
    voxelPts[4] = voxelPts[1];
    voxelPts[5] = voxelPts[2];
    voxelPts[6] = voxelPts[0];
    voxelPts[7] = voxelPts[1] + spacing[1];
    voxelPts[8] = voxelPts[2];
    voxelPts[9] = voxelPts[3];
    voxelPts[10] = voxelPts[7];
    voxelPts[11] = voxelPts[2];
    voxelPts[12] = voxelPts[0];
    voxelPts[13] = voxelPts[1];
    voxelPts[14] = voxelPts[2] + spacing[2];
    voxelPts[15] = voxelPts[3];
    voxelPts[16] = voxelPts[1];
    voxelPts[17] = voxelPts[14];
    voxelPts[18] = voxelPts[0];
    voxelPts[19] = voxelPts[7];
    voxelPts[20] = voxelPts[14];
    voxelPts[21] = voxelPts[3];
    voxelPts[22] = voxelPts[7];
    voxelPts[23] = voxelPts[14];
  };
  publicAPI.getPointGradient = (i, j, k, dims, slice, spacing, s, g) => {
    let sp;
    let sm;
    if (i === 0) {
      sp = s[i + 1 + j * dims[0] + k * slice];
      sm = s[i + j * dims[0] + k * slice];
      g[0] = (sm - sp) / spacing[0];
    } else if (i === dims[0] - 1) {
      sp = s[i + j * dims[0] + k * slice];
      sm = s[i - 1 + j * dims[0] + k * slice];
      g[0] = (sm - sp) / spacing[0];
    } else {
      sp = s[i + 1 + j * dims[0] + k * slice];
      sm = s[i - 1 + j * dims[0] + k * slice];
      g[0] = 0.5 * (sm - sp) / spacing[0];
    }
    if (j === 0) {
      sp = s[i + (j + 1) * dims[0] + k * slice];
      sm = s[i + j * dims[0] + k * slice];
      g[1] = (sm - sp) / spacing[1];
    } else if (j === dims[1] - 1) {
      sp = s[i + j * dims[0] + k * slice];
      sm = s[i + (j - 1) * dims[0] + k * slice];
      g[1] = (sm - sp) / spacing[1];
    } else {
      sp = s[i + (j + 1) * dims[0] + k * slice];
      sm = s[i + (j - 1) * dims[0] + k * slice];
      g[1] = 0.5 * (sm - sp) / spacing[1];
    }
    if (k === 0) {
      sp = s[i + j * dims[0] + (k + 1) * slice];
      sm = s[i + j * dims[0] + k * slice];
      g[2] = (sm - sp) / spacing[2];
    } else if (k === dims[2] - 1) {
      sp = s[i + j * dims[0] + k * slice];
      sm = s[i + j * dims[0] + (k - 1) * slice];
      g[2] = (sm - sp) / spacing[2];
    } else {
      sp = s[i + j * dims[0] + (k + 1) * slice];
      sm = s[i + j * dims[0] + (k - 1) * slice];
      g[2] = 0.5 * (sm - sp) / spacing[2];
    }
  };
  publicAPI.getVoxelGradients = (i, j, k, dims, slice, spacing, scalars) => {
    const g = [];
    publicAPI.getPointGradient(i, j, k, dims, slice, spacing, scalars, g);
    voxelGradients[0] = g[0];
    voxelGradients[1] = g[1];
    voxelGradients[2] = g[2];
    publicAPI.getPointGradient(i + 1, j, k, dims, slice, spacing, scalars, g);
    voxelGradients[3] = g[0];
    voxelGradients[4] = g[1];
    voxelGradients[5] = g[2];
    publicAPI.getPointGradient(i, j + 1, k, dims, slice, spacing, scalars, g);
    voxelGradients[6] = g[0];
    voxelGradients[7] = g[1];
    voxelGradients[8] = g[2];
    publicAPI.getPointGradient(i + 1, j + 1, k, dims, slice, spacing, scalars, g);
    voxelGradients[9] = g[0];
    voxelGradients[10] = g[1];
    voxelGradients[11] = g[2];
    publicAPI.getPointGradient(i, j, k + 1, dims, slice, spacing, scalars, g);
    voxelGradients[12] = g[0];
    voxelGradients[13] = g[1];
    voxelGradients[14] = g[2];
    publicAPI.getPointGradient(i + 1, j, k + 1, dims, slice, spacing, scalars, g);
    voxelGradients[15] = g[0];
    voxelGradients[16] = g[1];
    voxelGradients[17] = g[2];
    publicAPI.getPointGradient(i, j + 1, k + 1, dims, slice, spacing, scalars, g);
    voxelGradients[18] = g[0];
    voxelGradients[19] = g[1];
    voxelGradients[20] = g[2];
    publicAPI.getPointGradient(i + 1, j + 1, k + 1, dims, slice, spacing, scalars, g);
    voxelGradients[21] = g[0];
    voxelGradients[22] = g[1];
    voxelGradients[23] = g[2];
  };
  publicAPI.produceTriangles = (cVal, i, j, k, extent, slice, dims, origin3, spacing, scalars, points, tris, normals) => {
    var _a;
    const CASE_MASK = [1, 2, 4, 8, 16, 32, 64, 128];
    const VERT_MAP = [0, 1, 3, 2, 4, 5, 7, 6];
    const xyz = [];
    const n = [];
    let pId;
    publicAPI.getVoxelScalars(i, j, k, slice, dims, origin3, spacing, scalars);
    let index = 0;
    for (let idx = 0; idx < 8; idx++) {
      if (voxelScalars[VERT_MAP[idx]] >= cVal) {
        index |= CASE_MASK[idx];
      }
    }
    const voxelTris = vtkCaseTable.getCase(index);
    if (voxelTris[0] < 0) {
      return;
    }
    publicAPI.getVoxelPoints(i + extent[0], j + extent[2], k + extent[4], origin3, spacing);
    if (model.computeNormals) {
      publicAPI.getVoxelGradients(i, j, k, dims, slice, spacing, scalars);
    }
    for (let idx = 0; voxelTris[idx] >= 0; idx += 3) {
      tris.push(3);
      for (let eid = 0; eid < 3; eid++) {
        const edgeVerts = vtkCaseTable.getEdge(voxelTris[idx + eid]);
        pId = void 0;
        if (model.mergePoints) {
          pId = (_a = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])) == null ? void 0 : _a.value;
        }
        if (pId === void 0) {
          const t = (cVal - voxelScalars[edgeVerts[0]]) / (voxelScalars[edgeVerts[1]] - voxelScalars[edgeVerts[0]]);
          const x0 = voxelPts.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);
          const x1 = voxelPts.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);
          xyz[0] = x0[0] + t * (x1[0] - x0[0]);
          xyz[1] = x0[1] + t * (x1[1] - x0[1]);
          xyz[2] = x0[2] + t * (x1[2] - x0[2]);
          pId = points.length / 3;
          points.push(xyz[0], xyz[1], xyz[2]);
          if (model.computeNormals) {
            const n0 = voxelGradients.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);
            const n1 = voxelGradients.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);
            n[0] = n0[0] + t * (n1[0] - n0[0]);
            n[1] = n0[1] + t * (n1[1] - n0[1]);
            n[2] = n0[2] + t * (n1[2] - n0[2]);
            normalize(n);
            normals.push(n[0], n[1], n[2]);
          }
          if (model.mergePoints) {
            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);
          }
        }
        tris.push(pId);
      }
    }
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro18("Invalid or missing input");
      return;
    }
    console.time("mcubes");
    const origin3 = input.getOrigin();
    const spacing = input.getSpacing();
    const dims = input.getDimensions();
    const s = input.getPointData().getScalars().getData();
    const pBuffer = [];
    const tBuffer = [];
    const nBuffer = [];
    const extent = input.getExtent();
    const slice = dims[0] * dims[1];
    for (let k = 0; k < dims[2] - 1; ++k) {
      for (let j = 0; j < dims[1] - 1; ++j) {
        for (let i = 0; i < dims[0] - 1; ++i) {
          publicAPI.produceTriangles(model.contourValue, i, j, k, extent, slice, dims, origin3, spacing, s, pBuffer, tBuffer, nBuffer);
        }
      }
    }
    edgeLocator.initialize();
    const polydata = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    polydata.getPoints().setData(new Float32Array(pBuffer), 3);
    polydata.getPolys().setData(new Uint32Array(tBuffer));
    if (model.computeNormals) {
      const nData = new Float32Array(nBuffer);
      const normals = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: nData,
        name: "Normals"
      });
      polydata.getPointData().setNormals(normals);
    }
    outData[0] = polydata;
    vtkDebugMacro("Produced output");
    console.timeEnd("mcubes");
  };
}
var DEFAULT_VALUES24 = {
  contourValue: 0,
  computeNormals: false,
  mergePoints: false
};
function extend30(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES24, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["contourValue", "computeNormals", "mergePoints"]);
  macro.algo(publicAPI, model, 1, 1);
  vtkImageMarchingCubes(publicAPI, model);
}
var newInstance30 = macro.newInstance(extend30, "vtkImageMarchingCubes");
var vtkImageMarchingCubes$1 = {
  newInstance: newInstance30,
  extend: extend30
};

// node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js
var MARCHING_SQUARES_CASES = [
  [-1, -1, -1, -1, -1],
  [0, 3, -1, -1, -1],
  [1, 0, -1, -1, -1],
  [1, 3, -1, -1, -1],
  [2, 1, -1, -1, -1],
  [0, 3, 2, 1, -1],
  [2, 0, -1, -1, -1],
  [2, 3, -1, -1, -1],
  [3, 2, -1, -1, -1],
  [0, 2, -1, -1, -1],
  [1, 0, 3, 2, -1],
  [1, 2, -1, -1, -1],
  [3, 1, -1, -1, -1],
  [0, 1, -1, -1, -1],
  [3, 0, -1, -1, -1],
  [-1, -1, -1, -1, -1]
  /* 15 */
];
var EDGES2 = [[0, 1], [1, 3], [2, 3], [0, 2]];
function getCase2(index) {
  return MARCHING_SQUARES_CASES[index];
}
function getEdge2(eid) {
  return EDGES2[eid];
}
var vtkCaseTable2 = {
  getCase: getCase2,
  getEdge: getEdge2
};

// node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js
var {
  vtkErrorMacro: vtkErrorMacro19,
  vtkDebugMacro: vtkDebugMacro2
} = macro;
function vtkImageMarchingSquares(publicAPI, model) {
  function getKernels() {
    let kernelX = 0;
    let kernelY = 1;
    if (model.slicingMode === 1) {
      kernelX = 0;
      kernelY = 2;
    } else if (model.slicingMode === 0) {
      kernelX = 1;
      kernelY = 2;
    }
    return [kernelX, kernelY];
  }
  model.classHierarchy.push("vtkImageMarchingSquares");
  publicAPI.getContourValues = () => model.contourValues;
  publicAPI.setContourValues = (cValues) => {
    model.contourValues = cValues;
    publicAPI.modified();
  };
  const ids = [];
  const pixelScalars = [];
  const pixelPts = [];
  const edgeLocator = vtkEdgeLocator.newInstance();
  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {
    const [i, j, k] = ijk;
    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i;
    ids[1] = ids[0] + increments[kernelX];
    ids[2] = ids[0] + increments[kernelY];
    ids[3] = ids[2] + increments[kernelX];
    for (let ii = 0; ii < 4; ++ii) {
      pixelScalars[ii] = scalars[ids[ii]];
    }
  };
  publicAPI.getPixelPoints = (ijk, kernelX, kernelY, indexToWorld) => {
    const neighborIJK = [...ijk];
    indexToWorld(neighborIJK, pixelPts);
    neighborIJK[kernelX] += 1;
    const temp = indexToWorld(neighborIJK, []);
    pixelPts[3] = temp[0];
    pixelPts[4] = temp[1];
    pixelPts[5] = temp[2];
    neighborIJK[kernelY] += 1;
    indexToWorld(neighborIJK, temp);
    pixelPts[9] = temp[0];
    pixelPts[10] = temp[1];
    pixelPts[11] = temp[2];
    neighborIJK[kernelX] -= 1;
    indexToWorld(neighborIJK, temp);
    pixelPts[6] = temp[0];
    pixelPts[7] = temp[1];
    pixelPts[8] = temp[2];
  };
  publicAPI.produceLines = (cVal, ijk, dims, scalars, points, lines, increments, kernelX, kernelY, indexToWorld) => {
    var _a;
    const CASE_MASK = [1, 2, 8, 4];
    const xyz = [];
    let pId;
    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);
    let index = 0;
    for (let idx = 0; idx < 4; idx++) {
      if (pixelScalars[idx] >= cVal) {
        index |= CASE_MASK[idx];
      }
    }
    const pixelLines = vtkCaseTable2.getCase(index);
    if (pixelLines[0] < 0) {
      return;
    }
    publicAPI.getPixelPoints(ijk, kernelX, kernelY, indexToWorld);
    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {
      lines.push(2);
      for (let eid = 0; eid < 2; eid++) {
        const edgeVerts = vtkCaseTable2.getEdge(pixelLines[idx + eid]);
        pId = void 0;
        if (model.mergePoints) {
          pId = (_a = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])) == null ? void 0 : _a.value;
        }
        if (pId === void 0) {
          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);
          const x0 = pixelPts.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);
          const x1 = pixelPts.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);
          xyz[0] = x0[0] + t * (x1[0] - x0[0]);
          xyz[1] = x0[1] + t * (x1[1] - x0[1]);
          xyz[2] = x0[2] + t * (x1[2] - x0[2]);
          pId = points.length / 3;
          points.push(xyz[0], xyz[1], xyz[2]);
          if (model.mergePoints) {
            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);
          }
        }
        lines.push(pId);
      }
    }
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro19("Invalid or missing input");
      return;
    }
    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {
      vtkErrorMacro19("Invalid or missing slicing mode");
      return;
    }
    console.time("msquares");
    const dims = input.getDimensions();
    const extent = input.getExtent();
    const increments = input.computeIncrements(extent);
    const scalars = input.getPointData().getScalars().getData();
    const [kernelX, kernelY] = getKernels();
    const indexToWorld = input.indexToWorld;
    const points = [];
    const lines = [];
    let k = Math.round(model.slice);
    if (k >= dims[model.slicingMode]) {
      k = 0;
    }
    const ijk = [0, 0, 0];
    ijk[model.slicingMode] = k;
    for (let cv = 0; cv < model.contourValues.length; ++cv) {
      for (let j = 0; j < dims[kernelY] - 1; ++j) {
        ijk[kernelY] = j;
        for (let i = 0; i < dims[kernelX] - 1; ++i) {
          ijk[kernelX] = i;
          publicAPI.produceLines(model.contourValues[cv], ijk, dims, scalars, points, lines, increments, kernelX, kernelY, indexToWorld);
        }
      }
      edgeLocator.initialize();
    }
    const polydata = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    polydata.getPoints().setData(new Float32Array(points), 3);
    polydata.getLines().setData(new Uint32Array(lines));
    outData[0] = polydata;
    vtkDebugMacro2("Produced output");
    console.timeEnd("msquares");
  };
}
var DEFAULT_VALUES25 = {
  contourValues: [],
  slicingMode: 2,
  slice: 0,
  mergePoints: false
};
function extend31(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES25, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["slicingMode", "slice", "mergePoints"]);
  macro.algo(publicAPI, model, 1, 1);
  vtkImageMarchingSquares(publicAPI, model);
}
var newInstance31 = macro.newInstance(extend31, "vtkImageMarchingSquares");
var vtkImageMarchingSquares$1 = {
  newInstance: newInstance31,
  extend: extend31
};

// node_modules/@kitware/vtk.js/Filters/General/ImageOutlineFilter.js
var {
  vtkErrorMacro: vtkErrorMacro20
} = macro;
function vtkImageOutlineFilter(publicAPI, model) {
  model.classHierarchy.push("vtkImageOutlineFilter");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input || input.getClassName() !== "vtkImageData") {
      vtkErrorMacro20("Invalid or missing input");
      return;
    }
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkImageData$1.newInstance();
    output.set(input.get("spacing", "origin", "direction"));
    const getIndex = (point, dims2) => point[0] + point[1] * dims2[0] + point[2] * dims2[0] * dims2[1];
    const getIJK = (index, dims2) => {
      const ijk = [0, 0, 0];
      ijk[0] = index % dims2[0];
      ijk[1] = Math.floor(index / dims2[0]) % dims2[1];
      ijk[2] = Math.floor(index / (dims2[0] * dims2[1]));
      return ijk;
    };
    const dims = input.getDimensions();
    output.setDimensions(dims);
    output.computeTransforms();
    const values = new Uint8Array(input.getNumberOfPoints());
    const inputDataArray = input.getPointData().getScalars().getData();
    let kernelX = 0;
    let kernelY = 1;
    if (model.slicingMode === 1) {
      kernelX = 0;
      kernelY = 2;
    } else if (model.slicingMode === 0) {
      kernelX = 1;
      kernelY = 2;
    }
    inputDataArray.forEach((el, index) => {
      if (el !== model.background) {
        const ijk = getIJK(index, dims);
        let isBorder = false;
        for (let x = -1; x <= 1 && !isBorder; x++) {
          for (let y = -1; y <= 1 && !isBorder; y++) {
            let dx = x;
            let dy = y;
            let dz = 0;
            if (model.slicingMode === 1) {
              dx = x;
              dy = 0;
              dz = y;
            } else if (model.slicingMode === 0) {
              dx = 0;
              dy = y;
              dz = x;
            }
            const evalX = ijk[kernelX] + dx;
            const evalY = ijk[kernelY] + dy;
            if (evalX >= 0 && evalX < dims[kernelX] && evalY >= 0 && evalY < dims[kernelY]) {
              const hoodValue = inputDataArray[getIndex([ijk[0] + dx, ijk[1] + dy, ijk[2] + dz], dims)];
              if (hoodValue !== el) isBorder = true;
            }
          }
        }
        if (isBorder) values[index] = el;
        else values[index] = model.background;
      } else {
        values[index] = model.background;
      }
    });
    const dataArray = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values
    });
    output.getPointData().setScalars(dataArray);
    outData[0] = output;
  };
}
var DEFAULT_VALUES26 = {
  slicingMode: 2,
  background: 0
};
function extend32(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES26, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["slicingMode", "background"]);
  vtkImageOutlineFilter(publicAPI, model);
}
var newInstance32 = macro.newInstance(extend32, "vtkImageOutlineFilter");
var vtkImageOutlineFilter$1 = {
  newInstance: newInstance32,
  extend: extend32
};

// node_modules/@kitware/vtk.js/Filters/General/ImageSliceFilter.js
var {
  vtkErrorMacro: vtkErrorMacro21
} = macro;
function vtkImageSliceFilter(publicAPI, model) {
  model.classHierarchy.push("vtkImageSliceFilter");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro21("Invalid or missing input");
      return;
    }
    const scalars = input.getPointData().getScalars();
    if (!scalars) {
      vtkErrorMacro21("No scalars from input");
      return;
    }
    const datasetDefinition = input.get("extent", "spacing", "origin");
    datasetDefinition.extent[4] = model.sliceIndex;
    datasetDefinition.extent[5] = datasetDefinition.extent[4];
    const numberOfComponents = scalars.getNumberOfComponents();
    const sliceSize = (datasetDefinition.extent[1] - datasetDefinition.extent[0] + 1) * (datasetDefinition.extent[3] - datasetDefinition.extent[2] + 1) * numberOfComponents;
    const offset = sliceSize * model.sliceIndex;
    const sliceRawArray = scalars.getData().slice(offset, offset + sliceSize);
    const sliceArray = vtkDataArray$1.newInstance({
      name: scalars.getName(),
      numberOfComponents,
      values: sliceRawArray
    });
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkImageData$1.newInstance();
    output.set(datasetDefinition);
    output.getPointData().setScalars(sliceArray);
    outData[0] = output;
  };
}
var DEFAULT_VALUES27 = {
  sliceIndex: 0
};
function extend33(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES27, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["sliceIndex", "orientation"]);
  vtkImageSliceFilter(publicAPI, model);
}
var newInstance33 = macro.newInstance(extend33, "vtkImageSliceFilter");
var vtkImageSliceFilter$1 = {
  newInstance: newInstance33,
  extend: extend33
};

// node_modules/@kitware/vtk.js/Filters/General/ImageStreamline.js
var {
  vtkErrorMacro: vtkErrorMacro22
} = macro;
function vtkImageStreamline(publicAPI, model) {
  model.classHierarchy.push("vtkImageStreamline");
  const indices = new Int32Array(3);
  const paramCoords = new Float32Array(3);
  const weights = new Float32Array(8);
  const voxelIndices = new Uint32Array(8);
  const dimensions = new Uint32Array(3);
  const velAt = new Float32Array(3);
  const xtmp = new Float32Array(3);
  publicAPI.interpolationFunctions = (pcoords, sf) => {
    const r = pcoords[0];
    const s = pcoords[1];
    const t = pcoords[2];
    const rm = 1 - r;
    const sm = 1 - s;
    const tm = 1 - t;
    sf[0] = rm * sm * tm;
    sf[1] = r * sm * tm;
    sf[2] = rm * s * tm;
    sf[3] = r * s * tm;
    sf[4] = rm * sm * t;
    sf[5] = r * sm * t;
    sf[6] = rm * s * t;
    sf[7] = r * s * t;
  };
  publicAPI.computeStructuredCoordinates = (x, ijk, pcoords, extent, spacing, origin3, bounds2) => {
    const tol2 = 1e-12;
    let isInBounds = true;
    for (let i = 0; i < 3; i++) {
      const d2 = x[i] - origin3[i];
      const doubleLoc = d2 / spacing[i];
      ijk[i] = Math.floor(doubleLoc);
      pcoords[i] = doubleLoc - ijk[i];
      let tmpInBounds = false;
      const minExt = extent[i * 2];
      const maxExt = extent[i * 2 + 1];
      if (minExt === maxExt) {
        const dist = x[i] - bounds2[2 * i];
        if (dist * dist <= spacing[i] * spacing[i] * tol2) {
          pcoords[i] = 0;
          ijk[i] = minExt;
          tmpInBounds = true;
        }
      } else if (ijk[i] < minExt) {
        if (spacing[i] >= 0 && x[i] >= bounds2[i * 2] || spacing[i] < 0 && x[i] <= bounds2[i * 2 + 1]) {
          pcoords[i] = 0;
          ijk[i] = minExt;
          tmpInBounds = true;
        }
      } else if (ijk[i] >= maxExt) {
        if (spacing[i] >= 0 && x[i] <= bounds2[i * 2 + 1] || spacing[i] < 0 && x[i] >= bounds2[i * 2]) {
          pcoords[i] = 1;
          ijk[i] = maxExt - 1;
          tmpInBounds = true;
        }
      } else {
        tmpInBounds = true;
      }
      isInBounds = isInBounds && tmpInBounds;
    }
    return isInBounds;
  };
  publicAPI.getVoxelIndices = (ijk, dims, ids) => {
    ids[0] = ijk[2] * dims[0] * dims[1] + ijk[1] * dims[0] + ijk[0];
    ids[1] = ids[0] + 1;
    ids[2] = ids[0] + dims[0];
    ids[3] = ids[2] + 1;
    ids[4] = ids[0] + dims[0] * dims[1];
    ids[5] = ids[4] + 1;
    ids[6] = ids[4] + dims[0];
    ids[7] = ids[6] + 1;
  };
  publicAPI.vectorAt = (xyz, velArray, image, velAtArg) => {
    if (!publicAPI.computeStructuredCoordinates(xyz, indices, paramCoords, image.getExtent(), image.getSpacing(), image.getOrigin(), image.getBounds())) {
      return false;
    }
    publicAPI.interpolationFunctions(paramCoords, weights);
    const extent = image.getExtent();
    dimensions[0] = extent[1] - extent[0] + 1;
    dimensions[1] = extent[3] - extent[2] + 1;
    dimensions[2] = extent[5] - extent[4] + 1;
    publicAPI.getVoxelIndices(indices, dimensions, voxelIndices);
    velAtArg[0] = 0;
    velAtArg[1] = 0;
    velAtArg[2] = 0;
    const vel = new Array(3);
    for (let i = 0; i < 8; i++) {
      velArray.getTuple(voxelIndices[i], vel);
      for (let j = 0; j < 3; j++) {
        velAtArg[j] += weights[i] * vel[j];
      }
    }
    return true;
  };
  publicAPI.computeNextStep = (velArray, image, delT, xyz) => {
    if (!publicAPI.vectorAt(xyz, velArray, image, velAt)) {
      return false;
    }
    for (let i = 0; i < 3; i++) {
      xtmp[i] = xyz[i] + delT / 2 * velAt[i];
    }
    if (!publicAPI.vectorAt(xtmp, velArray, image, velAt)) {
      return false;
    }
    for (let i = 0; i < 3; i++) {
      xyz[i] += delT * velAt[i];
    }
    if (!publicAPI.vectorAt(xyz, velArray, image, velAt)) {
      return false;
    }
    return true;
  };
  publicAPI.streamIntegrate = (velArray, image, seed, offset) => {
    const retVal = [];
    const maxSteps = model.maximumNumberOfSteps;
    const delT = model.integrationStep;
    const xyz = new Float32Array(3);
    xyz[0] = seed[0];
    xyz[1] = seed[1];
    xyz[2] = seed[2];
    const pointsBuffer = [];
    let step = 0;
    for (step = 0; step < maxSteps; step++) {
      if (!publicAPI.computeNextStep(velArray, image, delT, xyz)) {
        break;
      }
      for (let i = 0; i < 3; i++) {
        pointsBuffer[3 * step + i] = xyz[i];
      }
    }
    const pd = vtkPolyData$1.newInstance();
    const points = new Float32Array(pointsBuffer);
    retVal[0] = points;
    pd.getPoints().setData(points, 3);
    const npts = points.length / 3;
    const line = new Uint32Array(npts + 1);
    line[0] = npts;
    for (let i = 0; i < npts; i++) {
      line[i + 1] = i + offset;
    }
    retVal[1] = line;
    pd.getLines().setData(line);
    return retVal;
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const seeds = inData[1];
    if (!input) {
      vtkErrorMacro22("Invalid or missing input");
      return;
    }
    if (!seeds) {
      vtkErrorMacro22("Invalid or missing seeds");
      return;
    }
    const seedPts = seeds.getPoints();
    const nSeeds = seedPts.getNumberOfPoints();
    let offset = 0;
    const datas = [];
    const vectors = input.getPointData().getVectors();
    const point = [];
    for (let i = 0; i < nSeeds; i++) {
      seedPts.getTuple(i, point);
      const retVal = publicAPI.streamIntegrate(vectors, input, point, offset);
      offset += retVal[0].length / 3;
      datas.push(retVal);
    }
    let cellArrayLength = 0;
    let pointArrayLength = 0;
    datas.forEach((data2) => {
      cellArrayLength += data2[1].length;
      pointArrayLength += data2[0].length;
    });
    offset = 0;
    let offset2 = 0;
    const cellArray = new Uint32Array(cellArrayLength);
    const pointArray = new Float32Array(pointArrayLength);
    datas.forEach((data2) => {
      cellArray.set(data2[1], offset);
      offset += data2[1].length;
      pointArray.set(data2[0], offset2);
      offset2 += data2[0].length;
    });
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    output.getPoints().setData(pointArray, 3);
    output.getLines().setData(cellArray);
    outData[0] = output;
  };
}
var DEFAULT_VALUES28 = {
  integrationStep: 1,
  maximumNumberOfSteps: 1e3
};
function extend34(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES28, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 2, 1);
  macro.setGet(publicAPI, model, ["integrationStep", "maximumNumberOfSteps"]);
  vtkImageStreamline(publicAPI, model);
}
var newInstance34 = macro.newInstance(extend34, "vtkImageStreamline");
var vtkImageStreamline$1 = {
  newInstance: newInstance34,
  extend: extend34
};

// node_modules/@kitware/vtk.js/Filters/General/LineFilter.js
function vtkLineFilter(publicAPI, model) {
  model.classHierarchy.push("vtkLineFilter");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    dataset.getPoints().setData(inData[0].getPoints().getData());
    dataset.getLines().setData(inData[0].getLines().getData());
    outData[0] = dataset;
  };
}
var DEFAULT_VALUES29 = {};
function extend35(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES29, initialValues);
  macro.setGet(publicAPI, model, []);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkLineFilter(publicAPI, model);
}
var newInstance35 = macro.newInstance(extend35, "vtkLineFilter");
var vtkLineFilter$1 = {
  newInstance: newInstance35,
  extend: extend35
};

// node_modules/@kitware/vtk.js/Utilities/XMLConverter/chemistry/elements.json.js
var atoms = [
  {
    id: "Xx",
    atomicNumber: 0,
    mass: 0,
    exactMass: 0,
    radiusCovalent: 0,
    radiusVDW: 0,
    symbol: "Xx",
    name: "Dummy",
    elementColor: [
      0.07,
      0.5,
      0.7
    ]
  },
  {
    id: "H",
    atomicNumber: 1,
    mass: 1.00794,
    exactMass: 1.007825032,
    ionization: 13.5984,
    electronAffinity: 0.75420375,
    electronegativityPauling: 2.2,
    nameOrigin: "Greek 'hydro' and 'gennao' for 'forms water'",
    radiusCovalent: 0.37,
    radiusVDW: 1.2,
    boilingpoint: 20.28,
    meltingpoint: 14.01,
    periodTableBlock: "s",
    discoveryDate: "1766",
    period: "1",
    group: "1",
    electronicConfiguration: "1s1",
    family: "Non-Metal",
    symbol: "H",
    name: "Hydrogen",
    elementColor: [
      1,
      1,
      1
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "C.",
      "Cavendish"
    ]
  },
  {
    id: "He",
    atomicNumber: 2,
    mass: 4.002602,
    exactMass: 4.002603254,
    ionization: 24.5874,
    electronAffinity: 0,
    nameOrigin: "The Greek word for the sun was 'helios'",
    radiusCovalent: 0.32,
    radiusVDW: 1.4,
    boilingpoint: 4.216,
    meltingpoint: 0.95,
    periodTableBlock: "p",
    discoveryDate: "1895",
    period: "1",
    group: "8",
    electronicConfiguration: "1s2",
    family: "Noblegas",
    symbol: "He",
    name: "Helium",
    elementColor: [
      0.85,
      1,
      1
    ],
    discoveryCountry: [
      "se",
      "uk"
    ],
    discoverers: [
      "P. J. Janssen",
      "J. N. Lockyer"
    ]
  },
  {
    id: "Li",
    atomicNumber: 3,
    mass: 6.941,
    exactMass: 7.01600455,
    ionization: 5.3917,
    electronAffinity: 0.618049,
    electronegativityPauling: 0.98,
    nameOrigin: "Greek 'lithos' means 'stone'",
    radiusCovalent: 1.34,
    radiusVDW: 2.2,
    boilingpoint: 1615,
    meltingpoint: 453.7,
    periodTableBlock: "s",
    discoveryDate: "1817",
    period: "2",
    group: "1",
    electronicConfiguration: "He 2s1",
    family: "Alkali_Earth",
    symbol: "Li",
    name: "Lithium",
    elementColor: [
      0.8,
      0.5,
      1
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "A.",
      "Arfvedson"
    ]
  },
  {
    id: "Be",
    atomicNumber: 4,
    mass: 9.012182,
    exactMass: 9.0121822,
    ionization: 9.3227,
    electronAffinity: 0,
    electronegativityPauling: 1.57,
    nameOrigin: "Greek 'beryllos' for 'light-green stone'",
    radiusCovalent: 0.9,
    radiusVDW: 1.9,
    boilingpoint: 3243,
    meltingpoint: 1560,
    periodTableBlock: "s",
    discoveryDate: "1797",
    period: "2",
    group: "2",
    electronicConfiguration: "He 2s2",
    family: "Alkaline_Earth",
    symbol: "Be",
    name: "Beryllium",
    elementColor: [
      0.76,
      1,
      0
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "Nicholas",
      "Louis",
      "Vauquelin"
    ]
  },
  {
    id: "B",
    atomicNumber: 5,
    mass: 10.811,
    exactMass: 11.0093054,
    ionization: 8.298,
    electronAffinity: 0.279723,
    electronegativityPauling: 2.04,
    nameOrigin: "Boron means 'Bor(ax) + (carb)on'. It is found in borax and behaves a lot like carbon",
    radiusCovalent: 0.82,
    radiusVDW: 1.8,
    boilingpoint: 4275,
    meltingpoint: 2365,
    periodTableBlock: "p",
    discoveryDate: "1808",
    period: "2",
    group: "3",
    electronicConfiguration: "He 2s2 2p1",
    family: "Metalloids",
    symbol: "B",
    name: "Boron",
    elementColor: [
      1,
      0.71,
      0.71
    ],
    discoveryCountry: [
      "uk",
      "fr"
    ],
    discoverers: [
      "Louis Joseph Gay-Lussac",
      "Louis Jacques Thenard"
    ]
  },
  {
    id: "C",
    atomicNumber: 6,
    mass: 12.0107,
    exactMass: 12,
    ionization: 11.2603,
    electronAffinity: 1.262118,
    electronegativityPauling: 2.55,
    nameOrigin: "Latin 'carboneum' for carbon",
    radiusCovalent: 0.77,
    radiusVDW: 1.7,
    boilingpoint: 5100,
    meltingpoint: 3825,
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "2",
    group: "4",
    electronicConfiguration: "He 2s2 2p2",
    family: "Non-Metal",
    symbol: "C",
    name: "Carbon",
    elementColor: [
      0.5,
      0.5,
      0.5
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "N",
    atomicNumber: 7,
    mass: 14.0067,
    exactMass: 14.003074,
    ionization: 14.5341,
    electronAffinity: -0.07,
    electronegativityPauling: 3.04,
    nameOrigin: "Latin 'nitrogenium' ('forms saltpeter')",
    radiusCovalent: 0.75,
    radiusVDW: 1.6,
    boilingpoint: 77.344,
    meltingpoint: 63.15,
    periodTableBlock: "p",
    discoveryDate: "1772",
    period: "2",
    group: "5",
    electronicConfiguration: "He 2s2 2p3",
    family: "Non-Metal",
    symbol: "N",
    name: "Nitrogen",
    elementColor: [
      0.05,
      0.05,
      1
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "D.",
      "Rutherford"
    ]
  },
  {
    id: "O",
    atomicNumber: 8,
    mass: 15.9994,
    exactMass: 15.99491462,
    ionization: 13.6181,
    electronAffinity: 1.461112,
    electronegativityPauling: 3.44,
    nameOrigin: "Latin 'oxygenium' (forms acids)",
    radiusCovalent: 0.73,
    radiusVDW: 1.55,
    boilingpoint: 90.188,
    meltingpoint: 54.8,
    periodTableBlock: "p",
    discoveryDate: "1774",
    period: "2",
    group: "6",
    electronicConfiguration: "He 2s2 2p4",
    family: "Non-Metal",
    symbol: "O",
    name: "Oxygen",
    elementColor: [
      1,
      0.05,
      0.05
    ],
    discoveryCountry: [
      "se",
      "uk"
    ],
    discoverers: [
      "J.",
      "Priestley"
    ]
  },
  {
    id: "F",
    atomicNumber: 9,
    mass: 18.9984032,
    exactMass: 18.99840322,
    ionization: 17.4228,
    electronAffinity: 3.4011887,
    electronegativityPauling: 3.98,
    nameOrigin: "Latin 'fluere' ('floats')",
    radiusCovalent: 0.71,
    radiusVDW: 1.5,
    boilingpoint: 85,
    meltingpoint: 53.55,
    periodTableBlock: "p",
    discoveryDate: "1886",
    period: "2",
    group: "7",
    electronicConfiguration: "He 2s2 2p5",
    family: "Halogen",
    symbol: "F",
    name: "Fluorine",
    elementColor: [
      0.7,
      1,
      1
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "H.",
      "F.",
      "Moissan"
    ]
  },
  {
    id: "Ne",
    atomicNumber: 10,
    mass: 20.1797,
    exactMass: 19.99244018,
    ionization: 21.5645,
    electronAffinity: 0,
    nameOrigin: "Greek 'neo'. meaning 'new'",
    radiusCovalent: 0.69,
    radiusVDW: 1.54,
    boilingpoint: 27.1,
    meltingpoint: 24.55,
    periodTableBlock: "p",
    discoveryDate: "1898",
    period: "2",
    group: "8",
    electronicConfiguration: "He 2s2 2p6",
    family: "Noblegas",
    symbol: "Ne",
    name: "Neon",
    elementColor: [
      0.7,
      0.89,
      0.96
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "W. Ramsay",
      "M.W. Travers"
    ]
  },
  {
    id: "Na",
    atomicNumber: 11,
    mass: 22.98976928,
    exactMass: 22.98976928,
    ionization: 5.1391,
    electronAffinity: 0.547926,
    electronegativityPauling: 0.93,
    nameOrigin: "Arabic 'natrun' for 'soda'",
    radiusCovalent: 1.54,
    radiusVDW: 2.4,
    boilingpoint: 1156,
    meltingpoint: 371,
    periodTableBlock: "s",
    discoveryDate: "1807",
    period: "3",
    group: "1",
    electronicConfiguration: "Ne 3s1",
    family: "Alkali_Earth",
    symbol: "Na",
    name: "Sodium",
    elementColor: [
      0.67,
      0.36,
      0.95
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "Sir",
      "Humphrey",
      "Davy"
    ]
  },
  {
    id: "Mg",
    atomicNumber: 12,
    mass: 24.305,
    exactMass: 23.9850417,
    ionization: 7.6462,
    electronAffinity: 0,
    electronegativityPauling: 1.31,
    nameOrigin: "Named after the city of Magnesia",
    radiusCovalent: 1.3,
    radiusVDW: 2.2,
    boilingpoint: 1380,
    meltingpoint: 922,
    periodTableBlock: "s",
    discoveryDate: "1808",
    period: "3",
    group: "2",
    electronicConfiguration: "Ne 3s2",
    family: "Alkaline_Earth",
    symbol: "Mg",
    name: "Magnesium",
    elementColor: [
      0.54,
      1,
      0
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "H.",
      "B.",
      "Davy"
    ]
  },
  {
    id: "Al",
    atomicNumber: 13,
    mass: 26.9815386,
    exactMass: 26.98153863,
    ionization: 5.9858,
    electronAffinity: 0.43283,
    electronegativityPauling: 1.61,
    nameOrigin: "Latin 'alumen'",
    radiusCovalent: 1.18,
    radiusVDW: 2.1,
    boilingpoint: 2740,
    meltingpoint: 933.5,
    periodTableBlock: "p",
    discoveryDate: "1825",
    period: "3",
    group: "3",
    electronicConfiguration: "Ne 3s2 3p1",
    family: "Other_Metal",
    symbol: "Al",
    name: "Aluminium",
    elementColor: [
      0.75,
      0.65,
      0.65
    ],
    discoveryCountry: [
      "dk"
    ],
    discoverers: [
      "H.",
      "Ch.",
      "Oersted"
    ]
  },
  {
    id: "Si",
    atomicNumber: 14,
    mass: 28.0855,
    exactMass: 27.97692653,
    ionization: 8.1517,
    electronAffinity: 1.389521,
    electronegativityPauling: 1.9,
    nameOrigin: "Latin 'silex'",
    radiusCovalent: 1.11,
    radiusVDW: 2.1,
    boilingpoint: 2630,
    meltingpoint: 1683,
    periodTableBlock: "p",
    discoveryDate: "1823",
    period: "3",
    group: "4",
    electronicConfiguration: "Ne 3s2 3p2",
    family: "Metalloids",
    symbol: "Si",
    name: "Silicon",
    elementColor: [
      0.5,
      0.6,
      0.6
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "J.",
      "J.",
      "Berzelius"
    ]
  },
  {
    id: "P",
    atomicNumber: 15,
    mass: 30.973762,
    exactMass: 30.97376163,
    ionization: 10.4867,
    electronAffinity: 0.7465,
    electronegativityPauling: 2.19,
    nameOrigin: "Greek 'phosphoros' for 'carries light'",
    radiusCovalent: 1.06,
    radiusVDW: 1.95,
    boilingpoint: 553,
    meltingpoint: 317.3,
    periodTableBlock: "p",
    discoveryDate: "1669",
    period: "3",
    group: "5",
    electronicConfiguration: "Ne 3s2 3p3",
    family: "Non-Metal",
    symbol: "P",
    name: "Phosphorus",
    elementColor: [
      1,
      0.5,
      0
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "H.",
      "Brandt"
    ]
  },
  {
    id: "S",
    atomicNumber: 16,
    mass: 32.065,
    exactMass: 31.972071,
    ionization: 10.36,
    electronAffinity: 2.0771029,
    electronegativityPauling: 2.58,
    nameOrigin: "In sanskrit 'sweb' means 'to sleep'",
    radiusCovalent: 1.02,
    radiusVDW: 1.8,
    boilingpoint: 717.82,
    meltingpoint: 392.2,
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "3",
    group: "6",
    electronicConfiguration: "Ne 3s2 3p4",
    family: "Non-Metal",
    symbol: "S",
    name: "Sulfur",
    elementColor: [
      1,
      1,
      0.19
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Cl",
    atomicNumber: 17,
    mass: 35.453,
    exactMass: 34.96885268,
    ionization: 12.9676,
    electronAffinity: 3.612724,
    electronegativityPauling: 3.16,
    nameOrigin: "Greek 'chloros' for 'yellow-green'",
    radiusCovalent: 0.99,
    radiusVDW: 1.8,
    boilingpoint: 239.18,
    meltingpoint: 172.17,
    periodTableBlock: "p",
    discoveryDate: "1774",
    period: "3",
    group: "7",
    electronicConfiguration: "Ne 3s2 3p5",
    family: "Halogen",
    symbol: "Cl",
    name: "Chlorine",
    elementColor: [
      0.12,
      0.94,
      0.12
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "C.",
      "W.",
      "Scheele"
    ]
  },
  {
    id: "Ar",
    atomicNumber: 18,
    mass: 39.948,
    exactMass: 39.96238312,
    ionization: 15.7596,
    electronAffinity: 0,
    nameOrigin: "Greek 'aergon' for 'inactive'",
    radiusCovalent: 0.97,
    radiusVDW: 1.88,
    boilingpoint: 87.45,
    meltingpoint: 83.95,
    periodTableBlock: "p",
    discoveryDate: "1894",
    period: "3",
    group: "8",
    electronicConfiguration: "Ne 3s2 3p6",
    family: "Noblegas",
    symbol: "Ar",
    name: "Argon",
    elementColor: [
      0.5,
      0.82,
      0.89
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "W. Ramsay",
      "J. Rayleigh"
    ]
  },
  {
    id: "K",
    atomicNumber: 19,
    mass: 39.0983,
    exactMass: 38.96370668,
    ionization: 4.3407,
    electronAffinity: 0.501459,
    electronegativityPauling: 0.82,
    nameOrigin: "Arabic 'al qaliy' for potash",
    radiusCovalent: 1.96,
    radiusVDW: 2.8,
    boilingpoint: 1033,
    meltingpoint: 336.8,
    periodTableBlock: "s",
    discoveryDate: "1807",
    period: "4",
    group: "1",
    electronicConfiguration: "Ar 4s1",
    family: "Alkali_Earth",
    symbol: "K",
    name: "Potassium",
    elementColor: [
      0.56,
      0.25,
      0.83
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "H.",
      "B.",
      "Davy"
    ]
  },
  {
    id: "Ca",
    atomicNumber: 20,
    mass: 40.078,
    exactMass: 39.96259098,
    ionization: 6.1132,
    electronAffinity: 0.02455,
    electronegativityPauling: 1,
    nameOrigin: "Latin 'calx' for 'lime'",
    radiusCovalent: 1.74,
    radiusVDW: 2.4,
    boilingpoint: 1757,
    meltingpoint: 1112,
    periodTableBlock: "s",
    discoveryDate: "1808",
    period: "4",
    group: "2",
    electronicConfiguration: "Ar 4s2",
    family: "Alkaline_Earth",
    symbol: "Ca",
    name: "Calcium",
    elementColor: [
      0.24,
      1,
      0
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "H.",
      "B.",
      "Davy"
    ]
  },
  {
    id: "Sc",
    atomicNumber: 21,
    mass: 44.955912,
    exactMass: 44.9559119,
    ionization: 6.5615,
    electronAffinity: 0.188,
    electronegativityPauling: 1.36,
    nameOrigin: "Named because it was found in Scandinavia",
    radiusCovalent: 1.44,
    radiusVDW: 2.3,
    boilingpoint: 3109,
    meltingpoint: 1814,
    periodTableBlock: "d",
    discoveryDate: "1879",
    period: "4",
    group: "3",
    electronicConfiguration: "Ar 3d1 4s2",
    family: "Transition",
    symbol: "Sc",
    name: "Scandium",
    elementColor: [
      0.9,
      0.9,
      0.9
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "L.",
      "Nilson"
    ]
  },
  {
    id: "Ti",
    atomicNumber: 22,
    mass: 47.867,
    exactMass: 47.9479463,
    ionization: 6.8281,
    electronAffinity: 0.084,
    electronegativityPauling: 1.54,
    nameOrigin: "The Titans were giants in Greek mythology",
    radiusCovalent: 1.36,
    radiusVDW: 2.15,
    boilingpoint: 3560,
    meltingpoint: 1935,
    periodTableBlock: "d",
    discoveryDate: "1791",
    period: "4",
    group: "4",
    electronicConfiguration: "Ar 3d2 4s2",
    family: "Transition",
    symbol: "Ti",
    name: "Titanium",
    elementColor: [
      0.75,
      0.76,
      0.78
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "W.",
      "Gregor"
    ]
  },
  {
    id: "V",
    atomicNumber: 23,
    mass: 50.9415,
    exactMass: 50.9439595,
    ionization: 6.7462,
    electronAffinity: 0.525,
    electronegativityPauling: 1.63,
    nameOrigin: "'Vanadis' is another name for the Nordic goddess Freyja",
    radiusCovalent: 1.25,
    radiusVDW: 2.05,
    boilingpoint: 3650,
    meltingpoint: 2163,
    periodTableBlock: "d",
    discoveryDate: "1830",
    period: "4",
    group: "5",
    electronicConfiguration: "Ar 3d3 4s2",
    family: "Transition",
    symbol: "V",
    name: "Vanadium",
    elementColor: [
      0.65,
      0.65,
      0.67
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "N.",
      "Sefstrm"
    ]
  },
  {
    id: "Cr",
    atomicNumber: 24,
    mass: 51.9961,
    exactMass: 51.9405075,
    ionization: 6.7665,
    electronAffinity: 0.67584,
    electronegativityPauling: 1.66,
    nameOrigin: "Greek 'chroma' means 'color'",
    radiusCovalent: 1.27,
    radiusVDW: 2.05,
    boilingpoint: 2945,
    meltingpoint: 2130,
    periodTableBlock: "d",
    discoveryDate: "1797",
    period: "4",
    group: "6",
    electronicConfiguration: "Ar 3d5 4s1",
    family: "Transition",
    symbol: "Cr",
    name: "Chromium",
    elementColor: [
      0.54,
      0.6,
      0.78
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "Nicholas",
      "Louis",
      "Vauquelin"
    ]
  },
  {
    id: "Mn",
    atomicNumber: 25,
    mass: 54.938045,
    exactMass: 54.9380451,
    ionization: 7.434,
    electronAffinity: 0,
    electronegativityPauling: 1.55,
    nameOrigin: "It was discovered near a town named Magnesia in black earth. Thus, it was named 'magnesia nigra', or for short, Manganese.",
    radiusCovalent: 1.39,
    radiusVDW: 2.05,
    boilingpoint: 2235,
    meltingpoint: 1518,
    periodTableBlock: "d",
    discoveryDate: "1774",
    period: "4",
    group: "7",
    electronicConfiguration: "Ar 3d5 4s2",
    family: "Transition",
    symbol: "Mn",
    name: "Manganese",
    elementColor: [
      0.61,
      0.48,
      0.78
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "C.",
      "W.",
      "Scheele"
    ]
  },
  {
    id: "Fe",
    atomicNumber: 26,
    mass: 55.845,
    exactMass: 55.9349375,
    ionization: 7.9024,
    electronAffinity: 0.151,
    electronegativityPauling: 1.83,
    nameOrigin: "Latin 'ferrum'",
    radiusCovalent: 1.25,
    radiusVDW: 2.05,
    boilingpoint: 3023,
    meltingpoint: 1808,
    periodTableBlock: "d",
    discoveryDate: "0",
    period: "4",
    group: "8",
    electronicConfiguration: "Ar 3d6 4s2",
    family: "Transition",
    symbol: "Fe",
    name: "Iron",
    elementColor: [
      0.5,
      0.48,
      0.78
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Co",
    atomicNumber: 27,
    mass: 58.933195,
    exactMass: 58.933195,
    ionization: 7.881,
    electronAffinity: 0.6633,
    electronegativityPauling: 1.88,
    nameOrigin: "Named after the German word 'Kobold' for 'goblin'",
    radiusCovalent: 1.26,
    radiusVDW: 2,
    boilingpoint: 3143,
    meltingpoint: 1768,
    periodTableBlock: "d",
    discoveryDate: "1737",
    period: "4",
    group: "8",
    electronicConfiguration: "Ar 3d7 4s2",
    family: "Transition",
    symbol: "Co",
    name: "Cobalt",
    elementColor: [
      0.44,
      0.48,
      0.78
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "G.",
      "Brandt"
    ]
  },
  {
    id: "Ni",
    atomicNumber: 28,
    mass: 58.6934,
    exactMass: 57.9353429,
    ionization: 7.6398,
    electronAffinity: 1.15716,
    electronegativityPauling: 1.91,
    nameOrigin: "'Nickel' was the name of a mountain goblin",
    radiusCovalent: 1.21,
    radiusVDW: 2,
    boilingpoint: 3005,
    meltingpoint: 1726,
    periodTableBlock: "d",
    discoveryDate: "1751",
    period: "4",
    group: "8",
    electronicConfiguration: "Ar 3d8 4s2",
    family: "Transition",
    symbol: "Ni",
    name: "Nickel",
    elementColor: [
      0.36,
      0.48,
      0.76
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "A.",
      "F.",
      "Cronstedt"
    ]
  },
  {
    id: "Cu",
    atomicNumber: 29,
    mass: 63.546,
    exactMass: 62.9295975,
    ionization: 7.7264,
    electronAffinity: 1.23578,
    electronegativityPauling: 1.9,
    nameOrigin: "Greek 'cuprum' for Cypres",
    radiusCovalent: 1.38,
    radiusVDW: 2,
    boilingpoint: 2840,
    meltingpoint: 1356.6,
    periodTableBlock: "d",
    discoveryDate: "0",
    period: "4",
    group: "1",
    electronicConfiguration: "Ar 3d10 4s1",
    family: "Transition",
    symbol: "Cu",
    name: "Copper",
    elementColor: [
      1,
      0.48,
      0.38
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Zn",
    atomicNumber: 30,
    mass: 65.38,
    exactMass: 63.9291422,
    ionization: 9.3942,
    electronAffinity: 0,
    electronegativityPauling: 1.65,
    nameOrigin: "German 'zinking' for 'rough', because zinc ore is very rough",
    radiusCovalent: 1.31,
    radiusVDW: 2.1,
    boilingpoint: 1180,
    meltingpoint: 692.73,
    periodTableBlock: "d",
    discoveryDate: "1746",
    period: "4",
    group: "2",
    electronicConfiguration: "Ar 3d10 4s2",
    family: "Transition",
    symbol: "Zn",
    name: "Zinc",
    elementColor: [
      0.49,
      0.5,
      0.69
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Andreas",
      "Marggraf"
    ]
  },
  {
    id: "Ga",
    atomicNumber: 31,
    mass: 69.723,
    exactMass: 68.9255736,
    ionization: 5.9993,
    electronAffinity: 0.41,
    electronegativityPauling: 1.81,
    nameOrigin: "'Gallia' is an old name for France",
    radiusCovalent: 1.26,
    radiusVDW: 2.1,
    boilingpoint: 2478,
    meltingpoint: 302.92,
    periodTableBlock: "p",
    discoveryDate: "1875",
    period: "4",
    group: "3",
    electronicConfiguration: "Ar 3d10 4s2 4p1",
    family: "Other_Metal",
    symbol: "Ga",
    name: "Gallium",
    elementColor: [
      0.76,
      0.56,
      0.56
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "P.",
      "E.",
      "Lecoq",
      "de",
      "Boisbaudran"
    ]
  },
  {
    id: "Ge",
    atomicNumber: 32,
    mass: 72.64,
    exactMass: 73.9211778,
    ionization: 7.8994,
    electronAffinity: 1.232712,
    electronegativityPauling: 2.01,
    nameOrigin: "Latin 'germania' is an old name for Germany",
    radiusCovalent: 1.22,
    radiusVDW: 2.1,
    boilingpoint: 3107,
    meltingpoint: 1211.5,
    periodTableBlock: "p",
    discoveryDate: "1886",
    period: "4",
    group: "4",
    electronicConfiguration: "Ar 3d10 4s2 4p2",
    family: "Metalloids",
    symbol: "Ge",
    name: "Germanium",
    elementColor: [
      0.4,
      0.56,
      0.56
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "C.",
      "A.",
      "Winkler"
    ]
  },
  {
    id: "As",
    atomicNumber: 33,
    mass: 74.9216,
    exactMass: 74.9215965,
    ionization: 9.7886,
    electronAffinity: 0.814,
    electronegativityPauling: 2.18,
    nameOrigin: "Greek 'arsenikos' for 'male' or 'bold'",
    radiusCovalent: 1.19,
    radiusVDW: 2.05,
    boilingpoint: 876,
    meltingpoint: 1090,
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "4",
    group: "5",
    electronicConfiguration: "Ar 3d10 4s2 4p3",
    family: "Metalloids",
    symbol: "As",
    name: "Arsenic",
    elementColor: [
      0.74,
      0.5,
      0.89
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Se",
    atomicNumber: 34,
    mass: 78.96,
    exactMass: 79.9165213,
    ionization: 9.7524,
    electronAffinity: 2.02067,
    electronegativityPauling: 2.55,
    nameOrigin: "Greek 'selena' for 'moon'",
    radiusCovalent: 1.16,
    radiusVDW: 1.9,
    boilingpoint: 958,
    meltingpoint: 494,
    periodTableBlock: "p",
    discoveryDate: "1817",
    period: "4",
    group: "6",
    electronicConfiguration: "Ar 3d10 4s2 4p4",
    family: "Non-Metal",
    symbol: "Se",
    name: "Selenium",
    elementColor: [
      1,
      0.63,
      0
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "J.",
      "J.",
      "Berzelius"
    ]
  },
  {
    id: "Br",
    atomicNumber: 35,
    mass: 79.904,
    exactMass: 78.9183371,
    ionization: 11.8138,
    electronAffinity: 3.363588,
    electronegativityPauling: 2.96,
    nameOrigin: "Greek 'bromos' for 'smells badly'",
    radiusCovalent: 1.14,
    radiusVDW: 1.9,
    boilingpoint: 331.85,
    meltingpoint: 265.95,
    periodTableBlock: "p",
    discoveryDate: "1826",
    period: "4",
    group: "7",
    electronicConfiguration: "Ar 3d10 4s2 4p5",
    family: "Halogen",
    symbol: "Br",
    name: "Bromine",
    elementColor: [
      0.65,
      0.16,
      0.16
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "A.",
      "J.",
      "Balard"
    ]
  },
  {
    id: "Kr",
    atomicNumber: 36,
    mass: 83.798,
    exactMass: 83.911507,
    ionization: 13.9996,
    electronAffinity: 0,
    electronegativityPauling: 3,
    nameOrigin: "Greek 'kryptos' for 'hidden'",
    radiusCovalent: 1.1,
    radiusVDW: 2.02,
    boilingpoint: 120.85,
    meltingpoint: 116,
    periodTableBlock: "p",
    discoveryDate: "1898",
    period: "4",
    group: "8",
    electronicConfiguration: "Ar 3d10 4s2 4p6",
    family: "Noblegas",
    symbol: "Kr",
    name: "Krypton",
    elementColor: [
      0.36,
      0.72,
      0.82
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "W. Ramsay",
      "M. W. Travers"
    ]
  },
  {
    id: "Rb",
    atomicNumber: 37,
    mass: 85.4678,
    exactMass: 84.91178974,
    ionization: 4.1771,
    electronAffinity: 0.485916,
    electronegativityPauling: 0.82,
    nameOrigin: "Latin 'rubidus' for 'dark red'",
    radiusCovalent: 2.11,
    radiusVDW: 2.9,
    boilingpoint: 961,
    meltingpoint: 312.63,
    periodTableBlock: "s",
    discoveryDate: "1861",
    period: "5",
    group: "1",
    electronicConfiguration: "Kr 5s1",
    family: "Alkali_Earth",
    symbol: "Rb",
    name: "Rubidium",
    elementColor: [
      0.44,
      0.18,
      0.69
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Robert W. Bunsen",
      "Gustav R. Kirchhoff"
    ]
  },
  {
    id: "Sr",
    atomicNumber: 38,
    mass: 87.62,
    exactMass: 87.9056121,
    ionization: 5.6949,
    electronAffinity: 0.05206,
    electronegativityPauling: 0.95,
    nameOrigin: "Named after the mineral Strontianit",
    radiusCovalent: 1.92,
    radiusVDW: 2.55,
    boilingpoint: 1655,
    meltingpoint: 1042,
    periodTableBlock: "s",
    discoveryDate: "1790",
    period: "5",
    group: "2",
    electronicConfiguration: "Kr 5s2",
    family: "Alkaline_Earth",
    symbol: "Sr",
    name: "Strontium",
    elementColor: [
      0,
      1,
      0
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "H.",
      "B.",
      "Davy"
    ]
  },
  {
    id: "Y",
    atomicNumber: 39,
    mass: 88.90585,
    exactMass: 88.9058483,
    ionization: 6.2173,
    electronAffinity: 0.307,
    electronegativityPauling: 1.22,
    nameOrigin: "Named after the small town of Ytterby near Stockholm in Sweden. Terbium. Ytterbium and Gadolinium are also named after this town.",
    radiusCovalent: 1.62,
    radiusVDW: 2.4,
    boilingpoint: 3611,
    meltingpoint: 1795,
    periodTableBlock: "d",
    discoveryDate: "1794",
    period: "5",
    group: "3",
    electronicConfiguration: "Kr 4d1 5s2",
    family: "Transition",
    symbol: "Y",
    name: "Yttrium",
    elementColor: [
      0.58,
      1,
      1
    ],
    discoveryCountry: [
      "fi"
    ],
    discoverers: [
      "Johann",
      "Gadolin"
    ]
  },
  {
    id: "Zr",
    atomicNumber: 40,
    mass: 91.224,
    exactMass: 89.9047044,
    ionization: 6.6339,
    electronAffinity: 0.426,
    electronegativityPauling: 1.33,
    nameOrigin: "Named after the mineral zircon",
    radiusCovalent: 1.48,
    radiusVDW: 2.3,
    boilingpoint: 4682,
    meltingpoint: 2128,
    periodTableBlock: "d",
    discoveryDate: "1789",
    period: "5",
    group: "4",
    electronicConfiguration: "Kr 4d2 5s2",
    family: "Transition",
    symbol: "Zr",
    name: "Zirconium",
    elementColor: [
      0.58,
      0.88,
      0.88
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Martin",
      "Heinrich",
      "Klaproth"
    ]
  },
  {
    id: "Nb",
    atomicNumber: 41,
    mass: 92.90638,
    exactMass: 92.9063781,
    ionization: 6.7589,
    electronAffinity: 0.893,
    electronegativityPauling: 1.6,
    nameOrigin: "Named after Niobe, the daughter of the Greek god Tantalus.",
    radiusCovalent: 1.37,
    radiusVDW: 2.15,
    boilingpoint: 5015,
    meltingpoint: 2742,
    periodTableBlock: "d",
    discoveryDate: "1801",
    period: "5",
    group: "5",
    electronicConfiguration: "Kr 4d4",
    family: "Transition",
    symbol: "Nb",
    name: "Niobium",
    elementColor: [
      0.45,
      0.76,
      0.79
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "Ch.",
      "Hatchett"
    ]
  },
  {
    id: "Mo",
    atomicNumber: 42,
    mass: 95.96,
    exactMass: 97.9054082,
    ionization: 7.0924,
    electronAffinity: 0.7472,
    electronegativityPauling: 2.16,
    nameOrigin: "This name has Greek roots. It means 'like Platinum' - it was difficult to distinguish Molybdenum from Platinum.",
    radiusCovalent: 1.45,
    radiusVDW: 2.1,
    boilingpoint: 4912,
    meltingpoint: 2896,
    periodTableBlock: "d",
    discoveryDate: "1778",
    period: "5",
    group: "6",
    electronicConfiguration: "Kr 4d5 5s1",
    family: "Transition",
    symbol: "Mo",
    name: "Molybdenum",
    elementColor: [
      0.33,
      0.71,
      0.71
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "C.",
      "W.",
      "Scheele"
    ]
  },
  {
    id: "Tc",
    atomicNumber: 43,
    mass: 98,
    exactMass: 97.907216,
    ionization: 7.28,
    electronAffinity: 0.55,
    electronegativityPauling: 1.9,
    nameOrigin: "Greek 'technetos' for artificial",
    radiusCovalent: 1.56,
    radiusVDW: 2.05,
    boilingpoint: 4538,
    meltingpoint: 2477,
    periodTableBlock: "d",
    discoveryDate: "1937",
    period: "5",
    group: "7",
    electronicConfiguration: "Kr 4d6 5s1",
    family: "Transition",
    symbol: "Tc",
    name: "Technetium",
    elementColor: [
      0.23,
      0.62,
      0.62
    ],
    discoveryCountry: [
      "it"
    ],
    discoverers: [
      "C. Perrier",
      "E. G. Segre"
    ]
  },
  {
    id: "Ru",
    atomicNumber: 44,
    mass: 101.07,
    exactMass: 101.9043493,
    ionization: 7.3605,
    electronAffinity: 1.04638,
    electronegativityPauling: 2.2,
    nameOrigin: "Ruthenia is the old name of Russia",
    radiusCovalent: 1.26,
    radiusVDW: 2.05,
    boilingpoint: 4425,
    meltingpoint: 2610,
    periodTableBlock: "d",
    discoveryDate: "1844",
    period: "5",
    group: "8",
    electronicConfiguration: "Kr 4d7 5s1",
    family: "Transition",
    symbol: "Ru",
    name: "Ruthenium",
    elementColor: [
      0.14,
      0.56,
      0.56
    ],
    discoveryCountry: [
      "ru"
    ],
    discoverers: [
      "K.",
      "Klaus"
    ]
  },
  {
    id: "Rh",
    atomicNumber: 45,
    mass: 102.9055,
    exactMass: 102.905504,
    ionization: 7.4589,
    electronAffinity: 1.14289,
    electronegativityPauling: 2.28,
    nameOrigin: "Greek 'rhodeos' means 'red like a rose'",
    radiusCovalent: 1.35,
    radiusVDW: 2,
    boilingpoint: 3970,
    meltingpoint: 2236,
    periodTableBlock: "d",
    discoveryDate: "1803",
    period: "5",
    group: "8",
    electronicConfiguration: "Kr 4d8 5s1",
    family: "Transition",
    symbol: "Rh",
    name: "Rhodium",
    elementColor: [
      0.04,
      0.49,
      0.55
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "W.",
      "Wollaston"
    ]
  },
  {
    id: "Pd",
    atomicNumber: 46,
    mass: 106.42,
    exactMass: 105.903486,
    ionization: 8.3369,
    electronAffinity: 0.56214,
    electronegativityPauling: 2.2,
    nameOrigin: "Named after the asteroid Pallas",
    radiusCovalent: 1.31,
    radiusVDW: 2.05,
    boilingpoint: 3240,
    meltingpoint: 1825,
    periodTableBlock: "d",
    discoveryDate: "1803",
    period: "5",
    group: "8",
    electronicConfiguration: "Kr 4d10",
    family: "Transition",
    symbol: "Pd",
    name: "Palladium",
    elementColor: [
      0,
      0.41,
      0.52
    ],
    discoveryCountry: [
      "uk"
    ]
  },
  {
    id: "Ag",
    atomicNumber: 47,
    mass: 107.8682,
    exactMass: 106.905097,
    ionization: 7.5762,
    electronAffinity: 1.30447,
    electronegativityPauling: 1.93,
    nameOrigin: "Latin 'argentum' for silver",
    radiusCovalent: 1.53,
    radiusVDW: 2.1,
    boilingpoint: 2436,
    meltingpoint: 1235.1,
    periodTableBlock: "d",
    discoveryDate: "0",
    period: "5",
    group: "1",
    electronicConfiguration: "Kr 4d10 5s1",
    family: "Transition",
    symbol: "Ag",
    name: "Silver",
    elementColor: [
      0.88,
      0.88,
      1
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Cd",
    atomicNumber: 48,
    mass: 112.411,
    exactMass: 113.9033585,
    ionization: 8.9938,
    electronAffinity: 0,
    electronegativityPauling: 1.69,
    nameOrigin: "Greek 'kadmia' ('Galmei' = Zinc carbonate)",
    radiusCovalent: 1.48,
    radiusVDW: 2.2,
    boilingpoint: 1040,
    meltingpoint: 594.26,
    periodTableBlock: "d",
    discoveryDate: "1817",
    period: "5",
    group: "2",
    electronicConfiguration: "Kr 4d10 5s2",
    family: "Transition",
    symbol: "Cd",
    name: "Cadmium",
    elementColor: [
      1,
      0.85,
      0.56
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "F.",
      "Stromeyer"
    ]
  },
  {
    id: "In",
    atomicNumber: 49,
    mass: 114.818,
    exactMass: 114.903878,
    ionization: 5.7864,
    electronAffinity: 0.404,
    electronegativityPauling: 1.78,
    nameOrigin: "Named after 'Indigo' because of its blue spectrum",
    radiusCovalent: 1.44,
    radiusVDW: 2.2,
    boilingpoint: 2350,
    meltingpoint: 429.78,
    periodTableBlock: "p",
    discoveryDate: "1863",
    period: "5",
    group: "3",
    electronicConfiguration: "Kr 4d10 5s2 5p1",
    family: "Other_Metal",
    symbol: "In",
    name: "Indium",
    elementColor: [
      0.65,
      0.46,
      0.45
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "F. Reich",
      "H.T. Richter"
    ]
  },
  {
    id: "Sn",
    atomicNumber: 50,
    mass: 118.71,
    exactMass: 119.9021947,
    ionization: 7.3439,
    electronAffinity: 1.112066,
    electronegativityPauling: 1.96,
    nameOrigin: "Latin 'stannum' for tin",
    radiusCovalent: 1.41,
    radiusVDW: 2.25,
    boilingpoint: 2876,
    meltingpoint: 505.12,
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "5",
    group: "4",
    electronicConfiguration: "Kr 4d10 5s2 5p2",
    family: "Other_Metal",
    symbol: "Sn",
    name: "Tin",
    elementColor: [
      0.4,
      0.5,
      0.5
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Sb",
    atomicNumber: 51,
    mass: 121.76,
    exactMass: 120.9038157,
    ionization: 8.6084,
    electronAffinity: 1.047401,
    electronegativityPauling: 2.05,
    nameOrigin: "Arabic 'anthos ammonos' for 'blossom of the god Ammon'",
    radiusCovalent: 1.38,
    radiusVDW: 2.2,
    boilingpoint: 1860,
    meltingpoint: 903.91,
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "5",
    group: "5",
    electronicConfiguration: "Kr 4d10 5s2 5p3",
    family: "Metalloids",
    symbol: "Sb",
    name: "Antimony",
    elementColor: [
      0.62,
      0.39,
      0.71
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Te",
    atomicNumber: 52,
    mass: 127.6,
    exactMass: 129.9062244,
    ionization: 9.0096,
    electronAffinity: 1.970875,
    electronegativityPauling: 2.1,
    nameOrigin: "Latin 'tellus' or 'telluris' for 'Planet Earth'",
    radiusCovalent: 1.35,
    radiusVDW: 2.1,
    boilingpoint: 1261,
    meltingpoint: 722.72,
    periodTableBlock: "p",
    discoveryDate: "1782",
    period: "5",
    group: "6",
    electronicConfiguration: "Kr 4d10 5s2 5p4",
    family: "Metalloids",
    symbol: "Te",
    name: "Tellurium",
    elementColor: [
      0.83,
      0.48,
      0
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Franz",
      "Joseph",
      "Muller",
      "von",
      "Reichstein"
    ]
  },
  {
    id: "I",
    atomicNumber: 53,
    mass: 126.90447,
    exactMass: 126.904473,
    ionization: 10.4513,
    electronAffinity: 3.059038,
    electronegativityPauling: 2.66,
    nameOrigin: "Greek 'ioeides' for 'violet'.",
    radiusCovalent: 1.33,
    radiusVDW: 2.1,
    boilingpoint: 457.5,
    meltingpoint: 386.7,
    periodTableBlock: "p",
    discoveryDate: "1811",
    period: "5",
    group: "7",
    electronicConfiguration: "Kr 4d10 5s2 5p5",
    family: "Halogen",
    symbol: "I",
    name: "Iodine",
    elementColor: [
      0.58,
      0,
      0.58
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "Bernard",
      "Courtois"
    ]
  },
  {
    id: "Xe",
    atomicNumber: 54,
    mass: 131.293,
    exactMass: 131.9041535,
    ionization: 12.1298,
    electronAffinity: 0,
    electronegativityPauling: 2.6,
    nameOrigin: "Greek 'xenos' for 'foreigner'",
    radiusCovalent: 1.3,
    radiusVDW: 2.16,
    boilingpoint: 165.1,
    meltingpoint: 161.39,
    periodTableBlock: "p",
    discoveryDate: "1898",
    period: "5",
    group: "8",
    electronicConfiguration: "Kr 4d10 5s2 5p6",
    family: "Noblegas",
    symbol: "Xe",
    name: "Xenon",
    elementColor: [
      0.26,
      0.62,
      0.69
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "W. Ramsay",
      "M. W. Travers"
    ]
  },
  {
    id: "Cs",
    atomicNumber: 55,
    mass: 132.9054519,
    exactMass: 132.9054519,
    ionization: 3.8939,
    electronAffinity: 0.471626,
    electronegativityPauling: 0.79,
    nameOrigin: "Latin 'caesius' for 'heaven blue'.",
    radiusCovalent: 2.25,
    radiusVDW: 3,
    boilingpoint: 944,
    meltingpoint: 301.54,
    periodTableBlock: "s",
    discoveryDate: "1860",
    period: "6",
    group: "1",
    electronicConfiguration: "Xe 6s1",
    family: "Alkali_Earth",
    symbol: "Cs",
    name: "Caesium",
    elementColor: [
      0.34,
      0.09,
      0.56
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Robert Wilhelm Bunsen",
      "Gustav Robert Kirchhoff"
    ]
  },
  {
    id: "Ba",
    atomicNumber: 56,
    mass: 137.327,
    exactMass: 137.9052472,
    ionization: 5.2117,
    electronAffinity: 0.14462,
    electronegativityPauling: 0.89,
    nameOrigin: "Greek 'barys' for 'heavy'",
    radiusCovalent: 1.98,
    radiusVDW: 2.7,
    boilingpoint: 2078,
    meltingpoint: 1002,
    periodTableBlock: "s",
    discoveryDate: "1808",
    period: "6",
    group: "2",
    electronicConfiguration: "Xe 6s2",
    family: "Alkaline_Earth",
    symbol: "Ba",
    name: "Barium",
    elementColor: [
      0,
      0.79,
      0
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "Humphry",
      "Bartholomew",
      "Davy"
    ]
  },
  {
    id: "La",
    atomicNumber: 57,
    mass: 138.90547,
    exactMass: 138.9063533,
    ionization: 5.5769,
    electronAffinity: 0.47,
    electronegativityPauling: 1.1,
    nameOrigin: "Greek 'lanthanein' for 'hidden'. The Lanthanoids are also called the 'rare earth' elements.",
    radiusCovalent: 1.69,
    radiusVDW: 2.5,
    boilingpoint: 3737,
    meltingpoint: 1191,
    periodTableBlock: "f",
    discoveryDate: "1839",
    period: "6",
    group: "3",
    electronicConfiguration: "Xe 5d1 6s2",
    family: "Rare_Earth",
    symbol: "La",
    name: "Lanthanum",
    elementColor: [
      0.44,
      0.83,
      1
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "K.",
      "G.",
      "Mosander"
    ]
  },
  {
    id: "Ce",
    atomicNumber: 58,
    mass: 140.116,
    exactMass: 139.9054387,
    ionization: 5.5387,
    electronAffinity: 0.5,
    electronegativityPauling: 1.12,
    nameOrigin: "Named after the planetoid Ceres",
    radiusVDW: 2.48,
    boilingpoint: 3715,
    meltingpoint: 1071,
    periodTableBlock: "f",
    discoveryDate: "1803",
    period: "6",
    group: "4",
    electronicConfiguration: "Xe 4f1 5d1 6s2",
    family: "Rare_Earth",
    symbol: "Ce",
    name: "Cerium",
    elementColor: [
      1,
      1,
      0.78
    ],
    discoverers: [
      "Jns Jacob Berzelius",
      "W. Hisinger",
      "M. Klaproth"
    ]
  },
  {
    id: "Pr",
    atomicNumber: 59,
    mass: 140.90765,
    exactMass: 140.9076528,
    ionization: 5.473,
    electronAffinity: 0.5,
    electronegativityPauling: 1.13,
    nameOrigin: "Greek 'prasinos didymos' for 'green twin'",
    radiusVDW: 2.47,
    boilingpoint: 3785,
    meltingpoint: 1204,
    periodTableBlock: "f",
    discoveryDate: "1885",
    period: "6",
    group: "5",
    electronicConfiguration: "Xe 4f3 6s2",
    family: "Rare_Earth",
    symbol: "Pr",
    name: "Praseodymium",
    elementColor: [
      0.85,
      1,
      0.78
    ],
    discoverers: [
      "Carl",
      "F.",
      "Auer",
      "von",
      "Welsbach"
    ]
  },
  {
    id: "Nd",
    atomicNumber: 60,
    mass: 144.242,
    exactMass: 141.9077233,
    ionization: 5.525,
    electronAffinity: 0.5,
    electronegativityPauling: 1.14,
    nameOrigin: "Greek 'neos didymos' for 'new twin'",
    radiusVDW: 2.45,
    boilingpoint: 3347,
    meltingpoint: 1294,
    periodTableBlock: "f",
    discoveryDate: "1885",
    period: "6",
    group: "6",
    electronicConfiguration: "Xe 4f4 6s2",
    family: "Rare_Earth",
    symbol: "Nd",
    name: "Neodymium",
    elementColor: [
      0.78,
      1,
      0.78
    ],
    discoverers: [
      "Carl",
      "F.",
      "Auer",
      "von",
      "Welsbach"
    ]
  },
  {
    id: "Pm",
    atomicNumber: 61,
    mass: 145,
    exactMass: 144.912749,
    ionization: 5.582,
    electronAffinity: 0.5,
    nameOrigin: "Named after the Greek Prometheus. Prometheus stole the fire from the gods and gave it to mankind.",
    radiusVDW: 2.43,
    boilingpoint: 3273,
    meltingpoint: 1315,
    periodTableBlock: "f",
    discoveryDate: "1945",
    period: "6",
    group: "7",
    electronicConfiguration: "Xe 4f5 6s2",
    family: "Rare_Earth",
    symbol: "Pm",
    name: "Promethium",
    elementColor: [
      0.64,
      1,
      0.78
    ],
    discoverers: [
      "J. A. Marinsky",
      "C. D. Coryell",
      "L. E. Glendenin"
    ]
  },
  {
    id: "Sm",
    atomicNumber: 62,
    mass: 150.36,
    exactMass: 151.9197324,
    ionization: 5.6437,
    electronAffinity: 0.5,
    electronegativityPauling: 1.17,
    nameOrigin: "Named after the mineral Samarskit",
    radiusVDW: 2.42,
    boilingpoint: 2067,
    meltingpoint: 1347,
    periodTableBlock: "f",
    discoveryDate: "1879",
    period: "6",
    group: "8",
    electronicConfiguration: "Xe 4f6 6s2",
    family: "Rare_Earth",
    symbol: "Sm",
    name: "Samarium",
    elementColor: [
      0.56,
      1,
      0.78
    ],
    discoverers: [
      "P.",
      "Lecoq",
      "de",
      "Boisbaudran"
    ]
  },
  {
    id: "Eu",
    atomicNumber: 63,
    mass: 151.964,
    exactMass: 152.9212303,
    ionization: 5.6704,
    electronAffinity: 0.5,
    nameOrigin: "Named after Europe",
    radiusVDW: 2.4,
    boilingpoint: 1800,
    meltingpoint: 1095,
    periodTableBlock: "f",
    discoveryDate: "1901",
    period: "6",
    group: "8",
    electronicConfiguration: "Xe 4f7 6s2",
    family: "Rare_Earth",
    symbol: "Eu",
    name: "Europium",
    elementColor: [
      0.38,
      1,
      0.78
    ],
    discoverers: [
      "E.",
      "A.",
      "Demarcay"
    ]
  },
  {
    id: "Gd",
    atomicNumber: 64,
    mass: 157.25,
    exactMass: 157.9241039,
    ionization: 6.1498,
    electronAffinity: 0.5,
    electronegativityPauling: 1.2,
    nameOrigin: "Named after the Finnish chemist Johan Gadolin",
    radiusVDW: 2.38,
    boilingpoint: 3545,
    meltingpoint: 1585,
    periodTableBlock: "f",
    discoveryDate: "1880",
    period: "6",
    group: "8",
    electronicConfiguration: "Xe 4f7 5d1 6s2",
    family: "Rare_Earth",
    symbol: "Gd",
    name: "Gadolinium",
    elementColor: [
      0.27,
      1,
      0.78
    ],
    discoverers: [
      "Jean",
      "de",
      "Marignac"
    ]
  },
  {
    id: "Tb",
    atomicNumber: 65,
    mass: 158.92535,
    exactMass: 158.9253468,
    ionization: 5.8638,
    electronAffinity: 0.5,
    nameOrigin: "Named after the Swedish town of Ytterby",
    radiusVDW: 2.37,
    boilingpoint: 3500,
    meltingpoint: 1629,
    periodTableBlock: "f",
    discoveryDate: "1843",
    period: "6",
    group: "1",
    electronicConfiguration: "Xe 4f9 6s2",
    family: "Rare_Earth",
    symbol: "Tb",
    name: "Terbium",
    elementColor: [
      0.19,
      1,
      0.78
    ],
    discoverers: [
      "K.",
      "G.",
      "Mosander"
    ]
  },
  {
    id: "Dy",
    atomicNumber: 66,
    mass: 162.5,
    exactMass: 163.9291748,
    ionization: 5.9389,
    electronAffinity: 0.5,
    electronegativityPauling: 1.22,
    nameOrigin: "Greek 'dysprositor' for 'difficult to reach'",
    radiusVDW: 2.35,
    boilingpoint: 2840,
    meltingpoint: 1685,
    periodTableBlock: "f",
    discoveryDate: "1886",
    period: "6",
    group: "2",
    electronicConfiguration: "Xe 4f10 6s2",
    family: "Rare_Earth",
    symbol: "Dy",
    name: "Dysprosium",
    elementColor: [
      0.12,
      1,
      0.78
    ],
    discoverers: [
      "F.",
      "E.",
      "Lecoq",
      "de",
      "Boisbaudran"
    ]
  },
  {
    id: "Ho",
    atomicNumber: 67,
    mass: 164.93032,
    exactMass: 164.9303221,
    ionization: 6.0215,
    electronAffinity: 0.5,
    electronegativityPauling: 1.23,
    nameOrigin: "Latin 'holmia' for the old name of Stockholm",
    radiusVDW: 2.33,
    boilingpoint: 2968,
    meltingpoint: 1747,
    periodTableBlock: "f",
    discoveryDate: "1878",
    period: "6",
    group: "3",
    electronicConfiguration: "Xe 4f11 6s2",
    family: "Rare_Earth",
    symbol: "Ho",
    name: "Holmium",
    elementColor: [
      0,
      1,
      0.61
    ],
    discoverers: [
      "J. L. Soret",
      "P.T. Cleve"
    ]
  },
  {
    id: "Er",
    atomicNumber: 68,
    mass: 167.259,
    exactMass: 165.9302931,
    ionization: 6.1077,
    electronAffinity: 0.5,
    electronegativityPauling: 1.24,
    nameOrigin: "Named ofter the Swedish town of Ytterby. Terbium and Ytterbium are also named after this town.",
    radiusVDW: 2.32,
    boilingpoint: 3140,
    meltingpoint: 1802,
    periodTableBlock: "f",
    discoveryDate: "1843",
    period: "6",
    group: "4",
    electronicConfiguration: "Xe 4f12 6s2",
    family: "Rare_Earth",
    symbol: "Er",
    name: "Erbium",
    elementColor: [
      0,
      0.9,
      0.46
    ],
    discoverers: [
      "K.",
      "G.",
      "Mosander"
    ]
  },
  {
    id: "Tm",
    atomicNumber: 69,
    mass: 168.93421,
    exactMass: 168.9342133,
    ionization: 6.1843,
    electronAffinity: 0.5,
    electronegativityPauling: 1.25,
    nameOrigin: "Named after the old name of Scandinavia, 'Thule'.",
    radiusVDW: 2.3,
    boilingpoint: 2223,
    meltingpoint: 1818,
    periodTableBlock: "f",
    discoveryDate: "1879",
    period: "6",
    group: "5",
    electronicConfiguration: "Xe 4f13 6s2",
    family: "Rare_Earth",
    symbol: "Tm",
    name: "Thulium",
    elementColor: [
      0,
      0.83,
      0.32
    ],
    discoverers: [
      "P.",
      "T.",
      "Cleve"
    ]
  },
  {
    id: "Yb",
    atomicNumber: 70,
    mass: 173.054,
    exactMass: 173.9388621,
    ionization: 6.2542,
    electronAffinity: 0.5,
    nameOrigin: "Like Terbium and Gadolinium, this is named after the Swedish town of Ytterby.",
    radiusVDW: 2.28,
    boilingpoint: 1469,
    meltingpoint: 1092,
    periodTableBlock: "f",
    discoveryDate: "1878",
    period: "6",
    group: "6",
    electronicConfiguration: "Xe 4f14 6s2",
    family: "Rare_Earth",
    symbol: "Yb",
    name: "Ytterbium",
    elementColor: [
      0,
      0.75,
      0.22
    ],
    discoverers: [
      "J.",
      "Ch.",
      "Marignac"
    ]
  },
  {
    id: "Lu",
    atomicNumber: 71,
    mass: 174.9668,
    exactMass: 174.9407718,
    ionization: 5.4259,
    electronAffinity: 0.5,
    electronegativityPauling: 1.27,
    nameOrigin: "Named after the Roman name 'Lutetia' for Paris",
    radiusCovalent: 1.6,
    radiusVDW: 2.27,
    boilingpoint: 3668,
    meltingpoint: 1936,
    periodTableBlock: "f",
    discoveryDate: "1907",
    period: "6",
    group: "7",
    electronicConfiguration: "Xe 4f14 5d1 6s2",
    family: "Rare_Earth",
    symbol: "Lu",
    name: "Lutetium",
    elementColor: [
      0,
      0.67,
      0.14
    ],
    discoverers: [
      "Carl F. Auer von Welsbach",
      "G. Urbain"
    ]
  },
  {
    id: "Hf",
    atomicNumber: 72,
    mass: 178.49,
    exactMass: 179.94655,
    ionization: 6.8251,
    electronAffinity: 0,
    electronegativityPauling: 1.3,
    nameOrigin: "'Hafnia' is the old name of Kopenhagen (Denmark)",
    radiusCovalent: 1.5,
    radiusVDW: 2.25,
    boilingpoint: 4875,
    meltingpoint: 2504,
    periodTableBlock: "d",
    discoveryDate: "1923",
    period: "6",
    group: "4",
    electronicConfiguration: "Xe 4f14 5d2 6s2",
    family: "Transition",
    symbol: "Hf",
    name: "Hafnium",
    elementColor: [
      0.3,
      0.76,
      1
    ],
    discoveryCountry: [
      "dk"
    ],
    discoverers: [
      "D. Coster",
      "G. Hevesy"
    ]
  },
  {
    id: "Ta",
    atomicNumber: 73,
    mass: 180.94788,
    exactMass: 180.9479958,
    ionization: 7.5496,
    electronAffinity: 0.322,
    electronegativityPauling: 1.5,
    nameOrigin: "Named after the Greek myth of Tantalos",
    radiusCovalent: 1.38,
    radiusVDW: 2.2,
    boilingpoint: 5730,
    meltingpoint: 3293,
    periodTableBlock: "d",
    discoveryDate: "1802",
    period: "6",
    group: "5",
    electronicConfiguration: "Xe 4f14 5d3 6s2",
    family: "Transition",
    symbol: "Ta",
    name: "Tantalum",
    elementColor: [
      0.3,
      0.65,
      1
    ],
    discoveryCountry: [
      "se"
    ],
    discoverers: [
      "A.",
      "Ekeberg"
    ]
  },
  {
    id: "W",
    atomicNumber: 74,
    mass: 183.84,
    exactMass: 183.9509312,
    ionization: 7.864,
    electronAffinity: 0.815,
    electronegativityPauling: 2.36,
    nameOrigin: "'tung sten' means 'heavy stone' in Swedish. The old name (and thus the symbol 'W') was Wolfram, named after a mineral.",
    radiusCovalent: 1.46,
    radiusVDW: 2.1,
    boilingpoint: 5825,
    meltingpoint: 3695,
    periodTableBlock: "d",
    discoveryDate: "1783",
    period: "6",
    group: "6",
    electronicConfiguration: "Xe 4f14 5d4 6s2",
    family: "Transition",
    symbol: "W",
    name: "Tungsten",
    elementColor: [
      0.13,
      0.58,
      0.84
    ],
    discoveryCountry: [
      "es"
    ],
    discoverers: [
      "C.",
      "W.",
      "Scheele"
    ]
  },
  {
    id: "Re",
    atomicNumber: 75,
    mass: 186.207,
    exactMass: 186.9557531,
    ionization: 7.8335,
    electronAffinity: 0.15,
    electronegativityPauling: 1.9,
    nameOrigin: "Named after the German river Rhine (latin 'Rhenium').",
    radiusCovalent: 1.59,
    radiusVDW: 2.05,
    boilingpoint: 5870,
    meltingpoint: 3455,
    periodTableBlock: "d",
    discoveryDate: "1925",
    period: "6",
    group: "7",
    electronicConfiguration: "Xe 4f14 5d5 6s2",
    family: "Transition",
    symbol: "Re",
    name: "Rhenium",
    elementColor: [
      0.15,
      0.49,
      0.67
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Walter Noddack",
      "Ida Tacke-Noddack",
      "Otto Berg"
    ]
  },
  {
    id: "Os",
    atomicNumber: 76,
    mass: 190.23,
    exactMass: 191.9614807,
    ionization: 8.4382,
    electronAffinity: 1.0778,
    electronegativityPauling: 2.2,
    nameOrigin: "Greek for 'smell'. Its oxides smell strongly like radishes.",
    radiusCovalent: 1.28,
    radiusVDW: 2,
    boilingpoint: 5300,
    meltingpoint: 3300,
    periodTableBlock: "d",
    discoveryDate: "1804",
    period: "6",
    group: "8",
    electronicConfiguration: "Xe 4f14 5d6 6s2",
    family: "Transition",
    symbol: "Os",
    name: "Osmium",
    elementColor: [
      0.15,
      0.4,
      0.59
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "S.",
      "Tennant"
    ]
  },
  {
    id: "Ir",
    atomicNumber: 77,
    mass: 192.217,
    exactMass: 192.9629264,
    ionization: 8.967,
    electronAffinity: 1.56436,
    electronegativityPauling: 2.2,
    nameOrigin: "Greek 'iris' for 'rainbow'",
    radiusCovalent: 1.37,
    radiusVDW: 2,
    boilingpoint: 4700,
    meltingpoint: 2720,
    periodTableBlock: "d",
    discoveryDate: "1804",
    period: "6",
    group: "8",
    electronicConfiguration: "Xe 4f14 5d7 6s2",
    family: "Transition",
    symbol: "Ir",
    name: "Iridium",
    elementColor: [
      0.09,
      0.33,
      0.53
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "S.",
      "Tennant"
    ]
  },
  {
    id: "Pt",
    atomicNumber: 78,
    mass: 195.084,
    exactMass: 194.9647911,
    ionization: 8.9588,
    electronAffinity: 2.1251,
    electronegativityPauling: 2.28,
    nameOrigin: "Spanish 'platina' means 'small silver'",
    radiusCovalent: 1.28,
    radiusVDW: 2.05,
    boilingpoint: 4100,
    meltingpoint: 2042.1,
    periodTableBlock: "d",
    discoveryDate: "1735",
    period: "6",
    group: "8",
    electronicConfiguration: "Xe 4f14 5d9 6s1",
    family: "Transition",
    symbol: "Pt",
    name: "Platinum",
    elementColor: [
      0.96,
      0.93,
      0.82
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "A.",
      "de",
      "Ulloa"
    ]
  },
  {
    id: "Au",
    atomicNumber: 79,
    mass: 196.966569,
    exactMass: 196.9665687,
    ionization: 9.2255,
    electronAffinity: 2.30861,
    electronegativityPauling: 2.54,
    nameOrigin: "Latin 'aurum'. Named after Aurora, the goddess of sunrise",
    radiusCovalent: 1.44,
    radiusVDW: 2.1,
    boilingpoint: 3130,
    meltingpoint: 1337.58,
    periodTableBlock: "d",
    discoveryDate: "0",
    period: "6",
    group: "1",
    electronicConfiguration: "Xe 4f14 5d10 6s1",
    family: "Transition",
    symbol: "Au",
    name: "Gold",
    elementColor: [
      0.8,
      0.82,
      0.12
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Hg",
    atomicNumber: 80,
    mass: 200.59,
    exactMass: 201.970643,
    ionization: 10.4375,
    electronAffinity: 0,
    electronegativityPauling: 2,
    nameOrigin: "Graeco-Latin 'hydrargyrum' for 'liquid silver'",
    radiusCovalent: 1.49,
    radiusVDW: 2.05,
    boilingpoint: 629.88,
    meltingpoint: 234.31,
    periodTableBlock: "d",
    discoveryDate: "0",
    period: "6",
    group: "2",
    electronicConfiguration: "Xe 4f14 5d10 6s2",
    family: "Transition",
    symbol: "Hg",
    name: "Mercury",
    elementColor: [
      0.71,
      0.71,
      0.76
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Tl",
    atomicNumber: 81,
    mass: 204.3833,
    exactMass: 204.9744275,
    ionization: 6.1082,
    electronAffinity: 0.377,
    electronegativityPauling: 1.62,
    nameOrigin: "Greek 'tallos' for 'young twig'",
    radiusCovalent: 1.48,
    radiusVDW: 2.2,
    boilingpoint: 1746,
    meltingpoint: 577,
    periodTableBlock: "p",
    discoveryDate: "1861",
    period: "6",
    group: "3",
    electronicConfiguration: "Xe 4f14 5d10 6s2 6p1",
    family: "Other_Metal",
    symbol: "Tl",
    name: "Thallium",
    elementColor: [
      0.65,
      0.33,
      0.3
    ],
    discoveryCountry: [
      "uk"
    ],
    discoverers: [
      "W.",
      "Crookes"
    ]
  },
  {
    id: "Pb",
    atomicNumber: 82,
    mass: 207.2,
    exactMass: 207.9766521,
    ionization: 7.4167,
    electronAffinity: 0.364,
    electronegativityPauling: 2.33,
    nameOrigin: "Latin 'plumbum' for Lead",
    radiusCovalent: 1.47,
    radiusVDW: 2.3,
    boilingpoint: 2023,
    meltingpoint: 600.65,
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "6",
    group: "4",
    electronicConfiguration: "Xe 4f14 5d10 6s2 6p2",
    family: "Other_Metal",
    symbol: "Pb",
    name: "Lead",
    elementColor: [
      0.34,
      0.35,
      0.38
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Bi",
    atomicNumber: 83,
    mass: 208.9804,
    exactMass: 208.9803987,
    ionization: 7.2855,
    electronAffinity: 0.942363,
    electronegativityPauling: 2.02,
    nameOrigin: "The old name of Bismuth is 'Wismut', which stood for 'white mass'.",
    radiusCovalent: 1.46,
    radiusVDW: 2.3,
    boilingpoint: 1837,
    meltingpoint: 544.59,
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "6",
    group: "5",
    electronicConfiguration: "Xe 4f14 5d10 6s2 6p3",
    family: "Other_Metal",
    symbol: "Bi",
    name: "Bismuth",
    elementColor: [
      0.62,
      0.31,
      0.71
    ],
    discoveryCountry: [
      "ancient"
    ]
  },
  {
    id: "Po",
    atomicNumber: 84,
    mass: 209,
    exactMass: 208.9824304,
    ionization: 8.414,
    electronAffinity: 1.9,
    electronegativityPauling: 2,
    nameOrigin: "Named after Poland to honor Marie Curie",
    radiusVDW: 2,
    meltingpoint: 527,
    periodTableBlock: "p",
    discoveryDate: "1898",
    period: "6",
    group: "6",
    electronicConfiguration: "Xe 4f14 5d10 6s2 6p4",
    family: "Metalloids",
    symbol: "Po",
    name: "Polonium",
    elementColor: [
      0.67,
      0.36,
      0
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "M. Sklodowska-Curie",
      "P. Curie"
    ]
  },
  {
    id: "At",
    atomicNumber: 85,
    mass: 210,
    exactMass: 209.987148,
    ionization: 0,
    electronAffinity: 2.8,
    electronegativityPauling: 2.2,
    nameOrigin: "Greek 'astator' for 'changing'",
    radiusVDW: 2,
    boilingpoint: 610,
    meltingpoint: 575,
    periodTableBlock: "p",
    discoveryDate: "1940",
    period: "6",
    group: "7",
    electronicConfiguration: "Xe 4f14 5d10 6s2 6p5",
    family: "Halogen",
    symbol: "At",
    name: "Astatine",
    elementColor: [
      0.46,
      0.31,
      0.27
    ],
    discoveryCountry: [
      "us"
    ],
    discoverers: [
      "D. R. Corson",
      "K. R. McKenzie",
      "E. Segre"
    ]
  },
  {
    id: "Rn",
    atomicNumber: 86,
    mass: 222,
    exactMass: 222.0175777,
    ionization: 10.7485,
    electronAffinity: 0,
    nameOrigin: "Named after Radium. It ends with 'on' to make it clear that it is a noble gas.",
    radiusCovalent: 1.45,
    radiusVDW: 2,
    boilingpoint: 211.4,
    meltingpoint: 202,
    periodTableBlock: "p",
    discoveryDate: "1898",
    period: "6",
    group: "8",
    electronicConfiguration: "Xe 4f14 5d10 6s2 6p6",
    family: "Noblegas",
    symbol: "Rn",
    name: "Radon",
    elementColor: [
      0.26,
      0.51,
      0.59
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "E.",
      "Dorn"
    ]
  },
  {
    id: "Fr",
    atomicNumber: 87,
    mass: 223,
    exactMass: 223.0197359,
    ionization: 4.0727,
    electronegativityPauling: 0.7,
    nameOrigin: "Named after France to honor Marguerite Perey",
    radiusVDW: 2,
    boilingpoint: 950,
    meltingpoint: 300,
    periodTableBlock: "s",
    discoveryDate: "1939",
    period: "7",
    group: "1",
    electronicConfiguration: "Rn 7s1",
    family: "Alkali_Earth",
    symbol: "Fr",
    name: "Francium",
    elementColor: [
      0.26,
      0,
      0.4
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "M.",
      "Perey"
    ]
  },
  {
    id: "Ra",
    atomicNumber: 88,
    mass: 226,
    exactMass: 226.0254098,
    ionization: 5.2784,
    electronegativityPauling: 0.9,
    nameOrigin: "Latin 'radius' for 'beam', as it is radioactive",
    radiusVDW: 2,
    boilingpoint: 1413,
    meltingpoint: 973,
    periodTableBlock: "s",
    discoveryDate: "1898",
    period: "7",
    group: "2",
    electronicConfiguration: "Rn 7s2",
    family: "Alkaline_Earth",
    symbol: "Ra",
    name: "Radium",
    elementColor: [
      0,
      0.49,
      0
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "M. Sklodowska-Curie",
      "P. Curie"
    ]
  },
  {
    id: "Ac",
    atomicNumber: 89,
    mass: 227,
    exactMass: 227.0277521,
    ionization: 5.17,
    electronegativityPauling: 1.1,
    nameOrigin: "Greek 'aktis' for 'beam' - actinium is radioactive",
    radiusVDW: 2,
    boilingpoint: 3470,
    meltingpoint: 1324,
    periodTableBlock: "f",
    discoveryDate: "1899",
    period: "7",
    group: "3",
    electronicConfiguration: "Rn 6d1 7s2",
    family: "Other_Metal",
    symbol: "Ac",
    name: "Actinium",
    elementColor: [
      0.44,
      0.67,
      0.98
    ],
    discoveryCountry: [
      "fr"
    ],
    discoverers: [
      "A.",
      "L.",
      "Debierne"
    ]
  },
  {
    id: "Th",
    atomicNumber: 90,
    mass: 232.03806,
    exactMass: 232.0380553,
    ionization: 6.3067,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after the German god of thunder: Thor",
    radiusVDW: 2.4,
    boilingpoint: 5060,
    meltingpoint: 2028,
    periodTableBlock: "f",
    discoveryDate: "1828",
    period: "7",
    group: "4",
    electronicConfiguration: "Rn 6d2 7s2",
    family: "Other_Metal",
    symbol: "Th",
    name: "Thorium",
    elementColor: [
      0,
      0.73,
      1
    ],
    discoverers: [
      "J.",
      "J.",
      "Berzelius"
    ]
  },
  {
    id: "Pa",
    atomicNumber: 91,
    mass: 231.03588,
    exactMass: 231.035884,
    ionization: 5.89,
    electronegativityPauling: 1.5,
    nameOrigin: "Greek 'protos' for 'ancester'. Protactinium is before Actinium in the periodic table.",
    radiusVDW: 2,
    boilingpoint: 4300,
    meltingpoint: 1845,
    periodTableBlock: "f",
    discoveryDate: "1917",
    period: "7",
    group: "5",
    electronicConfiguration: "Rn 5f2 6d1 7s2",
    family: "Other_Metal",
    symbol: "Pa",
    name: "Protactinium",
    elementColor: [
      0,
      0.63,
      1
    ],
    discoverers: [
      "O. Hahn",
      "L. Meitern",
      "W. Wollaston"
    ]
  },
  {
    id: "U",
    atomicNumber: 92,
    mass: 238.02891,
    exactMass: 238.0507882,
    ionization: 6.1941,
    electronegativityPauling: 1.38,
    nameOrigin: "Greek 'ouranos' for 'heaven'. Named after the planet Uranus.",
    radiusVDW: 2.3,
    boilingpoint: 4407,
    meltingpoint: 1408,
    periodTableBlock: "f",
    discoveryDate: "1789",
    period: "7",
    group: "6",
    electronicConfiguration: "Rn 5f3 6d1 7s2",
    family: "Other_Metal",
    symbol: "U",
    name: "Uranium",
    elementColor: [
      0,
      0.56,
      1
    ],
    discoverers: [
      "M.",
      "M.",
      "Klaproth"
    ]
  },
  {
    id: "Np",
    atomicNumber: 93,
    mass: 237,
    exactMass: 237.0481734,
    ionization: 6.2657,
    electronegativityPauling: 1.36,
    nameOrigin: "Named after the planet Neptune.",
    radiusVDW: 2,
    boilingpoint: 4175,
    meltingpoint: 912,
    periodTableBlock: "f",
    discoveryDate: "1940",
    period: "7",
    group: "7",
    electronicConfiguration: "Rn 5f4 6d1 7s2",
    family: "Other_Metal",
    symbol: "Np",
    name: "Neptunium",
    elementColor: [
      0,
      0.5,
      1
    ],
    discoverers: [
      "E. M. McMillan",
      "P. Aberson"
    ]
  },
  {
    id: "Pu",
    atomicNumber: 94,
    mass: 244,
    exactMass: 244.064204,
    ionization: 6.026,
    electronegativityPauling: 1.28,
    nameOrigin: "Named after the planet Pluto.",
    radiusVDW: 2,
    boilingpoint: 3505,
    meltingpoint: 913,
    periodTableBlock: "f",
    discoveryDate: "1940",
    period: "7",
    group: "8",
    electronicConfiguration: "Rn 5f6 7s2",
    family: "Other_Metal",
    symbol: "Pu",
    name: "Plutonium",
    elementColor: [
      0,
      0.42,
      1
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "E. M. McMillan",
      "J. W. Kennedy",
      "A.C. Wahl"
    ]
  },
  {
    id: "Am",
    atomicNumber: 95,
    mass: 243,
    exactMass: 243.0613811,
    ionization: 5.9738,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after America.",
    radiusVDW: 2,
    boilingpoint: 2880,
    meltingpoint: 1449,
    periodTableBlock: "f",
    discoveryDate: "1945",
    period: "7",
    group: "8",
    electronicConfiguration: "Rn 5f7 7s2",
    family: "Other_Metal",
    symbol: "Am",
    name: "Americium",
    elementColor: [
      0.33,
      0.36,
      0.95
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "L. O. Morgan",
      "R. A. James",
      "A. Ghiors"
    ]
  },
  {
    id: "Cm",
    atomicNumber: 96,
    mass: 247,
    exactMass: 247.070354,
    ionization: 5.9914,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after Marie Curie.",
    radiusVDW: 2,
    boilingpoint: 3383,
    meltingpoint: 1620,
    periodTableBlock: "f",
    discoveryDate: "1944",
    period: "7",
    group: "8",
    electronicConfiguration: "Rn 5f7 6d1 7s2",
    family: "Other_Metal",
    symbol: "Cm",
    name: "Curium",
    elementColor: [
      0.47,
      0.36,
      0.89
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "R. A. James",
      "A. Ghiors"
    ]
  },
  {
    id: "Bk",
    atomicNumber: 97,
    mass: 247,
    exactMass: 247.070307,
    ionization: 6.1979,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after the town Berkeley where it was discovered.",
    radiusVDW: 2,
    boilingpoint: 983,
    meltingpoint: 1258,
    periodTableBlock: "f",
    discoveryDate: "1949",
    period: "7",
    group: "1",
    electronicConfiguration: "Rn 5f9 7s2",
    family: "Other_Metal",
    symbol: "Bk",
    name: "Berkelium",
    elementColor: [
      0.54,
      0.31,
      0.89
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "A. Ghiors",
      "S. G. Thompson"
    ]
  },
  {
    id: "Cf",
    atomicNumber: 98,
    mass: 251,
    exactMass: 251.079587,
    ionization: 6.2817,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after the US-State of California.",
    radiusVDW: 2,
    boilingpoint: 1173,
    meltingpoint: 1172,
    periodTableBlock: "f",
    discoveryDate: "1950",
    period: "7",
    group: "2",
    electronicConfiguration: "Rn 5f10 7s2",
    family: "Other_Metal",
    symbol: "Cf",
    name: "Californium",
    elementColor: [
      0.63,
      0.21,
      0.83
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "A. Ghiors",
      "S. G. Thompson"
    ]
  },
  {
    id: "Es",
    atomicNumber: 99,
    mass: 252,
    exactMass: 252.08298,
    ionization: 6.42,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after the scientist Albert Einstein.",
    radiusVDW: 2,
    meltingpoint: 1130,
    periodTableBlock: "f",
    discoveryDate: "1952",
    period: "7",
    group: "3",
    electronicConfiguration: "Rn 5f11 7s2",
    family: "Other_Metal",
    symbol: "Es",
    name: "Einsteinium",
    elementColor: [
      0.7,
      0.12,
      0.83
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "et al."
    ]
  },
  {
    id: "Fm",
    atomicNumber: 100,
    mass: 257,
    exactMass: 257.095105,
    ionization: 6.5,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after the scientist Enrico Fermi.",
    radiusVDW: 2,
    meltingpoint: 1800,
    periodTableBlock: "f",
    discoveryDate: "1953",
    period: "7",
    group: "4",
    electronicConfiguration: "Rn 5f12 7s2",
    family: "Other_Metal",
    symbol: "Fm",
    name: "Fermium",
    elementColor: [
      0.7,
      0.12,
      0.73
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "et al."
    ]
  },
  {
    id: "Md",
    atomicNumber: 101,
    mass: 258,
    exactMass: 258.098431,
    ionization: 6.58,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after the scientist D.I. Mendeleev.",
    radiusVDW: 2,
    meltingpoint: 1100,
    periodTableBlock: "f",
    discoveryDate: "1955",
    period: "7",
    group: "5",
    electronicConfiguration: "Rn 5f13 7s2",
    family: "Other_Metal",
    symbol: "Md",
    name: "Mendelevium",
    elementColor: [
      0.7,
      0.05,
      0.65
    ],
    discoverers: [
      "Glenn T. Seaborg",
      "Albert Ghiorso",
      "Bernard Harvey",
      "Gregory Choppin",
      "Stanley G. Thompson"
    ]
  },
  {
    id: "No",
    atomicNumber: 102,
    mass: 259,
    exactMass: 259.10103,
    ionization: 6.65,
    electronegativityPauling: 1.3,
    nameOrigin: "Named after the scientist Alfred Nobel.",
    radiusVDW: 2,
    meltingpoint: 1100,
    periodTableBlock: "f",
    discoveryDate: "1958",
    period: "7",
    group: "6",
    electronicConfiguration: "Rn 5f14 7s2",
    family: "Other_Metal",
    symbol: "No",
    name: "Nobelium",
    elementColor: [
      0.74,
      0.05,
      0.53
    ]
  },
  {
    id: "Lr",
    atomicNumber: 103,
    mass: 262,
    exactMass: 262.10963,
    ionization: 4.9,
    nameOrigin: "Named after the scientist Ernest Orlando Lawrence.",
    radiusVDW: 2,
    meltingpoint: 1900,
    periodTableBlock: "f",
    discoveryDate: "1961",
    period: "7",
    group: "7",
    electronicConfiguration: "Rn 5f14 7s2 7p1",
    family: "Other_Metal",
    symbol: "Lr",
    name: "Lawrencium",
    elementColor: [
      0.78,
      0,
      0.4
    ],
    discoverers: [
      "Albert Ghiorso",
      "Torbjorn Sikkeland",
      "Almon Larsh",
      "Robert M. Latimer"
    ]
  },
  {
    id: "Rf",
    atomicNumber: 104,
    mass: 267,
    exactMass: 261.10877,
    ionization: 6,
    nameOrigin: "Named after the scientist Ernest Rutherford",
    radiusVDW: 2,
    periodTableBlock: "d",
    discoveryDate: "1964",
    period: "7",
    group: "4",
    electronicConfiguration: "Rn 5f14 6d2 7s2",
    family: "Transition",
    symbol: "Rf",
    name: "Rutherfordium",
    elementColor: [
      0.8,
      0,
      0.35
    ],
    discoveryCountry: [
      "ru",
      "us"
    ]
  },
  {
    id: "Db",
    atomicNumber: 105,
    mass: 268,
    exactMass: 262.11408,
    nameOrigin: "Named after the science-town Dubna in Russia",
    radiusVDW: 2,
    periodTableBlock: "d",
    discoveryDate: "1967",
    period: "7",
    group: "5",
    electronicConfiguration: "Rn 5f14 6d3 7s2",
    family: "Transition",
    symbol: "Db",
    name: "Dubnium",
    elementColor: [
      0.82,
      0,
      0.31
    ],
    discoveryCountry: [
      "ru",
      "us"
    ]
  },
  {
    id: "Sg",
    atomicNumber: 106,
    mass: 271,
    exactMass: 263.11832,
    nameOrigin: "Named after the scientist G. Theodore Seaborg.",
    radiusVDW: 2,
    periodTableBlock: "d",
    discoveryDate: "1974",
    period: "7",
    group: "6",
    family: "Transition",
    symbol: "Sg",
    name: "Seaborgium",
    elementColor: [
      0.85,
      0,
      0.27
    ],
    discoveryCountry: [
      "ru",
      "us"
    ],
    discoverers: [
      "Albert Ghiorso",
      "et al."
    ]
  },
  {
    id: "Bh",
    atomicNumber: 107,
    mass: 272,
    exactMass: 264.1246,
    nameOrigin: "Named after the scientist Niels Bohr.",
    radiusVDW: 2,
    periodTableBlock: "d",
    discoveryDate: "1981",
    period: "7",
    group: "7",
    family: "Transition",
    symbol: "Bh",
    name: "Bohrium",
    elementColor: [
      0.88,
      0,
      0.22
    ],
    discoveryCountry: [
      "ru"
    ],
    discoverers: [
      "Peter Armbruster",
      "Gottfried Mnzenber",
      "et al."
    ]
  },
  {
    id: "Hs",
    atomicNumber: 108,
    mass: 270,
    exactMass: 265.13009,
    nameOrigin: "Latin 'hassia' for the German county Hessen. In Hessen a lot elements have been discovered.",
    radiusVDW: 2,
    periodTableBlock: "d",
    discoveryDate: "1984",
    period: "7",
    group: "8",
    family: "Transition",
    symbol: "Hs",
    name: "Hassium",
    elementColor: [
      0.9,
      0,
      0.18
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Peter Armbruster",
      "Gottfried Mnzenber",
      "et al."
    ]
  },
  {
    id: "Mt",
    atomicNumber: 109,
    mass: 276,
    exactMass: 268.13873,
    nameOrigin: "Named after the scientist Lise Meitner.",
    radiusVDW: 2,
    periodTableBlock: "d",
    discoveryDate: "1982",
    period: "7",
    group: "8",
    family: "Transition",
    symbol: "Mt",
    name: "Meitnerium",
    elementColor: [
      0.91,
      0,
      0.15
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "Peter Armbruster",
      "Gottfried Mnzenber",
      "et al."
    ]
  },
  {
    id: "Ds",
    atomicNumber: 110,
    mass: 281,
    exactMass: 271.14606,
    nameOrigin: "Named after the German city Darmstadt where many elements have been discovered.",
    periodTableBlock: "d",
    discoveryDate: "1994",
    period: "7",
    group: "8",
    family: "Transition",
    symbol: "Ds",
    name: "Darmstadtium",
    elementColor: [
      0.92,
      0,
      0.14
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "S. Hofmann",
      "V. Ninov",
      "F. P. Hessberger",
      "P. Armbruster",
      "H. Folger",
      "G. Mnzenberg",
      "H. J. Schtt",
      "et al."
    ]
  },
  {
    id: "Rg",
    atomicNumber: 111,
    mass: 280,
    exactMass: 272.15362,
    nameOrigin: "Named after Wilhelm Conrad Rntgen.",
    periodTableBlock: "d",
    discoveryDate: "1994",
    period: "7",
    group: "1",
    family: "Transition",
    symbol: "Rg",
    name: "Roentgenium",
    elementColor: [
      0.93,
      0,
      0.13
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "S. Hofmann",
      "V. Ninov",
      "F. P. Hessberger",
      "P. Armbruster",
      "H. Folger",
      "G. Mnzenberg",
      "et al."
    ]
  },
  {
    id: "Cn",
    atomicNumber: 112,
    mass: 285,
    exactMass: 285.17411,
    nameOrigin: "Historically known as eka-mercury. Ununbium is a temporary IUPAC systematic element name.",
    periodTableBlock: "d",
    discoveryDate: "1996",
    period: "7",
    family: "Transition",
    symbol: "Cn",
    name: "Copernicium",
    elementColor: [
      0.94,
      0,
      0.12
    ],
    discoveryCountry: [
      "de"
    ],
    discoverers: [
      "First",
      "created",
      "at",
      "the",
      "Gesellschaft",
      "fr",
      "Schwerionenforschung"
    ]
  },
  {
    id: "Uut",
    atomicNumber: 113,
    mass: 284,
    exactMass: 284.17808,
    nameOrigin: "Historically known as eka-thallium. Ununtrium is a temporary IUPAC systematic element name.",
    periodTableBlock: "p",
    discoveryDate: "2003",
    period: "7",
    family: "Other_Metal",
    symbol: "Uut",
    name: "Ununtrium",
    elementColor: [
      0.95,
      0,
      0.11
    ],
    discoveryCountry: [
      "ru",
      "us"
    ],
    discoverers: [
      "Russian scientists at Dubna (JINR)",
      "American scientists at the Lawrence Livermore National Laboratory."
    ]
  },
  {
    id: "Uuq",
    atomicNumber: 114,
    mass: 289,
    exactMass: 289.18728,
    nameOrigin: "Historically known as eka-lead. Ununquadium is a temporary IUPAC systematic element name.",
    periodTableBlock: "p",
    discoveryDate: "1998",
    period: "7",
    family: "Other_Metal",
    symbol: "Uuq",
    name: "Ununquadium",
    elementColor: [
      0.96,
      0,
      0.1
    ],
    discoveryCountry: [
      "ru",
      "us"
    ],
    discoverers: [
      "Joint",
      "Institute",
      "for",
      "Nuclear",
      "Research"
    ]
  },
  {
    id: "Uup",
    atomicNumber: 115,
    mass: 288,
    exactMass: 288.19249,
    nameOrigin: "Historically known as eka-bismuth. Ununpentium is a temporary IUPAC systematic element name.",
    periodTableBlock: "p",
    discoveryDate: "2004",
    period: "7",
    family: "Other_Metal",
    symbol: "Uup",
    name: "Ununpentium",
    elementColor: [
      0.97,
      0,
      0.09
    ],
    discoveryCountry: [
      "ru",
      "us"
    ],
    discoverers: [
      "Russian scientists at Dubna (JINR)",
      "American scientists at the Lawrence Livermore National Laboratory."
    ]
  },
  {
    id: "Uuh",
    atomicNumber: 116,
    mass: 293,
    exactMass: 292.19979,
    nameOrigin: "Historically known as eka-polonium. Ununhexium is a temporary IUPAC systematic element name.",
    periodTableBlock: "p",
    discoveryDate: "2000",
    period: "7",
    family: "Other_Metal",
    symbol: "Uuh",
    name: "Ununhexium",
    elementColor: [
      0.98,
      0,
      0.08
    ],
    discoveryCountry: [
      "ru"
    ],
    discoverers: [
      "Joint",
      "Institute",
      "for",
      "Nuclear",
      "Research"
    ]
  },
  {
    id: "Uus",
    atomicNumber: 117,
    nameOrigin: "Temporary symbol and name. Can also be referred to as eka-astatine.",
    periodTableBlock: "p",
    discoveryDate: "0",
    period: "7",
    family: "Halogen",
    symbol: "Uus",
    name: "Ununseptium",
    elementColor: [
      0.99,
      0,
      0.07
    ]
  },
  {
    id: "Uuo",
    atomicNumber: 118,
    mass: 294,
    nameOrigin: "Historically known as eka-radon, eka-emanation before 1960. Ununoctium is a temporary IUPAC systematic element name.",
    periodTableBlock: "p",
    discoveryDate: "2002",
    period: "7",
    family: "Noblegas",
    symbol: "Uuo",
    name: "Ununoctium",
    elementColor: [
      1,
      0,
      0.06
    ],
    discoveryCountry: [
      "ru",
      "us"
    ],
    discoverers: [
      "Russian scientists at Dubna (JINR)",
      "American scientists at the Lawrence Livermore National Laboratory."
    ]
  }
];
var atomElem = {
  atoms
};

// node_modules/@kitware/vtk.js/Filters/General/MoleculeToRepresentation.js
var {
  vtkErrorMacro: vtkErrorMacro23,
  vtkDebugMacro: vtkDebugMacro3
} = macro;
var ATOMS = {};
atomElem.atoms.forEach((a2) => {
  ATOMS[a2.atomicNumber] = a2;
});
function vtkMoleculeToRepresentation(publicAPI, model) {
  const bondPositionData = [];
  const bondScaleData = [];
  const bondOrientationData = [];
  const bondColorData = [];
  model.classHierarchy.push("vtkMoleculeToRepresentation");
  function addBond(position, orientation3, length) {
    let color4 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [1, 1, 1];
    let radius = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : model.bondRadius;
    bondScaleData.push(length);
    bondScaleData.push(radius);
    bondOrientationData.push(orientation3[0]);
    bondOrientationData.push(orientation3[1]);
    bondOrientationData.push(orientation3[2]);
    bondPositionData.push(position[0]);
    bondPositionData.push(position[1]);
    bondPositionData.push(position[2]);
    for (let i = 0; i < color4.length; ++i) {
      bondColorData.push(color4[i] * 255);
    }
  }
  publicAPI.requestData = (inData, outData) => {
    var _a, _b;
    const moleculedata = inData[0];
    if (!moleculedata) {
      vtkErrorMacro23("Invalid or missing input");
      return 1;
    }
    const SphereData = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    const StickData = ((_b = outData[1]) == null ? void 0 : _b.initialize()) || vtkPolyData$1.newInstance();
    let numPts = 0;
    let numBonds = 0;
    let pointsArray = null;
    let atomicNumber = null;
    let bondIndex = null;
    let bondOrder = null;
    bondPositionData.length = 0;
    bondScaleData.length = 0;
    bondOrientationData.length = 0;
    bondColorData.length = 0;
    if (moleculedata.getAtoms()) {
      if (moleculedata.getAtoms().coords !== void 0) {
        if (moleculedata.getAtoms().coords["3d"] !== void 0) {
          pointsArray = moleculedata.getAtoms().coords["3d"];
          numPts = pointsArray.length / 3;
        }
      }
      if (moleculedata.getAtoms().elements !== void 0) {
        if (moleculedata.getAtoms().elements.number !== void 0) {
          atomicNumber = moleculedata.getAtoms().elements.number;
        }
      }
    }
    if (moleculedata.getBonds()) {
      if (moleculedata.getBonds().connections !== void 0) {
        if (moleculedata.getBonds().connections.index !== void 0) {
          bondIndex = moleculedata.getBonds().connections.index;
          numBonds = bondIndex.length / 2;
        }
      }
      if (moleculedata.getBonds().order !== void 0) {
        bondOrder = moleculedata.getBonds().order;
      }
    }
    const pointsData = [];
    const scaleData = [];
    const colorData = [];
    const radiusArray = [];
    const covalentArray = [];
    const colorArray = [];
    vtkDebugMacro3("Checking for bonds with tolerance ", model.tolerance);
    let ptsIdx = 0;
    for (let i = 0; i < numPts; i++) {
      if (atomicNumber) {
        radiusArray.push(ATOMS[atomicNumber[i]][model.radiusType]);
        covalentArray.push(ATOMS[atomicNumber[i]].radiusCovalent);
        colorArray.push(ATOMS[atomicNumber[i]].elementColor[0]);
        colorArray.push(ATOMS[atomicNumber[i]].elementColor[1]);
        colorArray.push(ATOMS[atomicNumber[i]].elementColor[2]);
      }
      if (model.hideElements.indexOf(ATOMS[atomicNumber[i]].id) !== -1) {
        continue;
      }
      ptsIdx = i * 3;
      pointsData.push(pointsArray[ptsIdx]);
      pointsData.push(pointsArray[ptsIdx + 1]);
      pointsData.push(pointsArray[ptsIdx + 2]);
      if (radiusArray.length > 0) {
        scaleData.push(radiusArray[i] * model.atomicRadiusScaleFactor);
      }
      if (colorArray.length > 0) {
        ptsIdx = i * 3;
        colorData.push(colorArray[ptsIdx] * 255);
        colorData.push(colorArray[ptsIdx + 1] * 255);
        colorData.push(colorArray[ptsIdx + 2] * 255);
      }
    }
    if (!bondIndex) {
      bondIndex = [];
      bondOrder = [];
      for (let i = 0; i < numPts; i++) {
        for (let j = i + 1; j < numPts; j++) {
          const cutoff = covalentArray[i] + covalentArray[j] + model.tolerance;
          const jPtsIdx = j * 3;
          const iPtsIdx = i * 3;
          const diff = [pointsArray[jPtsIdx], pointsArray[jPtsIdx + 1], pointsArray[jPtsIdx + 2]];
          diff[0] -= pointsArray[iPtsIdx];
          diff[1] -= pointsArray[iPtsIdx + 1];
          diff[2] -= pointsArray[iPtsIdx + 2];
          if (Math.abs(diff[0]) > cutoff || Math.abs(diff[1]) > cutoff || Math.abs(diff[2]) > cutoff) {
            continue;
          }
          const cutoffSq = cutoff * cutoff;
          const diffsq = diff[0] * diff[0] + diff[1] * diff[1] + diff[2] * diff[2];
          if (diffsq < cutoffSq && diffsq > 0.1) {
            bondIndex.push(i);
            bondIndex.push(j);
            bondOrder.push(1);
          }
        }
      }
      numBonds = bondIndex.length / 2;
    }
    for (let index = 0; index < numBonds; index++) {
      const i = bondIndex[index * 2];
      const j = bondIndex[index * 2 + 1];
      if (model.hideElements.indexOf(ATOMS[atomicNumber[i]].id) !== -1 || model.hideElements.indexOf(ATOMS[atomicNumber[j]].id) !== -1) {
        continue;
      }
      const jPtsIdx = j * 3;
      const iPtsIdx = i * 3;
      const diff = [pointsArray[jPtsIdx], pointsArray[jPtsIdx + 1], pointsArray[jPtsIdx + 2]];
      diff[0] -= pointsArray[iPtsIdx];
      diff[1] -= pointsArray[iPtsIdx + 1];
      diff[2] -= pointsArray[iPtsIdx + 2];
      const diffsq = diff[0] * diff[0] + diff[1] * diff[1] + diff[2] * diff[2];
      let bondDelta = (2 + model.deltaBondFactor) * model.bondRadius;
      const r = Math.min(radiusArray[i] * model.atomicRadiusScaleFactor, radiusArray[j] * model.atomicRadiusScaleFactor);
      const t = (bondOrder[index] - 1) * bondDelta + 2 * model.bondRadius;
      if (t > 2 * r * 0.6) {
        model.bondRadius *= 2 * r * 0.6 / t;
        bondDelta = (2 + model.deltaBondFactor) * model.bondRadius;
      }
      const oddOrEven = bondOrder[index] % 2;
      for (let k = oddOrEven; k < bondOrder[index] + oddOrEven; k++) {
        let offset = (Math.floor(k / 2) * 2 + 1 - oddOrEven) * bondDelta / 2;
        const vectUnitJI = [diff[0] / Math.sqrt(diffsq), diff[1] / Math.sqrt(diffsq), diff[2] / Math.sqrt(diffsq)];
        const vectUnitJIperp = [0, 0, 0];
        for (let coord = 0; coord < 3; coord++) {
          if (Math.abs(vectUnitJI[coord]) < 1e-6) {
            continue;
          }
          vectUnitJIperp[coord] = -(vectUnitJI[(coord + 2) % 3] * vectUnitJI[(coord + 2) % 3] + vectUnitJI[(coord + 1) % 3] * vectUnitJI[(coord + 1) % 3]) / vectUnitJI[coord];
          vectUnitJIperp[(coord + 1) % 3] = vectUnitJI[(coord + 1) % 3];
          vectUnitJIperp[(coord + 2) % 3] = vectUnitJI[(coord + 2) % 3];
          normalize(vectUnitJIperp);
          break;
        }
        offset *= (-1) ** (k % 2);
        let bondPos;
        if (atomicNumber && atomicNumber[i] !== atomicNumber[j] && colorArray.length > 0) {
          const bondLength = Math.sqrt(diffsq) / 2;
          bondPos = [pointsArray[jPtsIdx] - bondLength * vectUnitJI[0] / 2 + offset * vectUnitJIperp[0], pointsArray[jPtsIdx + 1] - bondLength * vectUnitJI[1] / 2 + offset * vectUnitJIperp[1], pointsArray[jPtsIdx + 2] - bondLength * vectUnitJI[2] / 2 + offset * vectUnitJIperp[2]];
          addBond(bondPos, vectUnitJI, bondLength, colorArray.slice(jPtsIdx, jPtsIdx + 3));
          bondPos = [pointsArray[iPtsIdx] + bondLength * vectUnitJI[0] / 2 + offset * vectUnitJIperp[0], pointsArray[iPtsIdx + 1] + bondLength * vectUnitJI[1] / 2 + offset * vectUnitJIperp[1], pointsArray[iPtsIdx + 2] + bondLength * vectUnitJI[2] / 2 + offset * vectUnitJIperp[2]];
          addBond(bondPos, vectUnitJI, bondLength, colorArray.slice(iPtsIdx, iPtsIdx + 3));
        } else {
          const bondLength = Math.sqrt(diffsq);
          bondPos = [pointsArray[jPtsIdx] - diff[0] / 2 + offset * vectUnitJIperp[0], pointsArray[jPtsIdx + 1] - diff[1] / 2 + offset * vectUnitJIperp[1], pointsArray[jPtsIdx + 2] - diff[2] / 2 + offset * vectUnitJIperp[2]];
          if (colorArray.length > 0) {
            addBond(bondPos, vectUnitJI, bondLength, colorArray.slice(iPtsIdx, iPtsIdx + 3));
          } else {
            addBond(bondPos, vectUnitJI, bondLength);
          }
        }
      }
    }
    SphereData.getPoints().setData(pointsData, 3);
    if (radiusArray) {
      const scales = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: scaleData,
        name: publicAPI.getSphereScaleArrayName()
      });
      SphereData.getPointData().addArray(scales);
    }
    if (colorArray.length > 0) {
      const colors = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: Uint8Array.from(colorData),
        name: "colors"
      });
      SphereData.getPointData().setScalars(colors);
    }
    StickData.getPoints().setData(bondPositionData, 3);
    const stickScales = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: bondScaleData,
      name: "stickScales"
    });
    StickData.getPointData().addArray(stickScales);
    const orientation3 = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: bondOrientationData,
      name: "orientation"
    });
    StickData.getPointData().addArray(orientation3);
    if (colorArray.length > 0) {
      const bondColors = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: Uint8Array.from(bondColorData),
        name: "colors"
      });
      StickData.getPointData().setScalars(bondColors);
    }
    outData[0] = SphereData;
    outData[1] = StickData;
    return 1;
  };
}
var DEFAULT_VALUES30 = {
  sphereScaleArrayName: "radius",
  tolerance: 0.45,
  atomicRadiusScaleFactor: 0.3,
  bondRadius: 0.075,
  deltaBondFactor: 0.6,
  radiusType: "radiusVDW",
  hideElements: ""
};
function extend36(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES30, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["atomicRadiusScaleFactor", "bondRadius", "deltaBondFactor", "hideElements", "radiusType", "sphereScaleArrayName", "tolerance"]);
  macro.algo(publicAPI, model, 1, 2);
  vtkMoleculeToRepresentation(publicAPI, model);
}
var newInstance36 = macro.newInstance(extend36, "vtkMoleculeToRepresentation");
var vtkMoleculeToRepresentation$1 = {
  newInstance: newInstance36,
  extend: extend36
};

// node_modules/@kitware/vtk.js/Filters/General/OBBTree/OBBNode.js
function vtkOBBNode(publicAPI, model) {
  model.classHierarchy.push("vtkOBBNode");
  publicAPI.deepCopy = (nodeSource) => {
    publicAPI.setCorner(nodeSource.getCorner());
    const axes = nodeSource.getAxes();
    publicAPI.setAxes([[...axes[0]], [...axes[1]], [...axes[2]]]);
    publicAPI.setCells([...nodeSource.getCells()]);
    if (nodeSource.getKids()) {
      const kids0 = vtkOBBNode.newInstance();
      kids0.setParent(publicAPI);
      const kids1 = vtkOBBNode.newInstance();
      kids1.setParent(publicAPI);
      kids0.deepCopy(nodeSource.getKids()[0]);
      kids1.deepCopy(nodeSource.getKids()[1], kids1);
      publicAPI.setKids(kids0, kids1);
    }
  };
  publicAPI.getAxis = (axis) => model.axes[axis];
}
function defaultValues7(initialValues) {
  return {
    corner: [0, 0, 0],
    // center point of this node
    axes: [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
    // the axes defining the OBB - ordered from long->short
    cells: [],
    // list of cells in node
    // parent: null, null if root
    // kids: null, two children of this node; null if leaf
    ...initialValues
  };
}
function extend37(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues7(initialValues));
  model.corner = [0, 0, 0];
  model.axes = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  model.parent = null;
  model.kids = null;
  model.cells = [];
  macro.setGet(publicAPI, model, ["parent", "cells", "kids"]);
  macro.setGetArray(publicAPI, model, ["corner", "axes"], 3);
  macro.obj(publicAPI, model);
  vtkOBBNode(publicAPI, model);
}
var newInstance37 = macro.newInstance(extend37, "vtkOBBNode");
var vtkOBBNode$1 = {
  newInstance: newInstance37,
  extend: extend37
};

// node_modules/@kitware/vtk.js/IO/Misc/OBJReader.js
var data = {};
function copyVector(src, srcOffset, dst, dstOffset, vectorSize) {
  for (let i = 0; i < vectorSize; i++) {
    dst[dstOffset + i] = src[srcOffset + i];
  }
}
function begin(splitMode) {
  data.splitOn = splitMode;
  data.pieces = [];
  data.v = [];
  data.vt = [];
  data.vn = [];
  data.f = [[]];
  data.size = 0;
}
function faceMap(str) {
  const idxs = str.split("/").map((i) => Number(i));
  let vertexIdx = idxs[0] - 1;
  vertexIdx = vertexIdx < 0 ? vertexIdx + 1 + data.v.length / 3 : vertexIdx;
  let textCoordIdx = idxs[1] ? idxs[1] - 1 : vertexIdx;
  textCoordIdx = textCoordIdx < 0 ? textCoordIdx + 1 + data.vt.length / 2 : textCoordIdx;
  let vertexNormal = idxs[2] ? idxs[2] - 1 : vertexIdx;
  vertexNormal = vertexNormal < 0 ? vertexNormal + 1 + data.vn.length / 3 : vertexNormal;
  return [vertexIdx, textCoordIdx, vertexNormal];
}
function parseLine(line) {
  if (line[0] === "#") {
    return;
  }
  const tokens = line.split(/[ \t]+/);
  if (tokens[0] === data.splitOn) {
    tokens.shift();
    data.pieces.push(tokens.join(" ").trim());
    data.f.push([]);
    data.size++;
  } else if (tokens[0] === "v") {
    data.v.push(Number(tokens[1]));
    data.v.push(Number(tokens[2]));
    data.v.push(Number(tokens[3]));
  } else if (tokens[0] === "vt") {
    data.vt.push(Number(tokens[1]));
    data.vt.push(Number(tokens[2]));
  } else if (tokens[0] === "vn") {
    data.vn.push(Number(tokens[1]));
    data.vn.push(Number(tokens[2]));
    data.vn.push(Number(tokens[3]));
  } else if (tokens[0] === "f") {
    if (data.size === 0) {
      data.size++;
    }
    const cells = data.f[data.size - 1];
    tokens.shift();
    const faces = tokens.filter((s) => s.length > 0 && s !== "\r");
    const size = faces.length;
    cells.push(size);
    for (let i = 0; i < size; i++) {
      cells.push(faceMap(faces[i]));
    }
  }
}
function end(model) {
  const hasTcoords = !!data.vt.length;
  const hasNormals = !!data.vn.length;
  if (model.splitMode) {
    model.numberOfOutputs = data.size;
    for (let idx = 0; idx < data.size; idx++) {
      const polyIn = data.f[idx];
      const nbElems = polyIn.length;
      const nbPoints = data.v.length / 3;
      const keyPointId = {};
      let pointDuplicatesReferences;
      if (model.trackDuplicates) {
        const pointKeys = [];
        let duplicatesCount = 0;
        for (let offset2 = 0; offset2 < nbElems; ) {
          const cellSize = polyIn[offset2++];
          for (let pIdx = 0; pIdx < cellSize; pIdx++) {
            const [vIdx, tcIdx, nIdx] = polyIn[offset2++];
            const key = `${vIdx}/${tcIdx}/${nIdx}`;
            if (keyPointId[key] === void 0) {
              if (pointKeys[vIdx] === void 0) {
                pointKeys[vIdx] = [key];
              } else {
                pointKeys[vIdx].push(key);
                ++duplicatesCount;
              }
              keyPointId[key] = vIdx;
            }
          }
        }
        pointDuplicatesReferences = new Uint16Array(nbPoints + duplicatesCount);
        let duplicates = 0;
        for (let pointId = 0; pointId < pointKeys.length; ++pointId) {
          const usageCount = pointKeys[pointId] ? pointKeys[pointId].length : 0;
          pointDuplicatesReferences[pointId] = usageCount > 1 ? nbPoints + duplicates : pointId;
          for (let duplicateId = 1; duplicateId < usageCount; ++duplicateId) {
            const finalDuplicateId = nbPoints + duplicates++;
            pointDuplicatesReferences[finalDuplicateId] = pointId;
            keyPointId[pointKeys[pointId][duplicateId]] = finalDuplicateId;
          }
        }
      }
      const ctMapping = {};
      const polydata = vtkPolyData$1.newInstance({
        name: data.pieces[idx]
      });
      const pts = [];
      const tc = [];
      const normals = [];
      const polys = [];
      let offset = 0;
      while (offset < nbElems) {
        const cellSize = polyIn[offset];
        polys.push(cellSize);
        for (let pIdx = 0; pIdx < cellSize; pIdx++) {
          const [vIdx, tcIdx, nIdx] = polyIn[offset + pIdx + 1];
          const key = `${vIdx}/${tcIdx}/${nIdx}`;
          if (ctMapping[key] === void 0) {
            const dstOffset = model.trackDuplicates ? keyPointId[key] : pts.length / 3;
            ctMapping[key] = dstOffset;
            copyVector(data.v, vIdx * 3, pts, dstOffset * 3, 3);
            if (hasTcoords) {
              copyVector(data.vt, tcIdx * 2, tc, dstOffset * 2, 2);
            }
            if (hasNormals) {
              copyVector(data.vn, nIdx * 3, normals, dstOffset * 3, 3);
            }
          }
          polys.push(ctMapping[key]);
        }
        offset += cellSize + 1;
      }
      polydata.getPoints().setData(Float32Array.from(pts), 3);
      if (model.trackDuplicates) {
        const duplicatesArray = vtkDataArray$1.newInstance({
          name: "Duplicates",
          values: pointDuplicatesReferences
        });
        polydata.getPointData().addArray(duplicatesArray);
      }
      polydata.getPolys().setData(Uint32Array.from(polys));
      if (hasTcoords) {
        const tcoords = vtkDataArray$1.newInstance({
          numberOfComponents: 2,
          values: Float32Array.from(tc),
          name: "TextureCoordinates"
        });
        polydata.getPointData().setTCoords(tcoords);
      }
      if (hasNormals) {
        const normalsArray = vtkDataArray$1.newInstance({
          numberOfComponents: 3,
          values: Float32Array.from(normals),
          name: "Normals"
        });
        polydata.getPointData().setNormals(normalsArray);
      }
      model.output[idx] = polydata;
    }
  } else {
    model.numberOfOutputs = 1;
    const polydata = vtkPolyData$1.newInstance();
    polydata.getPoints().setData(Float32Array.from(data.v), 3);
    if (hasTcoords && data.v.length / 3 === data.vt.length / 2) {
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: Float32Array.from(data.vt),
        name: "TextureCoordinates"
      });
      polydata.getPointData().setTCoords(tcoords);
    }
    if (hasNormals && data.v.length === data.vn.length) {
      const normalsArray = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: Float32Array.from(data.vn),
        name: "Normals"
      });
      polydata.getPointData().setNormals(normalsArray);
    }
    const polys = [];
    const polyIn = data.f[0];
    const nbElems = polyIn.length;
    let offset = 0;
    while (offset < nbElems) {
      const cellSize = polyIn[offset];
      polys.push(cellSize);
      for (let pIdx = 0; pIdx < cellSize; pIdx++) {
        const [vIdx] = polyIn[offset + pIdx + 1];
        polys.push(vIdx);
      }
      offset += cellSize + 1;
    }
    polydata.getPolys().setData(Uint32Array.from(polys));
    model.output[0] = polydata;
  }
}
function getPointDuplicateIds(polyData, pointId) {
  const res = [];
  const duplicates = polyData.getPointData().getArrayByName("Duplicates");
  if (duplicates == null) {
    return res;
  }
  const duplicatesData = duplicates.getData();
  const originalPointId = Math.min(pointId, duplicatesData[pointId]);
  res.push(originalPointId);
  let duplicateId = duplicatesData[originalPointId];
  if (duplicateId !== originalPointId) {
    while (duplicateId < duplicatesData.length && duplicatesData[duplicateId] === originalPointId) {
      res.push(duplicateId++);
    }
  }
  return res;
}
var STATIC6 = {
  getPointDuplicateIds
};
function vtkOBJReader(publicAPI, model) {
  model.classHierarchy.push("vtkOBJReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return model.dataAccessHelper.fetchText(publicAPI, url, option);
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (url.indexOf(".obj") === -1 && !option.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.obj`;
    } else {
      model.url = url;
      const path = url.split("/");
      path.pop();
      model.baseURL = path.join("/");
    }
    return publicAPI.loadData(option);
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return fetchData(model.url, option).then((content) => publicAPI.isDeleted() ? false : publicAPI.parseAsText(content));
  };
  publicAPI.parseAsText = (content) => {
    if (!content) {
      return true;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    }
    model.parseData = content;
    model.numberOfOutputs = 0;
    begin(model.splitMode);
    content.split("\n").forEach(parseLine);
    end(model);
    return true;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsText(model.parseData);
  };
  publicAPI.isBusy = () => !!model.requestCount;
  publicAPI.getNumberOfOutputPorts = () => model.numberOfOutputs;
}
var DEFAULT_VALUES31 = {
  numberOfOutputs: 1,
  requestCount: 0,
  splitMode: null,
  trackDuplicates: false
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend38(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES31, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper", "splitMode", "trackDuplicates"]);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, "busy");
  vtkOBJReader(publicAPI, model);
}
var newInstance38 = macro.newInstance(extend38, "vtkOBJReader");
var vtkOBJReader$1 = {
  newInstance: newInstance38,
  extend: extend38,
  ...STATIC6
};

// node_modules/@kitware/vtk.js/Filters/General/OBBTree/helper.js
function getCellTriangles(cellPtsIds, type, idx) {
  let ptId0 = -1;
  let ptId1 = -1;
  let ptId2 = -1;
  const cellListLength = cellPtsIds.length;
  switch (type) {
    case CellType.VTK_TRIANGLE:
    case CellType.VTK_POLYGON:
    case CellType.VTK_QUAD: {
      if (idx > cellListLength) break;
      ptId0 = cellPtsIds[0];
      ptId1 = cellPtsIds[idx + 1];
      ptId2 = cellPtsIds[idx + 2];
      break;
    }
    case CellType.VTK_TRIANGLE_STRIP: {
      const idx1 = idx + 1 + (idx & 1);
      const idx2 = idx + 2 - (idx & 1);
      if (idx1 > cellListLength || idx2 > cellListLength) break;
      ptId0 = cellPtsIds[idx];
      ptId1 = cellPtsIds[idx1];
      ptId2 = cellPtsIds[idx2];
      break;
    }
    default:
      ptId0 = -1;
      ptId1 = -1;
      ptId2 = -1;
      break;
  }
  return {
    ptId0,
    ptId1,
    ptId2
  };
}
function pushArray(first, second) {
  const firstLength = first.length;
  const result = new first.constructor(firstLength + second.length);
  result.set(first);
  result.set(second, firstLength);
  return result;
}

// node_modules/@kitware/vtk.js/Filters/General/OBBTree.js
var {
  vtkErrorMacro: vtkErrorMacro24
} = macro;
var VTK_DOUBLE_MAX = Number.MAX_SAFE_INTEGER;
function vtkOBBTree(publicAPI, model) {
  model.classHierarchy.push("vtkOBBTree");
  function computeOBB(cells, corner2, max2, mid, min, size) {
    model.OBBCount++;
    model.pointsList = [];
    const numCells = cells.length;
    const mean3 = [0, 0, 0];
    let totMass = 0;
    const a0 = [0, 0, 0];
    const a1 = [0, 0, 0];
    const a2 = [0, 0, 0];
    let a3 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    const dp0 = [0, 0, 0];
    const dp1 = [0, 0, 0];
    const c2 = [0, 0, 0];
    let triMass = 0;
    if (!model.dataset.getCells()) {
      model.dataset.buildCells();
    }
    for (let i = 0; i < numCells; i++) {
      const cellId = cells[i];
      const type = model.dataset.getCells().getCellType(cellId);
      const ptIds = model.dataset.getCellPoints(cellId).cellPointIds;
      const numPts2 = ptIds.length;
      for (let j = 0; j < numPts2 - 2; j++) {
        const cellsIds = getCellTriangles(ptIds, type, j);
        const pId = cellsIds.ptId0;
        const qId = cellsIds.ptId1;
        const rId = cellsIds.ptId2;
        if (pId < 0) {
          continue;
        }
        const p = [];
        const q = [];
        const r = [];
        model.dataset.getPoints().getPoint(pId, p);
        model.dataset.getPoints().getPoint(qId, q);
        model.dataset.getPoints().getPoint(rId, r);
        for (let k = 0; k < 3; k++) {
          dp0[k] = q[k] - p[k];
          dp1[k] = r[k] - p[k];
          c2[k] = (p[k] + q[k] + r[k]) / 3;
        }
        const xp = cross(dp0, dp1, []);
        triMass = 0.5 * norm(xp);
        totMass += triMass;
        for (let k = 0; k < 3; k++) {
          mean3[k] += triMass * c2[k];
        }
        a0[0] += triMass * (9 * c2[0] * c2[0] + p[0] * p[0] + q[0] * q[0] + r[0] * r[0]) / 12;
        a1[1] += triMass * (9 * c2[1] * c2[1] + p[1] * p[1] + q[1] * q[1] + r[1] * r[1]) / 12;
        a2[2] += triMass * (9 * c2[2] * c2[2] + p[2] * p[2] + q[2] * q[2] + r[2] * r[2]) / 12;
        a0[1] += triMass * (9 * c2[0] * c2[1] + p[0] * p[1] + q[0] * q[1] + r[0] * r[1]) / 12;
        a0[2] += triMass * (9 * c2[0] * c2[2] + p[0] * p[2] + q[0] * q[2] + r[0] * r[2]) / 12;
        a1[2] += triMass * (9 * c2[1] * c2[2] + p[1] * p[2] + q[1] * q[2] + r[1] * r[2]) / 12;
      }
      for (let j = 0; j < numPts2; j++) {
        if (model.insertedPoints[ptIds[j]] !== model.OBBCount) {
          model.insertedPoints[ptIds[j]] = model.OBBCount;
          const pt = [];
          model.dataset.getPoints().getPoint(ptIds[j], pt);
          model.pointsList.push(pt);
        }
      }
    }
    for (let i = 0; i < 3; i++) {
      mean3[i] /= totMass;
    }
    a1[0] = a0[1];
    a2[0] = a0[2];
    a2[1] = a1[2];
    a3 = [a0[0], a0[1], a0[2], a1[0], a1[1], a1[2], a2[0], a2[1], a2[2]];
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        a3[i * 3 + j] = a3[i * 3 + j] / totMass - mean3[i] * mean3[j];
      }
    }
    const v = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    jacobi(a3, size, v);
    max2[0] = v[0];
    max2[1] = v[3];
    max2[2] = v[6];
    mid[0] = v[1];
    mid[1] = v[4];
    mid[2] = v[7];
    min[0] = v[2];
    min[1] = v[5];
    min[2] = v[8];
    for (let i = 0; i < 3; i++) {
      a3[i] = mean3[i] + max2[i];
      a3[3 + i] = mean3[i] + mid[i];
      a3[6 + i] = mean3[i] + min[i];
    }
    const tMin = [VTK_DOUBLE_MAX, VTK_DOUBLE_MAX, VTK_DOUBLE_MAX];
    const tMax = [-VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX];
    const numPts = model.pointsList.length;
    for (let ptId = 0; ptId < numPts; ptId++) {
      const p = model.pointsList[ptId];
      for (let i = 0; i < 3; i++) {
        const out = vtkLine$1.distanceToLine(p, mean3, a3.slice(3 * i, 3 * (i + 1)), []);
        if (out.t < tMin[i]) {
          tMin[i] = out.t;
        }
        if (out.t > tMax[i]) {
          tMax[i] = out.t;
        }
      }
    }
    for (let i = 0; i < 3; i++) {
      corner2[i] = mean3[i] + tMin[0] * max2[i] + tMin[1] * mid[i] + tMin[2] * min[i];
      max2[i] *= tMax[0] - tMin[0];
      mid[i] *= tMax[1] - tMin[1];
      min[i] *= tMax[2] - tMin[2];
    }
  }
  function buildTree(cells, obbNode, level) {
    const numCells = cells.length;
    if (level > model.level) {
      model.level = level;
    }
    const axes = obbNode.getAxes();
    const corner2 = obbNode.getCorner();
    const size = [0, 0, 0];
    computeOBB(cells, corner2, axes[0], axes[1], axes[2], size);
    obbNode.setAxes(axes);
    obbNode.setCorner(corner2);
    if (level < model.maxLevel && numCells > model.numberOfCellsPerNode) {
      let LHlist = [];
      let RHlist = [];
      const p = [0, 0, 0];
      const n = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        p[i] = corner2[i] + axes[0][i] / 2 + axes[1][i] / 2 + axes[2][i] / 2;
      }
      let splitPlane = 0;
      let splitAcceptable = 0;
      let bestRatio = 1;
      let foundBestSplit = 0;
      let bestPlane = 0;
      for (; !splitAcceptable && splitPlane < 3; ) {
        for (let i = 0; i < 3; i++) {
          n[i] = axes[splitPlane][i];
        }
        normalize(n);
        for (let i = 0; i < numCells; i++) {
          const cellId = cells[i];
          const pointsIDs = model.dataset.getCellPoints(cellId).cellPointIds;
          const cellPts = [];
          pointsIDs.forEach((id) => {
            const pt = [];
            model.dataset.getPoints().getPoint(pointsIDs[id], pt);
            cellPts.push(pt);
          });
          const c2 = [0, 0, 0];
          const numPts = cellPts.length;
          let negative = 0;
          let positive = 0;
          for (let j = 0; j < numPts; j++) {
            const ptId = pointsIDs[j];
            const x = model.dataset.getPoints().getPoint(ptId);
            const val = n[0] * (x[0] - p[0]) + n[1] * (x[1] - p[1]) + n[2] * (x[2] - p[2]);
            c2[0] += x[0];
            c2[1] += x[1];
            c2[2] += x[2];
            if (val < 0) {
              negative = 1;
            } else {
              positive = 1;
            }
          }
          if (negative && positive) {
            c2[0] /= numPts;
            c2[1] /= numPts;
            c2[2] /= numPts;
            const val = n[0] * (c2[0] - p[0]) + n[1] * (c2[1] - p[1]) + n[2] * (c2[2] - p[2]);
            if (val < 0) {
              LHlist.push(cellId);
            } else {
              RHlist.push(cellId);
            }
          } else if (negative) {
            LHlist.push(cellId);
          } else {
            RHlist.push(cellId);
          }
        }
        const numInLHnode = LHlist.length;
        const numInRHnode = RHlist.length;
        const ratio = Math.abs((numInRHnode - numInLHnode) / numCells);
        if (ratio < 0.6 || foundBestSplit) {
          splitAcceptable = 1;
        } else {
          LHlist = [];
          RHlist = [];
          if (ratio < bestRatio) {
            bestRatio = ratio;
            bestPlane = splitPlane;
          }
          if (++splitPlane === 3 && bestRatio < 0.95) {
            splitPlane = bestPlane;
            foundBestSplit = 1;
          }
        }
      }
      if (splitAcceptable) {
        const LHnode = vtkOBBNode$1.newInstance();
        const RHnode = vtkOBBNode$1.newInstance();
        obbNode.setKids([LHnode, RHnode]);
        LHnode.setParent(obbNode);
        RHnode.setParent(obbNode);
        cells.length = 0;
        buildTree(LHlist, LHnode, level + 1);
        buildTree(RHlist, RHnode, level + 1);
      } else {
        LHlist = [];
        RHlist = [];
      }
    }
    if (cells && model.retainCellLists) {
      obbNode.setCells(cells);
    } else if (cells) {
      cells.length = 0;
    }
  }
  function generatePolygons(obbNode, level, repLevel, points, cells) {
    if (level === repLevel || repLevel < 0 && obbNode.getKids()) {
      let nbPoints = points.getNumberOfPoints();
      const newPoints = [];
      const newCells = [];
      const cubeIds = [];
      newPoints.push(...obbNode.getCorner());
      cubeIds[0] = nbPoints++;
      const x = [];
      newPoints.push(...add(obbNode.getCorner(), obbNode.getAxis(0), x));
      cubeIds[1] = nbPoints++;
      const y = [];
      newPoints.push(...add(obbNode.getCorner(), obbNode.getAxis(1), y));
      cubeIds[2] = nbPoints++;
      const xy = [];
      newPoints.push(...add(x, obbNode.getAxis(1), xy));
      cubeIds[3] = nbPoints++;
      const z = [];
      newPoints.push(...add(obbNode.getCorner(), obbNode.getAxis(2), z));
      cubeIds[4] = nbPoints++;
      const xz = [];
      newPoints.push(...add(x, obbNode.getAxis(2), xz));
      cubeIds[5] = nbPoints++;
      const yz = [];
      newPoints.push(...add(y, obbNode.getAxis(2), yz));
      cubeIds[6] = nbPoints++;
      const xyz = [];
      newPoints.push(...add(xy, obbNode.getAxis(2), xyz));
      cubeIds[7] = nbPoints++;
      newCells.push(4, cubeIds[0], cubeIds[2], cubeIds[3], cubeIds[1]);
      newCells.push(4, cubeIds[0], cubeIds[1], cubeIds[5], cubeIds[4]);
      newCells.push(4, cubeIds[0], cubeIds[4], cubeIds[6], cubeIds[2]);
      newCells.push(4, cubeIds[1], cubeIds[3], cubeIds[7], cubeIds[5]);
      newCells.push(4, cubeIds[4], cubeIds[5], cubeIds[7], cubeIds[6]);
      newCells.push(4, cubeIds[2], cubeIds[6], cubeIds[7], cubeIds[3]);
      points.setData(pushArray(points.getData(), newPoints));
      cells.setData(pushArray(cells.getData(), newCells));
    } else if ((level < repLevel || repLevel < 0) && obbNode.getKids()) {
      generatePolygons(obbNode.getKids()[0], level + 1, repLevel, points, cells);
      generatePolygons(obbNode.getKids()[1], level + 1, repLevel, points, cells);
    }
  }
  publicAPI.transform = (transform) => {
    const matrix = mat4_exports.create();
    mat4_exports.copy(matrix, transform.getMatrix());
    matrix[12] = 0;
    matrix[13] = 0;
    matrix[14] = 0;
    matrix[15] = 1;
    const transformVector = vtkMatrixBuilder.buildFromRadian().setMatrix(matrix);
    const obbStack = new Array(model.level + 1);
    obbStack[0] = model.tree;
    let depth = 1;
    while (depth > 0) {
      depth -= 1;
      const node = obbStack[depth];
      const corner2 = node.getCorner();
      const max2 = node.getAxis(0);
      const mid = node.getAxis(1);
      const min = node.getAxis(2);
      transform.apply(corner2);
      transformVector.apply(max2);
      transformVector.apply(mid);
      transformVector.apply(min);
      node.setCorner(corner2);
      node.setAxes([max2, mid, min]);
      if (node.getKids() !== null) {
        obbStack[depth] = node.getKids()[0];
        obbStack[depth + 1] = node.getKids()[1];
        depth += 2;
      }
    }
  };
  publicAPI.deepCopy = (tree) => {
    if (!tree) {
      return;
    }
    publicAPI.setLevel(tree.getLevel());
    publicAPI.setRetainCellLists(tree.getRetainCellLists());
    publicAPI.setDataset(tree.getDataset());
    publicAPI.setAutomatic(tree.getAutomatic());
    publicAPI.setNumberOfCellsPerNode(tree.getNumberOfCellsPerNode());
    publicAPI.setTolerance(tree.getTolerance());
    const root = tree.getTree();
    if (root) {
      model.tree = vtkOBBNode$1.newInstance();
      model.tree.deepCopy(root);
    }
  };
  publicAPI.computeOBBFromDataset = (input, corner2, max2, mid, min, size) => {
    if (!input) {
      return;
    }
    const numPts = input.getPoints().getNumberOfPoints();
    const numCells = input.getNumberOfCells();
    if (numPts < 1 || numCells < 1) {
      vtkErrorMacro24("Can't compute OBB - no data available!");
      return;
    }
    model.dataset = input;
    model.OBBCount = 0;
    model.insertedPoints = Array.from({
      length: numPts
    }, (_) => 0);
    model.pointsList = [];
    const cellList = Array.from({
      length: numCells
    }, (_, i) => i);
    computeOBB(cellList, corner2, max2, mid, min, size);
  };
  publicAPI.disjointOBBNodes = (nodeA, nodeB, XformBtoA) => {
    if (!nodeA || !nodeB) {
      return 5;
    }
    const input = new Array(4);
    const output = new Array(4);
    const eps = model.tolerance;
    const pA = nodeA;
    let pB = vtkOBBNode$1.newInstance();
    const dotAB = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    if (XformBtoA) {
      input[0] = nodeB.getCorner()[0];
      input[1] = nodeB.getCorner()[1];
      input[2] = nodeB.getCorner()[2];
      input[3] = 1;
      vec4_exports.transformMat4(output, input, XformBtoA);
      pB.setCorner([output[0] / output[3], output[1] / output[3], output[2] / output[3]]);
      for (let ii = 0; ii < 3; ii++) {
        pB.getAxis(0)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(0)[ii];
        pB.getAxis(1)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(1)[ii];
        pB.getAxis(2)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(2)[ii];
      }
      for (let ii = 0; ii < 3; ii++) {
        input[0] = pB.getAxis(ii)[0];
        input[1] = pB.getAxis(ii)[1];
        input[2] = pB.getAxis(ii)[2];
        input[3] = 1;
        vec4_exports.transformMat4(output, input, XformBtoA);
        pB.getAxis(ii)[0] = output[0] / output[3];
        pB.getAxis(ii)[1] = output[1] / output[3];
        pB.getAxis(ii)[2] = output[2] / output[3];
      }
      for (let ii = 0; ii < 3; ii++) {
        pB.getAxis(0)[ii] = pB.getAxis(0)[ii] - pB.getCorner()[ii];
        pB.getAxis(1)[ii] = pB.getAxis(1)[ii] - pB.getCorner()[ii];
        pB.getAxis(2)[ii] = pB.getAxis(2)[ii] - pB.getCorner()[ii];
      }
    } else {
      pB = nodeB;
    }
    const centerA = [0, 0, 0];
    const centerB = [0, 0, 0];
    const AtoB = [0, 0, 0];
    for (let ii = 0; ii < 3; ii++) {
      centerA[ii] = pA.getCorner()[ii] + 0.5 * (pA.getAxis(0)[ii] + pA.getAxis(1)[ii] + pA.getAxis(2)[ii]);
      centerB[ii] = pB.getCorner()[ii] + 0.5 * (pB.getAxis(0)[ii] + pB.getAxis(1)[ii] + pB.getAxis(2)[ii]);
      AtoB[ii] = centerB[ii] - centerA[ii];
    }
    let rangeAmin = dot(pA.getCorner(), AtoB);
    let rangeAmax = rangeAmin;
    let rangeBmin = dot(pB.getCorner(), AtoB);
    let rangeBmax = rangeBmin;
    let dotA = 0;
    let dotB = 0;
    for (let ii = 0; ii < 3; ii++) {
      dotA = dot(pA.getAxis(ii), AtoB);
      if (dotA > 0) {
        rangeAmax += dotA;
      } else {
        rangeAmin += dotA;
      }
      dotB = dot(pB.getAxis(ii), AtoB);
      if (dotB > 0) {
        rangeBmax += dotB;
      } else {
        rangeBmin += dotB;
      }
    }
    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
      return 1;
    }
    for (let ii = 0; ii < 3; ii++) {
      rangeBmin = dot(pB.getCorner(), pB.getAxis(ii));
      rangeBmax = rangeBmin;
      rangeBmax += dot(pB.getAxis(ii), pB.getAxis(ii));
      rangeAmin = dot(pA.getCorner(), pB.getAxis(ii));
      rangeAmax = rangeAmin;
      for (let jj = 0; jj < 3; jj++) {
        dotA = dot(pB.getAxis(ii), pA.getAxis(jj));
        dotAB[ii * 3 + jj] = dotA;
        if (dotA > 0) {
          rangeAmax += dotA;
        } else {
          rangeAmin += dotA;
        }
      }
      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
        return 2;
      }
    }
    for (let ii = 0; ii < 3; ii++) {
      rangeAmin = dot(pA.getCorner(), pA.getAxis(ii));
      rangeAmax = rangeAmin;
      rangeAmax += dot(pA.getAxis(ii), pA.getAxis(ii));
      rangeBmin = dot(pB.getCorner(), pA.getAxis(ii));
      rangeBmax = rangeBmin;
      for (let jj = 0; jj < 3; jj++) {
        dotB = dotAB[jj * 3 + ii];
        if (dotB > 0) {
          rangeBmax += dotB;
        } else {
          rangeBmin += dotB;
        }
      }
      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
        return 3;
      }
    }
    for (let ii = 0; ii < 3; ii++) {
      for (let jj = 0; jj < 3; jj++) {
        cross(pA.getAxis(ii), pB.getAxis(jj), AtoB);
        rangeAmin = dot(pA.getCorner(), AtoB);
        rangeAmax = rangeAmin;
        rangeBmin = dot(pB.getCorner(), AtoB);
        rangeBmax = rangeBmin;
        for (let kk = 0; kk < 3; kk++) {
          dotA = dot(pA.getAxis(kk), AtoB);
          if (dotA > 0) {
            rangeAmax += dotA;
          } else {
            rangeAmin += dotA;
          }
          dotB = dot(pB.getAxis(kk), AtoB);
          if (dotB > 0) {
            rangeBmax += dotB;
          } else {
            rangeBmin += dotB;
          }
        }
        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
          return 4;
        }
      }
    }
    return 0;
  };
  publicAPI.intersectWithOBBTree = function(obbTreeB, XformBtoA) {
    let onIntersect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => -1;
    let maxDepth = model.level;
    let minDepth = obbTreeB.getLevel();
    if (minDepth > maxDepth) {
      minDepth = maxDepth;
      maxDepth = obbTreeB.getLevel();
    }
    const maxStackDepth = 3 * minDepth + 2 * (maxDepth - minDepth) + 1;
    const OBBStackA = new Array(maxStackDepth);
    const OBBStackB = new Array(maxStackDepth);
    OBBStackA[0] = model.tree;
    OBBStackB[0] = obbTreeB.getTree();
    let depth = 1;
    let count = 0;
    let returnValue = 0;
    while (depth > 0 && returnValue > -1) {
      depth--;
      const nodeA = OBBStackA[depth];
      const nodeB = OBBStackB[depth];
      if (!publicAPI.disjointOBBNodes(nodeA, nodeB, XformBtoA)) {
        if (!nodeA.getKids()) {
          if (!nodeB.getKids()) {
            returnValue = onIntersect(nodeA, nodeB, XformBtoA);
            count += Math.abs(returnValue);
          } else {
            OBBStackA[depth] = nodeA;
            OBBStackB[depth] = nodeB.getKids()[0];
            OBBStackA[depth + 1] = nodeA;
            OBBStackB[depth + 1] = nodeB.getKids()[1];
            depth += 2;
          }
        } else if (!nodeB.getKids()) {
          OBBStackB[depth] = nodeB;
          OBBStackA[depth] = nodeA.getKids()[0];
          OBBStackB[depth + 1] = nodeB;
          OBBStackA[depth + 1] = nodeA.getKids()[1];
          depth += 2;
        } else {
          OBBStackA[depth] = nodeA.getKids()[0];
          OBBStackB[depth] = nodeB.getKids()[0];
          OBBStackA[depth + 1] = nodeA.getKids()[1];
          OBBStackB[depth + 1] = nodeB.getKids()[0];
          OBBStackA[depth + 2] = nodeA.getKids()[0];
          OBBStackB[depth + 2] = nodeB.getKids()[1];
          OBBStackA[depth + 3] = nodeA.getKids()[1];
          OBBStackB[depth + 3] = nodeB.getKids()[1];
          depth += 4;
        }
      }
    }
    return count;
  };
  publicAPI.triangleIntersectsNode = (nodeA, p0, p1, p2, XformBtoA) => {
    const eps = model.tolerance;
    const pA = nodeA;
    const pB = [[...p0], [...p1], [...p2]];
    if (XformBtoA) {
      const input = [0, 0, 0, 1];
      const output = [];
      for (let ii = 0; ii < 3; ii++) {
        input[0] = pB[ii][0];
        input[1] = pB[ii][1];
        input[2] = pB[ii][2];
        vec4_exports.transformMat4(output, input, XformBtoA);
        pB[ii][0] = output[0] / output[3];
        pB[ii][1] = output[1] / output[3];
        pB[ii][2] = output[2] / output[3];
      }
    }
    const v0 = [];
    const v1 = [];
    for (let ii = 0; ii < 3; ii++) {
      v0[ii] = pB[1][ii] - pB[0][ii];
      v1[ii] = pB[2][ii] - pB[0][ii];
    }
    const xprod = cross(v0, v1, []);
    let rangeBmax = dot(pB[0], xprod);
    let rangeBmin = rangeBmax;
    let rangeAmax = dot(pA.getCorner(), xprod);
    let rangeAmin = rangeAmax;
    let dotA;
    for (let jj = 0; jj < 3; jj++) {
      dotA = dot(xprod, pA.getAxis(jj));
      if (dotA > 0) {
        rangeAmax += dotA;
      } else {
        rangeAmin += dotA;
      }
    }
    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
      return 0;
    }
    for (let ii = 0; ii < 3; ii++) {
      rangeAmax = dot(pA.getCorner(), pA.getAxis(ii));
      rangeAmin = rangeAmax;
      rangeAmax += dot(pA.getAxis(ii), pA.getAxis(ii));
      rangeBmax = dot(pB[0], pA.getAxis(ii));
      rangeBmin = rangeBmax;
      let dotB2 = dot(pB[1], pA.getAxis(ii));
      if (dotB2 > rangeBmax) {
        rangeBmax = dotB2;
      } else {
        rangeBmin = dotB2;
      }
      dotB2 = dot(pB[2], pA.getAxis(ii));
      if (dotB2 > rangeBmax) {
        rangeBmax = dotB2;
      } else if (dotB2 < rangeBmin) {
        rangeBmin = dotB2;
      }
      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
        return 0;
      }
    }
    const AtoB = [];
    let dotB;
    for (let ii = 0; ii < 3; ii++) {
      for (let jj = 0; jj < 3; jj++) {
        v0[0] = pB[(jj + 1) % 3][0] - pB[jj][0];
        v0[1] = pB[(jj + 1) % 3][1] - pB[jj][1];
        v0[2] = pB[(jj + 1) % 3][2] - pB[jj][2];
        cross(pA.getAxis(ii), v0, AtoB);
        rangeAmax = dot(pA.getCorner(), AtoB);
        rangeAmin = rangeAmax;
        rangeBmax = dot(pB[jj], AtoB);
        rangeBmin = rangeBmax;
        for (let kk = 0; kk < 3; kk++) {
          dotA = dot(pA.getAxis(kk), AtoB);
          if (dotA > 0) {
            rangeAmax += dotA;
          } else {
            rangeAmin += dotA;
          }
        }
        dotB = dot(pB[(jj + 2) % 3], AtoB);
        if (dotB > rangeBmax) {
          rangeBmax = dotB;
        } else {
          rangeBmin = dotB;
        }
        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {
          return 0;
        }
      }
    }
    return 1;
  };
  publicAPI.findTriangleIntersections = (info, node0, node1, transform) => {
    const mesh0 = publicAPI.getDataset();
    const mesh1 = info.obbTree1.getDataset();
    const pointOffset = info.intersectionLines.getPoints().getNumberOfPoints();
    const intersectionPoints = [];
    const intersectionLines = [];
    const numCells0 = node0.getCells().length;
    for (let id0 = 0; id0 < numCells0; id0++) {
      const cellId0 = node0.getCells()[id0];
      const type0 = mesh0.getCellType(cellId0);
      if (type0 === CellType.VTK_TRIANGLE) {
        const {
          cellPointIds: triPtIds0
        } = mesh0.getCellPoints(cellId0);
        const triPts0 = [[], [], []];
        for (let id = 0; id < triPtIds0.length; id++) {
          mesh0.getPoints().getPoint(triPtIds0[id], triPts0[id]);
        }
        if (info.obbTree1.triangleIntersectsNode(node1, triPts0[0], triPts0[1], triPts0[2], transform)) {
          const numCells1 = node1.getCells().length;
          for (let id1 = 0; id1 < numCells1; id1++) {
            const cellId1 = node1.getCells()[id1];
            const type1 = mesh1.getCellType(cellId1);
            if (type1 === CellType.VTK_TRIANGLE) {
              const {
                cellPointIds: triPtIds1
              } = mesh1.getCellPoints(cellId1);
              const triPts1 = [[], [], []];
              for (let id = 0; id < triPtIds1.length; id++) {
                mesh1.getPoints().getPoint(triPtIds1[id], triPts1[id]);
              }
              const {
                intersect,
                coplanar,
                pt1: outpt0,
                pt2: outpt1
                // surfaceId,
              } = vtkTriangle$1.intersectWithTriangle(...triPts0, ...triPts1, model.tolerance);
              if (intersect && !coplanar) {
                const pointId = intersectionPoints.length / 3;
                intersectionPoints.push(...outpt0, ...outpt1);
                intersectionLines.push(2, pointOffset + pointId, pointOffset + pointId + 1);
              }
            }
          }
        }
      }
    }
    if (intersectionPoints.length) {
      const points = vtkPoints$1.newInstance();
      points.setData(pushArray(info.intersectionLines.getPoints().getData(), intersectionPoints));
      info.intersectionLines.setPoints(points);
      const lines = vtkCellArray$1.newInstance();
      lines.setData(pushArray(info.intersectionLines.getLines().getData(), intersectionLines));
      info.intersectionLines.setLines(lines);
    }
    return intersectionLines.length / 3;
  };
  publicAPI.generateRepresentation = (level) => {
    if (!model.tree) {
      vtkErrorMacro24("No tree to generate representation for");
      return null;
    }
    const points = vtkPoints$1.newInstance();
    const polys = vtkCellArray$1.newInstance();
    generatePolygons(model.tree, 0, level, points, polys);
    const output = vtkPolyData$1.newInstance();
    output.setPoints(points);
    output.setPolys(polys);
    return output;
  };
  publicAPI.buildLocator = () => {
    if (model.dataset === null) {
      vtkErrorMacro24("Can't build OBB tree - no data available!");
      return;
    }
    const numPts = model.dataset.getPoints().getNumberOfPoints();
    const numCells = model.dataset.getNumberOfCells();
    if (numPts < 1 || numCells < 1) {
      vtkErrorMacro24("Can't build OBB tree - no data available!");
      return;
    }
    model.OBBCount = 0;
    model.insertedPoints = Array.from({
      length: numPts
    }, (_) => 0);
    model.pointsList = [];
    const cellList = Array.from({
      length: numCells
    }, (_, i) => i);
    model.tree = vtkOBBNode$1.newInstance();
    model.level = 0;
    buildTree(cellList, model.tree, 0);
    model.insertedPoints = [];
    model.pointsList = [];
    publicAPI.modified();
  };
}
var DEFAULT_VALUES32 = {
  tolerance: 0.01,
  automatic: true,
  numberOfCellsPerNode: 32,
  dataset: null,
  tree: null,
  pointsList: [],
  insertedPoints: [],
  OBBCount: 0,
  level: 8,
  maxLevel: 8,
  retainCellLists: 1
};
function extend39(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES32, initialValues);
  macro.setGet(publicAPI, model, ["tolerance", "automatic", "numberOfCellsPerNode", "dataset", "tree", "maxLevel", "level", "retainCellLists"]);
  macro.obj(publicAPI, model);
  vtkOBBTree(publicAPI, model);
}
var newInstance39 = macro.newInstance(extend39, "vtkOBBTree");
var vtkOBBTree$1 = {
  newInstance: newInstance39,
  extend: extend39
};

// node_modules/@kitware/vtk.js/Filters/General/OutlineFilter.js
var {
  vtkErrorMacro: vtkErrorMacro25
} = macro;
var BOUNDS_MAP = [
  0,
  2,
  4,
  // pt 0
  1,
  2,
  4,
  // pt 1
  0,
  3,
  4,
  // pt 2
  1,
  3,
  4,
  // pt 3
  0,
  2,
  5,
  // pt 4
  1,
  2,
  5,
  // pt 5
  0,
  3,
  5,
  // pt 6
  1,
  3,
  5
  // pt 7
];
var LINE_ARRAY = [2, 0, 1, 2, 2, 3, 2, 4, 5, 2, 6, 7, 2, 0, 2, 2, 1, 3, 2, 4, 6, 2, 5, 7, 2, 0, 4, 2, 1, 5, 2, 2, 6, 2, 3, 7];
function vtkOutlineFilter(publicAPI, model) {
  model.classHierarchy.push("vtkOutlineFilter");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro25("Invalid or missing input");
      return;
    }
    const bounds2 = input.getBounds();
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    output.getPoints().setData(Float32Array.from(BOUNDS_MAP.map((idx) => bounds2[idx])), 3);
    output.getLines().setData(Uint16Array.from(LINE_ARRAY));
    outData[0] = output;
  };
}
var DEFAULT_VALUES33 = {};
function extend40(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES33, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkOutlineFilter(publicAPI, model);
}
var newInstance40 = macro.newInstance(extend40, "vtkOutlineFilter");
var vtkOutlineFilter$1 = {
  newInstance: newInstance40,
  extend: extend40,
  BOUNDS_MAP,
  LINE_ARRAY
};

// node_modules/@kitware/vtk.js/Filters/General/PaintFilter.js
var import_webworker_promise = __toESM(require_src(), 1);

// node_modules/@kitware/vtk.js/_virtual/rollup-plugin-web-worker-loader__helper__funcToSource.js
function funcToSource(fn, sourcemapArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var regex = /(['"])__worker_loader_strict__(['"])/g;
  var lines = [];
  var source = fn.toString();
  source = source.replace(regex, "$1use strict$2");
  lines.push("(" + source + ")()");
  if (sourcemap) {
    lines.push("//# sourceMappingURL=" + sourcemap + "\n");
  }
  return lines;
}

// node_modules/@kitware/vtk.js/_virtual/rollup-plugin-web-worker-loader__helper__browser__createInlineWorkerFactory.js
function createURL(fn, sourcemapArg) {
  var lines = funcToSource(fn, sourcemapArg);
  var blob = new Blob(lines, { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function createInlineWorkerFactory(fn, sourcemapArg) {
  var url;
  return function WorkerFactory3(options) {
    url = url || createURL(fn, sourcemapArg);
    return new Worker(url, options);
  };
}

// node_modules/@kitware/vtk.js/_virtual/rollup-plugin-worker-loader__module_Sources/Filters/General/PaintFilter/PaintFilter.worker.js
var WorkerFactory = createInlineWorkerFactory(
  /* rollup-plugin-web-worker-loader */
  function() {
    (function() {
      "__worker_loader_strict__";
      var register = { exports: {} };
      var _createClass$1 = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var TinyEmitter$1 = function() {
        function TinyEmitter2() {
          _classCallCheck$1(this, TinyEmitter2);
          Object.defineProperty(this, "__listeners", {
            value: {},
            enumerable: false,
            writable: false
          });
        }
        _createClass$1(TinyEmitter2, [{
          key: "emit",
          value: function emit(eventName) {
            if (!this.__listeners[eventName]) return this;
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.__listeners[eventName][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var handler = _step.value;
                handler.apply(void 0, args);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return this;
          }
        }, {
          key: "once",
          value: function once(eventName, handler) {
            var _this = this;
            var once2 = function once3() {
              _this.off(eventName, once3);
              handler.apply(void 0, arguments);
            };
            return this.on(eventName, once2);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            if (!this.__listeners[eventName]) this.__listeners[eventName] = [];
            this.__listeners[eventName].push(handler);
            return this;
          }
        }, {
          key: "off",
          value: function off(eventName, handler) {
            if (handler) this.__listeners[eventName] = this.__listeners[eventName].filter(function(h) {
              return h !== handler;
            });
            else this.__listeners[eventName] = [];
            return this;
          }
        }]);
        return TinyEmitter2;
      }();
      var tinyEmitter = TinyEmitter$1;
      var _createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var _get = function get3(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === void 0) {
          var parent = Object.getPrototypeOf(object);
          if (parent === null) {
            return void 0;
          } else {
            return get3(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === void 0) {
            return void 0;
          }
          return getter.call(receiver);
        }
      };
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      function _defineProperty(obj2, key, value) {
        if (key in obj2) {
          Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj2[key] = value;
        }
        return obj2;
      }
      var TinyEmitter = tinyEmitter;
      var MESSAGE_RESULT = 0;
      var MESSAGE_EVENT = 1;
      var RESULT_ERROR = 0;
      var RESULT_SUCCESS = 1;
      var DEFAULT_HANDLER = "main";
      var isPromise = function isPromise2(o) {
        return (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && o !== null && typeof o.then === "function" && typeof o.catch === "function";
      };
      function RegisterPromise(fn) {
        var handlers = _defineProperty({}, DEFAULT_HANDLER, fn);
        var sendPostMessage = self.postMessage.bind(self);
        var server = new (function(_TinyEmitter) {
          _inherits(WorkerRegister, _TinyEmitter);
          function WorkerRegister() {
            _classCallCheck(this, WorkerRegister);
            return _possibleConstructorReturn(this, (WorkerRegister.__proto__ || Object.getPrototypeOf(WorkerRegister)).apply(this, arguments));
          }
          _createClass(WorkerRegister, [{
            key: "emit",
            value: function emit(eventName) {
              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (args.length == 1 && args[0] instanceof TransferableResponse) {
                sendPostMessage({ eventName, args }, args[0].transferable);
              } else {
                sendPostMessage({ eventName, args });
              }
              return this;
            }
          }, {
            key: "emitLocally",
            value: function emitLocally(eventName) {
              var _get2;
              for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              (_get2 = _get(WorkerRegister.prototype.__proto__ || Object.getPrototypeOf(WorkerRegister.prototype), "emit", this)).call.apply(_get2, [this, eventName].concat(args));
            }
          }, {
            key: "operation",
            value: function operation(name2, handler) {
              handlers[name2] = handler;
              return this;
            }
          }]);
          return WorkerRegister;
        }(TinyEmitter))();
        var run = function run2(messageId, payload, handlerName) {
          var onSuccess = function onSuccess2(result2) {
            if (result2 && result2 instanceof TransferableResponse) {
              sendResult(messageId, RESULT_SUCCESS, result2.payload, result2.transferable);
            } else {
              sendResult(messageId, RESULT_SUCCESS, result2);
            }
          };
          var onError = function onError2(e2) {
            sendResult(messageId, RESULT_ERROR, {
              message: e2.message,
              stack: e2.stack
            });
          };
          try {
            var result = runFn(messageId, payload, handlerName);
            if (isPromise(result)) {
              result.then(onSuccess).catch(onError);
            } else {
              onSuccess(result);
            }
          } catch (e2) {
            onError(e2);
          }
        };
        var runFn = function runFn2(messageId, payload, handlerName) {
          var handler = handlers[handlerName || DEFAULT_HANDLER];
          if (!handler) throw new Error("Not found handler for this request");
          return handler(payload, sendEvent.bind(null, messageId));
        };
        var sendResult = function sendResult2(messageId, success, payload) {
          var transferable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
          sendPostMessage([MESSAGE_RESULT, messageId, success, payload], transferable);
        };
        var sendEvent = function sendEvent2(messageId, eventName, payload) {
          if (!eventName) throw new Error("eventName is required");
          if (typeof eventName !== "string") throw new Error("eventName should be string");
          sendPostMessage([MESSAGE_EVENT, messageId, eventName, payload]);
        };
        self.addEventListener("message", function(_ref) {
          var data2 = _ref.data;
          if (Array.isArray(data2)) {
            run.apply(void 0, _toConsumableArray(data2));
          } else if (data2 && data2.eventName) {
            server.emitLocally.apply(server, [data2.eventName].concat(_toConsumableArray(data2.args)));
          }
        });
        return server;
      }
      var TransferableResponse = function TransferableResponse2(payload, transferable) {
        _classCallCheck(this, TransferableResponse2);
        this.payload = payload;
        this.transferable = transferable;
      };
      register.exports = RegisterPromise;
      register.exports.TransferableResponse = TransferableResponse;
      var registerWebworker = register.exports;
      const SlicingMode5 = {
        NONE: -1,
        I: 0,
        J: 1,
        K: 2,
        X: 3,
        Y: 4,
        Z: 5
      };
      var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
      if (!Math.hypot) Math.hypot = function() {
        var y = 0, i = arguments.length;
        while (i--) {
          y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
      };
      function create3() {
        var out = new ARRAY_TYPE(3);
        if (ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
        }
        return out;
      }
      function subtract2(out, a2, b2) {
        out[0] = a2[0] - b2[0];
        out[1] = a2[1] - b2[1];
        out[2] = a2[2] - b2[2];
        return out;
      }
      function scale(out, a2, b2) {
        out[0] = a2[0] * b2;
        out[1] = a2[1] * b2;
        out[2] = a2[2] * b2;
        return out;
      }
      function scaleAndAdd(out, a2, b2, scale2) {
        out[0] = a2[0] + b2[0] * scale2;
        out[1] = a2[1] + b2[1] * scale2;
        out[2] = a2[2] + b2[2] * scale2;
        return out;
      }
      (function() {
        var vec = create3();
        return function(a2, stride, offset, count, fn, arg) {
          var i, l;
          if (!stride) {
            stride = 3;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l = Math.min(count * stride + offset, a2.length);
          } else {
            l = a2.length;
          }
          for (i = offset; i < l; i += stride) {
            vec[0] = a2[i];
            vec[1] = a2[i + 1];
            vec[2] = a2[i + 2];
            fn(vec, vec, arg);
            a2[i] = vec[0];
            a2[i + 1] = vec[1];
            a2[i + 2] = vec[2];
          }
          return a2;
        };
      })();
      const globals = {
        // single-component labelmap
        buffer: null,
        dimensions: [0, 0, 0],
        prevPoint: null,
        slicingMode: null
        // 2D or 3D painting
      };
      function handlePaintRectangle(_ref) {
        let {
          point1,
          point2
        } = _ref;
        const [x1, y1, z1] = point1;
        const [x2, y2, z2] = point2;
        const xstart = Math.max(Math.min(x1, x2), 0);
        const xend = Math.min(Math.max(x1, x2), globals.dimensions[0] - 1);
        if (xstart <= xend) {
          const ystart = Math.max(Math.min(y1, y2), 0);
          const yend = Math.min(Math.max(y1, y2), globals.dimensions[1] - 1);
          const zstart = Math.max(Math.min(z1, z2), 0);
          const zend = Math.min(Math.max(z1, z2), globals.dimensions[2] - 1);
          const jStride = globals.dimensions[0];
          const kStride = globals.dimensions[0] * globals.dimensions[1];
          for (let k = zstart; k <= zend; k++) {
            for (let j = ystart; j <= yend; j++) {
              const index = j * jStride + k * kStride;
              globals.buffer.fill(1, index + xstart, index + xend + 1);
            }
          }
        }
      }
      function handlePaintEllipse(_ref2) {
        let {
          center,
          scale3: scale33
        } = _ref2;
        const radius3 = [...scale33];
        const indexCenter = center.map((val) => Math.round(val));
        let sliceAxis = -1;
        if (globals.slicingMode != null && globals.slicingMode !== SlicingMode5.NONE) {
          sliceAxis = globals.slicingMode % 3;
        }
        const yStride = globals.dimensions[0];
        const zStride = globals.dimensions[0] * globals.dimensions[1];
        let [xmin, ymin, zmin] = indexCenter;
        let [xmax, ymax, zmax] = indexCenter;
        if (sliceAxis !== 2) {
          zmin = Math.round(Math.max(indexCenter[2] - radius3[2], 0));
          zmax = Math.round(Math.min(indexCenter[2] + radius3[2], globals.dimensions[2] - 1));
        }
        for (let z = zmin; z <= zmax; z++) {
          let dz = 0;
          if (sliceAxis !== 2) {
            dz = (indexCenter[2] - z) / radius3[2];
          }
          const dzSquared = dz * dz;
          if (dzSquared <= 1) {
            const ay = radius3[1] * Math.sqrt(1 - dzSquared);
            if (sliceAxis !== 1) {
              ymin = Math.round(Math.max(indexCenter[1] - ay, 0));
              ymax = Math.round(Math.min(indexCenter[1] + ay, globals.dimensions[1] - 1));
            }
            for (let y = ymin; y <= ymax; y++) {
              let dy = 0;
              if (sliceAxis !== 1) {
                dy = (indexCenter[1] - y) / radius3[1];
              }
              const dySquared = dy * dy;
              if (dySquared + dzSquared <= 1) {
                if (sliceAxis !== 0) {
                  const ax = radius3[0] * Math.sqrt(1 - dySquared - dzSquared);
                  xmin = Math.round(Math.max(indexCenter[0] - ax, 0));
                  xmax = Math.round(Math.min(indexCenter[0] + ax, globals.dimensions[0] - 1));
                }
                if (xmin <= xmax) {
                  const index = y * yStride + z * zStride;
                  globals.buffer.fill(1, index + xmin, index + xmax + 1);
                }
              }
            }
          }
        }
      }
      function handlePaint(_ref3) {
        let {
          point,
          radius
        } = _ref3;
        if (!globals.prevPoint) {
          globals.prevPoint = point;
        }
        const delta = [point[0] - globals.prevPoint[0], point[1] - globals.prevPoint[1], point[2] - globals.prevPoint[2]];
        const inc = [1, 1, 1];
        for (let i = 0; i < 3; i++) {
          if (delta[i] < 0) {
            delta[i] = -delta[i];
            inc[i] = -1;
          }
        }
        const step = Math.max(...delta);
        const thresh = [step, step, step];
        const pt = [...globals.prevPoint];
        for (let s = 0; s <= step; s++) {
          handlePaintEllipse({
            center: pt,
            scale3: radius
          });
          for (let ii = 0; ii < 3; ii++) {
            thresh[ii] -= delta[ii];
            if (thresh[ii] <= 0) {
              thresh[ii] += step;
              pt[ii] += inc[ii];
            }
          }
        }
        globals.prevPoint = point;
      }
      function handlePaintTriangles(_ref4) {
        let {
          triangleList
        } = _ref4;
        const triangleCount = Math.floor(triangleList.length / 9);
        for (let i = 0; i < triangleCount; i++) {
          const point0 = triangleList.subarray(9 * i + 0, 9 * i + 3);
          const point1 = triangleList.subarray(9 * i + 3, 9 * i + 6);
          const point2 = triangleList.subarray(9 * i + 6, 9 * i + 9);
          const v1 = [0, 0, 0];
          const v2 = [0, 0, 0];
          subtract2(v1, point1, point0);
          subtract2(v2, point2, point0);
          const step1 = [0, 0, 0];
          const numStep1 = 2 * Math.max(Math.abs(v1[0]), Math.abs(v1[1]), Math.abs(v1[2]));
          scale(step1, v1, 1 / numStep1);
          const step2 = [0, 0, 0];
          const numStep2 = 2 * Math.max(Math.abs(v2[0]), Math.abs(v2[1]), Math.abs(v2[2]));
          scale(step2, v2, 1 / numStep2);
          const jStride = globals.dimensions[0];
          const kStride = globals.dimensions[0] * globals.dimensions[1];
          for (let u = 0; u <= numStep1 + 1; u++) {
            const maxV = numStep2 - u * (numStep2 / numStep1);
            for (let v = 0; v <= maxV + 1; v++) {
              const point = [...point0];
              scaleAndAdd(point, point, step1, u);
              scaleAndAdd(point, point, step2, v);
              point[0] = Math.round(point[0]);
              point[1] = Math.round(point[1]);
              point[2] = Math.round(point[2]);
              if (point[0] >= 0 && point[0] < globals.dimensions[0] && point[1] >= 0 && point[1] < globals.dimensions[1] && point[2] >= 0 && point[2] < globals.dimensions[2]) {
                globals.buffer[point[0] + jStride * point[1] + kStride * point[2]] = 1;
              }
            }
          }
        }
      }
      registerWebworker().operation("start", (_ref5) => {
        let {
          bufferType,
          dimensions,
          slicingMode
        } = _ref5;
        if (!globals.buffer) {
          const bufferSize = dimensions[0] * dimensions[1] * dimensions[2];
          globals.buffer = new self[bufferType](bufferSize);
          globals.dimensions = dimensions;
          globals.prevPoint = null;
          globals.slicingMode = slicingMode;
        }
      }).operation("paint", handlePaint).operation("paintRectangle", handlePaintRectangle).operation("paintEllipse", handlePaintEllipse).operation("paintTriangles", handlePaintTriangles).operation("end", () => {
        const response = new registerWebworker.TransferableResponse(globals.buffer.buffer, [globals.buffer.buffer]);
        globals.buffer = null;
        return response;
      });
    })();
  },
  null
);

// node_modules/@kitware/vtk.js/Filters/General/PaintFilter.js
var {
  vtkErrorMacro: vtkErrorMacro26
} = macro;
function vtkPaintFilter(publicAPI, model) {
  model.classHierarchy.push("vtkPaintFilter");
  let worker = null;
  let workerPromise = null;
  const history = {};
  function resetHistory() {
    history.index = -1;
    history.snapshots = [];
    history.labels = [];
  }
  function pushToHistory(snapshot, label) {
    const spliceIndex = history.index + 1;
    const spliceLength = history.snapshots.length - history.index;
    history.snapshots.splice(spliceIndex, spliceLength);
    history.labels.splice(spliceIndex, spliceLength);
    history.snapshots.push(snapshot);
    history.labels.push(label);
    history.index++;
  }
  publicAPI.startStroke = () => {
    if (model.labelMap) {
      if (!workerPromise) {
        worker = new WorkerFactory();
        workerPromise = new import_webworker_promise.default(worker);
      }
      workerPromise.exec("start", {
        bufferType: "Uint8Array",
        dimensions: model.labelMap.getDimensions(),
        slicingMode: model.slicingMode
      });
    }
  };
  publicAPI.endStroke = () => {
    let endStrokePromise;
    if (workerPromise) {
      endStrokePromise = workerPromise.exec("end");
      endStrokePromise.then((strokeBuffer) => {
        publicAPI.applyBinaryMask(strokeBuffer);
        worker.terminate();
        worker = null;
        workerPromise = null;
      });
    }
    return endStrokePromise;
  };
  publicAPI.applyBinaryMask = (maskBuffer) => {
    const scalars = model.labelMap.getPointData().getScalars();
    const data2 = scalars.getData();
    const maskLabelMap = new Uint8Array(maskBuffer);
    let diffCount = 0;
    for (let i = 0; i < maskLabelMap.length; i++) {
      diffCount += maskLabelMap[i];
    }
    const snapshot = new Array(diffCount);
    const label = model.label;
    let diffIdx = 0;
    if (model.voxelFunc) {
      const bgScalars = model.backgroundImage.getPointData().getScalars();
      const voxel = [];
      for (let i = 0; i < maskLabelMap.length; i++) {
        if (maskLabelMap[i]) {
          bgScalars.getTuple(i, voxel);
          if (model.voxelFunc(voxel, i, label)) {
            snapshot[diffIdx++] = [i, data2[i]];
            data2[i] = label;
          }
        }
      }
    } else {
      for (let i = 0; i < maskLabelMap.length; i++) {
        if (maskLabelMap[i]) {
          if (data2[i] !== label) {
            snapshot[diffIdx++] = [i, data2[i]];
            data2[i] = label;
          }
        }
      }
    }
    pushToHistory(snapshot, label);
    scalars.setData(data2);
    scalars.modified();
    model.labelMap.modified();
    publicAPI.modified();
  };
  publicAPI.addPoint = (point) => {
    if (workerPromise) {
      const worldPt = [point[0], point[1], point[2]];
      const indexPt = [0, 0, 0];
      vec3_exports.transformMat4(indexPt, worldPt, model.maskWorldToIndex);
      indexPt[0] = Math.round(indexPt[0]);
      indexPt[1] = Math.round(indexPt[1]);
      indexPt[2] = Math.round(indexPt[2]);
      const spacing = model.labelMap.getSpacing();
      const radius = spacing.map((s) => model.radius / s);
      workerPromise.exec("paint", {
        point: indexPt,
        radius
      });
    }
  };
  publicAPI.paintRectangle = (point1, point2) => {
    if (workerPromise) {
      const index1 = [0, 0, 0];
      const index2 = [0, 0, 0];
      vec3_exports.transformMat4(index1, point1, model.maskWorldToIndex);
      vec3_exports.transformMat4(index2, point2, model.maskWorldToIndex);
      index1[0] = Math.round(index1[0]);
      index1[1] = Math.round(index1[1]);
      index1[2] = Math.round(index1[2]);
      index2[0] = Math.round(index2[0]);
      index2[1] = Math.round(index2[1]);
      index2[2] = Math.round(index2[2]);
      workerPromise.exec("paintRectangle", {
        point1: index1,
        point2: index2
      });
    }
  };
  publicAPI.paintEllipse = (center, scale33) => {
    if (workerPromise) {
      const realCenter = [0, 0, 0];
      const origin3 = [0, 0, 0];
      let realScale3 = [0, 0, 0];
      vec3_exports.transformMat4(realCenter, center, model.maskWorldToIndex);
      vec3_exports.transformMat4(origin3, origin3, model.maskWorldToIndex);
      vec3_exports.transformMat4(realScale3, scale33, model.maskWorldToIndex);
      vec3_exports.subtract(realScale3, realScale3, origin3);
      realScale3 = realScale3.map((s) => s === 0 ? 0.25 : Math.abs(s));
      workerPromise.exec("paintEllipse", {
        center: realCenter,
        scale3: realScale3
      });
    }
  };
  publicAPI.canUndo = () => history.index > -1;
  publicAPI.paintPolygon = (pointList) => {
    if (workerPromise && pointList.length > 0) {
      const polygon = vtkPolygon$1.newInstance();
      const poly = [];
      for (let i = 0; i < pointList.length / 3; i++) {
        poly.push([pointList[3 * i + 0], pointList[3 * i + 1], pointList[3 * i + 2]]);
      }
      polygon.setPoints(poly);
      if (!polygon.triangulate()) {
        console.log("triangulation failed!");
      }
      const points = polygon.getPointArray();
      const triangleList = new Float32Array(points.length);
      const numPoints = Math.floor(triangleList.length / 3);
      for (let i = 0; i < numPoints; i++) {
        const point = points.slice(3 * i, 3 * i + 3);
        const voxel = triangleList.subarray(3 * i, 3 * i + 3);
        vec3_exports.transformMat4(voxel, point, model.maskWorldToIndex);
      }
      workerPromise.exec("paintTriangles", {
        triangleList
      });
    }
  };
  publicAPI.applyLabelMap = (labelMap) => {
    const currentMapData = model.labelMap.getPointData().getScalars().getData();
    const newMapData = labelMap.getPointData().getScalars().getData();
    const snapshot = [];
    for (let i = 0; i < newMapData.length; ++i) {
      if (currentMapData[i] !== newMapData[i]) {
        snapshot.push([i, currentMapData[i]]);
      }
    }
    pushToHistory(snapshot, model.label);
    model.labelMap = labelMap;
    publicAPI.modified();
  };
  publicAPI.undo = () => {
    if (history.index > -1) {
      const scalars = model.labelMap.getPointData().getScalars();
      const data2 = scalars.getData();
      const snapshot = history.snapshots[history.index];
      for (let i = 0; i < snapshot.length; i++) {
        if (!snapshot[i]) {
          break;
        }
        const [index, oldLabel] = snapshot[i];
        data2[index] = oldLabel;
      }
      history.index--;
      scalars.setData(data2);
      scalars.modified();
      model.labelMap.modified();
      publicAPI.modified();
    }
  };
  publicAPI.canRedo = () => history.index < history.labels.length - 1;
  publicAPI.redo = () => {
    if (history.index < history.labels.length - 1) {
      const scalars = model.labelMap.getPointData().getScalars();
      const data2 = scalars.getData();
      const redoLabel = history.labels[history.index + 1];
      const snapshot = history.snapshots[history.index + 1];
      for (let i = 0; i < snapshot.length; i++) {
        if (!snapshot[i]) {
          break;
        }
        const [index] = snapshot[i];
        data2[index] = redoLabel;
      }
      history.index++;
      scalars.setData(data2);
      scalars.modified();
      model.labelMap.modified();
      publicAPI.modified();
    }
  };
  const superSetLabelMap = publicAPI.setLabelMap;
  publicAPI.setLabelMap = (lm) => {
    if (superSetLabelMap(lm)) {
      model.maskWorldToIndex = model.labelMap.getWorldToIndex();
      resetHistory();
      return true;
    }
    return false;
  };
  publicAPI.requestData = (inData, outData) => {
    if (!model.backgroundImage) {
      vtkErrorMacro26("No background image");
      return;
    }
    if (!model.backgroundImage.getPointData().getScalars()) {
      vtkErrorMacro26("Background image has no scalars");
      return;
    }
    if (!model.labelMap) {
      const labelMap = vtkImageData$1.newInstance(model.backgroundImage.get("spacing", "origin", "direction"));
      labelMap.setDimensions(model.backgroundImage.getDimensions());
      labelMap.computeTransforms();
      const values = new Uint8Array(model.backgroundImage.getNumberOfPoints());
      const dataArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        // labelmap with single component
        values
      });
      labelMap.getPointData().setScalars(dataArray);
      publicAPI.setLabelMap(labelMap);
    }
    if (!model.maskWorldToIndex) {
      model.maskWorldToIndex = model.labelMap.getWorldToIndex();
    }
    const scalars = model.labelMap.getPointData().getScalars();
    if (!scalars) {
      vtkErrorMacro26("Mask image has no scalars");
      return;
    }
    model.labelMap.modified();
    outData[0] = model.labelMap;
  };
  resetHistory();
}
var DEFAULT_VALUES34 = {
  backgroundImage: null,
  labelMap: null,
  maskWorldToIndex: null,
  voxelFunc: null,
  radius: 1,
  label: 0,
  slicingMode: null
};
function extend41(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES34, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 0, 1);
  macro.setGet(publicAPI, model, ["backgroundImage", "labelMap", "maskWorldToIndex", "voxelFunc", "label", "radius", "slicingMode"]);
  vtkPaintFilter(publicAPI, model);
}
var newInstance41 = macro.newInstance(extend41, "vtkPaintFilter");
var vtkPaintFilter$1 = {
  newInstance: newInstance41,
  extend: extend41
};

// node_modules/@kitware/vtk.js/Filters/General/ScalarToRGBA.js
var {
  vtkErrorMacro: vtkErrorMacro27
} = macro;
function vtkScalarToRGBA(publicAPI, model) {
  model.classHierarchy.push("vtkScalarToRGBA");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro27("Invalid or missing input");
      return;
    }
    const scalars = input.getPointData().getScalars();
    if (!scalars) {
      vtkErrorMacro27("No scalars from input");
      return;
    }
    if (!model.lookupTable) {
      vtkErrorMacro27("No lookupTable available");
      return;
    }
    if (!model.piecewiseFunction) {
      vtkErrorMacro27("No piecewiseFunction available");
      return;
    }
    const rgba = [0, 0, 0, 0];
    const data2 = scalars.getData();
    const rgbaArray = new Uint8ClampedArray(data2.length * 4);
    let offset = 0;
    for (let idx = 0; idx < data2.length; idx++) {
      const x = data2[idx];
      model.lookupTable.getColor(x, rgba);
      rgba[3] = model.piecewiseFunction.getValue(x);
      rgbaArray[offset++] = 255 * rgba[0];
      rgbaArray[offset++] = 255 * rgba[1];
      rgbaArray[offset++] = 255 * rgba[2];
      rgbaArray[offset++] = 255 * rgba[3];
    }
    const colorArray = vtkDataArray$1.newInstance({
      name: "rgba",
      numberOfComponents: 4,
      values: rgbaArray
    });
    const datasetDefinition = input.get("extent", "spacing", "origin", "direction");
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkImageData$1.newInstance();
    output.set(datasetDefinition);
    output.getPointData().setScalars(colorArray);
    outData[0] = output;
  };
}
var DEFAULT_VALUES35 = {};
function extend42(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES35, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["lookupTable", "piecewiseFunction"]);
  vtkScalarToRGBA(publicAPI, model);
}
var newInstance42 = macro.newInstance(extend42, "vtkScalarToRGBA");
var vtkScalarToRGBA$1 = {
  newInstance: newInstance42,
  extend: extend42
};

// node_modules/@kitware/vtk.js/Filters/General/ShrinkPolyData.js
var {
  vtkErrorMacro: vtkErrorMacro28
} = macro;
function vtkShrinkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkShrinkPolyData");
  function shrinkTowardsPoint(point, center, shrinkFactor) {
    let shrunkPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
    shrunkPoint[0] = center[0] + shrinkFactor * (point[0] - center[0]);
    shrunkPoint[1] = center[1] + shrinkFactor * (point[1] - center[1]);
    shrunkPoint[2] = center[2] + shrinkFactor * (point[2] - center[2]);
    return shrunkPoint;
  }
  function shrinkCell(cellPointIds, inPoints, shrinkFactor, newPointsData, outCount) {
    const inPts = inPoints.getData();
    const center = [0, 0, 0];
    const newPointIds = [];
    const shrunkPoint = [0, 0, 0];
    const currentPoint = [0, 0, 0];
    let nextOutCount = outCount;
    const numPoints = cellPointIds.length;
    if (numPoints === 0) {
      return {
        newPointIds,
        outCount: nextOutCount
      };
    }
    if (numPoints === 1) {
      const ptId = cellPointIds[0];
      newPointsData[nextOutCount * 3] = inPts[ptId * 3];
      newPointsData[nextOutCount * 3 + 1] = inPts[ptId * 3 + 1];
      newPointsData[nextOutCount * 3 + 2] = inPts[ptId * 3 + 2];
      newPointIds.push(nextOutCount);
      nextOutCount++;
    } else if (numPoints === 2) {
      vtkPolygon$1.computeCentroid(cellPointIds, inPoints, center);
      for (let i = 0; i < 2; i++) {
        const ptId = cellPointIds[i];
        currentPoint[0] = inPts[ptId * 3];
        currentPoint[1] = inPts[ptId * 3 + 1];
        currentPoint[2] = inPts[ptId * 3 + 2];
        shrinkTowardsPoint(currentPoint, center, shrinkFactor, shrunkPoint);
        newPointsData[nextOutCount * 3] = shrunkPoint[0];
        newPointsData[nextOutCount * 3 + 1] = shrunkPoint[1];
        newPointsData[nextOutCount * 3 + 2] = shrunkPoint[2];
        newPointIds.push(nextOutCount);
        nextOutCount++;
      }
    } else {
      vtkPolygon$1.computeCentroid(cellPointIds, inPoints, center);
      for (let i = 0; i < numPoints; i++) {
        const ptId = cellPointIds[i];
        currentPoint[0] = inPts[ptId * 3];
        currentPoint[1] = inPts[ptId * 3 + 1];
        currentPoint[2] = inPts[ptId * 3 + 2];
        shrinkTowardsPoint(currentPoint, center, shrinkFactor, shrunkPoint);
        newPointsData[nextOutCount * 3] = shrunkPoint[0];
        newPointsData[nextOutCount * 3 + 1] = shrunkPoint[1];
        newPointsData[nextOutCount * 3 + 2] = shrunkPoint[2];
        newPointIds.push(nextOutCount);
        nextOutCount++;
      }
    }
    return {
      newPointIds,
      outCount: nextOutCount
    };
  }
  function shrinkData(input, output) {
    const inPoints = input.getPoints();
    const inVerts = input.getVerts();
    const inLines = input.getLines();
    const inPolys = input.getPolys();
    const inStrips = input.getStrips();
    const shrinkFactor = model.shrinkFactor;
    let numNewPts = 0;
    if (inVerts) {
      const cellSizes = inVerts.getCellSizes();
      for (let i = 0; i < cellSizes.length; i++) {
        numNewPts += cellSizes[i];
      }
    }
    if (inLines) {
      const cellSizes = inLines.getCellSizes();
      for (let i = 0; i < cellSizes.length; i++) {
        numNewPts += (cellSizes[i] - 1) * 2;
      }
    }
    if (inPolys) {
      const cellSizes = inPolys.getCellSizes();
      for (let i = 0; i < cellSizes.length; i++) {
        numNewPts += cellSizes[i];
      }
    }
    if (inStrips) {
      const cellSizes = inStrips.getCellSizes();
      for (let i = 0; i < cellSizes.length; i++) {
        numNewPts += (cellSizes[i] - 2) * 3;
      }
    }
    const newPointsData = new Float32Array(numNewPts * 3);
    const newPoints = vtkPoints$1.newInstance();
    newPoints.setData(newPointsData, 3);
    const newVerts = vtkCellArray$1.newInstance();
    const newLines = vtkCellArray$1.newInstance();
    const newPolys = vtkCellArray$1.newInstance();
    let outCount = 0;
    if (inVerts) {
      const vertData = inVerts.getData();
      const newVertData = [];
      const cellPointIds = [];
      for (let i = 0; i < vertData.length; ) {
        cellPointIds.length = 0;
        const npts = vertData[i];
        for (let j = 1; j <= npts; j++) {
          cellPointIds.push(vertData[i + j]);
        }
        const result = shrinkCell(cellPointIds, inPoints, shrinkFactor, newPointsData, outCount);
        outCount = result.outCount;
        newVertData.push(npts);
        newVertData.push(...result.newPointIds);
        i += npts + 1;
      }
      newVerts.setData(new Uint32Array(newVertData));
    }
    if (inLines) {
      const lineData = inLines.getData();
      const newLineData = [];
      for (let i = 0; i < lineData.length; ) {
        const npts = lineData[i];
        for (let j = 0; j < npts - 1; j++) {
          const cellPointIds = [lineData[i + j + 1], lineData[i + j + 2]];
          const result = shrinkCell(cellPointIds, inPoints, shrinkFactor, newPointsData, outCount);
          outCount = result.outCount;
          newLineData.push(2, result.newPointIds[0], result.newPointIds[1]);
        }
        i += npts + 1;
      }
      newLines.setData(new Uint32Array(newLineData));
    }
    if (inPolys) {
      const polyData = inPolys.getData();
      const newPolyData = [];
      const cellPointIds = [];
      for (let i = 0; i < polyData.length; ) {
        cellPointIds.length = 0;
        const npts = polyData[i];
        for (let j = 1; j <= npts; j++) {
          cellPointIds.push(polyData[i + j]);
        }
        const result = shrinkCell(cellPointIds, inPoints, shrinkFactor, newPointsData, outCount);
        outCount = result.outCount;
        newPolyData.push(npts);
        newPolyData.push(...result.newPointIds);
        i += npts + 1;
      }
      newPolys.setData(new Uint32Array(newPolyData));
    }
    if (inStrips) {
      const stripData = inStrips.getData();
      const newPolyData = [];
      for (let i = 0; i < stripData.length; ) {
        const npts = stripData[i];
        for (let j = 0; j < npts - 2; j++) {
          const cellPointIds = [stripData[i + j + 1], stripData[i + j + 2], stripData[i + j + 3]];
          const result = shrinkCell(cellPointIds, inPoints, shrinkFactor, newPointsData, outCount);
          outCount = result.outCount;
          const newIds = [...result.newPointIds];
          if (j % 2) {
            const tmp = newIds[0];
            newIds[0] = newIds[2];
            newIds[2] = tmp;
          }
          newPolyData.push(3, newIds[0], newIds[1], newIds[2]);
        }
        i += npts + 1;
      }
      if (newPolyData.length > 0) {
        const existingPolyData = newPolys.getData();
        const combinedPolyData = new Uint32Array(existingPolyData.length + newPolyData.length);
        combinedPolyData.set(existingPolyData);
        combinedPolyData.set(newPolyData, existingPolyData.length);
        newPolys.setData(combinedPolyData);
      }
    }
    output.setPoints(newPoints);
    output.setVerts(newVerts);
    output.setLines(newLines);
    output.setPolys(newPolys);
    output.getCellData().passData(input.getCellData());
  }
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    if (!input) {
      vtkErrorMacro28("No input!");
      return;
    }
    if (!input.getPoints()) {
      vtkErrorMacro28("Input has no points!");
      return;
    }
    shrinkData(input, output);
    outData[0] = output;
  };
  publicAPI.setShrinkFactor = (shrinkFactor) => {
    if (shrinkFactor !== model.shrinkFactor) {
      model.shrinkFactor = Math.max(0, Math.min(1, shrinkFactor));
      publicAPI.modified();
    }
  };
}
var DEFAULT_VALUES36 = {
  shrinkFactor: 0.5
};
function extend43(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES36, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["shrinkFactor"]);
  vtkShrinkPolyData(publicAPI, model);
}
var newInstance43 = macro.newInstance(extend43, "vtkShrinkPolyData");
var vtkShrinkPolyData$1 = {
  newInstance: newInstance43,
  extend: extend43
};

// node_modules/@kitware/vtk.js/Filters/General/TransformPolyDataFilter.js
var {
  vtkErrorMacro: vtkErrorMacro29
} = macro;
function vtkTransformPolyDataFilter(publicAPI, model) {
  model.classHierarchy.push("vtkTransformPolyDataFilter");
  function transformPolyData(input, output) {
    if (!model.transform) {
      vtkErrorMacro29("No transform defined!");
      return false;
    }
    const inPts = input.getPoints();
    const inPtData = input.getPointData();
    const outPD = output.getPointData();
    const inCellData = input.getCellData();
    const outCD = output.getCellData();
    if (!inPts) {
      return true;
    }
    const numPoints = inPts.getNumberOfPoints();
    const inVectors = inPtData.getVectors();
    const inNormals = inPtData.getNormals();
    const inCellVectors = inCellData.getVectors();
    const inCellNormals = inCellData.getNormals();
    let pointType = inPts.getDataType();
    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
      pointType = VtkDataTypes.FLOAT;
    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
      pointType = VtkDataTypes.DOUBLE;
    }
    const outPts = vtkPoints$1.newInstance({
      dataType: pointType
    });
    const inPtsData = inPts.getData();
    outPts.setNumberOfPoints(numPoints);
    const outPtsData = outPts.getData();
    let outVectors = null;
    if (inVectors) {
      outVectors = vtkDataArray$1.newInstance({
        name: inVectors.getName(),
        numberOfComponents: 3,
        size: numPoints * 3
      });
    }
    let outNormals = null;
    if (inNormals) {
      outNormals = vtkDataArray$1.newInstance({
        name: inNormals.getName(),
        numberOfComponents: 3,
        size: numPoints * 3
      });
    }
    if (inVectors || inNormals) {
      model.transform.transformPointsNormalsVectors(inPts, outPts, inNormals, outNormals, inVectors, outVectors);
    } else {
      model.transform.transformPoints(inPtsData, outPtsData);
    }
    let outCellVectors = null;
    if (inCellVectors) {
      const numCells = inCellVectors.getNumberOfTuples();
      outCellVectors = vtkDataArray$1.newInstance({
        name: inCellVectors.getName(),
        numberOfComponents: 3,
        size: numCells * 3
      });
      model.transform.transformVectors(inCellVectors, outCellVectors);
    }
    let outCellNormals = null;
    if (inCellNormals) {
      const numCells = inCellNormals.getNumberOfTuples();
      outCellNormals = vtkDataArray$1.newInstance({
        name: inCellNormals.getName(),
        numberOfComponents: 3,
        size: numCells * 3
      });
      model.transform.transformNormals(inCellNormals, outCellNormals);
    }
    output.setPoints(outPts);
    output.setVerts(input.getVerts());
    output.setLines(input.getLines());
    output.setPolys(input.getPolys());
    output.setStrips(input.getStrips());
    if (outNormals) {
      outPD.setNormals(outNormals);
      outPD.copyFieldOff(outNormals.getName());
    }
    if (outVectors) {
      outPD.setVectors(outVectors);
      outPD.copyFieldOff(outVectors.getName());
    }
    if (outCellNormals) {
      outCD.setNormals(outCellNormals);
      outCD.copyFieldOff(outCellNormals.getName());
    }
    if (outCellVectors) {
      outCD.setVectors(outCellVectors);
      outCD.copyFieldOff(outCellVectors.getName());
    }
    outPD.passData(inPtData);
    outCD.passData(inCellData);
    return true;
  }
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    if (transformPolyData(input, output)) {
      outData[0] = output;
    } else {
      vtkErrorMacro29("TransformPolyDataFilter failed to transform input data.");
    }
  };
}
var DEFAULT_VALUES37 = {
  transform: null,
  outputPointsPrecision: DesiredOutputPrecision.DEFAULT
};
function extend44(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES37, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["transform", "outputPointsPrecision"]);
  vtkTransformPolyDataFilter(publicAPI, model);
}
var newInstance44 = macro.newInstance(extend44, "vtkTransformPolyDataFilter");
var vtkTransformPolyDataFilter$1 = {
  newInstance: newInstance44,
  extend: extend44
};

// node_modules/@kitware/vtk.js/Filters/General/TriangleFilter.js
var {
  vtkWarningMacro: vtkWarningMacro5
} = macro;
function vtkTriangleFilter(publicAPI, model) {
  model.classHierarchy.push("vtkTriangleFilter");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const points = input.getPoints().getData();
    const polys = input.getPolys().getData();
    const cellsDataType = input.getPolys().getDataType();
    const pointsDataType = input.getPoints().getDataType();
    const newCells = [];
    const newPoints = [];
    model.errorCount = 0;
    if (polys) {
      let npts = 0;
      let isLastPointDuplicated = false;
      for (let c2 = 0; c2 < polys.length; c2 += npts + 1) {
        npts = polys[c2];
        isLastPointDuplicated = polys[c2 + 1] === polys[c2 + npts];
        if (isLastPointDuplicated) {
          --npts;
        }
        const cellPoints = [];
        cellPoints.length = npts;
        for (let i = 0; i < npts; i++) {
          const pointId = polys[c2 + i + 1];
          cellPoints[i] = [points[3 * pointId], points[3 * pointId + 1], points[3 * pointId + 2]];
        }
        if (npts === 3) {
          const newIdStart = newPoints.length / 3;
          newCells.push(3, newIdStart, newIdStart + 1, newIdStart + 2);
          newPoints.push(...cellPoints[0], ...cellPoints[1], ...cellPoints[2]);
        } else if (npts > 3) {
          const polygon = vtkPolygon$1.newInstance();
          polygon.setPoints(cellPoints);
          if (!polygon.triangulate()) {
            vtkWarningMacro5(`Triangulation failed at cellOffset ${c2}`);
            ++model.errorCount;
          }
          const newCellPoints = polygon.getPointArray();
          const numSimplices = Math.floor(newCellPoints.length / 9);
          const triPts = [];
          triPts.length = 9;
          for (let i = 0; i < numSimplices; i++) {
            for (let j = 0; j < 9; j++) {
              triPts[j] = newCellPoints[9 * i + j];
            }
            const newIdStart = newPoints.length / 3;
            newCells.push(3, newIdStart, newIdStart + 1, newIdStart + 2);
            newPoints.push(...triPts);
          }
        }
        if (isLastPointDuplicated) {
          ++npts;
        }
      }
    }
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    dataset.getPoints().setData(macro.newTypedArrayFrom(pointsDataType, newPoints));
    dataset.getPolys().setData(macro.newTypedArrayFrom(cellsDataType, newCells));
    outData[0] = dataset;
  };
}
var DEFAULT_VALUES38 = {
  errorCount: 0
};
function extend45(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES38, initialValues);
  macro.setGet(publicAPI, model, []);
  macro.get(publicAPI, model, ["errorCount"]);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkTriangleFilter(publicAPI, model);
}
var newInstance45 = macro.newInstance(extend45, "vtkTriangleFilter");
var vtkTriangleFilter$1 = {
  newInstance: newInstance45,
  extend: extend45
};

// node_modules/@kitware/vtk.js/Filters/General/TubeFilter/Constants.js
var VaryRadius = {
  VARY_RADIUS_OFF: 0,
  // default
  VARY_RADIUS_BY_SCALAR: 1,
  VARY_RADIUS_BY_VECTOR: 2,
  VARY_RADIUS_BY_ABSOLUTE_SCALAR: 3
};
var GenerateTCoords = {
  TCOORDS_OFF: 0,
  // default
  TCOORDS_FROM_NORMALIZED_LENGTH: 1,
  TCOORDS_FROM_LENGTH: 2,
  TCOORDS_FROM_SCALARS: 3
};
var Constants6 = {
  VaryRadius,
  GenerateTCoords
};

// node_modules/@kitware/vtk.js/Filters/General/TubeFilter.js
var {
  VaryRadius: VaryRadius2,
  GenerateTCoords: GenerateTCoords2
} = Constants6;
var {
  vtkDebugMacro: vtkDebugMacro4,
  vtkErrorMacro: vtkErrorMacro30,
  vtkWarningMacro: vtkWarningMacro6
} = macro;
function vtkTubeFilter(publicAPI, model) {
  model.classHierarchy.push("vtkTubeFilter");
  function computeOffset(offset, npts) {
    let newOffset = offset;
    if (model.sidesShareVertices) {
      newOffset += model.numberOfSides * npts;
    } else {
      newOffset += 2 * model.numberOfSides * npts;
    }
    if (model.capping) {
      newOffset += 2 * model.numberOfSides;
    }
    return newOffset;
  }
  function findNextValidSegment(points, pointIds, start) {
    const ptId = pointIds[start];
    const ps = points.slice(3 * ptId, 3 * (ptId + 1));
    let end2 = start + 1;
    while (end2 < pointIds.length) {
      const endPtId = pointIds[end2];
      const pe = points.slice(3 * endPtId, 3 * (endPtId + 1));
      if (ps !== pe) {
        return end2 - 1;
      }
      ++end2;
    }
    return pointIds.length;
  }
  function generateSlidingNormals(pts, lines, normals) {
    let firstNormal = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    let normal = [0, 0, 1];
    const lineData = lines;
    let npts = lineData[0];
    for (let i = 0; i < lineData.length; i += npts + 1) {
      npts = lineData[i];
      if (npts === 1) {
        normals.setTuple(lineData[i + 1], normal);
      } else if (npts > 1) {
        let sNextId = 0;
        let sPrev = [0, 0, 0];
        const sNext = [0, 0, 0];
        const linePts = lineData.slice(i + 1, i + 1 + npts);
        sNextId = findNextValidSegment(pts, linePts, 0);
        if (sNextId !== npts) {
          let pt1Id = linePts[sNextId];
          let pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));
          let pt2Id = linePts[sNextId + 1];
          let pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));
          sPrev = pt2.map((elem, idx) => elem - pt1[idx]);
          normalize(sPrev);
          if (firstNormal) {
            normal = firstNormal;
          } else {
            while (++sNextId < npts) {
              sNextId = findNextValidSegment(pts, linePts, sNextId);
              if (sNextId !== npts) {
                pt1Id = linePts[sNextId];
                pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));
                pt2Id = linePts[sNextId + 1];
                pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));
                for (let j = 0; j < 3; ++j) {
                  sNext[j] = pt2[j] - pt1[j];
                }
                normalize(sNext);
                const n = [0, 0, 0];
                cross(sPrev, sNext, n);
                if (norm(n) > 1e-3) {
                  normal = n;
                  sPrev = sNext;
                  break;
                }
              }
            }
            if (sNextId >= npts) {
              for (let j = 0; j < 3; ++j) {
                if (sPrev[j] !== 0) {
                  normal[(j + 2) % 3] = 0;
                  normal[(j + 1) % 3] = 1;
                  normal[j] = -sPrev[(j + 1) % 3] / sPrev[j];
                  break;
                }
              }
            }
          }
          normalize(normal);
          let lastNormalId = 0;
          while (++sNextId < npts) {
            sNextId = findNextValidSegment(pts, linePts, sNextId);
            if (sNextId === npts) {
              break;
            }
            pt1Id = linePts[sNextId];
            pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));
            pt2Id = linePts[sNextId + 1];
            pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));
            for (let j = 0; j < 3; ++j) {
              sNext[j] = pt2[j] - pt1[j];
            }
            normalize(sNext);
            const w = [0, 0, 0];
            cross(sPrev, normal, w);
            if (normalize(w) !== 0) {
              const q = [0, 0, 0];
              cross(sNext, sPrev, q);
              if (normalize(q) !== 0) {
                const f1 = dot(q, normal);
                let f2 = 1 - f1 * f1;
                if (f2 > 0) {
                  f2 = Math.sqrt(f2);
                } else {
                  f2 = 0;
                }
                const c2 = [0, 0, 0];
                for (let j = 0; j < 3; ++j) {
                  c2[j] = sNext[j] + sPrev[j];
                }
                normalize(c2);
                cross(c2, q, w);
                cross(sPrev, q, c2);
                if (dot(normal, c2) * dot(w, c2) < 0) {
                  f2 *= -1;
                }
                for (let j = lastNormalId; j < sNextId; ++j) {
                  normals.setTuple(linePts[j], normal);
                }
                lastNormalId = sNextId;
                sPrev = sNext;
                normal = f1 * q + f2 * w;
              }
            }
          }
          for (let j = lastNormalId; j < npts; ++j) {
            normals.setTuple(linePts[j], normal);
          }
        } else {
          for (let j = 0; j < npts; ++j) {
            normals.setTuple(linePts[j], normal);
          }
        }
      }
    }
    return 1;
  }
  function generatePoints(offset, npts, pts, inPts, newPts, pd, outPD, newNormals, inScalars, range, inVectors, maxSpeed, inNormals, theta) {
    const sNext = [0, 0, 0];
    const sPrev = [0, 0, 0];
    const startCapNorm = [0, 0, 0];
    const endCapNorm = [0, 0, 0];
    let p = [0, 0, 0];
    let pNext = [0, 0, 0];
    let s = [0, 0, 0];
    let n = [0, 0, 0];
    const w = [0, 0, 0];
    const nP = [0, 0, 0];
    const normal = [0, 0, 0];
    let sFactor = 1;
    let ptId = offset;
    const vector = [];
    for (let j = 0; j < npts; ++j) {
      if (j === 0) {
        p = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));
        pNext = inPts.slice(3 * pts[1], 3 * (pts[1] + 1));
        for (let i = 0; i < 3; ++i) {
          sNext[i] = pNext[i] - p[i];
          sPrev[i] = sNext[i];
          startCapNorm[i] = -sPrev[i];
        }
        normalize(startCapNorm);
      } else if (j === npts - 1) {
        for (let i = 0; i < 3; ++i) {
          sPrev[i] = sNext[i];
          p[i] = pNext[i];
          endCapNorm[i] = sNext[i];
        }
        normalize(endCapNorm);
      } else {
        for (let i = 0; i < 3; ++i) {
          p[i] = pNext[i];
        }
        pNext = inPts.slice(3 * pts[j + 1], 3 * (pts[j + 1] + 1));
        for (let i = 0; i < 3; ++i) {
          sPrev[i] = sNext[i];
          sNext[i] = pNext[i] - p[i];
        }
      }
      if (normalize(sNext) === 0) {
        vtkWarningMacro6("Coincident points!");
        return 0;
      }
      for (let i = 0; i < 3; ++i) {
        s[i] = (sPrev[i] + sNext[i]) / 2;
      }
      n = inNormals.slice(3 * pts[j], 3 * (pts[j] + 1));
      if (normalize(s) === 0) {
        cross(sPrev, n, s);
        if (normalize(s) === 0) {
          vtkDebugMacro4("Using alternate bevel vector");
        }
      }
      cross(s, n, w);
      if (normalize(w) === 0) {
        let msg = "Bad normal: s = ";
        msg += `${s[0]},  ${s[1]}, ${s[2]}`;
        msg += ` n = ${n[0]},  ${n[1]}, ${n[2]}`;
        vtkWarningMacro6(msg);
        return 0;
      }
      cross(w, s, nP);
      normalize(nP);
      if (inScalars && model.varyRadius === VaryRadius2.VARY_RADIUS_BY_SCALAR) {
        sFactor = 1 + (model.radiusFactor - 1) * (inScalars.getComponent(pts[j], 0) - range[0]) / (range[1] - range[0]);
      } else if (inVectors && model.varyRadius === VaryRadius2.VARY_RADIUS_BY_VECTOR) {
        sFactor = Math.sqrt(maxSpeed / norm(inVectors.getTuple(pts[j], vector)));
        if (sFactor > model.radiusFactor) {
          sFactor = model.radiusFactor;
        }
      } else if (inScalars && model.varyRadius === VaryRadius2.VARY_RADIUS_BY_ABSOLUTE_SCALAR) {
        sFactor = inScalars.getComponent(pts[j], 0);
        if (sFactor < 0) {
          vtkWarningMacro6("Scalar value less than zero, skipping line");
          return 0;
        }
      }
      if (model.sidesShareVertices) {
        for (let k = 0; k < model.numberOfSides; ++k) {
          for (let i = 0; i < 3; ++i) {
            normal[i] = w[i] * Math.cos(k * theta) + nP[i] * Math.sin(k * theta);
            s[i] = p[i] + model.radius * sFactor * normal[i];
            newPts[3 * ptId + i] = s[i];
            newNormals[3 * ptId + i] = normal[i];
          }
          outPD.passData(pd, pts[j], ptId);
          ptId++;
        }
      } else {
        const nRight = [0, 0, 0];
        const nLeft = [0, 0, 0];
        for (let k = 0; k < model.numberOfSides; ++k) {
          for (let i = 0; i < 3; ++i) {
            normal[i] = w[i] * Math.cos(k * theta) + nP[i] * Math.sin(k * theta);
            nRight[i] = w[i] * Math.cos((k - 0.5) * theta) + nP[i] * Math.sin((k - 0.5) * theta);
            nLeft[i] = w[i] * Math.cos((k + 0.5) * theta) + nP[i] * Math.sin((k + 0.5) * theta);
            s[i] = p[i] + model.radius * sFactor * normal[i];
            newPts[3 * ptId + i] = s[i];
            newNormals[3 * ptId + i] = nRight[i];
            newPts[3 * (ptId + 1) + i] = s[i];
            newNormals[3 * (ptId + 1) + i] = nLeft[i];
          }
          outPD.passData(pd, pts[j], ptId + 1);
          ptId += 2;
        }
      }
    }
    if (model.capping) {
      let numCapSides = model.numberOfSides;
      let capIncr = 1;
      if (!model.sidesShareVertices) {
        numCapSides = 2 * model.numberOfSides;
        capIncr = 2;
      }
      for (let k = 0; k < numCapSides; k += capIncr) {
        s = newPts.slice(3 * (offset + k), 3 * (offset + k + 1));
        for (let i = 0; i < 3; ++i) {
          newPts[3 * ptId + i] = s[i];
          newNormals[3 * ptId + i] = startCapNorm[i];
        }
        outPD.passData(pd, pts[0], ptId);
        ptId++;
      }
      let endOffset = offset + (npts - 1) * model.numberOfSides;
      if (!model.sidesShareVertices) {
        endOffset = offset + 2 * (npts - 1) * model.numberOfSides;
      }
      for (let k = 0; k < numCapSides; k += capIncr) {
        s = newPts.slice(3 * (endOffset + k), 3 * (endOffset + k + 1));
        for (let i = 0; i < 3; ++i) {
          newPts[3 * ptId + i] = s[i];
          newNormals[3 * ptId + i] = endCapNorm[i];
        }
        outPD.passData(pd, pts[npts - 1], ptId);
        ptId++;
      }
    }
    return 1;
  }
  function generateStrips(offset, npts, inCellId, outCellId, inCD, outCD, newStrips) {
    let i1 = 0;
    let i2 = 0;
    let i3 = 0;
    let newOutCellId = outCellId;
    let outCellIdx = 0;
    const newStripsData = newStrips.getData();
    let cellId = 0;
    while (outCellIdx < newStripsData.length) {
      if (cellId === outCellId) {
        break;
      }
      outCellIdx += newStripsData[outCellIdx] + 1;
      cellId++;
    }
    if (model.sidesShareVertices) {
      for (let k = offset; k < model.numberOfSides + offset; k += model.onRatio) {
        i1 = k % model.numberOfSides;
        i2 = (k + 1) % model.numberOfSides;
        newStripsData[outCellIdx++] = npts * 2;
        for (let i = 0; i < npts; ++i) {
          i3 = i * model.numberOfSides;
          newStripsData[outCellIdx++] = offset + i2 + i3;
          newStripsData[outCellIdx++] = offset + i1 + i3;
        }
        outCD.passData(inCD, inCellId, newOutCellId++);
      }
    } else {
      for (let k = offset; k < model.numberOfSides + offset; k += model.onRatio) {
        i1 = 2 * (k % model.numberOfSides) + 1;
        i2 = 2 * ((k + 1) % model.numberOfSides);
        newStripsData[outCellIdx] = npts * 2;
        outCellIdx++;
        for (let i = 0; i < npts; ++i) {
          i3 = i * 2 * model.numberOfSides;
          newStripsData[outCellIdx++] = offset + i2 + i3;
          newStripsData[outCellIdx++] = offset + i1 + i3;
        }
        outCD.passData(inCD, inCellId, newOutCellId++);
      }
    }
    if (model.capping) {
      let startIdx = offset + npts * model.numberOfSides;
      let idx = 0;
      if (!model.sidesShareVertices) {
        startIdx = offset + 2 * npts * model.numberOfSides;
      }
      newStripsData[outCellIdx++] = model.numberOfSides;
      newStripsData[outCellIdx++] = startIdx;
      newStripsData[outCellIdx++] = startIdx + 1;
      let k = 0;
      for (i1 = model.numberOfSides - 1, i2 = 2, k = 0; k < model.numberOfSides - 2; ++k) {
        if (k % 2) {
          idx = startIdx + i2;
          newStripsData[outCellIdx++] = idx;
          i2++;
        } else {
          idx = startIdx + i1;
          newStripsData[outCellIdx++] = idx;
          i1--;
        }
      }
      outCD.passData(inCD, inCellId, newOutCellId++);
      startIdx += model.numberOfSides;
      newStripsData[outCellIdx++] = model.numberOfSides;
      newStripsData[outCellIdx++] = startIdx;
      newStripsData[outCellIdx++] = startIdx + model.numberOfSides - 1;
      for (i1 = model.numberOfSides - 2, i2 = 1, k = 0; k < model.numberOfSides - 2; ++k) {
        if (k % 2) {
          idx = startIdx + i1;
          newStripsData[outCellIdx++] = idx;
          i1--;
        } else {
          idx = startIdx + i2;
          newStripsData[outCellIdx++] = idx;
          i2++;
        }
      }
      outCD.passData(inCD, inCellId, newOutCellId++);
    }
    return newOutCellId;
  }
  function generateTCoords(offset, npts, pts, inPts, inScalars, newTCoords) {
    let numSides = model.numberOfSides;
    if (!model.sidesShareVertices) {
      numSides = 2 * model.numberOfSides;
    }
    let tc = 0;
    let s0 = 0;
    let s = 0;
    const inScalarsData = inScalars.getData();
    if (model.generateTCoords === GenerateTCoords2.TCOORDS_FROM_SCALARS) {
      s0 = inScalarsData[pts[0]];
      for (let i = 0; i < npts; ++i) {
        s = inScalarsData[pts[i]];
        tc = (s - s0) / model.textureLength;
        for (let k = 0; k < numSides; ++k) {
          const tcy = k / (numSides - 1);
          const tcId = 2 * (offset + i * numSides + k);
          newTCoords[tcId] = tc;
          newTCoords[tcId + 1] = tcy;
        }
      }
    } else if (model.generateTCoords === GenerateTCoords2.TCOORDS_FROM_LENGTH) {
      let len = 0;
      const xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));
      for (let i = 0; i < npts; ++i) {
        const x = inPts.slice(3 * pts[i], 3 * (pts[i] + 1));
        len += Math.sqrt(distance2BetweenPoints(x, xPrev));
        tc = len / model.textureLength;
        for (let k = 0; k < numSides; ++k) {
          const tcy = k / (numSides - 1);
          const tcId = 2 * (offset + i * numSides + k);
          newTCoords[tcId] = tc;
          newTCoords[tcId + 1] = tcy;
        }
        for (let k = 0; k < 3; ++k) {
          xPrev[k] = x[k];
        }
      }
    } else if (model.generateTCoords === GenerateTCoords2.TCOORDS_FROM_NORMALIZED_LENGTH) {
      let len = 0;
      let len1 = 0;
      let xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));
      for (let i = 0; i < npts; ++i) {
        const x = inPts.slice(3 * pts[i], 3 * (pts[i] + 1));
        len1 += Math.sqrt(distance2BetweenPoints(x, xPrev));
        for (let k = 0; k < 3; ++k) {
          xPrev[k] = x[k];
        }
      }
      xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));
      for (let i = 0; i < npts; ++i) {
        const x = inPts.slice(3 * pts[i], 3 * (pts[i] + 1));
        len += Math.sqrt(distance2BetweenPoints(x, xPrev));
        tc = len / len1;
        for (let k = 0; k < numSides; ++k) {
          const tcy = k / (numSides - 1);
          const tcId = 2 * (offset + i * numSides + k);
          newTCoords[tcId] = tc;
          newTCoords[tcId + 1] = tcy;
        }
        for (let k = 0; k < 3; ++k) {
          xPrev[k] = x[k];
        }
      }
    }
    if (model.capping) {
      const startIdx = offset + npts * numSides;
      for (let ik = 0; ik < model.numberOfSides; ++ik) {
        const tcId = 2 * (startIdx + ik);
        newTCoords[tcId] = 0;
        newTCoords[tcId + 1] = 0;
      }
      for (let ik = 0; ik < model.numberOfSides; ++ik) {
        const tcId = 2 * (startIdx + model.numberOfSides + ik);
        newTCoords[tcId] = 0;
        newTCoords[tcId + 1] = 0;
      }
    }
  }
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    outData[0] = output;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro30("Invalid or missing input");
      return;
    }
    const inPts = input.getPoints();
    if (!inPts) {
      return;
    }
    const numPts = inPts.getNumberOfPoints();
    if (numPts < 1) {
      return;
    }
    const inLines = input.getLines();
    if (!inLines) {
      return;
    }
    const numLines = inLines.getNumberOfCells();
    if (numLines < 1) {
      return;
    }
    let numNewPts = 0;
    let numStrips = 0;
    const inLinesData = inLines.getData();
    let npts = inLinesData[0];
    for (let i = 0; i < inLinesData.length; i += npts + 1) {
      npts = inLinesData[i];
      numNewPts = computeOffset(numNewPts, npts);
      numStrips += (2 * npts + 1) * Math.ceil(model.numberOfSides / model.onRatio);
      if (model.capping) {
        numStrips += 2 * (model.numberOfSides + 1);
      }
    }
    let pointType = inPts.getDataType();
    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
      pointType = VtkDataTypes.FLOAT;
    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
      pointType = VtkDataTypes.DOUBLE;
    }
    const newPts = vtkPoints$1.newInstance({
      dataType: pointType,
      size: numNewPts * 3,
      numberOfComponents: 3
    });
    const numNormals = 3 * numNewPts;
    const newNormalsData = new Float32Array(numNormals);
    const newNormals = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: newNormalsData,
      name: "TubeNormals"
    });
    const newStripsData = new Uint32Array(numStrips);
    const newStrips = vtkCellArray$1.newInstance({
      values: newStripsData
    });
    let newStripId = 0;
    let inNormals = input.getPointData().getNormals();
    let inNormalsData = null;
    let generateNormals = false;
    if (!inNormals || model.useDefaultNormal) {
      inNormalsData = new Float32Array(3 * numPts);
      inNormals = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: inNormalsData,
        name: "Normals"
      });
      if (model.useDefaultNormal) {
        inNormalsData = inNormalsData.map((elem, index) => {
          const i = index % 3;
          return model.defaultNormal[i];
        });
      } else {
        generateNormals = true;
      }
    }
    const numArrays = input.getPointData().getNumberOfArrays();
    let oldArray = null;
    let newArray = null;
    for (let i = 0; i < numArrays; i++) {
      oldArray = input.getPointData().getArrayByIndex(i);
      newArray = vtkDataArray$1.newInstance({
        name: oldArray.getName(),
        dataType: oldArray.getDataType(),
        numberOfComponents: oldArray.getNumberOfComponents(),
        size: numNewPts * oldArray.getNumberOfComponents()
      });
      output.getPointData().addArray(newArray);
    }
    let numNewCells = inLines.getNumberOfCells() * model.numberOfSides;
    if (model.capping) {
      numNewCells += 2;
    }
    const numCellArrays = input.getCellData().getNumberOfArrays();
    for (let i = 0; i < numCellArrays; i++) {
      oldArray = input.getCellData().getArrayByIndex(i);
      newArray = vtkDataArray$1.newInstance({
        name: oldArray.getName(),
        dataType: oldArray.getDataType(),
        numberOfComponents: oldArray.getNumberOfComponents(),
        size: numNewCells * oldArray.getNumberOfComponents()
      });
      output.getCellData().addArray(newArray);
    }
    const inScalars = publicAPI.getInputArrayToProcess(0);
    let outScalars = null;
    let range = [];
    if (inScalars) {
      outScalars = vtkDataArray$1.newInstance({
        name: inScalars.getName(),
        dataType: inScalars.getDataType(),
        numberOfComponents: inScalars.getNumberOfComponents(),
        size: numNewPts * inScalars.getNumberOfComponents()
      });
      range = inScalars.getRange();
      if (range[1] - range[0] === 0) {
        if (model.varyRadius === VaryRadius2.VARY_RADIUS_BY_SCALAR) {
          vtkWarningMacro6("Scalar range is zero!");
        }
        range[1] = range[0] + 1;
      }
    }
    const inVectors = publicAPI.getInputArrayToProcess(1);
    let maxSpeed = 0;
    if (inVectors) {
      maxSpeed = inVectors.getMaxNorm();
    }
    const outCD = output.getCellData();
    outCD.copyNormalsOff();
    outCD.passData(input.getCellData());
    const outPD = output.getPointData();
    if (outPD.getNormals() !== null) {
      outPD.copyNormalsOff();
    }
    if (inScalars && outScalars) {
      outPD.setScalars(outScalars);
    }
    let newTCoords = null;
    if (model.generateTCoords === GenerateTCoords2.TCOORDS_FROM_SCALARS && inScalars || model.generateTCoords === GenerateTCoords2.TCOORDS_FROM_LENGTH || model.generateTCoords === GenerateTCoords2.TCOORDS_FROM_NORMALIZED_LENGTH) {
      const newTCoordsData = new Float32Array(2 * numNewPts);
      newTCoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: newTCoordsData,
        name: "TCoords"
      });
      outPD.copyTCoordsOff();
    }
    outPD.passData(input.getPointData());
    const theta = 2 * Math.PI / model.numberOfSides;
    npts = inLinesData[0];
    let offset = 0;
    let inCellId = input.getVerts().getNumberOfCells();
    for (let i = 0; i < inLinesData.length; i += npts + 1) {
      npts = inLinesData[i];
      const pts = inLinesData.slice(i + 1, i + 1 + npts);
      if (npts > 1) {
        if (generateNormals) {
          const polyLine = inLinesData.slice(i, i + npts + 1);
          generateSlidingNormals(inPts.getData(), polyLine, inNormals);
        }
      }
      if (generatePoints(offset, npts, pts, inPts.getData(), newPts.getData(), input.getPointData(), outPD, newNormalsData, inScalars, range, inVectors, maxSpeed, inNormalsData, theta)) {
        newStripId = generateStrips(offset, npts, inCellId, newStripId, input.getCellData(), outCD, newStrips);
        if (newTCoords) {
          generateTCoords(offset, npts, pts, inPts.getData(), inScalars, newTCoords.getData());
        }
      } else {
        vtkWarningMacro6("Could not generate points");
      }
      offset = computeOffset(offset, npts);
      inCellId++;
    }
    output.setPoints(newPts);
    output.setStrips(newStrips);
    output.setPointData(outPD);
    outPD.setNormals(newNormals);
  };
}
var DEFAULT_VALUES39 = {
  outputPointsPrecision: DesiredOutputPrecision.DEFAULT,
  radius: 0.5,
  varyRadius: VaryRadius2.VARY_RADIUS_OFF,
  numberOfSides: 3,
  radiusFactor: 10,
  defaultNormal: [0, 0, 1],
  useDefaultNormal: false,
  sidesShareVertices: true,
  capping: false,
  onRatio: 1,
  offset: 0,
  generateTCoords: GenerateTCoords2.TCOORDS_OFF,
  textureLength: 1
};
function extend46(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES39, initialValues);
  macro.setGet(publicAPI, model, ["outputPointsPrecision", "radius", "varyRadius", "numberOfSides", "radiusFactor", "defaultNormal", "useDefaultNormal", "sidesShareVertices", "capping", "onRatio", "offset", "generateTCoords", "textureLength"]);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkTubeFilter(publicAPI, model);
}
var newInstance46 = macro.newInstance(extend46, "vtkTubeFilter");
var vtkTubeFilter$1 = {
  newInstance: newInstance46,
  extend: extend46
};

// node_modules/@kitware/vtk.js/Filters/General/WarpScalar.js
var {
  vtkDebugMacro: vtkDebugMacro5,
  vtkErrorMacro: vtkErrorMacro31
} = macro;
function vtkWarpScalar(publicAPI, model) {
  model.classHierarchy.push("vtkWarpScalar");
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input) {
      vtkErrorMacro31("Invalid or missing input");
      return 1;
    }
    const inPts = input.getPoints();
    const pd = input.getPointData();
    const inNormals = pd.getNormals();
    const inScalars = publicAPI.getInputArrayToProcess(0);
    if (!inPts || !inScalars) {
      vtkDebugMacro5("No data to warp", !!inPts, !!inScalars);
      outData[0] = inData[0];
      return 1;
    }
    const numPts = inPts.getNumberOfPoints();
    let pointNormal = null;
    const normal = [0, 0, 1];
    if (inNormals && !model.useNormal) {
      pointNormal = (id, array) => [array.getData()[id * 3], array.getData()[id * 3 + 1], array.getData()[id * 3 + 2]];
      vtkDebugMacro5("Using data normals");
    } else if (publicAPI.getXyPlane()) {
      pointNormal = (id, array) => normal;
      vtkDebugMacro5("Using x-y plane normal");
    } else {
      pointNormal = (id, array) => model.normal;
      vtkDebugMacro5("Using Normal instance variable");
    }
    const newPtsData = new Float32Array(numPts * 3);
    const inPoints = inPts.getData();
    let ptOffset = 0;
    let n = [0, 0, 1];
    let s = 1;
    const scalarDataArray = inScalars.getData();
    const nc = inScalars.getNumberOfComponents();
    for (let ptId = 0; ptId < numPts; ++ptId) {
      ptOffset = ptId * 3;
      n = pointNormal(ptId, inNormals);
      if (model.xyPlane) {
        s = inPoints[ptOffset + 2];
      } else {
        s = scalarDataArray[ptId * nc];
      }
      newPtsData[ptOffset] = inPoints[ptOffset] + model.scaleFactor * s * n[0];
      newPtsData[ptOffset + 1] = inPoints[ptOffset + 1] + model.scaleFactor * s * n[1];
      newPtsData[ptOffset + 2] = inPoints[ptOffset + 2] + model.scaleFactor * s * n[2];
    }
    const newDataSet = outData[0] && outData[0] !== inData[0] ? outData[0].initialize() : vtk({
      vtkClass: input.getClassName()
    });
    newDataSet.shallowCopy(input);
    const points = vtkPoints$1.newInstance();
    points.setData(newPtsData, 3);
    newDataSet.setPoints(points);
    outData[0] = newDataSet;
    return 1;
  };
}
var DEFAULT_VALUES40 = {
  scaleFactor: 1,
  useNormal: false,
  normal: [0, 0, 1],
  xyPlane: false
};
function extend47(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES40, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["scaleFactor", "useNormal", "xyPlane"]);
  macro.setGetArray(publicAPI, model, ["normal"], 3);
  vtkWarpScalar(publicAPI, model);
}
var newInstance47 = macro.newInstance(extend47, "vtkWarpScalar");
var vtkWarpScalar$1 = {
  newInstance: newInstance47,
  extend: extend47
};

// node_modules/@kitware/vtk.js/Filters/General/WindowedSincPolyDataFilter.js
var VertexType = {
  VTK_SIMPLE_VERTEX: 0,
  VTK_FIXED_VERTEX: 1,
  VTK_FEATURE_EDGE_VERTEX: 2,
  VTK_BOUNDARY_EDGE_VERTEX: 3
};
function vtkWindowedSincPolyDataFilter(publicAPI, model) {
  model.classHierarchy.push("vtkWindowedSincPolyDataFilter");
  publicAPI.vtkWindowedSincPolyDataFilterExecute = (inPts, inputPolyData, output) => {
    if (!inPts || model.numberOfIterations <= 0) {
      return inPts;
    }
    const inPtsData = inPts.getData();
    const inVerts = inputPolyData.getVerts().getData();
    const inLines = inputPolyData.getLines().getData();
    const inPolys = inputPolyData.getPolys().getData();
    const inStrips = inputPolyData.getStrips().getData();
    const cosFeatureAngle = Math.cos(vtkMath.radiansFromDegrees(model.featureAngle));
    const cosEdgeAngle = Math.cos(vtkMath.radiansFromDegrees(model.edgeAngle));
    const numPts = inPts.getNumberOfPoints();
    const verts = new Array(numPts);
    for (let i = 0; i < numPts; ++i) {
      verts[i] = {
        type: VertexType.VTK_SIMPLE_VERTEX,
        edges: null
      };
    }
    let npts = 0;
    for (let i = 0; i < inVerts.length; i += npts + 1) {
      npts = inVerts[i];
      const pts = inVerts.slice(i + 1, i + 1 + npts);
      for (let j = 0; j < pts.length; ++j) {
        verts[pts[j]].type = VertexType.VTK_FIXED_VERTEX;
      }
    }
    for (let i = 0; i < inLines.length; i += npts + 1) {
      npts = inLines[i];
      const pts = inLines.slice(i + 1, i + 1 + npts);
      const closedLoop = pts[0] === pts[npts - 1] && npts > 3;
      for (let j = 0; j < npts; ++j) {
        if (verts[pts[j]].type === VertexType.VTK_SIMPLE_VERTEX) {
          if (j === 0) {
            if (!closedLoop) {
              verts[pts[0]].type = VertexType.VTK_FIXED_VERTEX;
            } else {
              verts[pts[0]].type = VertexType.VTK_FEATURE_EDGE_VERTEX;
              verts[pts[0]].edges = [pts[npts - 2], pts[1]];
            }
          } else if (j === npts - 1 && !closedLoop) {
            verts[pts[j]].type = VertexType.VTK_FIXED_VERTEX;
          } else {
            verts[pts[j]].type = VertexType.VTK_FEATURE_EDGE_VERTEX;
            verts[pts[j]].edges = [pts[j - 1], pts[closedLoop && j === npts - 2 ? 0 : j + 1]];
          }
        } else if (verts[pts[j]].type === VertexType.VTK_FEATURE_EDGE_VERTEX && !(closedLoop && j === npts - 1)) {
          verts[pts[j]].type = VertexType.VTK_FIXED_VERTEX;
          verts[pts[j]].edges = null;
        }
      }
    }
    const numPolys = inPolys.length;
    const numStrips = inStrips.length;
    if (numPolys > 0 || numStrips > 0) {
      const inMesh = vtkPolyData$1.newInstance();
      inMesh.setPoints(inputPolyData.getPoints());
      inMesh.setPolys(inputPolyData.getPolys());
      const mesh = inMesh;
      let neighbors = [];
      let nei = 0;
      const normal = [];
      const neiNormal = [];
      mesh.buildLinks();
      const polys = mesh.getPolys().getData();
      let cellId = 0;
      for (let c3 = 0; c3 < polys.length; c3 += npts + 1, ++cellId) {
        npts = polys[c3];
        const pts = polys.slice(c3 + 1, c3 + 1 + npts);
        for (let i = 0; i < npts; ++i) {
          const p1 = pts[i];
          const p2 = pts[(i + 1) % npts];
          if (verts[p1].edges === null) {
            verts[p1].edges = [];
          }
          if (verts[p2].edges == null) {
            verts[p2].edges = [];
          }
          neighbors = mesh.getCellEdgeNeighbors(cellId, p1, p2);
          const numNei = neighbors.length;
          let edge = VertexType.VTK_SIMPLE_VERTEX;
          if (numNei === 0) {
            edge = VertexType.VTK_BOUNDARY_EDGE_VERTEX;
          } else if (numNei >= 2) {
            if (!model.nonManifoldSmoothing) {
              let j = 0;
              for (; j < numNei; ++j) {
                if (neighbors[j] < cellId) {
                  break;
                }
              }
              if (j >= numNei) {
                edge = VertexType.VTK_FEATURE_EDGE_VERTEX;
              }
            }
          } else if (numNei === 1 && (nei = neighbors[0]) > cellId) {
            if (model.featureEdgeSmoothing) {
              vtkTriangle$1.computeNormal(inPts.getPoint(pts[0]), inPts.getPoint(pts[1]), inPts.getPoint(pts[2]), normal);
              const {
                cellPointIds
              } = mesh.getCellPoints(nei);
              vtkTriangle$1.computeNormal(inPts.getPoint(cellPointIds[0]), inPts.getPoint(cellPointIds[1]), inPts.getPoint(cellPointIds[2]), neiNormal);
              if (vtkMath.dot(normal, neiNormal) <= cosFeatureAngle) {
                edge = VertexType.VTK_FEATURE_EDGE_VERTEX;
              }
            }
          } else {
            continue;
          }
          if (edge && verts[p1].type === VertexType.VTK_SIMPLE_VERTEX) {
            verts[p1].edges = [p2];
            verts[p1].type = edge;
          } else if (edge && verts[p1].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX || edge && verts[p1].type === VertexType.VTK_FEATURE_EDGE_VERTEX || !edge && verts[p1].type === VertexType.VTK_SIMPLE_VERTEX) {
            verts[p1].edges.push(p2);
            if (verts[p1].type && edge === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {
              verts[p1].type = VertexType.VTK_BOUNDARY_EDGE_VERTEX;
            }
          }
          if (edge && verts[p2].type === VertexType.VTK_SIMPLE_VERTEX) {
            verts[p2].edges = [p1];
            verts[p2].type = edge;
          } else if (edge && verts[p2].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX || edge && verts[p2].type === VertexType.VTK_FEATURE_EDGE_VERTEX || !edge && verts[p2].type === VertexType.VTK_SIMPLE_VERTEX) {
            verts[p2].edges.push(p1);
            if (verts[p2].type && edge === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {
              verts[p2].type = VertexType.VTK_BOUNDARY_EDGE_VERTEX;
            }
          }
        }
      }
    }
    for (let i = 0; i < numPts; ++i) {
      if (verts[i].type === VertexType.VTK_SIMPLE_VERTEX) ;
      else if (verts[i].type === VertexType.VTK_FIXED_VERTEX) ;
      else if (verts[i].type === VertexType.VTK_FEATURE_EDGE_VERTEX || verts[i].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {
        if (!model.boundarySmoothing && verts[i].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {
          verts[i].type = VertexType.VTK_FIXED_VERTEX;
        } else if ((npts = verts[i].edges.length) !== 2) {
          verts[i].type = VertexType.VTK_FIXED_VERTEX;
        } else {
          const x12 = inPts.getPoint(verts[i].edges[0]);
          const x22 = inPts.getPoint(i);
          const x3 = inPts.getPoint(verts[i].edges[1]);
          const l1 = [0, 0, 0];
          const l2 = [0, 0, 0];
          for (let k = 0; k < 3; ++k) {
            l1[k] = x22[k] - x12[k];
            l2[k] = x3[k] - x22[k];
          }
          if (vtkMath.normalize(l1) >= 0 && vtkMath.normalize(l2) >= 0 && vtkMath.dot(l1, l2) < cosEdgeAngle) {
            verts[i].type = VertexType.VTK_FIXED_VERTEX;
          } else if (verts[i].type === VertexType.VTK_FEATURE_EDGE_VERTEX) ;
          else ;
        }
      }
    }
    let zero = 0;
    let one = 1;
    let two = 2;
    const three = 3;
    const newPts = [];
    newPts.push(vtkPoints$1.newInstance());
    newPts[zero].setNumberOfPoints(numPts);
    newPts.push(vtkPoints$1.newInstance());
    newPts[one].setNumberOfPoints(numPts);
    newPts.push(vtkPoints$1.newInstance());
    newPts[two].setNumberOfPoints(numPts);
    newPts.push(vtkPoints$1.newInstance());
    newPts[three].setNumberOfPoints(numPts);
    const inCenter = vtkBoundingBox.getCenter(inputPolyData.getBounds());
    const inLength = vtkBoundingBox.getDiagonalLength(inputPolyData.getBounds());
    if (!model.normalizeCoordinates) {
      const copy = macro.newTypedArray(newPts[zero].getDataType(), inPtsData);
      newPts[zero].setData(copy, 3);
    } else {
      const normalizedPoint = [0, 0, 0];
      for (let i = 0; i < numPts; ++i) {
        inPts.getPoint(i, normalizedPoint);
        normalizedPoint[0] = (normalizedPoint[0] - inCenter[0]) / inLength;
        normalizedPoint[1] = (normalizedPoint[1] - inCenter[1]) / inLength;
        normalizedPoint[2] = (normalizedPoint[2] - inCenter[2]) / inLength;
        newPts[zero].setPoint(i, ...normalizedPoint);
      }
    }
    const kPb = model.passBand;
    const thetaPb = Math.acos(1 - 0.5 * kPb);
    const w = new Array(model.numberOfIterations + 1);
    const c2 = new Array(model.numberOfIterations + 1);
    const cprime = new Array(model.numberOfIterations + 1);
    const zerovector = [0, 0, 0];
    for (let i = 0; i <= model.numberOfIterations; ++i) {
      w[i] = 0.54 + 0.46 * Math.cos(i * Math.PI / (model.numberOfIterations + 1));
    }
    let fKpb = 0;
    let fPrimeKpb = 0;
    let done = false;
    let sigma = 0;
    for (let j = 0; !done && j < 500; ++j) {
      c2[0] = w[0] * (thetaPb + sigma) / Math.PI;
      for (let i = 1; i <= model.numberOfIterations; ++i) {
        c2[i] = 2 * w[i] * Math.sin(i * (thetaPb + sigma)) / (i * Math.PI);
      }
      cprime[model.numberOfIterations] = 0;
      cprime[model.numberOfIterations - 1] = 0;
      if (model.numberOfIterations > 1) {
        cprime[model.numberOfIterations - 2] = 2 * (model.numberOfIterations - 1) * c2[model.numberOfIterations - 1];
      }
      for (let i = model.numberOfIterations - 3; i >= 0; --i) {
        cprime[i] = cprime[i + 2] + 2 * (i + 1) * c2[i + 1];
      }
      fKpb = 0;
      fPrimeKpb = 0;
      fKpb += c2[0];
      fPrimeKpb += cprime[0];
      for (let i = 1; i <= model.numberOfIterations; ++i) {
        if (i === 1) {
          fKpb += c2[i] * (1 - 0.5 * kPb);
          fPrimeKpb += cprime[i] * (1 - 0.5 * kPb);
        } else {
          fKpb += c2[i] * Math.cos(i * Math.acos(1 - 0.5 * kPb));
          fPrimeKpb += cprime[i] * Math.cos(i * Math.acos(1 - 0.5 * kPb));
        }
      }
      if (model.numberOfIterations > 1) {
        if (Math.abs(fKpb - 1) >= 1e-3) {
          sigma -= (fKpb - 1) / fPrimeKpb;
        } else {
          done = true;
        }
      } else {
        done = true;
        sigma = 0;
      }
    }
    if (Math.abs(fKpb - 1) >= 1e-3) {
      console.log("An optimal offset for the smoothing filter could not be found.  Unpredictable smoothing/shrinkage may result.");
    }
    const x = [0, 0, 0];
    const y = [0, 0, 0];
    const deltaX = [0, 0, 0];
    const xNew = [0, 0, 0];
    const x1 = [0, 0, 0];
    const x2 = [0, 0, 0];
    for (let i = 0; i < numPts; ++i) {
      if (verts[i].edges != null && (npts = verts[i].edges.length) > 0) {
        newPts[zero].getPoint(i, x);
        deltaX[0] = 0;
        deltaX[1] = 0;
        deltaX[2] = 0;
        for (let j = 0; j < npts; ++j) {
          newPts[zero].getPoint(verts[i].edges[j], y);
          for (let k = 0; k < 3; ++k) {
            deltaX[k] += (x[k] - y[k]) / npts;
          }
        }
        for (let k = 0; k < 3; ++k) {
          deltaX[k] = x[k] - 0.5 * deltaX[k];
        }
        newPts[one].setPoint(i, ...deltaX);
        if (verts[i].type === VertexType.VTK_FIXED_VERTEX) {
          newPts[zero].getPoint(i, deltaX);
        } else {
          for (let k = 0; k < 3; ++k) {
            deltaX[k] = c2[0] * x[k] + c2[1] * deltaX[k];
          }
        }
        newPts[three].setPoint(i, ...deltaX);
      } else {
        newPts[one].setPoint(i, ...zerovector);
        newPts[zero].getPoint(i, deltaX);
        newPts[three].setPoint(i, ...deltaX);
      }
    }
    const pX0 = [0, 0, 0];
    const pX1 = [0, 0, 0];
    const pX3 = [0, 0, 0];
    let iterationNumber = 2;
    for (; iterationNumber <= model.numberOfIterations; iterationNumber++) {
      for (let i = 0; i < numPts; ++i) {
        npts = verts[i].edges != null ? verts[i].edges.length : 0;
        if (npts > 0) {
          newPts[zero].getPoint(i, pX0);
          newPts[one].getPoint(i, pX1);
          deltaX[0] = 0;
          deltaX[1] = 0;
          deltaX[2] = 0;
          for (let j = 0; j < npts; ++j) {
            newPts[one].getPoint(verts[i].edges[j], y);
            for (let k = 0; k < 3; ++k) {
              deltaX[k] += (pX1[k] - y[k]) / npts;
            }
          }
          for (let k = 0; k < 3; ++k) {
            deltaX[k] = pX1[k] - pX0[k] + pX1[k] - deltaX[k];
          }
          newPts[two].setPoint(i, ...deltaX);
          newPts[three].getPoint(i, pX3);
          for (let k = 0; k < 3; ++k) {
            xNew[k] = pX3[k] + c2[iterationNumber] * deltaX[k];
          }
          if (verts[i].type !== VertexType.VTK_FIXED_VERTEX) {
            newPts[three].setPoint(i, ...xNew);
          }
        } else {
          newPts[one].setPoint(i, ...zerovector);
          newPts[two].setPoint(i, ...zerovector);
        }
      }
      zero = (1 + zero) % 3;
      one = (1 + one) % 3;
      two = (1 + two) % 3;
    }
    --iterationNumber;
    zero = three;
    if (model.normalizeCoordinates) {
      const repositionedPoint = [0, 0, 0];
      for (let i = 0; i < numPts; ++i) {
        newPts[zero].getPoint(i, repositionedPoint);
        for (let j = 0; j < 3; ++j) {
          repositionedPoint[j] = repositionedPoint[j] * inLength + inCenter[j];
        }
        newPts[zero].setPoint(i, ...repositionedPoint);
      }
    }
    if (model.generateErrorScalars) {
      const newScalars = new Float32Array(numPts);
      for (let i = 0; i < numPts; ++i) {
        inPts.getPoint(i, x1);
        newPts[zero].getPoint(i, x2);
        newScalars[i] = Math.sqrt(Math.distance2BetweenPoints(x1, x2));
      }
      const newScalarsArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: newScalars
      });
      const idx = output.getPointData().addArray(newScalarsArray);
      output.getPointData().setActiveAttribute(idx, AttributeTypes.SCALARS);
    }
    if (model.generateErrorVectors) {
      const newVectors = new Float32Array(3 * numPts);
      for (let i = 0; i < numPts; ++i) {
        inPts.getPoint(i, x1);
        newPts[zero].getPoint(i, x2);
        for (let j = 0; j < 3; ++j) {
          newVectors[3 * i + j] = x2[j] - x1[j];
        }
      }
      const newVectorsArray = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: newVectors
      });
      output.getPointData().setVectors(newVectorsArray);
    }
    return newPts[zero];
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const numberOfInputs = publicAPI.getNumberOfInputPorts();
    if (!numberOfInputs) {
      return;
    }
    const input = inData[0];
    if (!input) {
      return;
    }
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    const outputPoints = publicAPI.vtkWindowedSincPolyDataFilterExecute(input.getPoints(), input, output);
    output.setPointData(input.getPointData());
    output.setCellData(input.getCellData());
    output.setFieldData(input.getFieldData());
    output.setPoints(outputPoints);
    output.setVerts(input.getVerts());
    output.setLines(input.getLines());
    output.setPolys(input.getPolys());
    output.setStrips(input.getStrips());
    outData[0] = output;
  };
}
var DEFAULT_VALUES41 = {
  numberOfIterations: 20,
  passBand: 0.1,
  featureAngle: 45,
  edgeAngle: 15,
  featureEdgeSmoothing: 0,
  boundarySmoothing: 1,
  nonManifoldSmoothing: 0,
  generateErrorScalars: 0,
  generateErrorVectors: 0,
  normalizeCoordinates: 0
};
function extend48(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES41, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["numberOfIterations", "passBand", "featureAngle", "edgeAngle", "featureEdgeSmoothing", "boundarySmoothing", "nonManifoldSmoothing", "generateErrorScalars", "generateErrorVectors", "normalizeCoordinates"]);
  vtkWindowedSincPolyDataFilter(publicAPI, model);
}
var newInstance48 = macro.newInstance(extend48, "vtkWindowedSincPolyDataFilter");
var vtkWindowedSincPolyDataFilter$1 = {
  newInstance: newInstance48,
  extend: extend48
};

// node_modules/@kitware/vtk.js/Filters/General.js
var General = {
  vtkAppendPolyData: vtkAppendPolyData$1,
  vtkCalculator: vtkCalculator$1,
  vtkClipClosedSurface: vtkClipClosedSurface$1,
  vtkClosedPolyLineToSurfaceFilter: vtkClosedPolyLineToSurfaceFilter$1,
  vtkContourTriangulator: vtkContourTriangulator$1,
  vtkImageCropFilter: vtkImageCropFilter$1,
  vtkImageMarchingCubes: vtkImageMarchingCubes$1,
  vtkImageMarchingSquares: vtkImageMarchingSquares$1,
  vtkImageOutlineFilter: vtkImageOutlineFilter$1,
  vtkImageSliceFilter: vtkImageSliceFilter$1,
  vtkImageStreamline: vtkImageStreamline$1,
  vtkLineFilter: vtkLineFilter$1,
  vtkMoleculeToRepresentation: vtkMoleculeToRepresentation$1,
  vtkOBBTree: vtkOBBTree$1,
  vtkOutlineFilter: vtkOutlineFilter$1,
  vtkPaintFilter: vtkPaintFilter$1,
  vtkScalarToRGBA: vtkScalarToRGBA$1,
  vtkShrinkPolyData: vtkShrinkPolyData$1,
  vtkTransformPolyDataFilter: vtkTransformPolyDataFilter$1,
  vtkTriangleFilter: vtkTriangleFilter$1,
  vtkTubeFilter: vtkTubeFilter$1,
  vtkWarpScalar: vtkWarpScalar$1,
  vtkWindowedSincPolyDataFilter: vtkWindowedSincPolyDataFilter$1
};

// node_modules/@kitware/vtk.js/Filters/Sources/ArcSource.js
var {
  VtkDataTypes: VtkDataTypes2
} = vtkDataArray$1;
function vtkArcSource(publicAPI, model) {
  model.classHierarchy.push("vtkArcSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const numLines = model.resolution;
    const numPts = model.resolution + 1;
    const tc = [0, 0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    let angle = 0;
    let radius = 0.5;
    const perpendicular = [0, 0, 0];
    const v1 = [0, 0, 0];
    if (model.useNormalAndAngle) {
      angle = vtkMath.radiansFromDegrees(model.angle);
      v1[0] = model.polarVector[0];
      v1[1] = model.polarVector[1];
      v1[2] = model.polarVector[2];
      vtkMath.cross(model.normal, model.polarVector, perpendicular);
      radius = vtkMath.normalize(v1);
    } else {
      vtkMath.subtract(model.point1, model.center, v1);
      const v2 = [0, 0, 0];
      vtkMath.subtract(model.point2, model.center, v2);
      const normal = [0, 0, 0];
      vtkMath.cross(v1, v2, normal);
      vtkMath.cross(normal, v1, perpendicular);
      const dotProduct = vtkMath.dot(v1, v2) / (vtkMath.norm(v1) * vtkMath.norm(v2));
      angle = Math.acos(dotProduct);
      if (model.negative) {
        angle -= 2 * Math.PI;
      }
      radius = vtkMath.normalize(v1);
    }
    const angleInc = angle / model.resolution;
    vtkMath.normalize(perpendicular);
    let pointType = 0;
    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
      pointType = VtkDataTypes2.FLOAT;
    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
      pointType = VtkDataTypes2.DOUBLE;
    }
    const points = vtkPoints$1.newInstance({
      dataType: pointType
    });
    points.setNumberOfPoints(numPts);
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      size: numPts * 2,
      dataType: VtkDataTypes2.FLOAT,
      name: "TextureCoordinates"
    });
    const lines = vtkCellArray$1.newInstance();
    lines.allocate(numLines);
    let theta = 0;
    for (let i = 0; i <= model.resolution; ++i, theta += angleInc) {
      const cosine = Math.cos(theta);
      const sine = Math.sin(theta);
      const p = [model.center[0] + cosine * radius * v1[0] + sine * radius * perpendicular[0], model.center[1] + cosine * radius * v1[1] + sine * radius * perpendicular[1], model.center[2] + cosine * radius * v1[2] + sine * radius * perpendicular[2]];
      tc[0] = i / model.resolution;
      tc[1] = 0;
      points.setPoint(i, ...p);
      tcoords.setTuple(i, tc);
    }
    const pointIds = Array.from({
      length: numPts
    }, (_, i) => i);
    lines.insertNextCell(pointIds);
    output.setPoints(points);
    output.getPointData().setTCoords(tcoords);
    output.setLines(lines);
    outData[0] = output;
  };
}
var DEFAULT_VALUES42 = {
  point1: [0, 0.5, 0],
  point2: [0.5, 0, 0],
  center: [0, 0, 0],
  normal: [0, 0, 1],
  polarVector: [1, 0, 0],
  angle: 90,
  resolution: 6,
  negative: false,
  useNormalAndAngle: false,
  outputPointsPrecision: DesiredOutputPrecision.SINGLE
};
function extend49(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES42, initialValues);
  if (model.resolution < 1) {
    model.resolution = 1;
  }
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 0, 1);
  macro.setGet(publicAPI, model, ["resolution", "angle", "negative", "useNormalAndAngle", "outputPointsPrecision"]);
  macro.setGetArray(publicAPI, model, ["point1", "point2", "center", "normal", "polarVector"], 3);
  vtkArcSource(publicAPI, model);
}
var newInstance49 = macro.newInstance(extend49, "vtkArcSource");
var vtkArcSource$1 = {
  newInstance: newInstance49,
  extend: extend49
};

// node_modules/@kitware/vtk.js/Filters/Sources/ConeSource.js
function vtkConeSource(publicAPI, model) {
  model.classHierarchy.push("vtkConeSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const angle = 2 * Math.PI / model.resolution;
    const xbot = -model.height / 2;
    const numberOfPoints = model.resolution + 1;
    const cellArraySize = 4 * model.resolution + 1 + model.resolution;
    let pointIdx = 0;
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    let cellLocation = 0;
    const polys = new Uint32Array(cellArraySize);
    points[0] = model.height / 2;
    points[1] = 0;
    points[2] = 0;
    if (model.capping) {
      polys[cellLocation++] = model.resolution;
    }
    for (let i = 0; i < model.resolution; i++) {
      pointIdx++;
      points[pointIdx * 3 + 0] = xbot;
      points[pointIdx * 3 + 1] = model.radius * Math.cos(i * angle);
      points[pointIdx * 3 + 2] = model.radius * Math.sin(i * angle);
      if (model.capping) {
        polys[model.resolution - cellLocation++ + 1] = pointIdx;
      }
    }
    for (let i = 0; i < model.resolution; i++) {
      polys[cellLocation++] = 3;
      polys[cellLocation++] = 0;
      polys[cellLocation++] = i + 1;
      polys[cellLocation++] = i + 2 > model.resolution ? 1 : i + 2;
    }
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).apply(points);
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    outData[0] = dataset;
  };
}
var DEFAULT_VALUES43 = {
  height: 1,
  radius: 0.5,
  resolution: 6,
  center: [0, 0, 0],
  direction: [1, 0, 0],
  capping: true,
  pointType: "Float64Array"
};
function extend50(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES43, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "radius", "resolution", "capping"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkConeSource(publicAPI, model);
}
var newInstance50 = macro.newInstance(extend50, "vtkConeSource");
var vtkConeSource$1 = {
  newInstance: newInstance50,
  extend: extend50
};

// node_modules/@kitware/vtk.js/Filters/Sources/CylinderSource.js
function vtkCylinderSource(publicAPI, model) {
  model.classHierarchy.push("vtkCylinderSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const angle = 2 * Math.PI / model.resolution;
    let numberOfPoints = 2 * model.resolution;
    let numberOfPolys = 5 * model.resolution;
    if (model.capping) {
      numberOfPoints = 4 * model.resolution;
      numberOfPolys = 7 * model.resolution + 2;
    }
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    let cellLocation = 0;
    const polys = new Uint32Array(numberOfPolys);
    const normalsData = new Float32Array(numberOfPoints * 3);
    const normals = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: normalsData,
      name: "Normals"
    });
    const tcData = new Float32Array(numberOfPoints * 2);
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcData,
      name: "TCoords"
    });
    const nbot = [0, 0, 0];
    const ntop = [0, 0, 0];
    const xbot = [0, 0, 0];
    const xtop = [0, 0, 0];
    const tcbot = [0, 0];
    const tctop = [0, 0];
    const otherRadius = model.otherRadius == null ? model.radius : model.otherRadius;
    for (let i = 0; i < model.resolution; i++) {
      nbot[0] = Math.cos(i * angle + model.initAngle);
      ntop[0] = nbot[0];
      xbot[0] = model.radius * nbot[0] + model.center[0];
      xtop[0] = xbot[0];
      tcbot[0] = Math.abs(2 * i / model.resolution - 1);
      tctop[0] = tcbot[0];
      xbot[1] = 0.5 * model.height + model.center[1];
      xtop[1] = -0.5 * model.height + model.center[1];
      tcbot[1] = 0;
      tctop[1] = 1;
      nbot[2] = -Math.sin(i * angle + model.initAngle);
      ntop[2] = nbot[2];
      xbot[2] = otherRadius * nbot[2] + model.center[2];
      xtop[2] = xbot[2];
      const pointIdx = 2 * i;
      for (let j = 0; j < 3; j++) {
        normalsData[pointIdx * 3 + j] = nbot[j];
        normalsData[(pointIdx + 1) * 3 + j] = ntop[j];
        points[pointIdx * 3 + j] = xbot[j];
        points[(pointIdx + 1) * 3 + j] = xtop[j];
        if (j < 2) {
          tcData[pointIdx * 2 + j] = tcbot[j];
          tcData[(pointIdx + 1) * 2 + j] = tctop[j];
        }
      }
    }
    for (let i = 0; i < model.resolution; i++) {
      polys[cellLocation++] = 4;
      polys[cellLocation++] = 2 * i;
      polys[cellLocation++] = 2 * i + 1;
      const pt = (2 * i + 3) % (2 * model.resolution);
      polys[cellLocation++] = pt;
      polys[cellLocation++] = pt - 1;
    }
    if (model.capping) {
      for (let i = 0; i < model.resolution; i++) {
        xbot[0] = model.radius * Math.cos(i * angle + model.initAngle);
        xtop[0] = xbot[0];
        tcbot[0] = xbot[0];
        tctop[0] = xbot[0];
        xbot[0] += model.center[0];
        xtop[0] += model.center[0];
        nbot[1] = 1;
        ntop[1] = -1;
        xbot[1] = 0.5 * model.height + model.center[1];
        xtop[1] = -0.5 * model.height + model.center[1];
        xbot[2] = -otherRadius * Math.sin(i * angle + model.initAngle);
        xtop[2] = xbot[2];
        tcbot[1] = xbot[2];
        tctop[1] = xbot[2];
        xbot[2] += model.center[2];
        xtop[2] += model.center[2];
        const botIdx = 2 * model.resolution + i;
        const topIdx = 3 * model.resolution + model.resolution - i - 1;
        for (let j = 0; j < 3; j++) {
          normalsData[3 * botIdx + j] = nbot[j];
          normalsData[3 * topIdx + j] = ntop[j];
          points[3 * botIdx + j] = xbot[j];
          points[3 * topIdx + j] = xtop[j];
          if (j < 2) {
            tcData[2 * botIdx + j] = tcbot[j];
            tcData[2 * topIdx + j] = tctop[j];
          }
        }
      }
      polys[cellLocation++] = model.resolution;
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 2 * model.resolution + i;
      }
      polys[cellLocation++] = model.resolution;
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 3 * model.resolution + i;
      }
    }
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([0, 1, 0], model.direction).translate(...model.center.map((c2) => c2 * -1)).apply(points);
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    dataset.getPointData().setNormals(normals);
    dataset.getPointData().setTCoords(tcoords);
    outData[0] = dataset;
  };
}
var DEFAULT_VALUES44 = {
  height: 1,
  initAngle: 0,
  radius: 1,
  resolution: 6,
  center: [0, 0, 0],
  direction: [0, 1, 0],
  capping: true,
  pointType: "Float64Array"
};
function extend51(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES44, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "initAngle", "otherRadius", "radius", "resolution", "capping"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkCylinderSource(publicAPI, model);
}
var newInstance51 = macro.newInstance(extend51, "vtkCylinderSource");
var vtkCylinderSource$1 = {
  newInstance: newInstance51,
  extend: extend51
};

// node_modules/@kitware/vtk.js/Filters/Sources/ArrowSource.js
function vtkArrowSource(publicAPI, model) {
  model.classHierarchy.push("vtkArrowSource");
  publicAPI.requestData = (inData, outData) => {
    const cylinder = vtkCylinderSource$1.newInstance({
      capping: true
    });
    cylinder.setResolution(model.shaftResolution);
    cylinder.setRadius(model.shaftRadius);
    cylinder.setHeight(1 - model.tipLength);
    cylinder.setCenter(0, (1 - model.tipLength) * 0.5, 0);
    const cylinderPD = cylinder.getOutputData();
    const cylinderPts = cylinderPD.getPoints().getData();
    const cylinderNormals = cylinderPD.getPointData().getNormals().getData();
    vtkMatrixBuilder.buildFromDegree().rotateZ(-90).apply(cylinderPts).apply(cylinderNormals);
    const cone = vtkConeSource$1.newInstance();
    cone.setResolution(model.tipResolution);
    cone.setHeight(model.tipLength);
    cone.setRadius(model.tipRadius);
    const conePD = cone.getOutputData();
    const conePts = conePD.getPoints().getData();
    vtkMatrixBuilder.buildFromRadian().translate(1 - model.tipLength * 0.5, 0, 0).apply(conePts);
    const append = vtkAppendPolyData$1.newInstance();
    append.setInputData(cylinderPD);
    append.addInputData(conePD);
    const appendPD = append.getOutputData();
    const appendPts = appendPD.getPoints().getData();
    vtkMatrixBuilder.buildFromRadian().translate(-0.5 + model.tipLength * 0.5, 0, 0).apply(appendPts);
    if (model.invert) {
      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(-1, -1, -1).apply(appendPts);
      outData[0] = appendPD;
    } else {
      vtkMatrixBuilder.buildFromRadian().rotateFromDirections([1, 0, 0], model.direction).scale(1, 1, 1).apply(appendPts);
      outData[0] = append.getOutputData();
    }
  };
}
var DEFAULT_VALUES45 = {
  tipResolution: 6,
  tipRadius: 0.1,
  tipLength: 0.35,
  shaftResolution: 6,
  shaftRadius: 0.03,
  invert: false,
  direction: [1, 0, 0],
  pointType: "Float64Array"
};
function extend52(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES45, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["tipResolution", "tipRadius", "tipLength", "shaftResolution", "shaftRadius", "invert"]);
  macro.setGetArray(publicAPI, model, ["direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkArrowSource(publicAPI, model);
}
var newInstance52 = macro.newInstance(extend52, "vtkArrowSource");
var vtkArrowSource$1 = {
  newInstance: newInstance52,
  extend: extend52
};

// node_modules/@kitware/vtk.js/Filters/Sources/CircleSource.js
function vtkCircleSource(publicAPI, model) {
  model.classHierarchy.push("vtkCircleSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    const points = macro.newTypedArray(model.pointType, model.resolution * 3);
    const edges = new Uint32Array(model.resolution + 2);
    edges[0] = model.resolution + 1;
    const angle = 2 * Math.PI / model.resolution;
    for (let i = 0; i < model.resolution; i++) {
      const x = model.center[0];
      const y = model.radius * Math.cos(i * angle) + model.center[1];
      const z = model.radius * Math.sin(i * angle) + model.center[2];
      points.set([x, y, z], i * 3);
      edges[i + 1] = i;
    }
    edges[edges.length - 1] = edges[1];
    dataset.getPoints().setData(points, 3);
    if (model.lines) {
      dataset.getLines().setData(edges, 1);
    }
    if (model.face) {
      dataset.getPolys().setData(edges, 1);
    }
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).translate(...multiplyScalar([...model.center], -1)).apply(points);
    outData[0] = dataset;
  };
}
function defaultValues8(initialValues) {
  return {
    face: true,
    center: [0, 0, 0],
    lines: false,
    direction: [1, 0, 0],
    pointType: "Float64Array",
    radius: 1,
    resolution: 6,
    ...initialValues
  };
}
function extend53(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues8(initialValues));
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["radius", "resolution", "lines", "face"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkCircleSource(publicAPI, model);
}
var newInstance53 = macro.newInstance(extend53, "vtkCircleSource");
var vtkCircleSource$1 = {
  newInstance: newInstance53,
  extend: extend53
};

// node_modules/@kitware/vtk.js/Filters/Sources/ConcentricCylinderSource.js
function vtkConcentricCylinderSource(publicAPI, model) {
  model.classHierarchy.push("vtkConcentricCylinderSource");
  function validateCellFields() {
    while (model.cellFields.length < model.radius.length) {
      model.cellFields.push(model.cellFields.length);
    }
  }
  publicAPI.clearRadius = () => {
    model.radius = [];
    model.cellFields = [];
    publicAPI.modified();
  };
  publicAPI.addRadius = (radius, cellField) => {
    model.radius.push(radius);
    if (cellField !== void 0) {
      model.cellFields.push(cellField);
    }
    validateCellFields();
    publicAPI.modified();
  };
  publicAPI.getNumberOfRadius = () => model.radius.length;
  publicAPI.getRadius = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.radius[index];
  };
  publicAPI.setRadius = (index, radius) => {
    model.radius[index] = radius;
    publicAPI.modified();
  };
  publicAPI.setCellField = (index, field) => {
    model.cellFields[index] = field;
    publicAPI.modified();
  };
  publicAPI.removeMask = () => {
    model.mask = null;
    publicAPI.modified();
  };
  publicAPI.setMaskLayer = (index, hidden) => {
    let changeDetected = false;
    if (!model.mask && hidden) {
      changeDetected = true;
      model.mask = [];
    }
    if (model.mask) {
      if (!model.mask[index] !== !hidden) {
        changeDetected = true;
      }
      model.mask[index] = hidden;
    }
    if (changeDetected) {
      publicAPI.modified();
    }
  };
  publicAPI.getMaskLayer = (index) => index === void 0 ? model.mask : model.mask[index];
  publicAPI.requestData = (inData, outData) => {
    var _a;
    if (!model.radius.length) {
      macro.vtkErrorMacro("No radius defined");
      return;
    }
    validateCellFields();
    const numLayers = model.radius.length;
    const zRef = model.height / 2;
    let cellArraySize = 0;
    let numCells = 0;
    let startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;
    startTheta *= Math.PI / 180;
    let endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;
    endTheta *= Math.PI / 180;
    let thetaResolution = model.resolution;
    let partialDisk = false;
    if (endTheta >= startTheta + 2 * Math.PI) {
      endTheta = startTheta + 2 * Math.PI;
    } else {
      ++thetaResolution;
      partialDisk = true;
    }
    const deltaTheta = (endTheta - startTheta) / model.resolution;
    const numberOfPoints = thetaResolution * numLayers * 2 + 2;
    if (!model.skipInnerFaces && !model.mask) {
      cellArraySize = 2 * (thetaResolution + 1) + 5 * thetaResolution + (numLayers - 1) * thetaResolution * 20 + (partialDisk ? 10 * numLayers : 0);
      numCells = 2 + thetaResolution + (numLayers - 1) * 4 * thetaResolution + (partialDisk ? 2 * numLayers : 0);
    } else if (!model.skipInnerFaces && model.mask) {
      if (!model.mask[0]) {
        cellArraySize += 2 * (thetaResolution + 1) + 5 * thetaResolution + (partialDisk ? 10 : 0);
        numCells += 2 + thetaResolution + (partialDisk ? 2 : 0);
      }
      for (let layer = 1; layer < numLayers; layer++) {
        if (!model.mask[layer]) {
          cellArraySize += thetaResolution * 20 + (partialDisk ? 10 : 0);
          numCells += 4 * thetaResolution + (partialDisk ? 2 : 0);
        }
      }
    } else {
      if (!model.skipInnerFaces || !model.mask || !model.mask[0]) {
        cellArraySize += 2 * (thetaResolution + 1) + (partialDisk ? 10 : 0);
        numCells += 2 + (partialDisk ? 2 : 0);
        if (model.radius.length === 1 || !model.skipInnerFaces || model.mask && model.mask[1]) {
          cellArraySize += 5 * thetaResolution;
          numCells += thetaResolution;
        }
      }
      for (let layer = 1; layer < numLayers; layer++) {
        if (!model.skipInnerFaces || !model.mask || !model.mask[layer]) {
          const lastLayer = numLayers - 1 === layer;
          cellArraySize += thetaResolution * 10 + (partialDisk ? 10 : 0);
          numCells += thetaResolution * 2 + (partialDisk ? 2 : 0);
          if (!model.skipInnerFaces || model.mask && model.mask[layer - 1]) {
            cellArraySize += thetaResolution * 5;
            numCells += thetaResolution;
          }
          if (lastLayer || !model.skipInnerFaces || model.mask && model.mask[layer + 1]) {
            cellArraySize += thetaResolution * 5;
            numCells += thetaResolution;
          }
        }
      }
    }
    let pointIdx = 0;
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    let cellLocation = 0;
    const polys = new Uint32Array(cellArraySize);
    let fieldLocation = 0;
    const field = new Float32Array(numCells);
    points[pointIdx * 3 + 0] = 0;
    points[pointIdx * 3 + 1] = 0;
    points[pointIdx * 3 + 2] = zRef;
    pointIdx++;
    points[pointIdx * 3 + 0] = 0;
    points[pointIdx * 3 + 1] = 0;
    points[pointIdx * 3 + 2] = -zRef;
    pointIdx++;
    for (let layer = 0; layer < numLayers; layer++) {
      const radius = model.radius[layer];
      for (let i = 0; i < thetaResolution; i++) {
        const theta = startTheta + i * deltaTheta;
        points[pointIdx * 3 + 0] = radius * Math.cos(theta);
        points[pointIdx * 3 + 1] = radius * Math.sin(theta);
        points[pointIdx * 3 + 2] = zRef;
        pointIdx++;
      }
      for (let i = 0; i < thetaResolution; i++) {
        const theta = startTheta + i * deltaTheta;
        points[pointIdx * 3 + 0] = radius * Math.cos(theta);
        points[pointIdx * 3 + 1] = radius * Math.sin(theta);
        points[pointIdx * 3 + 2] = -zRef;
        pointIdx++;
      }
    }
    let currentField = model.cellFields[0];
    if (!model.mask || !model.mask[0]) {
      field[fieldLocation++] = currentField;
      polys[cellLocation++] = thetaResolution + (partialDisk ? 1 : 0);
      if (partialDisk) polys[cellLocation++] = 0;
      for (let i = 0; i < thetaResolution; i++) {
        polys[cellLocation++] = i + 2;
      }
      field[fieldLocation++] = currentField;
      polys[cellLocation++] = thetaResolution + (partialDisk ? 1 : 0);
      if (partialDisk) polys[cellLocation++] = 1;
      for (let i = 0; i < thetaResolution; i++) {
        polys[cellLocation++] = 2 * thetaResolution - i - 1 + 2;
      }
      if (!model.skipInnerFaces || model.mask && model.mask[1] || numLayers === 1) {
        for (let i = 0; i < model.resolution; i++) {
          polys[cellLocation++] = 4;
          polys[cellLocation++] = (i + 1) % thetaResolution + 2;
          polys[cellLocation++] = i + 2;
          polys[cellLocation++] = i + thetaResolution + 2;
          polys[cellLocation++] = (i + 1) % thetaResolution + thetaResolution + 2;
          field[fieldLocation++] = currentField;
        }
      }
      if (partialDisk) {
        polys[cellLocation++] = 4;
        polys[cellLocation++] = 2;
        polys[cellLocation++] = 0;
        polys[cellLocation++] = 1;
        polys[cellLocation++] = thetaResolution + 2;
        field[fieldLocation++] = currentField;
        polys[cellLocation++] = 4;
        polys[cellLocation++] = 0;
        polys[cellLocation++] = thetaResolution + 1;
        polys[cellLocation++] = 2 * thetaResolution + 1;
        polys[cellLocation++] = 1;
        field[fieldLocation++] = currentField;
      }
    }
    for (let layer = 1; layer < numLayers; layer++) {
      if (model.mask && model.mask[layer]) {
        continue;
      }
      const offset = thetaResolution * 2 * (layer - 1) + 2;
      const a2 = offset + 2 * thetaResolution;
      const lastLayer = numLayers - 1 === layer;
      currentField = model.cellFields[layer];
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 4;
        polys[cellLocation++] = i + offset;
        polys[cellLocation++] = (i + 1) % thetaResolution + offset;
        polys[cellLocation++] = (i + 1) % thetaResolution + a2;
        polys[cellLocation++] = i + a2;
        field[fieldLocation++] = currentField;
      }
      for (let i = 0; i < model.resolution; i++) {
        polys[cellLocation++] = 4;
        polys[cellLocation++] = (i + 1) % thetaResolution + offset + thetaResolution;
        polys[cellLocation++] = i + offset + thetaResolution;
        polys[cellLocation++] = i + a2 + thetaResolution;
        polys[cellLocation++] = (i + 1) % thetaResolution + a2 + thetaResolution;
        field[fieldLocation++] = currentField;
      }
      if (!model.skipInnerFaces || model.mask && model.mask[layer - 1]) {
        for (let i = 0; i < model.resolution; i++) {
          polys[cellLocation++] = 4;
          polys[cellLocation++] = i + offset;
          polys[cellLocation++] = (i + 1) % thetaResolution + offset;
          polys[cellLocation++] = (i + 1) % thetaResolution + thetaResolution + offset;
          polys[cellLocation++] = i + thetaResolution + offset;
          field[fieldLocation++] = currentField;
        }
      }
      if (!model.skipInnerFaces || lastLayer || model.mask && (model.mask[layer + 1] || lastLayer)) {
        for (let i = 0; i < model.resolution; i++) {
          polys[cellLocation++] = 4;
          polys[cellLocation++] = (i + 1) % thetaResolution + a2;
          polys[cellLocation++] = i + a2;
          polys[cellLocation++] = i + thetaResolution + a2;
          polys[cellLocation++] = (i + 1) % thetaResolution + thetaResolution + a2;
          field[fieldLocation++] = currentField;
        }
      }
      if (partialDisk) {
        polys[cellLocation++] = 4;
        polys[cellLocation++] = a2;
        polys[cellLocation++] = offset;
        polys[cellLocation++] = thetaResolution + offset;
        polys[cellLocation++] = thetaResolution + a2;
        field[fieldLocation++] = currentField;
        polys[cellLocation++] = 4;
        polys[cellLocation++] = model.resolution + a2;
        polys[cellLocation++] = model.resolution + offset;
        polys[cellLocation++] = model.resolution + thetaResolution + offset;
        polys[cellLocation++] = model.resolution + thetaResolution + a2;
        field[fieldLocation++] = currentField;
      }
    }
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([0, 0, 1], model.direction).apply(points);
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    dataset.getCellData().setScalars(vtkDataArray$1.newInstance({
      name: "layer",
      values: field
    }));
    outData[0] = dataset;
  };
}
var DEFAULT_VALUES46 = {
  height: 1,
  radius: [0.5],
  cellFields: [1],
  resolution: 6,
  startTheta: 0,
  endTheta: 360,
  center: [0, 0, 0],
  direction: [0, 0, 1],
  skipInnerFaces: true,
  mask: null,
  // If present, array to know if a layer should be skipped(=true)
  pointType: "Float64Array"
};
function extend54(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES46, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "resolution", "startTheta", "endTheta", "skipInnerFaces"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.getArray(publicAPI, model, ["cellFields"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkConcentricCylinderSource(publicAPI, model);
}
var newInstance54 = macro.newInstance(extend54, "vtkConcentricCylinderSource");
var vtkConcentricCylinderSource$1 = {
  newInstance: newInstance54,
  extend: extend54
};

// node_modules/@kitware/vtk.js/Filters/Sources/CubeSource.js
var LINE_ARRAY2 = [2, 0, 1, 2, 2, 3, 2, 4, 5, 2, 6, 7, 2, 0, 2, 2, 1, 3, 2, 4, 6, 2, 5, 7, 2, 0, 4, 2, 1, 5, 2, 2, 6, 2, 3, 7];
var POLY_ARRAY = [4, 0, 1, 3, 2, 4, 4, 6, 7, 5, 4, 8, 10, 11, 9, 4, 12, 13, 15, 14, 4, 16, 18, 19, 17, 4, 20, 21, 23, 22];
function vtkCubeSource(publicAPI, model) {
  model.classHierarchy.push("vtkCubeSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const polyData = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    outData[0] = polyData;
    const numberOfPoints = 24;
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    polyData.getPoints().setData(points, 3);
    const normals = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    const normalArray = vtkDataArray$1.newInstance({
      name: "Normals",
      values: normals,
      numberOfComponents: 3
    });
    polyData.getPointData().setNormals(normalArray);
    let tcdim = 2;
    if (model.generate3DTextureCoordinates === true) {
      tcdim = 3;
    }
    const textureCoords = macro.newTypedArray(model.pointType, numberOfPoints * tcdim);
    const tcoords = vtkDataArray$1.newInstance({
      name: "TextureCoordinates",
      values: textureCoords,
      numberOfComponents: tcdim
    });
    polyData.getPointData().setTCoords(tcoords);
    const x = [0, 0, 0];
    const n = [0, 0, 0];
    const tc = [0, 0];
    let pointIndex = 0;
    x[0] = -model.xLength / 2;
    n[0] = -1;
    n[1] = 0;
    n[2] = 0;
    for (let i = 0; i < 2; i++) {
      x[1] = -model.yLength / 2;
      for (let j = 0; j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[2] = -model.zLength / 2;
        for (let k = 0; k < 2; k++) {
          tc[0] = (x[2] + 0.5) * (1 - 2 * i);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[1] += model.yLength;
      }
      x[0] += model.xLength;
      n[0] += 2;
    }
    x[1] = -model.yLength / 2;
    n[1] = -1;
    n[0] = 0;
    n[2] = 0;
    for (let i = 0; i < 2; i++) {
      x[0] = -model.xLength / 2;
      for (let j = 0; j < 2; j++) {
        tc[0] = (x[0] + 0.5) * (2 * i - 1);
        x[2] = -model.zLength / 2;
        for (let k = 0; k < 2; k++) {
          tc[1] = (x[2] + 0.5) * -1;
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[0] += model.xLength;
      }
      x[1] += model.yLength;
      n[1] += 2;
    }
    x[2] = -model.zLength / 2;
    n[2] = -1;
    n[0] = 0;
    n[1] = 0;
    for (let i = 0; i < 2; i++) {
      x[1] = -model.yLength / 2;
      for (let j = 0; j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[0] = -model.xLength / 2;
        for (let k = 0; k < 2; k++) {
          tc[0] = (x[0] + 0.5) * (2 * i - 1);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * k - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * i - 1;
          }
          pointIndex++;
          x[0] += model.xLength;
        }
        x[1] += model.yLength;
      }
      x[2] += model.zLength;
      n[2] += 2;
    }
    if (model.rotations) {
      vtkMatrixBuilder.buildFromDegree().rotateX(model.rotations[0]).rotateY(model.rotations[1]).rotateZ(model.rotations[2]).apply(points).apply(normals);
    }
    if (model.center) {
      vtkMatrixBuilder.buildFromRadian().translate(...model.center).apply(points);
    }
    if (model.matrix) {
      vtkMatrixBuilder.buildFromRadian().setMatrix(model.matrix).apply(points);
      const rotMatrix = [model.matrix[0], model.matrix[1], model.matrix[2], 0, model.matrix[4], model.matrix[5], model.matrix[6], 0, model.matrix[8], model.matrix[9], model.matrix[10], 0, 0, 0, 0, 1];
      vtkMatrixBuilder.buildFromRadian().setMatrix(rotMatrix).apply(normals);
    }
    if (model.generateFaces) {
      polyData.getPolys().deepCopy(model._polys);
    } else {
      polyData.getPolys().initialize();
    }
    if (model.generateLines) {
      polyData.getLines().deepCopy(model._lineCells);
      polyData.getPointData().setNormals(null);
    } else {
      polyData.getLines().initialize();
    }
    polyData.modified();
  };
  publicAPI.setBounds = function() {
    let boundsArray = [];
    if (Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      boundsArray = arguments.length <= 0 ? void 0 : arguments[0];
    } else {
      for (let i = 0; i < arguments.length; i++) {
        boundsArray.push(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
      }
    }
    if (boundsArray.length !== 6) {
      return;
    }
    publicAPI.setXLength(boundsArray[1] - boundsArray[0]);
    publicAPI.setYLength(boundsArray[3] - boundsArray[2]);
    publicAPI.setZLength(boundsArray[5] - boundsArray[4]);
    publicAPI.setCenter([(boundsArray[0] + boundsArray[1]) / 2, (boundsArray[2] + boundsArray[3]) / 2, (boundsArray[4] + boundsArray[5]) / 2]);
  };
}
var DEFAULT_VALUES47 = {
  xLength: 1,
  yLength: 1,
  zLength: 1,
  pointType: "Float64Array",
  generate3DTextureCoordinates: false,
  generateFaces: true,
  generateLines: false
};
function extend55(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES47, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["xLength", "yLength", "zLength", "generate3DTextureCoordinates", "generateFaces", "generateLines"]);
  macro.setGetArray(publicAPI, model, ["center", "rotations"], 3);
  macro.setGetArray(publicAPI, model, ["matrix"], 16);
  model._polys = vtkCellArray$1.newInstance({
    values: Uint16Array.from(POLY_ARRAY)
  });
  model._lineCells = vtkCellArray$1.newInstance({
    values: Uint16Array.from(LINE_ARRAY2)
  });
  macro.moveToProtected(publicAPI, model, ["polys", "lineCells"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkCubeSource(publicAPI, model);
}
var newInstance55 = macro.newInstance(extend55, "vtkCubeSource");
var vtkCubeSource$1 = {
  newInstance: newInstance55,
  extend: extend55
};

// node_modules/@kitware/vtk.js/Filters/Sources/Cursor3D.js
function vtkCursor3D(publicAPI, model) {
  model.classHierarchy.push("vtkCursor3D");
  publicAPI.setModelBounds = (bounds2) => {
    if (!Array.isArray(bounds2) || bounds2.length < 6) {
      return;
    }
    if (model.modelBounds[0] === bounds2[0] && model.modelBounds[1] === bounds2[1] && model.modelBounds[2] === bounds2[2] && model.modelBounds[3] === bounds2[3] && model.modelBounds[4] === bounds2[4] && model.modelBounds[5] === bounds2[5]) {
      return;
    }
    publicAPI.modified();
    model.modelBounds = bounds2.map((v) => Number(v));
    for (let i = 0; i < 3; ++i) {
      model.modelBounds[2 * i] = Math.min(model.modelBounds[2 * i], model.modelBounds[2 * i + 1]);
    }
  };
  publicAPI.setFocalPoint = (points) => {
    if (!Array.isArray(points) || points.length < 3) {
      return;
    }
    if (points[0] === model.focalPoint[0] && points[1] === model.focalPoint[1] && points[2] === model.focalPoint[2]) {
      return;
    }
    publicAPI.modified();
    const v = [];
    for (let i = 0; i < 3; i++) {
      v[i] = points[i] - model.focalPoint[i];
      model.focalPoint[i] = Number(points[i]);
      if (model.translationMode) {
        model.modelBounds[2 * i] += v[i];
        model.modelBounds[2 * i + 1] += v[i];
      } else if (model.wrap) {
        model.focalPoint[i] = model.modelBounds[2 * i] + (model.focalPoint[i] - model.modelBounds[2 * i]) * 1 % ((model.modelBounds[2 * i + 1] - model.modelBounds[2 * i]) * 1);
      } else {
        if (points[i] < model.modelBounds[2 * i]) {
          model.focalPoint[i] = model.modelBounds[2 * i];
        }
        if (points[i] > model.modelBounds[2 * i + 1]) {
          model.focalPoint[i] = model.modelBounds[2 * i + 1];
        }
      }
    }
  };
  publicAPI.setAll = (flag) => {
    publicAPI.setOutline(flag);
    publicAPI.setAxes(flag);
    publicAPI.setXShadows(flag);
    publicAPI.setYShadows(flag);
    publicAPI.setZShadows(flag);
  };
  publicAPI.allOn = () => {
    publicAPI.setAll(true);
  };
  publicAPI.allOff = () => {
    publicAPI.setAll(false);
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    let numPts = 0;
    let numLines = 0;
    if (model.wrap) {
      for (let i = 0; i < model.focalPoint.length; ++i) {
        model.focalPoint[i] = model.modelBounds[2 * i] + (model.focalPoint[i] - model.modelBounds[2 * i]) * 1 % (model.modelBounds[2 * i + 1] - model.modelBounds[2 * i]);
      }
    } else {
      for (let i = 0; i < model.focalPoint.length; ++i) {
        model.focalPoint[i] = Math.max(model.focalPoint[i], model.modelBounds[2 * i]);
        model.focalPoint[i] = Math.min(model.focalPoint[i], model.modelBounds[2 * i + 1]);
      }
    }
    if (model.axes) {
      numPts += 6;
      numLines += 3;
    }
    if (model.outline) {
      numPts += 8;
      numLines += 12;
    }
    if (model.xShadows) {
      numPts += 8;
      numLines += 4;
    }
    if (model.yShadows) {
      numPts += 8;
      numLines += 4;
    }
    if (model.zShadows) {
      numPts += 8;
      numLines += 4;
    }
    if (numPts === 0) {
      return;
    }
    const polyData = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    const newPts = vtkPoints$1.newInstance({
      size: numPts * 3
    });
    const newLines = vtkCellArray$1.newInstance({
      size: numLines * (2 + 1)
    });
    let pid = 0;
    let cid = 0;
    if (model.axes) {
      newPts.getData()[pid * 3 + 0] = model.modelBounds[0];
      newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
      newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[1];
      newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
      newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
      ++pid;
      newLines.getData()[cid * 3 + 0] = 2;
      newLines.getData()[cid * 3 + 1] = pid - 2;
      newLines.getData()[cid * 3 + 2] = pid - 1;
      ++cid;
      newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[2];
      newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[3];
      newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
      ++pid;
      newLines.getData()[cid * 3 + 0] = 2;
      newLines.getData()[cid * 3 + 1] = pid - 2;
      newLines.getData()[cid * 3 + 2] = pid - 1;
      ++cid;
      newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
      newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[4];
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
      newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[5];
      ++pid;
      newLines.getData()[cid * 3 + 0] = 2;
      newLines.getData()[cid * 3 + 1] = pid - 2;
      newLines.getData()[cid * 3 + 2] = pid - 1;
      ++cid;
    }
    if (model.outline) {
      newPts.getData()[pid * 3 + 0] = model.modelBounds[0];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[2];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[4];
      const corner024 = pid;
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[1];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[2];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[4];
      const corner124 = pid;
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[0];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[3];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[4];
      const corner034 = pid;
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[0];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[2];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[5];
      const corner025 = pid;
      ++pid;
      newLines.getData()[(cid + 0) * 3 + 0] = 2;
      newLines.getData()[(cid + 0) * 3 + 1] = corner024;
      newLines.getData()[(cid + 0) * 3 + 2] = corner124;
      newLines.getData()[(cid + 1) * 3 + 0] = 2;
      newLines.getData()[(cid + 1) * 3 + 1] = corner024;
      newLines.getData()[(cid + 1) * 3 + 2] = corner034;
      newLines.getData()[(cid + 2) * 3 + 0] = 2;
      newLines.getData()[(cid + 2) * 3 + 1] = corner024;
      newLines.getData()[(cid + 2) * 3 + 2] = corner025;
      cid += 3;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[1];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[3];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[5];
      const corner135 = pid;
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[0];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[3];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[5];
      const corner035 = pid;
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[1];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[2];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[5];
      const corner125 = pid;
      ++pid;
      newPts.getData()[pid * 3 + 0] = model.modelBounds[1];
      newPts.getData()[pid * 3 + 1] = model.modelBounds[3];
      newPts.getData()[pid * 3 + 2] = model.modelBounds[4];
      const corner134 = pid;
      ++pid;
      newLines.getData()[(cid + 0) * 3 + 0] = 2;
      newLines.getData()[(cid + 0) * 3 + 1] = corner135;
      newLines.getData()[(cid + 0) * 3 + 2] = corner035;
      newLines.getData()[(cid + 1) * 3 + 0] = 2;
      newLines.getData()[(cid + 1) * 3 + 1] = corner135;
      newLines.getData()[(cid + 1) * 3 + 2] = corner125;
      newLines.getData()[(cid + 2) * 3 + 0] = 2;
      newLines.getData()[(cid + 2) * 3 + 1] = corner135;
      newLines.getData()[(cid + 2) * 3 + 2] = corner134;
      cid += 3;
      newLines.getData()[(cid + 0) * 3 + 0] = 2;
      newLines.getData()[(cid + 0) * 3 + 1] = corner124;
      newLines.getData()[(cid + 0) * 3 + 2] = corner134;
      newLines.getData()[(cid + 1) * 3 + 0] = 2;
      newLines.getData()[(cid + 1) * 3 + 1] = corner124;
      newLines.getData()[(cid + 1) * 3 + 2] = corner125;
      cid += 2;
      newLines.getData()[(cid + 0) * 3 + 0] = 2;
      newLines.getData()[(cid + 0) * 3 + 1] = corner034;
      newLines.getData()[(cid + 0) * 3 + 2] = corner134;
      newLines.getData()[(cid + 1) * 3 + 0] = 2;
      newLines.getData()[(cid + 1) * 3 + 1] = corner034;
      newLines.getData()[(cid + 1) * 3 + 2] = corner035;
      cid += 2;
      newLines.getData()[(cid + 0) * 3 + 0] = 2;
      newLines.getData()[(cid + 0) * 3 + 1] = corner025;
      newLines.getData()[(cid + 0) * 3 + 2] = corner125;
      newLines.getData()[(cid + 1) * 3 + 0] = 2;
      newLines.getData()[(cid + 1) * 3 + 1] = corner025;
      newLines.getData()[(cid + 1) * 3 + 2] = corner035;
      cid += 2;
    }
    if (model.xShadows) {
      for (let i = 0; i < 2; ++i) {
        newPts.getData()[pid * 3 + 0] = model.modelBounds[i];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[2];
        newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
        ++pid;
        newPts.getData()[pid * 3 + 0] = model.modelBounds[i];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[3];
        newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
        ++pid;
        newLines.getData()[cid * 3 + 0] = 2;
        newLines.getData()[cid * 3 + 1] = pid - 2;
        newLines.getData()[cid * 3 + 2] = pid - 1;
        ++cid;
        newPts.getData()[pid * 3 + 0] = model.modelBounds[i];
        newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[4];
        ++pid;
        newPts.getData()[pid * 3 + 0] = model.modelBounds[i];
        newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[5];
        ++pid;
        newLines.getData()[cid * 3 + 0] = 2;
        newLines.getData()[cid * 3 + 1] = pid - 2;
        newLines.getData()[cid * 3 + 2] = pid - 1;
        ++cid;
      }
    }
    if (model.yShadows) {
      for (let i = 0; i < 2; ++i) {
        newPts.getData()[pid * 3 + 0] = model.modelBounds[0];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[i + 2];
        newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
        ++pid;
        newPts.getData()[pid * 3 + 0] = model.modelBounds[1];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[i + 2];
        newPts.getData()[pid * 3 + 2] = model.focalPoint[2];
        ++pid;
        newLines.getData()[cid * 3 + 0] = 2;
        newLines.getData()[cid * 3 + 1] = pid - 2;
        newLines.getData()[cid * 3 + 2] = pid - 1;
        ++cid;
        newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[i + 2];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[4];
        ++pid;
        newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[i + 2];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[5];
        ++pid;
        newLines.getData()[cid * 3 + 0] = 2;
        newLines.getData()[cid * 3 + 1] = pid - 2;
        newLines.getData()[cid * 3 + 2] = pid - 1;
        ++cid;
      }
    }
    if (model.zShadows) {
      for (let i = 0; i < 2; ++i) {
        newPts.getData()[pid * 3 + 0] = model.modelBounds[0];
        newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[i + 4];
        ++pid;
        newPts.getData()[pid * 3 + 0] = model.modelBounds[1];
        newPts.getData()[pid * 3 + 1] = model.focalPoint[1];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[i + 4];
        ++pid;
        newLines.getData()[cid * 3 + 0] = 2;
        newLines.getData()[cid * 3 + 1] = pid - 2;
        newLines.getData()[cid * 3 + 2] = pid - 1;
        ++cid;
        newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[2];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[i + 4];
        ++pid;
        newPts.getData()[pid * 3 + 0] = model.focalPoint[0];
        newPts.getData()[pid * 3 + 1] = model.modelBounds[3];
        newPts.getData()[pid * 3 + 2] = model.modelBounds[i + 4];
        ++pid;
        newLines.getData()[cid * 3 + 0] = 2;
        newLines.getData()[cid * 3 + 1] = pid - 2;
        newLines.getData()[cid * 3 + 2] = pid - 1;
        ++cid;
      }
    }
    const pts = vtkPoints$1.newInstance({
      size: 3
    });
    pts.getData()[0] = model.focalPoint[0];
    pts.getData()[1] = model.focalPoint[1];
    pts.getData()[2] = model.focalPoint[2];
    model.focus = vtkPolyData$1.newInstance();
    model.focus.setPoints(pts);
    polyData.setPoints(newPts);
    polyData.setLines(newLines);
    outData[0] = polyData;
  };
}
var DEFAULT_VALUES48 = {
  focus: null,
  modelBounds: [-1, 1, -1, 1, -1, 1],
  focalPoint: [0, 0, 0],
  outline: true,
  axes: true,
  xShadows: true,
  yShadows: true,
  zShadows: true,
  wrap: false,
  translationMode: false
};
function extend56(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES48, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["focus"]);
  macro.getArray(publicAPI, model, ["modelBounds"], 6);
  macro.getArray(publicAPI, model, ["focalPoint"], 3);
  macro.setGet(publicAPI, model, ["outline"]);
  macro.setGet(publicAPI, model, ["axes"]);
  macro.setGet(publicAPI, model, ["xShadows"]);
  macro.setGet(publicAPI, model, ["yShadows"]);
  macro.setGet(publicAPI, model, ["zShadows"]);
  macro.setGet(publicAPI, model, ["wrap"]);
  macro.setGet(publicAPI, model, ["translationMode"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkCursor3D(publicAPI, model);
}
var newInstance56 = macro.newInstance(extend56, "vtkCursor3D");
var vtkCursor3D$1 = {
  newInstance: newInstance56,
  extend: extend56
};

// node_modules/@kitware/vtk.js/Filters/Sources/DiskSource.js
var {
  vtkErrorMacro: vtkErrorMacro32
} = macro;
function vtkDiskSource(publicAPI, model) {
  model.classHierarchy.push("vtkDiskSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const {
      innerRadius,
      outerRadius,
      center,
      normal,
      radialResolution,
      circumferentialResolution,
      pointType
    } = model;
    const points = vtkPoints$1.newInstance({
      dataType: pointType
    });
    const n = [normal[0], normal[1], normal[2]];
    const length = Math.hypot(n[0], n[1], n[2]);
    if (length === 0) {
      vtkErrorMacro32("Normal vector cannot be zero-length");
      return;
    }
    n[0] /= length;
    n[1] /= length;
    n[2] /= length;
    const matrix = vtkMatrixBuilder.buildFromDegree().identity().translate(-center[0], -center[1], -center[2]).rotateFromDirections([0, 0, 1], n).translate(center[0], center[1], center[2]).getMatrix();
    const polys = vtkCellArray$1.newInstance();
    const deltaR = (outerRadius - innerRadius) / radialResolution;
    const thetaStep = 2 * Math.PI / circumferentialResolution;
    for (let i = 0; i < circumferentialResolution; i++) {
      const theta = i * thetaStep;
      const cosT = Math.cos(theta);
      const sinT = Math.sin(theta);
      for (let j = 0; j <= radialResolution; j++) {
        const r = innerRadius + j * deltaR;
        const localPoint = [center[0] + r * cosT, center[1] + r * sinT, center[2]];
        const x = matrix[0] * localPoint[0] + matrix[4] * localPoint[1] + matrix[8] * localPoint[2] + matrix[12];
        const y = matrix[1] * localPoint[0] + matrix[5] * localPoint[1] + matrix[9] * localPoint[2] + matrix[13];
        const z = matrix[2] * localPoint[0] + matrix[6] * localPoint[1] + matrix[10] * localPoint[2] + matrix[14];
        points.insertNextPoint(x, y, z);
      }
    }
    const cellCount = radialResolution * circumferentialResolution;
    const cellData = new Uint8Array(cellCount * 5);
    let offset = 0;
    for (let i = 0; i < model.circumferentialResolution; i++) {
      for (let j = 0; j < model.radialResolution; j++) {
        const p0 = i * (model.radialResolution + 1) + j;
        const p1 = p0 + 1;
        const p2 = i < model.circumferentialResolution - 1 ? p1 + (model.radialResolution + 1) : j + 1;
        const p3 = p2 - 1;
        cellData[offset++] = 4;
        cellData[offset++] = p0;
        cellData[offset++] = p1;
        cellData[offset++] = p2;
        cellData[offset++] = p3;
      }
    }
    polys.setData(cellData, cellCount, 1);
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    dataset.setPoints(points);
    dataset.setPolys(polys);
    outData[0] = dataset;
  };
}
function defaultValues9(initialValues) {
  return {
    innerRadius: 0.25,
    outerRadius: 0.5,
    center: [0, 0, 0],
    normal: [0, 0, 1],
    radialResolution: 1,
    circumferentialResolution: 6,
    pointType: "Float64Array",
    ...initialValues
  };
}
function extend57(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues9(initialValues));
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["innerRadius", "outerRadius", "radialResolution", "circumferentialResolution", "pointType"]);
  macro.setGetArray(publicAPI, model, ["center", "normal"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkDiskSource(publicAPI, model);
}
var newInstance57 = macro.newInstance(extend57, "vtkDiskSource");
var vtkDiskSource$1 = {
  newInstance: newInstance57,
  extend: extend57
};

// node_modules/@kitware/vtk.js/Filters/Sources/EllipseArcSource.js
var {
  vtkErrorMacro: vtkErrorMacro33
} = macro;
var {
  VtkDataTypes: VtkDataTypes3
} = vtkDataArray$1;
function vtkEllipseArcSource(publicAPI, model) {
  model.classHierarchy.push("vtkEllipseArcSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const isClosedShape = Math.abs(model.segmentAngle - 360) < 1e-5;
    const resolution = model.close && !isClosedShape ? model.resolution + 1 : model.resolution;
    const numLines = resolution;
    const numPts = resolution + 1;
    const tc = [0, 0];
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    const normal = [...model.normal];
    vtkMath.normalize(normal);
    const orthogonalVect = [0, 0, 0];
    vtkMath.cross(normal, model.majorRadiusVector, orthogonalVect);
    if (vtkMath.norm(orthogonalVect) < 1e-10) {
      vtkErrorMacro33("Ellipse normal vector and major radius axis are collinear");
      return;
    }
    vtkMath.normalize(orthogonalVect);
    const majorRadiusVect = [0, 0, 0];
    vtkMath.cross(orthogonalVect, normal, majorRadiusVect);
    vtkMath.normalize(majorRadiusVect);
    const a2 = vtkMath.norm(model.majorRadiusVector);
    const b2 = a2 * model.ratio;
    let startAngleRad = vtkMath.radiansFromDegrees(model.startAngle);
    if (startAngleRad < 0) {
      startAngleRad += 2 * Math.PI;
    }
    const segmentAngleRad = vtkMath.radiansFromDegrees(model.segmentAngle);
    const angleIncRad = segmentAngleRad / model.resolution;
    let pointType = VtkDataTypes3.FLOAT;
    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
      pointType = VtkDataTypes3.FLOAT;
    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
      pointType = VtkDataTypes3.DOUBLE;
    }
    const points = vtkPoints$1.newInstance({
      dataType: pointType
    });
    points.setNumberOfPoints(numPts);
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      size: numPts * 2,
      dataType: VtkDataTypes3.FLOAT,
      name: "TextureCoordinates"
    });
    const lines = vtkCellArray$1.newInstance();
    lines.allocate(numLines);
    const skipLastPoint = model.close && isClosedShape;
    let theta = startAngleRad;
    let pointIndex = 0;
    for (let i = 0; i <= resolution; ++i, theta += angleIncRad) {
      const quotient = Math.floor(theta / (2 * Math.PI));
      const normalizedTheta = theta - quotient * 2 * Math.PI;
      let thetaEllipse = Math.atan(Math.tan(normalizedTheta) * model.ratio);
      if (normalizedTheta > Math.PI / 2 && normalizedTheta <= Math.PI) {
        thetaEllipse += Math.PI;
      } else if (normalizedTheta > Math.PI && normalizedTheta <= 1.5 * Math.PI) {
        thetaEllipse -= Math.PI;
      }
      const cosTheta = Math.cos(thetaEllipse);
      const sinTheta = Math.sin(thetaEllipse);
      const p = [model.center[0] + a2 * cosTheta * majorRadiusVect[0] + b2 * sinTheta * orthogonalVect[0], model.center[1] + a2 * cosTheta * majorRadiusVect[1] + b2 * sinTheta * orthogonalVect[1], model.center[2] + a2 * cosTheta * majorRadiusVect[2] + b2 * sinTheta * orthogonalVect[2]];
      tc[0] = i / resolution;
      tc[1] = 0;
      if (i !== resolution || !skipLastPoint) {
        points.setPoint(pointIndex, ...p);
        tcoords.setTuple(pointIndex, tc);
        pointIndex++;
      }
    }
    const actualNumPts = pointIndex;
    const pointIds = [];
    for (let k = 0; k < actualNumPts - 1; ++k) {
      pointIds.push(k);
    }
    if (model.close) {
      pointIds.push(0);
    } else {
      pointIds.push(actualNumPts - 1);
    }
    lines.insertNextCell(pointIds);
    output.setPoints(points);
    output.getPointData().setTCoords(tcoords);
    output.setLines(lines);
    outData[0] = output;
  };
}
var DEFAULT_VALUES49 = {
  center: [0, 0, 0],
  normal: [0, 0, 1],
  majorRadiusVector: [1, 0, 0],
  startAngle: 0,
  segmentAngle: 90,
  resolution: 100,
  close: false,
  outputPointsPrecision: DesiredOutputPrecision.SINGLE,
  ratio: 1
};
function extend58(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES49, initialValues);
  if (model.resolution < 1) {
    model.resolution = 1;
  }
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 0, 1);
  macro.setGet(publicAPI, model, ["resolution", "startAngle", "segmentAngle", "close", "outputPointsPrecision", "ratio"]);
  macro.setGetArray(publicAPI, model, ["center", "normal", "majorRadiusVector"], 3);
  vtkEllipseArcSource(publicAPI, model);
}
var newInstance58 = macro.newInstance(extend58, "vtkEllipseArcSource");
var vtkEllipseArcSource$1 = {
  newInstance: newInstance58,
  extend: extend58
};

// node_modules/@kitware/vtk.js/Filters/Sources/ImageGridSource.js
function vtkImageGridSource(publicAPI, model) {
  model.classHierarchy.push("vtkImageGridSource");
  publicAPI.requestData = (inData, outData) => {
    const state = {};
    const dataset = {
      type: "vtkImageData",
      mtime: model.mtime,
      metadata: {
        source: "vtkImageGridSource",
        state
      }
    };
    ["gridSpacing", "gridOrigin", "dataSpacing", "dataOrigin"].forEach((field) => {
      state[field] = [].concat(model[field]);
    });
    const id = vtkImageData$1.newInstance(dataset);
    id.setOrigin(model.dataOrigin[0], model.dataOrigin[1], model.dataOrigin[2]);
    id.setSpacing(model.dataSpacing[0], model.dataSpacing[1], model.dataSpacing[2]);
    id.setExtent.apply(this, model.dataExtent);
    id.setDirection(model.dataDirection);
    let dims = [0, 0, 0];
    dims = dims.map((_, i2) => model.dataExtent[i2 * 2 + 1] - model.dataExtent[i2 * 2] + 1);
    const newArray = new Uint8Array(dims[0] * dims[1] * dims[2]);
    let xval = 0;
    let yval = 0;
    let zval = 0;
    let i = 0;
    for (let z = model.dataExtent[4]; z <= model.dataExtent[5]; z++) {
      if (model.gridSpacing[2]) {
        zval = z % model.gridSpacing[2] === model.gridOrigin[2];
      } else {
        zval = 0;
      }
      for (let y = model.dataExtent[2]; y <= model.dataExtent[3]; y++) {
        if (model.gridSpacing[1]) {
          yval = y % model.gridSpacing[1] === model.gridOrigin[1];
        } else {
          yval = 0;
        }
        for (let x = model.dataExtent[0]; x <= model.dataExtent[1]; x++) {
          if (model.gridSpacing[0]) {
            xval = x % model.gridSpacing[0] === model.gridOrigin[0];
          } else {
            xval = 0;
          }
          newArray[i] = zval || yval || xval ? model.lineValue : model.fillValue;
          i++;
        }
      }
    }
    const da = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: newArray
    });
    da.setName("scalars");
    const cpd = id.getPointData();
    cpd.setScalars(da);
    outData[0] = id;
  };
}
var DEFAULT_VALUES50 = {
  lineValue: 0,
  fillValue: 255,
  gridSpacing: [10, 10, 0],
  gridOrigin: [0, 0, 0],
  dataSpacing: [1, 1, 1],
  dataOrigin: [0, 0, 0],
  dataExtent: [0, 255, 0, 255, 0, 0],
  dataDirection: [1, 0, 0, 0, 1, 0, 0, 0, 1]
};
function extend59(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES50, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["lineValue", "fillValue"]);
  macro.setGetArray(publicAPI, model, ["gridOrigin", "gridSpacing", "dataOrigin", "dataSpacing"], 3);
  macro.setGetArray(publicAPI, model, ["dataExtent"], 6);
  macro.setGetArray(publicAPI, model, ["dataDirection"], 9);
  macro.algo(publicAPI, model, 0, 1);
  vtkImageGridSource(publicAPI, model);
}
var newInstance59 = macro.newInstance(extend59, "vtkImageGridSource");
var vtkImageGridSource$1 = {
  newInstance: newInstance59,
  extend: extend59
};

// node_modules/@kitware/vtk.js/Filters/Sources/LineSource.js
var {
  vtkWarningMacro: vtkWarningMacro7
} = macro;
function vtkLineSource(publicAPI, model) {
  model.classHierarchy.push("vtkLineSource");
  publicAPI.requestData = (inData, outData) => {
    const dataset = outData[0];
    const pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;
    const pd = (dataset == null ? void 0 : dataset.initialize()) || vtkPolyData$1.newInstance();
    const v21 = [];
    subtract(model.point2, model.point1, v21);
    if (norm(v21) <= 0) {
      vtkWarningMacro7("Zero-length line definition");
      return;
    }
    const res = model.resolution;
    const numPts = res + 1;
    const points = macro.newTypedArray(pointDataType, numPts * 3);
    pd.getPoints().setData(points, 3);
    const lines = new Uint32Array(numPts + 1);
    pd.getLines().setData(lines, 1);
    let idx = 0;
    let t = 0;
    for (let i = 0; i < res + 1; i++) {
      t = i / res;
      points[idx * 3] = model.point1[0] + t * v21[0];
      points[idx * 3 + 1] = model.point1[1] + t * v21[1];
      points[idx * 3 + 2] = model.point1[2] + t * v21[2];
      idx++;
    }
    idx = 0;
    lines[0] = numPts;
    for (let i = 0; i < numPts; i++) {
      lines[i + 1] = i;
    }
    outData[0] = pd;
  };
}
var DEFAULT_VALUES51 = {
  resolution: 10,
  point1: [-1, 0, 0],
  point2: [1, 0, 0],
  pointType: "Float64Array"
};
function extend60(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES51, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["resolution"]);
  macro.setGetArray(publicAPI, model, ["point1", "point2"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkLineSource(publicAPI, model);
}
var newInstance60 = macro.newInstance(extend60, "vtkLineSource");
var vtkLineSource$1 = {
  newInstance: newInstance60,
  extend: extend60
};

// node_modules/@kitware/vtk.js/Filters/Sources/PlaneSource.js
var {
  vtkWarningMacro: vtkWarningMacro8
} = macro;
var EPSILON3 = 1e-6;
function vtkPlaneSource(publicAPI, model) {
  model.classHierarchy.push("vtkPlaneSource");
  publicAPI.requestData = (inData, outData) => {
    const dataset = outData[0];
    const pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;
    const pd = (dataset == null ? void 0 : dataset.initialize()) || vtkPolyData$1.newInstance();
    const v10 = [];
    const v20 = [];
    subtract(model.point1, model.origin, v10);
    subtract(model.point2, model.origin, v20);
    if (!publicAPI.updatePlane(v10, v20)) {
      vtkWarningMacro8("Bad plane definition");
      return;
    }
    const xres = model.xResolution;
    const yres = model.yResolution;
    const numPts = (xres + 1) * (yres + 1);
    const numPolys = xres * yres;
    const points = macro.newTypedArray(pointDataType, numPts * 3);
    pd.getPoints().setData(points, 3);
    const polys = new Uint32Array(5 * numPolys);
    pd.getPolys().setData(polys, 1);
    const normalsData = new Float32Array(numPts * 3);
    const normals = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: normalsData,
      name: "Normals"
    });
    pd.getPointData().setNormals(normals);
    const tcData = new Float32Array(numPts * 2);
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcData,
      name: "TextureCoordinates"
    });
    pd.getPointData().setTCoords(tcoords);
    const tc = new Float32Array(2);
    let idx = 0;
    for (let j = 0; j < yres + 1; j++) {
      tc[1] = j / yres;
      for (let i = 0; i < xres + 1; i++) {
        tc[0] = i / xres;
        points[idx * 3] = model.origin[0] + tc[0] * v10[0] + tc[1] * v20[0];
        points[idx * 3 + 1] = model.origin[1] + tc[0] * v10[1] + tc[1] * v20[1];
        points[idx * 3 + 2] = model.origin[2] + tc[0] * v10[2] + tc[1] * v20[2];
        tcData[idx * 2] = tc[0];
        tcData[idx * 2 + 1] = tc[1];
        normalsData[idx * 3] = model.normal[0];
        normalsData[idx * 3 + 1] = model.normal[1];
        normalsData[idx * 3 + 2] = model.normal[2];
        idx++;
      }
    }
    idx = 0;
    for (let j = 0; j < yres; j++) {
      for (let i = 0; i < xres; i++) {
        polys[idx * 5 + 0] = 4;
        polys[idx * 5 + 1] = i + j * (xres + 1);
        polys[idx * 5 + 2] = polys[idx * 5 + 1] + 1;
        polys[idx * 5 + 3] = polys[idx * 5 + 1] + xres + 2;
        polys[idx * 5 + 4] = polys[idx * 5 + 1] + xres + 1;
        idx++;
      }
    }
    outData[0] = pd;
  };
  publicAPI.setNormal = function() {
    let n = [];
    if (arguments.length === 1 || Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      n = [...arguments.length <= 0 ? void 0 : arguments[0]];
    } else if (arguments.length === 3) {
      n = [arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2]];
    }
    if (normalize(n) !== 0) {
      const dp = dot(model.normal, n);
      let theta = 0;
      const rotationVector = [];
      if (dp < 1) {
        if (dp <= -1) {
          theta = radiansFromDegrees(180);
          subtract(model.point1, model.origin, rotationVector);
        } else {
          cross(model.normal, n, rotationVector);
          theta = Math.acos(dp);
        }
        publicAPI.rotate(theta, rotationVector);
      }
    }
  };
  publicAPI.rotate = (angle, rotationAxis) => {
    if (Math.abs(angle) < EPSILON3) {
      return;
    }
    const transform = mat4_exports.identity(new Float64Array(16));
    const negCenter = [];
    vec3_exports.negate(negCenter, model.center);
    mat4_exports.translate(transform, transform, model.center);
    mat4_exports.rotate(transform, transform, angle, rotationAxis);
    mat4_exports.translate(transform, transform, negCenter);
    vec3_exports.transformMat4(model.origin, model.origin, transform);
    vec3_exports.transformMat4(model.point1, model.point1, transform);
    vec3_exports.transformMat4(model.point2, model.point2, transform);
    vtkMatrixBuilder.buildFromRadian().rotate(angle, rotationAxis).apply(model.normal);
    publicAPI.modified();
  };
  publicAPI.setCenter = function() {
    let c2 = [];
    if (arguments.length === 1 || Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      c2 = [...arguments.length <= 0 ? void 0 : arguments[0]];
    } else if (arguments.length === 3) {
      c2 = [arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2]];
    }
    if (!vec3_exports.exactEquals(c2, model.center)) {
      const v1 = [];
      subtract(model.point1, model.origin, v1);
      const v2 = [];
      subtract(model.point2, model.origin, v2);
      for (let i = 0; i < 3; i++) {
        model.center[i] = c2[i];
        model.origin[i] = model.center[i] - 0.5 * (v1[i] + v2[i]);
        model.point1[i] = model.origin[i] + v1[i];
        model.point2[i] = model.origin[i] + v2[i];
      }
      publicAPI.modified();
    }
  };
  publicAPI.setPoint1 = function() {
    let point1 = [];
    if (arguments.length === 1 || Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      point1 = [...arguments.length <= 0 ? void 0 : arguments[0]];
    } else if (arguments.length === 3) {
      point1 = [arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2]];
    }
    if (!vec3_exports.exactEquals(point1, model.point1)) {
      const v1 = [];
      const v2 = [];
      model.point1 = [...point1];
      subtract(model.point1, model.origin, v1);
      subtract(model.point2, model.origin, v2);
      publicAPI.updatePlane(v1, v2);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint2 = function() {
    let point2 = [];
    if (arguments.length === 1 || Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      point2 = [...arguments.length <= 0 ? void 0 : arguments[0]];
    } else if (arguments.length === 3) {
      point2 = [arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2]];
    }
    if (!vec3_exports.exactEquals(point2, model.point2)) {
      const v1 = [];
      const v2 = [];
      model.point2 = [...point2];
      subtract(model.point1, model.origin, v1);
      subtract(model.point2, model.origin, v2);
      publicAPI.updatePlane(v1, v2);
      publicAPI.modified();
    }
  };
  publicAPI.updatePlane = (v1, v2) => {
    for (let i = 0; i < 3; i++) {
      model.center[i] = model.origin[i] + 0.5 * (v1[i] + v2[i]);
    }
    cross(v1, v2, model.normal);
    return normalize(model.normal) !== 0;
  };
}
var DEFAULT_VALUES52 = {
  xResolution: 10,
  yResolution: 10,
  origin: [0, 0, 0],
  point1: [1, 0, 0],
  point2: [0, 1, 0],
  pointType: "Float64Array"
};
function extend61(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES52, initialValues);
  model.normal = [0, 0, 1];
  model.center = [0, 0, 0];
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["xResolution", "yResolution"]);
  macro.setGetArray(publicAPI, model, ["origin"], 3);
  macro.getArray(publicAPI, model, ["point1", "point2", "normal", "center"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkPlaneSource(publicAPI, model);
  publicAPI.setPoint1(model.point1);
  publicAPI.setPoint2(model.point2);
}
var newInstance61 = macro.newInstance(extend61, "vtkPlaneSource");
var vtkPlaneSource$1 = {
  newInstance: newInstance61,
  extend: extend61
};

// node_modules/@kitware/vtk.js/Filters/Sources/PlatonicSolidSource/Constants.js
var SolidType = {
  VTK_SOLID_TETRAHEDRON: 0,
  VTK_SOLID_CUBE: 1,
  VTK_SOLID_OCTAHEDRON: 2,
  VTK_SOLID_ICOSAHEDRON: 3,
  VTK_SOLID_DODECAHEDRON: 4
};

// node_modules/@kitware/vtk.js/Filters/Sources/PlatonicSolidSource.js
var a = 0.61803398875;
var b = 0.38196601125;
var c = 0.5;
var d = 0.30901699;
var e = Math.sqrt(2);
var f = Math.sqrt(3);
var geometries = {
  tetrahedron: {
    points: [1, 1, 1, -1, 1, -1, 1, -1, -1, -1, -1, 1],
    cells: [0, 2, 1, 1, 2, 3, 0, 3, 2, 0, 1, 3],
    numPoints: 4,
    cellSize: 3,
    numCells: 4,
    scale: 1 / f
  },
  cube: {
    points: [-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1],
    cells: [0, 1, 5, 4, 0, 4, 7, 3, 4, 5, 6, 7, 3, 7, 6, 2, 1, 2, 6, 5, 0, 3, 2, 1],
    numPoints: 8,
    cellSize: 4,
    numCells: 6,
    scale: 1 / f
  },
  octahedron: {
    points: [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, 0, 0, -e, 0, 0, e],
    cells: [4, 1, 0, 4, 2, 1, 4, 3, 2, 4, 0, 3, 0, 1, 5, 1, 2, 5, 2, 3, 5, 3, 0, 5],
    numPoints: 6,
    cellSize: 3,
    numCells: 8,
    scale: 1 / e
  },
  icosahedron: {
    points: [0, d, -c, 0, d, c, 0, -d, c, -d, c, 0, -d, -c, 0, d, c, 0, d, -c, 0, 0, -d, -c, c, 0, d, -c, 0, d, -c, 0, -d, c, 0, -d],
    cells: [0, 3, 5, 1, 5, 3, 1, 9, 2, 1, 2, 8, 0, 11, 7, 0, 7, 10, 2, 4, 6, 7, 6, 4, 3, 10, 9, 4, 9, 10, 5, 8, 11, 6, 11, 8, 1, 3, 9, 1, 8, 5, 0, 10, 3, 0, 5, 11, 7, 4, 10, 7, 11, 6, 2, 9, 4, 2, 6, 8],
    numPoints: 12,
    cellSize: 3,
    numCells: 20,
    scale: 1 / 0.58778524999243
  },
  dodecahedron: {
    points: [b, 0, 1, -b, 0, 1, b, 0, -1, -b, 0, -1, 0, 1, -b, 0, 1, b, 0, -1, -b, 0, -1, b, 1, b, 0, 1, -b, 0, -1, b, 0, -1, -b, 0, -a, a, a, a, -a, a, -a, -a, -a, a, a, -a, a, a, a, -a, a, -a, -a, -a, a, a, -a, -a],
    cells: [0, 16, 5, 12, 1, 1, 18, 7, 13, 0, 2, 19, 6, 14, 3, 3, 17, 4, 15, 2, 4, 5, 16, 8, 15, 5, 4, 17, 10, 12, 6, 7, 18, 11, 14, 7, 6, 19, 9, 13, 8, 16, 0, 13, 9, 9, 19, 2, 15, 8, 10, 17, 3, 14, 11, 11, 18, 1, 12, 10],
    numPoints: 20,
    cellSize: 5,
    numCells: 12,
    scale: 1 / 1.070466269319
  }
};
function vtkPlatonicSolidSource(publicAPI, model) {
  model.classHierarchy.push("vtkPlatonicSolidSource");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    let solidData;
    switch (model.solidType) {
      case SolidType.VTK_SOLID_TETRAHEDRON:
        solidData = geometries.tetrahedron;
        break;
      case SolidType.VTK_SOLID_CUBE:
        solidData = geometries.cube;
        break;
      case SolidType.VTK_SOLID_OCTAHEDRON:
        solidData = geometries.octahedron;
        break;
      case SolidType.VTK_SOLID_ICOSAHEDRON:
        solidData = geometries.icosahedron;
        break;
      case SolidType.VTK_SOLID_DODECAHEDRON:
        solidData = geometries.dodecahedron;
        break;
      default:
        solidData = geometries.tetrahedron;
        break;
    }
    let pointType;
    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {
      pointType = VtkDataTypes.FLOAT;
    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {
      pointType = VtkDataTypes.DOUBLE;
    }
    const points = vtkPoints$1.newInstance({
      dataType: pointType,
      numberOfPoints: solidData.numPoints
    });
    for (let i = 0; i < solidData.points.length; i += 3) {
      points.insertNextPoint(solidData.scale * solidData.points[i] * model.scale, solidData.scale * solidData.points[i + 1] * model.scale, solidData.scale * solidData.points[i + 2] * model.scale);
    }
    const polys = vtkCellArray$1.newInstance();
    for (let i = 0; i < solidData.cells.length; i += solidData.cellSize) {
      const cell = solidData.cells.slice(i, i + solidData.cellSize);
      polys.insertNextCell(cell);
    }
    output.setPoints(points);
    output.setPolys(polys);
    outData[0] = output;
  };
}
var DEFAULT_VALUES53 = {
  solidType: SolidType.VTK_SOLID_TETRAHEDRON,
  outputPointsPrecision: DesiredOutputPrecision.DEFAULT,
  scale: 1
};
function extend62(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES53, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["solidType", "outputPointsPrecision", "scale"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkPlatonicSolidSource(publicAPI, model);
}
var newInstance62 = macro.newInstance(extend62, "vtkPlatonicSolidSource");
var vtkPlatonicSolidSource$1 = {
  newInstance: newInstance62,
  extend: extend62,
  SolidType
};

// node_modules/@kitware/vtk.js/Filters/Sources/PointSource.js
function vtkPointSource(publicAPI, model) {
  model.classHierarchy.push("vtkPointSource");
  publicAPI.requestData = (inData, outData) => {
    const dataset = outData[0];
    const pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;
    const pd = (dataset == null ? void 0 : dataset.initialize()) || vtkPolyData$1.newInstance();
    const numPts = model.numberOfPoints;
    const points = macro.newTypedArray(pointDataType, numPts * 3);
    pd.getPoints().setData(points, 3);
    const verts = new Uint32Array(numPts + 1);
    pd.getVerts().setData(verts, 1);
    let cosphi;
    let sinphi;
    let rho;
    let radius;
    let theta;
    for (let i = 0; i < numPts; i++) {
      cosphi = 1 - 2 * random();
      sinphi = Math.sqrt(1 - cosphi * cosphi);
      rho = model.radius * random() ** 0.33333333;
      radius = rho * sinphi;
      theta = 2 * Math.PI * random();
      points[i * 3] = model.center[0] + radius * Math.cos(theta);
      points[i * 3 + 1] = model.center[1] + radius * Math.sin(theta);
      points[i * 3 + 2] = model.center[2] + rho * cosphi;
    }
    verts[0] = numPts;
    for (let i = 0; i < numPts; i++) {
      verts[i + 1] = i;
    }
    outData[0] = pd;
  };
}
var DEFAULT_VALUES54 = {
  numberOfPoints: 10,
  center: [0, 0, 0],
  radius: 0.5,
  pointType: "Float64Array"
};
function extend63(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES54, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["numberOfPoints", "radius"]);
  macro.setGetArray(publicAPI, model, ["center"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkPointSource(publicAPI, model);
}
var newInstance63 = macro.newInstance(extend63, "vtkPointSource");
var vtkPointSource$1 = {
  newInstance: newInstance63,
  extend: extend63
};

// node_modules/@kitware/vtk.js/Filters/Sources/RTAnalyticSource.js
function vtkRTAnalyticSource(publicAPI, model) {
  model.classHierarchy.push("vtkRTAnalyticSource");
  publicAPI.requestData = (inData, outData) => {
    const state = {};
    const dataset = {
      type: "vtkImageData",
      mtime: model.mtime,
      metadata: {
        source: "vtkRTAnalyticSource",
        state
      }
    };
    ["standardDeviation", "center", "frequency", "magnitude", "maximum"].forEach((field) => {
      state[field] = [].concat(model[field]);
    });
    const id = vtkImageData$1.newInstance(dataset);
    id.setSpacing(1, 1, 1);
    id.setExtent.apply(this, model.wholeExtent);
    id.setOrigin(0, 0, 0);
    id.setDirection(model.dataDirection);
    let dims = [0, 0, 0];
    dims = dims.map((_, i2) => model.wholeExtent[i2 * 2 + 1] - model.wholeExtent[i2 * 2] + 1);
    const newArray = new Uint8Array(dims[0] * dims[1] * dims[2]);
    const temp2 = 1 / (2 * model.standardDeviation * model.standardDeviation);
    let xval = 0;
    let yval = 0;
    let zval = 0;
    const scale = [1 / (model.wholeExtent[1] - model.wholeExtent[0]), 1 / (model.wholeExtent[3] - model.wholeExtent[2]), 1 / (model.wholeExtent[5] - model.wholeExtent[4])];
    let i = 0;
    for (let z = model.wholeExtent[4]; z <= model.wholeExtent[5]; z++) {
      zval = (model.center[2] - z) * scale[2];
      const zfactor = model.magnitude[2] * Math.cos(model.frequency[2] * zval);
      zval *= zval;
      for (let y = model.wholeExtent[2]; y <= model.wholeExtent[3]; y++) {
        yval = (model.center[1] - y) * scale[1];
        const yfactor = model.magnitude[1] * Math.sin(model.frequency[1] * yval);
        yval *= yval;
        for (let x = model.wholeExtent[0]; x <= model.wholeExtent[1]; x++) {
          xval = (model.center[0] - x) * scale[0];
          const sum3 = zval + yval + xval * xval;
          const xfactor = model.magnitude[0] * Math.sin(model.frequency[0] * xval);
          newArray[i] = model.maximum * Math.exp(-sum3 * temp2) + xfactor + yfactor + zfactor + model.offset;
          i++;
        }
      }
    }
    const da = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: newArray
    });
    da.setName("scalars");
    const cpd = id.getPointData();
    cpd.setScalars(da);
    outData[0] = id;
  };
}
var DEFAULT_VALUES55 = {
  offset: 40,
  maximum: 120,
  center: [0, 0, 0],
  frequency: [60, 30, 40],
  magnitude: [10, 18, 5],
  standardDeviation: 0.5,
  wholeExtent: [-10, 10, -10, 10, -10, 10],
  dataDirection: [1, 0, 0, 0, 1, 0, 0, 0, 1]
};
function extend64(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES55, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["offset", "maximum", "standardDeviation"]);
  macro.setGetArray(publicAPI, model, ["center", "frequency", "magnitude"], 3);
  macro.setGetArray(publicAPI, model, ["wholeExtent"], 6);
  macro.setGetArray(publicAPI, model, ["dataDirection"], 9);
  macro.algo(publicAPI, model, 0, 1);
  vtkRTAnalyticSource(publicAPI, model);
}
var newInstance64 = macro.newInstance(extend64, "vtkRTAnalyticSource");
var vtkRTAnalyticSource$1 = {
  newInstance: newInstance64,
  extend: extend64
};

// node_modules/@kitware/vtk.js/Filters/Sources/SLICSource.js
function generateCoordinates(origin3, dimensions, spacing) {
  const coordinates = new Float64Array(dimensions[0] * dimensions[1] * dimensions[2] * 3);
  let offset = 0;
  for (let k = 0; k < dimensions[2]; k++) {
    const z = origin3[2] + spacing[2] * k;
    for (let j = 0; j < dimensions[1]; j++) {
      const y = origin3[1] + spacing[1] * j;
      for (let i = 0; i < dimensions[0]; i++) {
        const x = origin3[0] + spacing[0] * i;
        coordinates[offset++] = x;
        coordinates[offset++] = y;
        coordinates[offset++] = z;
      }
    }
  }
  return coordinates;
}
function vtkSLICSource(publicAPI, model) {
  model.classHierarchy.push("vtkSLICSource");
  publicAPI.addCluster = (centerX, centerY, centerZ, fnConst, fnDfDx, fnDfDy, fnDfDz) => {
    const id = model.clusters.length;
    model.clusters.push(new Float64Array([centerX, centerY, centerZ, fnConst, fnDfDx, fnDfDy, fnDfDz]));
    publicAPI.modified();
    return id;
  };
  publicAPI.removeCluster = (id) => {
    model.clusters.splice(id, 1);
    publicAPI.modified();
  };
  publicAPI.removeAllClusters = () => {
    model.clusters = [];
    publicAPI.modified();
  };
  publicAPI.updateCluster = (id, centerX, centerY, centerZ, fnConst, fnDfDx, fnDfDy, fnDfDz) => {
    if (!model.clusters[id]) {
      model.clusters[id] = new Float64Array(7);
    }
    model.clusters[id][0] = centerX;
    model.clusters[id][1] = centerY;
    model.clusters[id][2] = centerZ;
    model.clusters[id][3] = fnConst;
    model.clusters[id][4] = fnDfDx;
    model.clusters[id][5] = fnDfDy;
    model.clusters[id][6] = fnDfDz;
    publicAPI.modified();
  };
  publicAPI.getNumberOfClusters = () => model.clusters.length;
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const dataSize = model.dimensions[0] * model.dimensions[1] * model.dimensions[2];
    const imageData = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkImageData$1.newInstance();
    imageData.setSpacing(...model.spacing);
    imageData.setExtent(0, model.dimensions[0] - 1, 0, model.dimensions[1] - 1, 0, model.dimensions[2] - 1);
    imageData.setOrigin(...model.origin);
    const centers = generateCoordinates(model.origin, model.dimensions, model.spacing);
    const nbBytes = (model.clusters.length < 256 ? 8 : 0) || (model.clusters.length < 65536 ? 16 : 32);
    const clusterIdxValues = macro.newTypedArray(`Uint${nbBytes}Array`, dataSize);
    for (let i = 0; i < dataSize; i++) {
      let clusterDistance = Number.MAX_VALUE;
      model.clusters.forEach((cluster, idx) => {
        const dist = (cluster[0] - centers[i * 3]) * (cluster[0] - centers[i * 3]) + (cluster[1] - centers[i * 3 + 1]) * (cluster[1] - centers[i * 3 + 1]) + (cluster[2] - centers[i * 3 + 2]) * (cluster[2] - centers[i * 3 + 2]);
        if (dist < clusterDistance) {
          clusterDistance = dist;
          clusterIdxValues[i] = idx;
        }
      });
    }
    const clusters = vtkDataArray$1.newInstance({
      name: model.clusterArrayName,
      numberOfComponents: 1,
      values: clusterIdxValues
    });
    imageData.getPointData().addArray(clusters);
    const scalarValues = new Float32Array(dataSize);
    for (let i = 0; i < dataSize; i++) {
      const cluster = model.clusters[clusterIdxValues[i]];
      scalarValues[i] = cluster[3] + cluster[4] * (centers[i * 3 + 0] - cluster[0]) + cluster[5] * (centers[i * 3 + 1] - cluster[1]) + cluster[6] * (centers[i * 3 + 2] - cluster[2]);
    }
    const scalars = vtkDataArray$1.newInstance({
      name: model.scalarArrayName,
      numberOfComponents: 1,
      values: scalarValues
    });
    imageData.getPointData().addArray(scalars);
    outData[0] = imageData;
  };
}
var DEFAULT_VALUES56 = {
  clusters: [],
  spacing: [1, 1, 1],
  origin: [0, 0, 0],
  dimensions: [10, 10, 10],
  clusterArrayName: "cluster",
  scalarArrayName: "field"
};
function extend65(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES56, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["clusterArrayName", "scalarArrayName"]);
  macro.setGetArray(publicAPI, model, ["origin", "spacing", "dimensions"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkSLICSource(publicAPI, model);
}
var newInstance65 = macro.newInstance(extend65, "vtkSLICSource");
var vtkSLICSource$1 = {
  newInstance: newInstance65,
  extend: extend65
};

// node_modules/@kitware/vtk.js/Filters/Sources/SphereSource.js
function vtkSphereSource(publicAPI, model) {
  model.classHierarchy.push("vtkSphereSource");
  publicAPI.requestData = (inData, outData) => {
    let dataset = outData[0];
    const pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;
    dataset = (dataset == null ? void 0 : dataset.initialize()) || vtkPolyData$1.newInstance();
    let numPoles = 0;
    let {
      thetaResolution
    } = model;
    let startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;
    startTheta *= Math.PI / 180;
    let endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;
    endTheta *= Math.PI / 180;
    let startPhi = model.startPhi < model.endPhi ? model.startPhi : model.endPhi;
    startPhi *= Math.PI / 180;
    let endPhi = model.endPhi > model.startPhi ? model.endPhi : model.startPhi;
    endPhi *= Math.PI / 180;
    if (Math.abs(startTheta - endTheta) < 2 * Math.PI) {
      ++thetaResolution;
    }
    const deltaTheta = (endTheta - startTheta) / model.thetaResolution;
    const jStart = model.startPhi <= 0 ? 1 : 0;
    const jEnd = model.phiResolution + (model.endPhi >= 180 ? -1 : 0);
    const numPts = model.phiResolution * thetaResolution + 2;
    const numPolys = model.phiResolution * 2 * model.thetaResolution;
    let pointIdx = 0;
    let points = macro.newTypedArray(pointDataType, numPts * 3);
    let normals = new Float32Array(numPts * 3);
    let cellLocation = 0;
    let polys = new Uint32Array(numPolys * 5);
    if (model.startPhi <= 0) {
      points[pointIdx * 3 + 0] = model.center[0];
      points[pointIdx * 3 + 1] = model.center[1];
      points[pointIdx * 3 + 2] = model.center[2] + model.radius;
      normals[pointIdx * 3 + 0] = 0;
      normals[pointIdx * 3 + 1] = 0;
      normals[pointIdx * 3 + 2] = 1;
      pointIdx++;
      numPoles++;
    }
    if (model.endPhi >= 180) {
      points[pointIdx * 3 + 0] = model.center[0];
      points[pointIdx * 3 + 1] = model.center[1];
      points[pointIdx * 3 + 2] = model.center[2] - model.radius;
      normals[pointIdx * 3 + 0] = 0;
      normals[pointIdx * 3 + 1] = 0;
      normals[pointIdx * 3 + 2] = -1;
      pointIdx++;
      numPoles++;
    }
    const phiResolution = model.phiResolution - numPoles;
    const deltaPhi = (endPhi - startPhi) / (model.phiResolution - 1);
    for (let i = 0; i < thetaResolution; i++) {
      const theta = startTheta + i * deltaTheta;
      for (let j = jStart; j < jEnd; j++) {
        const phi = startPhi + j * deltaPhi;
        const radius = model.radius * Math.sin(phi);
        normals[pointIdx * 3 + 0] = radius * Math.cos(theta);
        normals[pointIdx * 3 + 1] = radius * Math.sin(theta);
        normals[pointIdx * 3 + 2] = model.radius * Math.cos(phi);
        points[pointIdx * 3 + 0] = normals[pointIdx * 3 + 0] + model.center[0];
        points[pointIdx * 3 + 1] = normals[pointIdx * 3 + 1] + model.center[1];
        points[pointIdx * 3 + 2] = normals[pointIdx * 3 + 2] + model.center[2];
        let norm2 = Math.sqrt(normals[pointIdx * 3 + 0] * normals[pointIdx * 3 + 0] + normals[pointIdx * 3 + 1] * normals[pointIdx * 3 + 1] + normals[pointIdx * 3 + 2] * normals[pointIdx * 3 + 2]);
        norm2 = norm2 === 0 ? 1 : norm2;
        normals[pointIdx * 3 + 0] /= norm2;
        normals[pointIdx * 3 + 1] /= norm2;
        normals[pointIdx * 3 + 2] /= norm2;
        pointIdx++;
      }
    }
    const base = phiResolution * thetaResolution;
    if (Math.abs(startTheta - endTheta) < 2 * Math.PI) {
      --thetaResolution;
    }
    if (model.startPhi <= 0) {
      for (let i = 0; i < thetaResolution; i++) {
        polys[cellLocation++] = 3;
        polys[cellLocation++] = phiResolution * i + numPoles;
        polys[cellLocation++] = phiResolution * (i + 1) % base + numPoles;
        polys[cellLocation++] = 0;
      }
    }
    if (model.endPhi >= 180) {
      const numOffset = phiResolution - 1 + numPoles;
      for (let i = 0; i < thetaResolution; i++) {
        polys[cellLocation++] = 3;
        polys[cellLocation++] = phiResolution * i + numOffset;
        polys[cellLocation++] = numPoles - 1;
        polys[cellLocation++] = phiResolution * (i + 1) % base + numOffset;
      }
    }
    for (let i = 0; i < thetaResolution; i++) {
      for (let j = 0; j < phiResolution - 1; j++) {
        const a2 = phiResolution * i + j + numPoles;
        const b2 = a2 + 1;
        const c2 = (phiResolution * (i + 1) + j) % base + numPoles + 1;
        if (!model.latLongTessellation) {
          polys[cellLocation++] = 3;
          polys[cellLocation++] = a2;
          polys[cellLocation++] = b2;
          polys[cellLocation++] = c2;
          polys[cellLocation++] = 3;
          polys[cellLocation++] = a2;
          polys[cellLocation++] = c2;
          polys[cellLocation++] = c2 - 1;
        } else {
          polys[cellLocation++] = 4;
          polys[cellLocation++] = a2;
          polys[cellLocation++] = b2;
          polys[cellLocation++] = c2;
          polys[cellLocation++] = c2 - 1;
        }
      }
    }
    points = points.subarray(0, pointIdx * 3);
    dataset.getPoints().setData(points, 3);
    normals = normals.subarray(0, pointIdx * 3);
    const normalArray = vtkDataArray$1.newInstance({
      name: "Normals",
      values: normals,
      numberOfComponents: 3
    });
    dataset.getPointData().setNormals(normalArray);
    polys = polys.subarray(0, cellLocation);
    dataset.getPolys().setData(polys, 1);
    outData[0] = dataset;
  };
}
var DEFAULT_VALUES57 = {
  radius: 0.5,
  latLongTessellation: false,
  thetaResolution: 8,
  startTheta: 0,
  endTheta: 360,
  phiResolution: 8,
  startPhi: 0,
  endPhi: 180,
  center: [0, 0, 0],
  pointType: "Float64Array"
};
function extend66(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES57, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["radius", "latLongTessellation", "thetaResolution", "startTheta", "endTheta", "phiResolution", "startPhi", "endPhi"]);
  macro.setGetArray(publicAPI, model, ["center"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkSphereSource(publicAPI, model);
}
var newInstance66 = macro.newInstance(extend66, "vtkSphereSource");
var vtkSphereSource$1 = {
  newInstance: newInstance66,
  extend: extend66
};

// node_modules/@kitware/vtk.js/Filters/Sources/TorusSource.js
var TAU = Math.PI * 2;
function vtkTorusSource(publicAPI, model) {
  model.classHierarchy.push("vtkTorusSource");
  function requestData(inData, outData) {
    let dataset = outData[0];
    const points = macro.newTypedArray(model.pointType, 3 * (model.resolution + 1) * (model.tubeResolution + 1));
    let pointIdx = 0;
    for (let ti = 0; ti <= model.tubeResolution; ti++) {
      const v = ti / model.tubeResolution * TAU;
      const cosV = Math.cos(v);
      const sinV = Math.sin(v);
      for (let ri = 0; ri <= model.resolution; ri++) {
        const u = ri / model.resolution * model.arcLength;
        points[pointIdx++] = (model.radius + model.tubeRadius * cosV) * Math.cos(u);
        points[pointIdx++] = (model.radius + model.tubeRadius * cosV) * Math.sin(u);
        points[pointIdx++] = model.tubeRadius * sinV;
      }
    }
    const cellArraySize = 4 * 2 * (model.resolution * model.tubeResolution);
    let cellLocation = 0;
    const polys = new Uint32Array(cellArraySize);
    for (let ti = 1; ti <= model.tubeResolution; ti++) {
      for (let ri = 1; ri <= model.resolution; ri++) {
        const a2 = (model.resolution + 1) * ti + ri - 1;
        const b2 = (model.resolution + 1) * (ti - 1) + ri - 1;
        const c2 = (model.resolution + 1) * (ti - 1) + ri;
        const d2 = (model.resolution + 1) * ti + ri;
        polys[cellLocation++] = 3;
        polys[cellLocation++] = a2;
        polys[cellLocation++] = b2;
        polys[cellLocation++] = d2;
        polys[cellLocation++] = 3;
        polys[cellLocation++] = b2;
        polys[cellLocation++] = c2;
        polys[cellLocation++] = d2;
      }
    }
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).apply(points);
    dataset = vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    outData[0] = dataset;
  }
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES58 = {
  radius: 0.5,
  tubeRadius: 0.01,
  resolution: 64,
  tubeResolution: 64,
  arcLength: TAU,
  center: [0, 0, 0],
  direction: [1, 0, 0],
  pointType: "Float64Array"
};
function extend67(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES58, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["radius", "tubeRadius", "resolution", "tubeResolution", "arcLength"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkTorusSource(publicAPI, model);
}
var newInstance67 = macro.newInstance(extend67, "vtkTorusSource");
var vtkTorusSource$1 = {
  newInstance: newInstance67,
  extend: extend67
};

// node_modules/@kitware/vtk.js/Filters/Sources.js
var Sources = {
  vtkArcSource: vtkArcSource$1,
  vtkArrowSource: vtkArrowSource$1,
  vtkCircleSource: vtkCircleSource$1,
  vtkConcentricCylinderSource: vtkConcentricCylinderSource$1,
  vtkConeSource: vtkConeSource$1,
  vtkCubeSource: vtkCubeSource$1,
  vtkCursor3D: vtkCursor3D$1,
  vtkCylinderSource: vtkCylinderSource$1,
  vtkDiskSource: vtkDiskSource$1,
  vtkEllipseArcSource: vtkEllipseArcSource$1,
  vtkImageGridSource: vtkImageGridSource$1,
  vtkLineSource: vtkLineSource$1,
  vtkPlaneSource: vtkPlaneSource$1,
  vtkPlatonicSolidSource: vtkPlatonicSolidSource$1,
  vtkPointSource: vtkPointSource$1,
  vtkRTAnalyticSource: vtkRTAnalyticSource$1,
  vtkSLICSource: vtkSLICSource$1,
  vtkSphereSource: vtkSphereSource$1,
  vtkTorusSource: vtkTorusSource$1
};

// node_modules/@kitware/vtk.js/Filters/Texture/TextureMapToSphere.js
var {
  vtkErrorMacro: vtkErrorMacro34
} = macro;
function vtkTextureMapToSphere(publicAPI, model) {
  model.classHierarchy.push("vtkTextureMapToSphere");
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const nbPoints = input.getPoints().getNumberOfPoints();
    if (nbPoints <= 1) {
      vtkErrorMacro34("Can't generate texture coordinates without points");
      return;
    }
    const piOverTwo = Math.PI / 2;
    const x = [];
    const points = input.getPoints();
    if (model.automaticSphereGeneration) {
      model.center = [0, 0, 0];
      for (let i = 0; i < nbPoints; i++) {
        points.getPoint(i, x);
        model.center[0] += x[0];
        model.center[1] += x[1];
        model.center[2] += x[2];
      }
      model.center[0] /= nbPoints;
      model.center[1] /= nbPoints;
      model.center[2] /= nbPoints;
    }
    let rho = 0;
    let diff = 0;
    let phi = 0;
    const tc = [0, 0];
    let r = 0;
    let thetaX = 0;
    let thetaY = 0;
    const tcoordsData = [];
    for (let i = 0; i < nbPoints; i++) {
      points.getPoint(i, x);
      rho = Math.sqrt(distance2BetweenPoints(x, model.center));
      if (rho !== 0) {
        diff = x[2] - model.center[2];
        if (Math.abs(diff) > rho) {
          phi = 0;
          if (diff > 0) {
            tc[1] = 0;
          } else {
            tc[1] = 1;
          }
        } else {
          phi = Math.acos(diff / rho);
          tc[1] = phi / Math.PI;
        }
      } else {
        tc[1] = 0;
      }
      r = rho * Math.sin(phi);
      if (r !== 0) {
        diff = x[0] - model.center[0];
        if (Math.abs(diff) > r) {
          if (diff > 0) {
            thetaX = 0;
          } else {
            thetaX = Math.PI;
          }
        } else {
          thetaX = Math.acos(diff / r);
        }
        diff = x[1] - model.center[1];
        if (Math.abs(diff) > r) {
          if (diff > 0) {
            thetaY = piOverTwo;
          } else {
            thetaY = -piOverTwo;
          }
        } else {
          thetaY = Math.asin(diff / r);
        }
      } else {
        thetaX = 0;
        thetaY = 0;
      }
      if (model.preventSeam) {
        tc[0] = thetaX / Math.PI;
      } else {
        tc[0] = thetaX / (2 * Math.PI);
        if (thetaY < 0) {
          tc[0] = 1 - tc[0];
        }
      }
      tcoordsData.push(...tc);
    }
    const tCoords = vtkDataArray$1.newInstance({
      name: "Texture Coordinates",
      numberOfComponents: 2,
      size: nbPoints,
      values: tcoordsData
    });
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    output.getPoints().setData(new Float32Array(input.getPoints().getData()), 3);
    output.getPolys().setData(new Uint32Array(input.getPolys().getData()));
    output.getPointData().setTCoords(tCoords);
    outData[0] = output;
  };
}
var DEFAULT_VALUES59 = {
  center: [0, 0, 0],
  automaticSphereGeneration: 1,
  preventSeam: 1
};
function extend68(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES59, initialValues);
  macro.obj(publicAPI, model);
  macro.setGetArray(publicAPI, model, ["center"], 3);
  macro.setGet(publicAPI, model, ["automaticSphereGeneration", "preventSeam"]);
  macro.algo(publicAPI, model, 1, 1);
  vtkTextureMapToSphere(publicAPI, model);
}
var newInstance68 = macro.newInstance(extend68, "vtkTextureMapToSphere");
var vtkTextureMapToSphere$1 = {
  newInstance: newInstance68,
  extend: extend68
};

// node_modules/@kitware/vtk.js/Filters/Texture/TextureMapToPlane.js
var {
  vtkErrorMacro: vtkErrorMacro35
} = macro;
function vtkTextureMapToPlane(publicAPI, model) {
  model.classHierarchy.push("vtkTextureMapToPlane");
  function computeNormal(output) {
    const VTK_TOLERANCE = 1e-3;
    const nbPoints = output.getPoints().getNumberOfPoints();
    let dir = 0;
    let m = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    const x = [0, 0, 0];
    const v = [0, 0, 0];
    const bounds2 = output.getBounds();
    const minBounds = [bounds2[0], bounds2[2], bounds2[4]];
    const maxBounds = [bounds2[1], bounds2[3], bounds2[5]];
    const length = Math.sqrt(distance2BetweenPoints(minBounds, maxBounds));
    let w = length;
    let i = 0;
    for (; i < 3; i++) {
      model.normal[i] = 0;
      if (bounds2[2 * i + 1] - bounds2[2 * i] < w) {
        dir = i;
        w = bounds2[2 * i + 1] - bounds2[2 * i];
      }
    }
    model.normal[dir] = 1;
    if (w <= length * VTK_TOLERANCE) {
      return;
    }
    v[0] = 0;
    v[1] = 0;
    v[2] = 0;
    for (let ptId = 0; ptId < nbPoints; ptId++) {
      output.getPoints().getPoint(ptId, x);
      v[0] += x[0] * x[2];
      v[1] += x[1] * x[2];
      v[2] += x[2];
      m[0] += x[0] * x[0];
      m[1] += x[0] * x[1];
      m[2] += x[0];
      m[3] += x[0] * x[1];
      m[4] += x[1] * x[1];
      m[5] += x[1];
      m[6] += x[0];
      m[7] += x[1];
    }
    m[8] = nbPoints;
    const c1 = [m[0], m[1], m[2]];
    const c2 = [m[3], m[4], m[5]];
    const c3 = [m[6], m[7], m[8]];
    const det = determinant3x3(m);
    if (det <= VTK_TOLERANCE) {
      return;
    }
    m = rowsToMat3(v, c2, c3, []);
    model.normal[0] = determinant3x3(m) / det;
    m = rowsToMat3(c1, v, c3, []);
    model.normal[1] = determinant3x3(m) / det;
    model.normal[2] = -1;
  }
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    const nbPoints = input.getPoints().getNumberOfPoints();
    if (nbPoints < 3 && model.automaticPlaneGeneration) {
      vtkErrorMacro35("Can't generate texture coordinates without points");
      return;
    }
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    output.getPoints().setData(new Float32Array(input.getPoints().getData()), 3);
    output.getPolys().setData(new Uint32Array(input.getPolys().getData()));
    const tcoordsData = [];
    let minProj = 0;
    let i = 0;
    let j = 0;
    let proj = 0;
    const axis = [0, 0, 0];
    let dir = 0;
    const tAxis = [0, 0, 0];
    const sAxis = [0, 0, 0];
    let s = 0;
    let t = 0;
    let sSf = 0;
    let tSf = 0;
    const p = [0, 0, 0];
    if (model.automaticPlaneGeneration && model.origin[0] === 0 && model.origin[1] === 0 && model.origin[2] === 0 && model.point1[0] === 0 && model.point1[1] === 0 && model.point2[0] === 0 && model.point2[1] === 0) {
      if (model.automaticPlaneGeneration) {
        computeNormal(output);
      }
      normalize(model.normal);
      minProj = 1;
      i = 0;
      for (; i < 3; i++) {
        axis[0] = 0;
        axis[1] = 0;
        axis[2] = 0;
        axis[i] = 1;
        proj = Math.abs(dot(model.normal, axis));
        if (proj < minProj) {
          minProj = proj;
          dir = i;
        }
      }
      axis[0] = 0;
      axis[1] = 0;
      axis[2] = 0;
      axis[dir] = 1;
      cross(model.normal, axis, tAxis);
      normalize(tAxis);
      cross(tAxis, model.normal, sAxis);
      const bounds2 = output.getBounds();
      for (i = 0; i < 3; i++) {
        axis[i] = bounds2[2 * i + 1] - bounds2[2 * i];
      }
      s = dot(sAxis, axis);
      t = dot(tAxis, axis);
      sSf = (model.sRange[1] - model.sRange[0]) / s;
      tSf = (model.tRange[1] - model.tRange[0]) / t;
      for (i = 0; i < nbPoints; i++) {
        output.getPoints().getPoint(i, p);
        for (j = 0; j < 3; j++) {
          axis[j] = p[j] - bounds2[2 * j];
        }
        tcoordsData.push(model.sRange[0] + dot(sAxis, axis) * sSf);
        tcoordsData.push(model.tRange[0] + dot(tAxis, axis) * tSf);
      }
    } else {
      let num = 0;
      for (i = 0; i < 3; i++) {
        sAxis[i] = model.point1[i] - model.origin[i];
        tAxis[i] = model.point2[i] - model.origin[i];
      }
      let sDenom = dot(sAxis, sAxis);
      let tDenom = dot(tAxis, tAxis);
      if (sDenom === 0 || tDenom === 0) {
        vtkErrorMacro35("Bad plane definition");
        sDenom = 1;
        tDenom = 1;
      }
      for (i = 0; i < nbPoints; i++) {
        output.getPoints().getPoint(i, p);
        for (j = 0; j < 3; j++) {
          axis[j] = p[j] - model.origin[j];
        }
        num = sAxis[0] * axis[0] + sAxis[1] * axis[1] + sAxis[2] * axis[2];
        tcoordsData.push(num / sDenom);
        num = tAxis[0] * axis[0] + tAxis[1] * axis[1] + tAxis[2] * axis[2];
        tcoordsData.push(num / tDenom);
      }
    }
    const tCoords = vtkDataArray$1.newInstance({
      name: "Texture Coordinates",
      numberOfComponents: 2,
      size: nbPoints,
      values: tcoordsData
    });
    output.getPointData().setTCoords(tCoords);
    outData[0] = output;
  };
}
var DEFAULT_VALUES60 = {
  origin: [0, 0, 0],
  point1: [0, 0, 0],
  point2: [0, 0, 0],
  normal: [0, 0, 0],
  sRange: [0, 1],
  tRange: [0, 1],
  automaticPlaneGeneration: 1
};
function extend69(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES60, initialValues);
  macro.obj(publicAPI, model);
  macro.setGetArray(publicAPI, model, ["origin", "point1", "point2", "normal"], 3);
  macro.setGetArray(publicAPI, model, ["sRange", "tRange"], 2);
  macro.setGet(publicAPI, model, ["automaticPlaneGeneration"]);
  macro.algo(publicAPI, model, 1, 1);
  vtkTextureMapToPlane(publicAPI, model);
}
var newInstance69 = macro.newInstance(extend69, "vtkTextureMapToPlane");
var vtkTextureMapToPlane$1 = {
  newInstance: newInstance69,
  extend: extend69
};

// node_modules/@kitware/vtk.js/Filters/Texture.js
var Texture = {
  vtkTextureMapToPlane: vtkTextureMapToPlane$1,
  vtkTextureMapToSphere: vtkTextureMapToSphere$1
};

// node_modules/@kitware/vtk.js/Filters/index.js
var Filters = {
  Cornerstone,
  Core: Core2,
  General,
  Sources,
  Texture
};

// node_modules/@kitware/vtk.js/Imaging/Core/AbstractImageInterpolator/Constants.js
var ImageBorderMode = {
  CLAMP: 0,
  REPEAT: 1,
  MIRROR: 2
};
var InterpolationMode = {
  NEAREST: 0,
  LINEAR: 1,
  CUBIC: 2
};
var Constants7 = {
  ImageBorderMode,
  InterpolationMode
};

// node_modules/@kitware/vtk.js/Imaging/Core/AbstractImageInterpolator/InterpolationInfo.js
var vtkInterpolationInfo = {
  pointer: null,
  extent: [0, -1, 0, -1, 0, -1],
  increments: [0, 0, 0],
  scalarType: null,
  // dataType
  dataTypeSize: 1,
  // BYTES_PER_ELEMENT
  numberOfComponents: 1,
  borderMode: ImageBorderMode.CLAMP,
  interpolationMode: InterpolationMode.LINEAR,
  extraInfo: null
};
var vtkInterpolationWeights = {
  ...vtkInterpolationInfo,
  positions: [0, 0, 0],
  weights: null,
  weightExtent: [0, -1, 0, -1, 0, -1],
  kernelSize: [1, 1, 1],
  workspace: null,
  lastY: null,
  lastZ: null
};
function vtkInterpolationMathFloor(x) {
  const integer = Math.floor(x);
  return {
    floored: integer,
    error: x - integer
  };
}
function vtkInterpolationMathRound(x) {
  return Math.round(x);
}
function vtkInterpolationMathClamp(a2, b2, c2) {
  let clamp2 = a2 <= c2 ? a2 : c2;
  clamp2 -= b2;
  clamp2 = clamp2 >= 0 ? clamp2 : 0;
  return clamp2;
}
function vtkInterpolationMathWrap(a2, b2, c2) {
  const range = c2 - b2 + 1;
  let wrap = a2 - b2;
  wrap %= range;
  wrap = wrap >= 0 ? wrap : wrap + range;
  return wrap;
}
function vtkInterpolationMathMirror(a2, b2, c2) {
  const range = c2 - b2;
  const ifzero = range === 0 ? 1 : 0;
  const range2 = 2 * range + ifzero;
  let mirror = a2 - b2;
  mirror = mirror >= 0 ? mirror : -mirror;
  mirror %= range2;
  mirror = mirror <= range ? mirror : range2 - mirror;
  return mirror;
}

// node_modules/@kitware/vtk.js/Imaging/Core/AbstractImageInterpolator.js
var {
  ImageBorderMode: ImageBorderMode2
} = Constants7;
function vtkAbstractImageInterpolator(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractImageInterpolator");
  publicAPI.initialize = (data2) => {
    publicAPI.releaseData();
    model.scalars = data2.getPointData().getScalars();
    model.spacing = data2.getSpacing();
    model.origin = data2.getOrigin();
    model.extent = data2.getExtent();
    publicAPI.update();
  };
  publicAPI.releaseData = () => {
    model.scalars = null;
  };
  publicAPI.update = () => {
    if (!model.scalars) {
      model.interpolationInfo.pointer = null;
      model.interpolationInfo.numberOfComponents = 1;
      return;
    }
    model.interpolationInfo.extent = model.extent.slice();
    const supportSize = publicAPI.computeSupportSize(null);
    const kernelSize = Math.max(Math.max(supportSize[0], supportSize[1]), supportSize[2]);
    const minBound = Number.MIN_SAFE_INTEGER + kernelSize / 2;
    const maxBound = Number.MAX_SAFE_INTEGER - kernelSize / 2;
    for (let i = 0; i < 3; ++i) {
      const newTol = Math.max(0.5 * (model.extent[2 * i] === model.extent[2 * i + 1]), model.tolerance);
      model.structuredBounds[2 * i] = Math.max(model.extent[2 * i] - newTol, minBound);
      model.structuredBounds[2 * i + 1] = Math.min(model.extent[2 * i + 1] + newTol, maxBound);
    }
    const xdim = model.extent[1] - model.extent[0] + 1;
    const ydim = model.extent[3] - model.extent[2] + 1;
    const ncomp = model.scalars.getNumberOfComponents();
    model.interpolationInfo.increments[0] = ncomp;
    model.interpolationInfo.increments[1] = model.interpolationInfo.increments[0] * xdim;
    model.interpolationInfo.increments[2] = model.interpolationInfo.increments[1] * ydim;
    let component = model.componentOffset;
    component = component > 0 ? component : 0;
    component = component < ncomp ? component : ncomp - 1;
    const dataSize = 1;
    const inPtr = model.scalars.getData();
    model.interpolationInfo.pointer = inPtr.subarray(component * dataSize);
    model.interpolationInfo.scalarType = model.scalars.dataType;
    model.interpolationInfo.dataTypeSize = 1;
    model.interpolationInfo.numberOfComponents = publicAPI.computeNumberOfComponents(ncomp);
    model.interpolationInfo.borderMode = model.borderMode;
    publicAPI.internalUpdate();
  };
  publicAPI.internalUpdate = () => {
  };
  publicAPI.interpolateXYZ = (x, y, z, component) => {
    let value = model.outValue;
    const point = [x, y, z];
    const p = [(point[0] - model.origin[0]) / model.spacing[0], (point[1] - model.origin[1]) / model.spacing[1], (point[2] - model.origin[2]) / model.spacing[2]];
    if (publicAPI.checkBoundsIJK(p)) {
      const iinfo = {
        ...model.interpolationInfo
      };
      const ncomp = iinfo.increments[0] - model.componentOffset;
      const dataTypeSize = 1;
      let c2 = component > 0 ? component : 0;
      c2 = c2 < ncomp ? c2 : ncomp - 1;
      iinfo.pointer = model.interpolationInfo.pointer.subarray(dataTypeSize * c2);
      iinfo.numberOfComponents = 1;
      const v = [value];
      publicAPI.interpolatePoint(iinfo, p, v);
      value = v[0];
    }
    return value;
  };
  publicAPI.interpolate = (point, value) => {
    const p = [(point[0] - model.origin[0]) / model.spacing[0], (point[1] - model.origin[1]) / model.spacing[1], (point[2] - model.origin[2]) / model.spacing[2]];
    if (publicAPI.checkBoundsIJK(p)) {
      publicAPI.interpolatePoint(model.interpolationInfo, p, value);
      return true;
    }
    for (let i = 0; i < model.interpolationInfo.numberOfComponents; ++i) {
      value[i] = model.outValue;
    }
    return false;
  };
  publicAPI.computeNumberOfComponents = (inputCount) => {
    const component = Math.min(Math.max(model.componentOffset, 0), inputCount - 1);
    const count = model.componentCount < inputCount - component ? model.componentCount : inputCount - component;
    return count > 0 ? count : inputCount - component;
  };
  publicAPI.getNumberOfComponents = () => model.interpolationInfo.numberOfComponents;
  publicAPI.interpolateIJK = (point, value) => {
    publicAPI.interpolatePoint(model.interpolationInfo, point, value);
  };
  publicAPI.checkBoundsIJK = (point) => !(point[0] < model.structuredBounds[0] || point[0] > model.structuredBounds[1] || point[1] < model.structuredBounds[2] || point[1] > model.structuredBounds[3] || point[2] < model.structuredBounds[4] || point[2] > model.structuredBounds[5]);
  publicAPI.computeSupportSize = null;
  publicAPI.isSeparable = null;
  publicAPI.precomputeWeightsForExtent = (matrix, inExtent, checkExtent) => {
  };
  publicAPI.FreePrecomputedWeights = (weights) => {
  };
  publicAPI.interpolatePoint = (interpolationInfo, point, value) => {
  };
  publicAPI.interpolateRow = (weights, xIdx, yIdx, zIdx, value, n) => {
  };
}
var DEFAULT_VALUES61 = {
  outValue: 0,
  tolerance: Number.EPSILON,
  componentOffset: 0,
  componentCount: -1,
  borderMode: ImageBorderMode2.CLAMP,
  slidingWindow: false,
  scalars: null,
  interpolationInfo: {
    ...vtkInterpolationInfo
  },
  interpolationFunc: null,
  rowInterpolationFunc: null,
  structuredBounds: [0, -1, 0, -1, 0, -1],
  spacing: null,
  origin: null,
  extent: null
};
function extend70(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES61, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["outValue", "tolerance", "componentOffset", "componentCount", "borderMode", "slidingWindow"]);
  macro.get(publicAPI, model, ["origin", "spacing"]);
  vtkAbstractImageInterpolator(publicAPI, model);
}
var newInstance70 = macro.newInstance(extend70, "vtkAbstractImageInterpolator");
var vtkAbstractImageInterpolator$1 = {
  newInstance: newInstance70,
  extend: extend70,
  ...Constants7
};

// node_modules/@kitware/vtk.js/Imaging/Core/ImageInterpolator.js
function vtkImageInterpolator(publicAPI, model) {
  model.classHierarchy.push("vtkImageInterpolator");
  publicAPI.computeSupportSize = (matrix) => {
    let s = 1;
    if (model.interpolationMode === InterpolationMode.LINEAR) {
      s = 2;
    } else if (model.interpolationMode === InterpolationMode.CUBIC) {
      s = 4;
    }
    const size = [s, s, s];
    if (matrix == null) {
      return size;
    }
    if (matrix[12] !== 0 || matrix[13] !== 0 || matrix[14] !== 0 || matrix[15] !== 1) {
      return size;
    }
    for (let i = 0; i < 3; ++i) {
      let integerRow = true;
      for (let j = 0; j < 3; ++j) {
        integerRow = integerRow && Number.isInteger(matrix[4 * i + j]);
      }
      if (integerRow) {
        size[i] = 1;
      }
    }
    return size;
  };
  publicAPI.internalUpdate = () => {
    model.interpolationInfo.interpolationMode = model.interpolationMode;
  };
  publicAPI.isSeparable = () => true;
  publicAPI.interpolateNearest = (interpolationInfo, point, value) => {
    const inExt = interpolationInfo.extent;
    const inInc = interpolationInfo.increments;
    const numscalars = interpolationInfo.numberOfComponents;
    let inIdX0 = vtkInterpolationMathRound(point[0]);
    let inIdY0 = vtkInterpolationMathRound(point[1]);
    let inIdZ0 = vtkInterpolationMathRound(point[2]);
    switch (interpolationInfo.borderMode) {
      case ImageBorderMode.REPEAT:
        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);
        break;
      case ImageBorderMode.MIRROR:
        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);
        break;
      default:
        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);
        break;
    }
    const startId = inIdX0 * inInc[0] + inIdY0 * inInc[1] + inIdZ0 * inInc[2];
    for (let i = 0; i < numscalars; ++i) {
      value[i] = interpolationInfo.pointer[startId + i];
    }
  };
  publicAPI.interpolateLinear = (interpolationInfo, point, value) => {
    const inExt = interpolationInfo.extent;
    const inInc = interpolationInfo.increments;
    const numscalars = interpolationInfo.numberOfComponents;
    const floorX = vtkInterpolationMathFloor(point[0]);
    const floorY = vtkInterpolationMathFloor(point[1]);
    const floorZ = vtkInterpolationMathFloor(point[2]);
    let inIdX0 = floorX.floored;
    let inIdY0 = floorY.floored;
    let inIdZ0 = floorZ.floored;
    const fx = floorX.error;
    const fy = floorY.error;
    const fz = floorZ.error;
    let inIdX1 = inIdX0 + (fx !== 0);
    let inIdY1 = inIdY0 + (fy !== 0);
    let inIdZ1 = inIdZ0 + (fz !== 0);
    switch (interpolationInfo.borderMode) {
      case ImageBorderMode.REPEAT:
        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);
        inIdX1 = vtkInterpolationMathWrap(inIdX1, inExt[0], inExt[1]);
        inIdY1 = vtkInterpolationMathWrap(inIdY1, inExt[2], inExt[3]);
        inIdZ1 = vtkInterpolationMathWrap(inIdZ1, inExt[4], inExt[5]);
        break;
      case ImageBorderMode.MIRROR:
        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);
        inIdX1 = vtkInterpolationMathMirror(inIdX1, inExt[0], inExt[1]);
        inIdY1 = vtkInterpolationMathMirror(inIdY1, inExt[2], inExt[3]);
        inIdZ1 = vtkInterpolationMathMirror(inIdZ1, inExt[4], inExt[5]);
        break;
      default:
        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);
        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);
        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);
        inIdX1 = vtkInterpolationMathClamp(inIdX1, inExt[0], inExt[1]);
        inIdY1 = vtkInterpolationMathClamp(inIdY1, inExt[2], inExt[3]);
        inIdZ1 = vtkInterpolationMathClamp(inIdZ1, inExt[4], inExt[5]);
        break;
    }
    const factX0 = inIdX0 * inInc[0];
    const factX1 = inIdX1 * inInc[0];
    const factY0 = inIdY0 * inInc[1];
    const factY1 = inIdY1 * inInc[1];
    const factZ0 = inIdZ0 * inInc[2];
    const factZ1 = inIdZ1 * inInc[2];
    const i00 = factY0 + factZ0;
    const i01 = factY0 + factZ1;
    const i10 = factY1 + factZ0;
    const i11 = factY1 + factZ1;
    const rx = 1 - fx;
    const ry = 1 - fy;
    const rz = 1 - fz;
    const ryrz = ry * rz;
    const fyrz = fy * rz;
    const ryfz = ry * fz;
    const fyfz = fy * fz;
    const inPtr = interpolationInfo.pointer;
    for (let i = 0; i < numscalars; ++i) {
      value[i] = rx * (ryrz * inPtr[factX0 + i00 + i * 4] + ryfz * inPtr[factX0 + i01 + i * 4] + fyrz * inPtr[factX0 + i10 + i * 4] + fyfz * inPtr[factX0 + i11 + i * 4]) + fx * (ryrz * inPtr[factX1 + i00 + i * 4] + ryfz * inPtr[factX1 + i01 + i * 4] + fyrz * inPtr[factX1 + i10 + i * 4] + fyfz * inPtr[factX1 + i11 + i * 4]);
    }
  };
  publicAPI.interpolatePoint = (interpolationInfo, point, value) => {
    switch (model.interpolationMode) {
      case InterpolationMode.LINEAR:
        publicAPI.interpolateLinear(interpolationInfo, point, value);
        break;
      case InterpolationMode.CUBIC:
        console.log("CUBIC not implemented");
        break;
      case InterpolationMode.NEAREST:
      default:
        publicAPI.interpolateNearest(interpolationInfo, point, value);
        break;
    }
  };
  publicAPI.interpolateRowNearest = (weights, idX, idY, idZ, outPtr, n) => {
    const iX = weights.positions[0].subarray(idX);
    const iY = weights.positions[1].subarray(idY);
    const iZ = weights.positions[2].subarray(idZ);
    const inPtr0 = weights.pointer.subarray(iY[0] + iZ[0]);
    const numscalars = weights.numberOfComponents;
    for (let i = 0; i < n; ++i) {
      outPtr.set(inPtr0.subarray(iX[i], numscalars), i * numscalars);
    }
  };
  publicAPI.interpolateRowLinear = (weights, idX, idY, idZ, outPtr, n) => {
    const stepX = weights.kernelSize[0];
    const stepY = weights.kernelSize[1];
    const stepZ = weights.kernelSize[2];
    const idXtemp = idX * stepX;
    const idYtemp = idY * stepY;
    const idZtemp = idZ * stepZ;
    const fX = weights.weights[0].subarray(idXtemp);
    const fY = weights.weights[1].subarray(idYtemp);
    const fZ = weights.weights[2].subarray(idZtemp);
    const iX = weights.positions[0].subarray(idXtemp);
    const iY = weights.positions[1].subarray(idYtemp);
    const iZ = weights.positions[2].subarray(idZtemp);
    const inPtr = weights.pointer;
    const numscalars = weights.numberOfComponents;
    const i00 = iY.subarray(iZ[0]);
    let i01 = i00;
    let i10 = i00;
    let i11 = i00;
    let ry = 1;
    let fy = 0;
    let rz = 1;
    let fz = 0;
    if (stepY === 2) {
      i10 = iY[1].subarray(iZ[0]);
      i11 = i10;
      ry = fY[0];
      fy = fY[1];
    }
    if (stepZ === 2) {
      i01 = iY[0].subarray(iZ[1]);
      i11 = i01;
      rz = fZ[0];
      fz = fZ[1];
    }
    if (stepY + stepZ === 4) {
      i11 = iY[1].subarray(iZ[1]);
    }
    const ryrz = ry * rz;
    const ryfz = ry * fz;
    const fyrz = fy * rz;
    const fyfz = fy * fz;
    if (stepX === 1) {
      if (fy === 0 && fz === 0) {
        for (let i = n; i > 0; --i) {
          for (let j = 0; j < numscalars; j++) {
            outPtr[j + n - i] = inPtr[i00 + iX[n - i] + j];
          }
        }
      } else if (fy === 0) {
        for (let i = n; i > 0; --i) {
          for (let j = 0; j < numscalars; j++) {
            outPtr[j + n - i] = rz * inPtr[iX[n - i] + i00 + j * 4] + fz * inPtr[iX[n - i] + i01 + j * 4];
          }
        }
      } else {
        for (let i = n; i > 0; --i) {
          for (let j = 0; j < numscalars; j++) {
            outPtr[j + n - i] = ryrz * inPtr[iX[n - i] + i00 + j * 4] + ryfz * inPtr[iX[n - i] + i01 + j * 4] + fyrz * inPtr[iX[n - i] + i10 + j * 4] + fyfz * inPtr[iX[n - i] + i11 + j * 4];
          }
        }
      }
    } else if (fz === 0) {
      let x = 0;
      for (let i = n; i > 0; --i) {
        const rx = fX[0 + 2 * x];
        const fx = fX[1 + 2 * x];
        const t0 = iX[0 + 2 * x];
        const t1 = iX[1 + 2 * x];
        for (let j = 0; j < numscalars; j++) {
          outPtr[j + n - i] = rx * (ry * inPtr[t0 + i00 + j * 4] + fy * inPtr[t0 + i10 + j * 4]) + fx * (ry * inPtr[t1 + i00 + j * 4] + fy * inPtr[t1 + i10 + j * 4]);
        }
        x++;
      }
    } else {
      let x = 0;
      for (let i = n; i > 0; --i) {
        const rx = fX[0 + 2 * x];
        const fx = fX[1 + 2 * x];
        const t0 = iX[0 + 2 * x];
        const t1 = iX[1 + 2 * x];
        for (let j = 0; j < numscalars; j++) {
          outPtr[j] = rx * (ryrz * inPtr[t0 + i00 + j * 4] + ryfz * inPtr[t0 + i01 + j * 4] + fyrz * inPtr[t0 + i10 + j * 4] + fyfz * inPtr[t0 + i11 + j * 4]) + fx * (ryrz * inPtr[t1 + i00 + j * 4] + ryfz * inPtr[t1 + i01 + j * 4] + fyrz * inPtr[t1 + i10 + j * 4] + fyfz * inPtr[t1 + i11 + j * 4]);
        }
        x++;
      }
    }
  };
  publicAPI.interpolateRow = (weights, xIdx, yIdx, zIdx, value, n) => {
    switch (model.interpolationMode) {
      case InterpolationMode.LINEAR:
        publicAPI.interpolateRowLinear(weights, xIdx, yIdx, zIdx, value, n);
        break;
      case InterpolationMode.CUBIC:
        console.log("CUBIC not implemented");
        break;
      case InterpolationMode.NEAREST:
      default:
        publicAPI.interpolateRowNearest(weights, xIdx, yIdx, zIdx, value, n);
        break;
    }
  };
  publicAPI.vtkTricubicInterpWeights = (f2) => {
    const half = 0.5;
    const fm1 = f2 - 1;
    const fd2 = f2 * half;
    const ft3 = f2 * 3;
    return [-fd2 * fm1 * fm1, ((ft3 - 2) * fd2 - 1) * fm1, -((ft3 - 4) * f2 - 1) * fd2, f2 * fd2 * fm1];
  };
  publicAPI.precomputeWeightsForExtent = (matrix, outExt, clipExt) => {
    const weights = {
      ...vtkInterpolationWeights.newInstance(),
      ...model.interpolationInfo
    };
    weights.weightType = "Float32Array";
    const interpMode = weights.interpolationMode;
    let validClip = true;
    for (let j = 0; j < 3; ++j) {
      let k;
      for (k = 0; k < 3; ++k) {
        if (matrix[4 * j + k] !== 0) {
          break;
        }
      }
      clipExt[2 * j] = outExt[2 * j];
      clipExt[2 * j + 1] = outExt[2 * j + 1];
      const minExt = weights.extent[2 * k];
      const maxExt = weights.extent[2 * k + 1];
      const minBounds = model.structuredBounds[2 * k];
      const maxBounds = model.structuredBounds[2 * k + 1];
      let step = 1;
      step = interpMode < InterpolationMode.LINEAR ? step : 2;
      step = interpMode < InterpolationMode.CUBIC ? step : 4;
      const inCount = maxExt - minExt + 1;
      step = step < inCount ? step : inCount;
      if (Number.isInteger(matrix[4 * j + k]) && Number.isInteger(matrix[4 * k + k])) {
        step = 1;
      }
      const size = step * (outExt[2 * j + 1] - outExt[2 * j] + 1);
      const positions = new Int16Array(size);
      const startPositions = step * outExt[2 * j];
      let constants = null;
      if (interpMode !== InterpolationMode.NEAREST) {
        constants = new Int16Array(size);
      }
      weights.kernelSize[j] = step;
      weights.weightExtent[2 * j] = outExt[2 * j];
      weights.weightExtent[2 * j + 1] = outExt[2 * j + 1];
      weights.positions[j] = positions;
      weights.weights[j] = constants;
      let region = 0;
      for (let i = outExt[2 * j]; i <= outExt[2 * j + 1]; ++i) {
        const point = matrix[4 * 3 + k] + i * matrix[4 * j + k];
        let lcount = step;
        let inId0 = 0;
        let f2 = 0;
        if (interpMode === InterpolationMode.NEAREST) {
          inId0 = Math.round(point);
        } else {
          const res = vtkInterpolationMathFloor(point);
          inId0 = res.integer;
          f2 = res.error;
          if (interpMode === InterpolationMode.CUBIC && step !== 1) {
            inId0--;
            lcount = 4;
          }
        }
        const inId = [0, 0, 0, 0];
        let l = 0;
        switch (weights.borderMode) {
          case ImageBorderMode.REPEAT:
            do {
              inId[l] = vtkInterpolationMathWrap(inId0, minExt, maxExt);
              inId0++;
            } while (++l < lcount);
            break;
          case ImageBorderMode.MIRROR:
            do {
              inId[l] = vtkInterpolationMathMirror(inId0, minExt, maxExt);
              inId0++;
            } while (++l < lcount);
            break;
          default:
            do {
              inId[l] = vtkInterpolationMathClamp(inId0, minExt, maxExt);
              inId0++;
            } while (++l < lcount);
            break;
        }
        const inInc = weights.increments[k];
        positions[step * i - startPositions] = inId[0] * inInc;
        if (interpMode !== InterpolationMode.NEAREST) {
          constants[step * i - startPositions] = 1;
        }
        if (step > 1) {
          if (interpMode === InterpolationMode.LINEAR) {
            positions[step * i + 1 - startPositions] = inId[1] * inInc;
            constants[step * i - startPositions] = 1 - f2;
            constants[step * i + 1 - startPositions] = f2;
          } else if (interpMode === InterpolationMode.CUBIC) {
            const g = publicAPI.vtkTricubicInterpWeights(f2);
            if (step === 4) {
              for (let ll = 0; ll < 4; ll++) {
                positions[step * i + ll - startPositions] = inId[ll] * inInc;
                constants[step * i + ll - startPositions] = g[ll];
              }
            } else {
              const gg = [0, 0, 0, 0];
              for (let ll = 0; ll < 4; ll++) {
                const rIdx = inId[ll] - minExt;
                gg[rIdx] += g[ll];
              }
              for (let jj = 0; jj < step; jj++) {
                positions[step * i + jj - startPositions] = minExt + jj;
                constants[step * i + jj - startPositions] = gg[jj];
              }
            }
          }
        }
        if (point >= minBounds && point <= maxBounds) {
          if (region === 0) {
            region = 1;
            clipExt[2 * j] = i;
          }
        } else if (region === 1) {
          region = 2;
          clipExt[2 * j + 1] = i - 1;
        }
      }
      if (region === 0 || clipExt[2 * j] > clipExt[2 * j + 1]) {
        validClip = false;
      }
    }
    if (!validClip) {
      for (let j = 0; j < 3; j++) {
        clipExt[2 * j] = outExt[2 * j];
        clipExt[2 * j + 1] = outExt[2 * j] - 1;
      }
    }
  };
}
var DEFAULT_VALUES62 = {
  interpolationMode: InterpolationMode.NEAREST
};
function extend71(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES62, initialValues);
  vtkAbstractImageInterpolator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["interpolationMode"]);
  vtkImageInterpolator(publicAPI, model);
}
var newInstance71 = macro.newInstance(extend71, "vtkImageInterpolator");
var vtkImageInterpolator$1 = {
  newInstance: newInstance71,
  extend: extend71
};

// node_modules/@kitware/vtk.js/Imaging/Core/ImagePointDataIterator.js
function vtkImagePointDataIterator(publicAPI, model) {
  model.classHierarchy.push("vtkImagePointDataIterator");
  publicAPI.initialize = (image, inExtent, stencil, algorithm) => {
    const dataExtent = image.getExtent();
    let extent = inExtent;
    if (extent == null) {
      extent = dataExtent;
    }
    let emptyExtent = false;
    for (let i = 0; i < 6; i += 2) {
      model.extent[i] = Math.max(extent[i], dataExtent[i]);
      model.extent[i + 1] = Math.min(extent[i + 1], dataExtent[i + 1]);
      if (model.extent[i] > model.extent[i + 1]) {
        emptyExtent = true;
      }
    }
    model.rowIncrement = dataExtent[1] - dataExtent[0] + 1;
    model.sliceIncrement = model.rowIncrement * (dataExtent[3] - dataExtent[2] + 1);
    let rowSpan;
    let sliceSpan;
    let volumeSpan;
    if (!emptyExtent) {
      rowSpan = model.extent[1] - model.extent[0] + 1;
      sliceSpan = model.extent[3] - model.extent[2] + 1;
      volumeSpan = model.extent[5] - model.extent[4] + 1;
      model.id = model.extent[0] - dataExtent[0] + (model.extent[2] - dataExtent[2]) * model.rowIncrement + (model.extent[4] - dataExtent[4]) * model.sliceIncrement;
      model.rowEndIncrement = model.rowIncrement - rowSpan;
      model.sliceEndIncrement = model.rowEndIncrement + model.sliceIncrement - model.rowIncrement * sliceSpan;
    } else {
      rowSpan = 0;
      sliceSpan = 0;
      volumeSpan = 0;
      model.id = 0;
      model.rowEndIncrement = 0;
      model.sliceEndIncrement = 0;
      for (let i = 0; i < 6; i += 2) {
        model.extent[i] = dataExtent[i];
        model.extent[i + 1] = dataExtent[i] - 1;
      }
    }
    model.spanEnd = model.id + rowSpan;
    model.rowEnd = model.id + rowSpan;
    model.sliceEnd = model.id + (model.rowIncrement * sliceSpan - model.rowEndIncrement);
    model.end = model.id + (model.sliceIncrement * volumeSpan - model.sliceEndIncrement);
    model.index[0] = model.extent[0];
    model.index[1] = model.extent[2];
    model.index[2] = model.extent[4];
    model.startY = model.index[1];
    if (stencil) {
      model.hasStencil = true;
      model.inStencil = false;
      model.spanIndex = 0;
      const stencilExtent = stencil.getExtent();
      model.spanSliceIncrement = 0;
      model.spanSliceEndIncrement = 0;
      if (stencilExtent[3] >= stencilExtent[2] && stencilExtent[5] >= stencilExtent[4]) {
        model.spanSliceIncrement = stencilExtent[3] - stencilExtent[2] + 1;
        const botOffset = model.extent[2] - stencilExtent[2];
        if (botOffset >= 0) {
          model.spanSliceEndIncrement += botOffset;
        }
        const topOffset = stencilExtent[3] - model.extent[3];
        if (topOffset >= 0) {
          model.spanSliceEndIncrement += topOffset;
        }
      }
      let startOffset = 0;
      const yOffset = model.extent[2] - stencilExtent[2];
      if (yOffset < 0) {
        model.extent[2] = stencilExtent[2];
        startOffset -= 1;
      } else {
        startOffset += yOffset;
      }
      if (stencilExtent[3] <= model.extent[3]) {
        model.extent[3] = stencilExtent[3];
      }
      const zOffset = model.extent[4] - stencilExtent[4];
      if (zOffset < 0) {
        model.extent[4] = stencilExtent[4];
        if (yOffset >= 0) {
          startOffset -= 1 + model.spanSliceEndIncrement;
        }
      } else {
        startOffset += zOffset * model.spanSliceIncrement;
      }
      if (stencilExtent[5] <= model.extent[5]) {
        model.extent[5] = stencilExtent[5];
      }
      if (model.extent[2] <= model.extent[3] && model.extent[4] <= model.extent[5]) {
        model.spanCountPointer = stencil.extentListLengths.subarray(startOffset);
        model.spanListPointer = stencil.extentLists.subarray(startOffset);
        if (yOffset >= 0 && zOffset >= 0) {
          model.inStencil = true;
          model.setSpanState(model.extent[0]);
        }
      } else {
        model.spanCountPointer = null;
        model.spanListPointer = null;
        model.inStencil = false;
      }
    } else {
      model.hasStencil = false;
      model.inStencil = true;
      model.spanSliceEndIncrement = 0;
      model.spanSliceIncrement = 0;
      model.spanIndex = 0;
      model.spanCountPointer = null;
      model.spanListPointer = null;
    }
    if (algorithm) {
      model.algorithm = algorithm;
      const maxCount = sliceSpan * volumeSpan;
      model.target = maxCount / 50 + 1;
      model.count = model.target * 50 - maxCount / model.target * model.target + 1;
    } else {
      model.algorithm = null;
      model.target = 0;
      model.count = 0;
    }
  };
  publicAPI.setSpanState = (idX) => {
    let inStencil = false;
    const spans = model.spanListPointer;
    const n = model.spanCountPointer[0];
    let i;
    for (i = 0; i < n; ++i) {
      if (spans[i] > idX) {
        break;
      }
      inStencil = !inStencil;
    }
    model.spanIndex = i;
    model.inStencil = inStencil;
    let endIdX = model.extent[1] + 1;
    if (i < n && spans[i] <= model.extent[1]) {
      endIdX = spans[i];
    }
    const rowStart = model.rowEnd - (model.rowIncrement - model.rowEndIncrement);
    model.id = rowStart + (idX - model.extent[0]);
    model.spanEnd = rowStart + (endIdX - model.extent[0]);
  };
  publicAPI.nextSpan = () => {
    if (model.spanEnd === model.rowEnd) {
      let spanIncr = 1;
      if (model.spanEnd !== model.sliceEnd) {
        model.id = model.rowEnd + model.rowEndIncrement;
        model.rowEnd += model.rowIncrement;
        model.spanEnd = model.rowEnd;
        model.index[1]++;
      } else if (model.spanEnd !== model.end) {
        model.id = model.sliceEnd + model.sliceEndIncrement;
        model.sliceEnd += model.sliceIncrement;
        model.rowEnd = model.id + (model.rowIncrement - model.rowEndIncrement);
        model.spanEnd = model.rowEnd;
        model.index[1] = model.startY;
        model.index[2]++;
        spanIncr += model.spanSliceEndIncrement;
      } else {
        model.id = model.end;
        return;
      }
      model.index[0] = model.extent[0];
      if (model.hasStencil) {
        if (model.index[1] >= model.extent[2] && model.index[1] <= model.extent[3] && model.index[2] >= model.extent[4] && model.index[2] <= model.extent[5]) {
          model.spanCountPointer = model.spanCountPointer.subarray(spanIncr);
          model.spanListPointer = model.spanListPointer.subarray(spanIncr);
          publicAPI.setSpanState(model.extent[0]);
        } else {
          model.inStencil = false;
        }
      }
      if (model.algorithm) {
        publicAPI.reportProgress();
      }
    } else {
      model.id = model.spanEnd;
      const spanCount = model.spanCountPointer[0];
      let endIdX = model.extent[1] + 1;
      model.index[0] = endIdX;
      if (model.spanIndex < spanCount) {
        const tmpIdX = model.spanListPointer[model.spanIndex];
        if (tmpIdX < endIdX) {
          model.index[0] = tmpIdX;
        }
      }
      model.spanIndex++;
      if (model.spanIndex < spanCount) {
        const tmpIdX = model.spanListPointer[model.spanIndex];
        if (tmpIdX < endIdX) {
          endIdX = tmpIdX;
        }
      }
      model.spanEnd = model.rowEnd - (model.rowIncrement - model.rowEndIncrement) + (endIdX - model.extent[0]);
      model.inStencil = !model.inStencil;
    }
  };
  publicAPI.isAtEnd = () => model.id === model.end;
  publicAPI.isInStencil = () => model.inStencil;
  publicAPI.spanEndId = () => model.spanEnd;
  publicAPI.reportProgress = () => {
  };
  publicAPI.getArray = (array, i) => array.getData().subarray(i * array.getNumberOfComponents());
  publicAPI.getScalars = function(image) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return publicAPI.getArray(image.getPointData().getScalars(), i);
  };
}
var DEFAULT_VALUES63 = {
  spanState: 0,
  extent: [0, -1, 0, -1, 0, -1],
  end: 0,
  spanEnd: 0,
  rowEnd: 0,
  sliceEnd: 0,
  rowIncrement: 0,
  rowEndIncrement: 0,
  sliceIncrement: 0,
  sliceEndIncrement: 0,
  id: 0,
  index: [0, 0, 0],
  startY: 0,
  hasStencil: false,
  inStencil: true,
  spanIndex: 0,
  spanSliceIncrement: 0,
  spanSliceEndIncrement: 0,
  spanCountPointer: null,
  spanListPointer: null,
  algorithm: null,
  target: 0,
  count: 0
};
function extend72(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES63, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["id", "index"]);
  vtkImagePointDataIterator(publicAPI, model);
}
var newInstance72 = macro.newInstance(extend72, "vtkImagePointDataIterator");
var vtkImagePointDataIterator$1 = {
  newInstance: newInstance72,
  extend: extend72
};

// node_modules/@kitware/vtk.js/Imaging/Core/ImageReslice/Constants.js
var SlabMode = {
  MIN: 0,
  MAX: 1,
  MEAN: 2,
  SUM: 3
};
var Constants8 = {
  SlabMode
};

// node_modules/@kitware/vtk.js/Imaging/Core/ImageReslice.js
var {
  SlabMode: SlabMode2
} = Constants8;
var {
  vtkErrorMacro: vtkErrorMacro36
} = macro;
function vtkImageReslice(publicAPI, model) {
  model.classHierarchy.push("vtkImageReslice");
  const superClass = {
    ...publicAPI
  };
  const indexMatrix = mat4_exports.identity(new Float64Array(16));
  let optimizedTransform = null;
  function getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f2) {
    const n = sampleCount - 1;
    for (let i = 0; i < inComponents; i += 1) {
      let result = tmpPtr[i] * 0.5;
      for (let j = 1; j < n; j += 1) {
        result += tmpPtr[i + j * inComponents];
      }
      result += tmpPtr[i + n * inComponents] * 0.5;
      tmpPtr[i] = result * f2;
    }
  }
  function getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f2) {
    for (let i = 0; i < inComponents; i += 1) {
      let result = tmpPtr[i];
      for (let j = 1; j < sampleCount; j += 1) {
        result += tmpPtr[i + j * inComponents];
      }
      tmpPtr[i] = result * f2;
    }
  }
  function getImageResliceCompositeMinValue(tmpPtr, inComponents, sampleCount) {
    for (let i = 0; i < inComponents; i += 1) {
      let result = tmpPtr[i];
      for (let j = 1; j < sampleCount; j += 1) {
        result = Math.min(result, tmpPtr[i + j * inComponents]);
      }
      tmpPtr[i] = result;
    }
  }
  function getImageResliceCompositeMaxValue(tmpPtr, inComponents, sampleCount) {
    for (let i = 0; i < inComponents; i += 1) {
      let result = tmpPtr[i];
      for (let j = 1; j < sampleCount; j += 1) {
        result = Math.max(result, tmpPtr[i + j * inComponents]);
      }
      tmpPtr[i] = result;
    }
  }
  function getImageResliceCompositeMeanValue(tmpPtr, inComponents, sampleCount) {
    const f2 = 1 / sampleCount;
    getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f2);
  }
  function getImageResliceCompositeMeanTrap(tmpPtr, inComponents, sampleCount) {
    const f2 = 1 / (sampleCount - 1);
    getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f2);
  }
  function getImageResliceCompositeSumValue(tmpPtr, inComponents, sampleCount) {
    const f2 = 1;
    getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f2);
  }
  function getImageResliceCompositeSumTrap(tmpPtr, inComponents, sampleCount) {
    const f2 = 1;
    getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f2);
  }
  publicAPI.getMTime = () => {
    let mTime = superClass.getMTime();
    if (model.resliceTransform) {
      mTime = Math.max(mTime, model.resliceTransform.getMTime());
    }
    return mTime;
  };
  publicAPI.setResliceAxes = (resliceAxes) => {
    if (!model.resliceAxes) {
      model.resliceAxes = mat4_exports.identity(new Float64Array(16));
    }
    if (!mat4_exports.exactEquals(model.resliceAxes, resliceAxes)) {
      mat4_exports.copy(model.resliceAxes, resliceAxes);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const input = inData[0];
    if (!input) {
      vtkErrorMacro36("Invalid or missing input");
      return;
    }
    const origin3 = input.getOrigin();
    const inSpacing = input.getSpacing();
    const dims = input.getDimensions();
    const inScalars = input.getPointData().getScalars();
    const inWholeExt = [0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1];
    const outOrigin = [0, 0, 0];
    const outSpacing = [1, 1, 1];
    const outWholeExt = [0, 0, 0, 0, 0, 0];
    const outDims = [0, 0, 0];
    const matrix = mat4_exports.identity(new Float64Array(16));
    if (model.resliceAxes) {
      mat4_exports.multiply(matrix, matrix, model.resliceAxes);
    }
    const imatrix = new Float64Array(16);
    mat4_exports.invert(imatrix, matrix);
    const inCenter = [origin3[0] + 0.5 * (inWholeExt[0] + inWholeExt[1]) * inSpacing[0], origin3[1] + 0.5 * (inWholeExt[2] + inWholeExt[3]) * inSpacing[1], origin3[2] + 0.5 * (inWholeExt[4] + inWholeExt[5]) * inSpacing[2]];
    let maxBounds = null;
    if (model.autoCropOutput) {
      maxBounds = publicAPI.getAutoCroppedOutputBounds(input);
    }
    for (let i = 0; i < 3; i++) {
      let s = 0;
      let d2 = 0;
      let e2 = 0;
      let c2 = 0;
      if (model.transformInputSampling) {
        let r = 0;
        for (let j = 0; j < 3; j++) {
          c2 += imatrix[4 * j + i] * (inCenter[j] - matrix[4 * 3 + j]);
          const tmp = matrix[4 * i + j] * matrix[4 * i + j];
          s += tmp * Math.abs(inSpacing[j]);
          d2 += tmp * (inWholeExt[2 * j + 1] - inWholeExt[2 * j]) * Math.abs(inSpacing[j]);
          e2 += tmp * inWholeExt[2 * j];
          r += tmp;
        }
        s /= r;
        d2 /= r * Math.sqrt(r);
        e2 /= r;
      } else {
        c2 = inCenter[i];
        s = inSpacing[i];
        d2 = (inWholeExt[2 * i + 1] - inWholeExt[2 * i]) * s;
        e2 = inWholeExt[2 * i];
      }
      if (model.outputSpacing == null) {
        outSpacing[i] = s;
      } else {
        outSpacing[i] = model.outputSpacing[i];
      }
      if (i >= model.outputDimensionality) {
        outWholeExt[2 * i] = 0;
        outWholeExt[2 * i + 1] = 0;
      } else if (model.outputExtent == null) {
        if (model.autoCropOutput) {
          d2 = maxBounds[2 * i + 1] - maxBounds[2 * i];
        }
        outWholeExt[2 * i] = Math.round(e2);
        outWholeExt[2 * i + 1] = Math.round(outWholeExt[2 * i] + Math.abs(d2 / outSpacing[i]));
      } else {
        outWholeExt[2 * i] = model.outputExtent[2 * i];
        outWholeExt[2 * i + 1] = model.outputExtent[2 * i + 1];
      }
      if (i >= model.outputDimensionality) {
        outOrigin[i] = 0;
      } else if (model.outputOrigin == null) {
        if (model.autoCropOutput) {
          outOrigin[i] = maxBounds[2 * i] - outWholeExt[2 * i] * outSpacing[i];
        } else {
          outOrigin[i] = c2 - 0.5 * (outWholeExt[2 * i] + outWholeExt[2 * i + 1]) * outSpacing[i];
        }
      } else {
        outOrigin[i] = model.outputOrigin[i];
      }
      outDims[i] = outWholeExt[2 * i + 1] - outWholeExt[2 * i] + 1;
    }
    let dataType = inScalars.getDataType();
    if (model.outputScalarType) {
      dataType = model.outputScalarType;
    }
    const numComponents = input.getPointData().getScalars().getNumberOfComponents();
    const outScalarsData = macro.newTypedArray(dataType, outDims[0] * outDims[1] * outDims[2] * numComponents);
    const outScalars = vtkDataArray$1.newInstance({
      name: "Scalars",
      values: outScalarsData,
      numberOfComponents: numComponents
    });
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkImageData$1.newInstance();
    output.setDimensions(outDims);
    output.setOrigin(outOrigin);
    output.setSpacing(outSpacing);
    if (model.outputDirection) {
      output.setDirection(model.outputDirection);
    }
    output.getPointData().setScalars(outScalars);
    publicAPI.getIndexMatrix(input, output);
    let interpolationMode = model.interpolationMode;
    model.usePermuteExecute = false;
    if (model.optimization) {
      if (optimizedTransform == null && model.slabSliceSpacingFraction === 1 && model.interpolator.isSeparable() && publicAPI.isPermutationMatrix(indexMatrix)) {
        model.usePermuteExecute = true;
        if (publicAPI.canUseNearestNeighbor(indexMatrix, outWholeExt)) {
          interpolationMode = InterpolationMode.NEAREST;
        }
      }
    }
    model.interpolator.setInterpolationMode(interpolationMode);
    let borderMode = ImageBorderMode.CLAMP;
    borderMode = model.wrap ? ImageBorderMode.REPEAT : borderMode;
    borderMode = model.mirror ? ImageBorderMode.MIRROR : borderMode;
    model.interpolator.setBorderMode(borderMode);
    const mintol = 762939453125e-17;
    const maxtol = 2 * 2147483647;
    let tol = 0.5 * model.border;
    tol = borderMode === ImageBorderMode.CLAMP ? tol : maxtol;
    tol = tol > mintol ? tol : mintol;
    model.interpolator.setTolerance(tol);
    model.interpolator.initialize(input);
    publicAPI.vtkImageResliceExecute(input, output);
    model.interpolator.releaseData();
    outData[0] = output;
  };
  publicAPI.vtkImageResliceExecute = (input, output) => {
    const inScalars = input.getPointData().getScalars();
    const outScalars = output.getPointData().getScalars();
    let outPtr = outScalars.getData();
    const outExt = output.getExtent();
    const newmat = indexMatrix;
    const nsamples = Math.max(model.slabNumberOfSlices, 1);
    const slabSampleSpacing = model.slabSliceSpacingFraction;
    const perspective = publicAPI.isPerspectiveMatrix(newmat);
    let inPtr = inScalars.getData();
    const inputScalarSize = 1;
    const inputScalarType = inScalars.getDataType();
    const inComponents = inScalars.getNumberOfComponents();
    const componentOffset = model.interpolator.getComponentOffset();
    const borderMode = model.interpolator.getBorderMode();
    const inDims = input.getDimensions();
    const inExt = [0, inDims[0] - 1, 0, inDims[1] - 1, 0, inDims[2] - 1];
    const inInc = [0, 0, 0];
    inInc[0] = inScalars.getNumberOfComponents();
    inInc[1] = inInc[0] * inDims[0];
    inInc[2] = inInc[1] * inDims[1];
    const fullSize = inDims[0] * inDims[1] * inDims[2];
    if (componentOffset > 0 && componentOffset + inComponents < inInc[0]) {
      inPtr = inPtr.subarray(inputScalarSize * componentOffset);
    }
    let interpolationMode = InterpolationMode.NEAREST;
    if (model.interpolator.isA("vtkImageInterpolator")) {
      interpolationMode = model.interpolator.getInterpolationMode();
    }
    const convertScalars = null;
    const rescaleScalars = model.scalarShift !== 0 || model.scalarScale !== 1;
    const optimizeNearest = interpolationMode === InterpolationMode.NEAREST && borderMode === ImageBorderMode.CLAMP && !(optimizedTransform != null || perspective || convertScalars != null || rescaleScalars) && inputScalarType === outScalars.getDataType() && fullSize === inScalars.getNumberOfTuples() && model.border === true && nsamples <= 1;
    const scalarType = outScalars.getDataType();
    const scalarSize = 1;
    const outComponents = outScalars.getNumberOfComponents();
    const xAxis = [0, 0, 0, 0];
    const yAxis = [0, 0, 0, 0];
    const zAxis = [0, 0, 0, 0];
    const origin3 = [0, 0, 0, 0];
    for (let i = 0; i < 4; ++i) {
      xAxis[i] = newmat[4 * 0 + i];
      yAxis[i] = newmat[4 * 1 + i];
      zAxis[i] = newmat[4 * 2 + i];
      origin3[i] = newmat[4 * 3 + i];
    }
    let floatPtr = null;
    if (!optimizeNearest) {
      floatPtr = new Float64Array(inComponents * (outExt[1] - outExt[0] + nsamples));
    }
    const background = macro.newTypedArray(inputScalarType, model.backgroundColor);
    const forceClamping = interpolationMode > InterpolationMode.LINEAR || nsamples > 1 && model.slabMode === SlabMode2.SUM;
    const convertpixels = publicAPI.getConversionFunc(inputScalarType, scalarType, model.scalarShift, model.scalarScale, forceClamping);
    const setpixels = publicAPI.getSetPixelsFunc(scalarType, scalarSize, outComponents, outPtr);
    const composite = publicAPI.getCompositeFunc(model.slabMode, model.slabTrapezoidIntegration);
    let idY = outExt[2] - 1;
    let idZ = outExt[4] - 1;
    const inPoint0 = [0, 0, 0, 0];
    const inPoint1 = [0, 0, 0, 0];
    const iter = vtkImagePointDataIterator$1.newInstance();
    iter.initialize(output, outExt, model.stencil, null);
    const outPtr0 = iter.getScalars(output, 0);
    let outPtrIndex = 0;
    const outTmp = macro.newTypedArray(scalarType, vtkBoundingBox.getDiagonalLength(outExt) * outComponents * 2);
    const interpolatedPtr = new Float64Array(inComponents * nsamples);
    const interpolatedPoint = new Float64Array(inComponents);
    for (; !iter.isAtEnd(); iter.nextSpan()) {
      const span = iter.spanEndId() - iter.getId();
      outPtrIndex = iter.getId() * scalarSize * outComponents;
      if (!iter.isInStencil()) {
        const n = setpixels(outTmp, background, outComponents, span);
        for (let i = 0; i < n; ++i) {
          outPtr0[outPtrIndex++] = outTmp[i];
        }
      } else {
        const outIndex = iter.getIndex();
        if (outIndex[2] > idZ) {
          idZ = outIndex[2];
          inPoint0[0] = origin3[0] + idZ * zAxis[0];
          inPoint0[1] = origin3[1] + idZ * zAxis[1];
          inPoint0[2] = origin3[2] + idZ * zAxis[2];
          inPoint0[3] = origin3[3] + idZ * zAxis[3];
          idY = outExt[2] - 1;
        }
        if (outIndex[1] > idY) {
          idY = outIndex[1];
          inPoint1[0] = inPoint0[0] + idY * yAxis[0];
          inPoint1[1] = inPoint0[1] + idY * yAxis[1];
          inPoint1[2] = inPoint0[2] + idY * yAxis[2];
          inPoint1[3] = inPoint0[3] + idY * yAxis[3];
        }
        const idXmin = outIndex[0];
        const idXmax = idXmin + span - 1;
        if (!optimizeNearest) {
          let wasInBounds = 1;
          let isInBounds = 1;
          let startIdX = idXmin;
          let idX = idXmin;
          const tmpPtr = floatPtr;
          let pixelIndex = 0;
          while (startIdX <= idXmax) {
            for (; idX <= idXmax && isInBounds === wasInBounds; idX++) {
              const inPoint2 = [inPoint1[0] + idX * xAxis[0], inPoint1[1] + idX * xAxis[1], inPoint1[2] + idX * xAxis[2], inPoint1[3] + idX * xAxis[3]];
              const inPoint3 = [0, 0, 0, 0];
              let inPoint = inPoint2;
              isInBounds = false;
              let interpolatedPtrIndex = 0;
              for (let sample = 0; sample < nsamples; ++sample) {
                if (nsamples > 1) {
                  let s = sample - 0.5 * (nsamples - 1);
                  s *= slabSampleSpacing;
                  inPoint3[0] = inPoint2[0] + s * zAxis[0];
                  inPoint3[1] = inPoint2[1] + s * zAxis[1];
                  inPoint3[2] = inPoint2[2] + s * zAxis[2];
                  inPoint3[3] = inPoint2[3] + s * zAxis[3];
                  inPoint = inPoint3;
                }
                if (perspective) {
                  const f2 = 1 / inPoint[3];
                  inPoint[0] *= f2;
                  inPoint[1] *= f2;
                  inPoint[2] *= f2;
                }
                if (optimizedTransform !== null) {
                  const inOrigin = model.interpolator.getOrigin();
                  const inSpacing = model.interpolator.getSpacing();
                  const inInvSpacing = [1 / inSpacing[0], 1 / inSpacing[1], 1 / inSpacing[2]];
                  publicAPI.applyTransform(optimizedTransform, inPoint, inOrigin, inInvSpacing);
                }
                if (model.interpolator.checkBoundsIJK(inPoint)) {
                  isInBounds = 1;
                  model.interpolator.interpolateIJK(inPoint, interpolatedPoint);
                  for (let i = 0; i < inComponents; ++i) {
                    interpolatedPtr[interpolatedPtrIndex++] = interpolatedPoint[i];
                  }
                }
              }
              if (interpolatedPtrIndex > inComponents) {
                composite(interpolatedPtr, inComponents, interpolatedPtrIndex / inComponents);
              }
              for (let i = 0; i < inComponents; ++i) {
                tmpPtr[pixelIndex++] = interpolatedPtr[i];
              }
              wasInBounds = idX > idXmin ? wasInBounds : isInBounds;
            }
            const endIdX = idX - 1 - (isInBounds !== wasInBounds);
            const numpixels = endIdX - startIdX + 1;
            let n = 0;
            if (wasInBounds) {
              if (rescaleScalars) {
                publicAPI.rescaleScalars(floatPtr, inComponents, idXmax - idXmin + 1, model.scalarShift, model.scalarScale);
              }
              {
                n = convertpixels(outTmp, floatPtr.subarray(startIdX * inComponents), outComponents, numpixels);
              }
            } else {
              n = setpixels(outTmp, background, outComponents, numpixels);
            }
            for (let i = 0; i < n; ++i) {
              outPtr0[outPtrIndex++] = outTmp[i];
            }
            startIdX += numpixels;
            wasInBounds = isInBounds;
          }
        } else {
          const inPtrTmp0 = inPtr;
          const outPtrTmp = outPtr;
          const inIncX = inInc[0] * inputScalarSize;
          const inIncY = inInc[1] * inputScalarSize;
          const inIncZ = inInc[2] * inputScalarSize;
          const inExtX = inExt[1] - inExt[0] + 1;
          const inExtY = inExt[3] - inExt[2] + 1;
          const inExtZ = inExt[5] - inExt[4] + 1;
          let startIdX = idXmin;
          let endIdX = idXmin - 1;
          let isInBounds = false;
          const bytesPerPixel = inputScalarSize * inComponents;
          for (let iidX = idXmin; iidX <= idXmax; iidX++) {
            const inPoint = [inPoint1[0] + iidX * xAxis[0], inPoint1[1] + iidX * xAxis[1], inPoint1[2] + iidX * xAxis[2]];
            const inIdX = vtkInterpolationMathRound(inPoint[0]) - inExt[0];
            const inIdY = vtkInterpolationMathRound(inPoint[1]) - inExt[2];
            const inIdZ = vtkInterpolationMathRound(inPoint[2]) - inExt[4];
            if (inIdX >= 0 && inIdX < inExtX && inIdY >= 0 && inIdY < inExtY && inIdZ >= 0 && inIdZ < inExtZ) {
              if (!isInBounds) {
                startIdX = iidX;
                isInBounds = true;
                const n2 = setpixels(outTmp, background, outComponents, startIdX - idXmin);
                for (let i = 0; i < n2; ++i) {
                  outPtr0[outPtrIndex++] = outTmp[i];
                }
              }
              endIdX = iidX;
              let offset = inIdX * inIncX + inIdY * inIncY + inIdZ * inIncZ;
              switch (bytesPerPixel) {
                case 1:
                  outPtr0[outPtrIndex++] = inPtrTmp0[offset];
                  break;
                case 2:
                case 3:
                case 4:
                case 8:
                case 12:
                case 16:
                  for (let i = 0; i < bytesPerPixel; ++i) {
                    outPtr0[outPtrIndex++] = inPtrTmp0[offset + i];
                  }
                  break;
                default: {
                  let oc = 0;
                  do {
                    outPtr0[outPtrIndex++] = inPtrTmp0[offset++];
                  } while (++oc !== bytesPerPixel);
                  break;
                }
              }
            } else if (isInBounds) {
              break;
            }
          }
          outPtr = outPtrTmp;
          const n = setpixels(outTmp, background, outComponents, idXmax - endIdX);
          for (let i = 0; i < n; ++i) {
            outPtr0[outPtrIndex++] = outTmp[i];
          }
        }
      }
    }
  };
  publicAPI.getIndexMatrix = (input, output) => {
    const transform = mat4_exports.identity(new Float64Array(16));
    optimizedTransform = null;
    if (model.resliceAxes) {
      mat4_exports.copy(transform, model.resliceAxes);
    }
    if (model.resliceTransform) {
      if (model.resliceTransform.isA("vtkHomogeneousTransform")) {
        mat4_exports.multiply(transform, model.resliceTransform.getMatrix(), transform);
      } else {
        vtkWarningMacro("Non homogeneous transform have not yet been ported");
      }
    }
    const outMatrix = output.getIndexToWorld();
    mat4_exports.multiply(transform, transform, outMatrix);
    if (optimizedTransform == null) {
      const inMatrix = input.getWorldToIndex();
      mat4_exports.multiply(transform, inMatrix, transform);
    }
    mat4_exports.copy(indexMatrix, transform);
    return indexMatrix;
  };
  publicAPI.getAutoCroppedOutputBounds = (input) => {
    const inOrigin = input.getOrigin();
    const inSpacing = input.getSpacing();
    const inDirection = input.getDirection();
    const dims = input.getDimensions();
    const inWholeExt = [0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1];
    const matrix = new Float64Array(16);
    if (model.resliceAxes) {
      mat4_exports.invert(matrix, model.resliceAxes);
    } else {
      mat4_exports.identity(matrix);
    }
    let transform = null;
    if (model.resliceTransform) {
      transform = model.resliceTransform.getInverse();
    }
    let imageTransform = null;
    if (!vtkMath.isIdentity3x3(inDirection)) {
      imageTransform = vtkMatrixBuilder.buildFromRadian().translate(inOrigin[0], inOrigin[1], inOrigin[2]).multiply3x3(inDirection).translate(-inOrigin[0], -inOrigin[1], -inOrigin[2]).invert().getMatrix();
    }
    const bounds2 = [Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE];
    const point = [0, 0, 0, 0];
    for (let i = 0; i < 8; ++i) {
      point[0] = inOrigin[0] + inWholeExt[i % 2] * inSpacing[0];
      point[1] = inOrigin[1] + inWholeExt[2 + Math.floor(i / 2) % 2] * inSpacing[1];
      point[2] = inOrigin[2] + inWholeExt[4 + Math.floor(i / 4) % 2] * inSpacing[2];
      point[3] = 1;
      if (imageTransform) {
        vec4_exports.transformMat4(point, point, imageTransform);
      }
      if (model.resliceTransform) {
        transform.transformPoint(point, point);
      }
      vec4_exports.transformMat4(point, point, matrix);
      const f2 = 1 / point[3];
      point[0] *= f2;
      point[1] *= f2;
      point[2] *= f2;
      for (let j = 0; j < 3; ++j) {
        if (point[j] > bounds2[2 * j + 1]) {
          bounds2[2 * j + 1] = point[j];
        }
        if (point[j] < bounds2[2 * j]) {
          bounds2[2 * j] = point[j];
        }
      }
    }
    return bounds2;
  };
  publicAPI.getDataTypeMinMax = (dataType) => {
    switch (dataType) {
      case "Int8Array":
        return {
          min: -128,
          max: 127
        };
      case "Int16Array":
        return {
          min: -32768,
          max: 32767
        };
      case "Uint16Array":
        return {
          min: 0,
          max: 65535
        };
      case "Int32Array":
        return {
          min: -2147483648,
          max: 2147483647
        };
      case "Uint32Array":
        return {
          min: 0,
          max: 4294967295
        };
      case "Float32Array":
        return {
          min: -12e37,
          max: 12e37
        };
      case "Float64Array":
        return {
          min: -12e37,
          max: 12e37
        };
      case "Uint8Array":
      case "Uint8ClampedArray":
      default:
        return {
          min: 0,
          max: 255
        };
    }
  };
  publicAPI.clamp = (outPtr, inPtr, numscalars, n, min, max2) => {
    const count = n * numscalars;
    for (let i = 0; i < count; ++i) {
      outPtr[i] = vtkInterpolationMathClamp(inPtr[i], min, max2);
    }
    return count;
  };
  publicAPI.convert = (outPtr, inPtr, numscalars, n) => {
    const count = n * numscalars;
    for (let i = 0; i < count; ++i) {
      outPtr[i] = Math.round(inPtr[i]);
    }
    return count;
  };
  publicAPI.getConversionFunc = (inputType, dataType, scalarShift, scalarScale, forceClamping) => {
    let useClamping = forceClamping;
    if (dataType !== VtkDataTypes.FLOAT && dataType !== VtkDataTypes.DOUBLE && !forceClamping) {
      const inMinMax = publicAPI.getDataTypeMinMax(inputType);
      let checkMin = (inMinMax.min + scalarShift) * scalarScale;
      let checkMax = (inMinMax.max + scalarShift) * scalarScale;
      const outMinMax = publicAPI.getDataTypeMinMax(dataType);
      const outputMin = outMinMax.min;
      const outputMax = outMinMax.max;
      if (checkMin > checkMax) {
        const tmp = checkMax;
        checkMax = checkMin;
        checkMin = tmp;
      }
      useClamping = checkMin < outputMin || checkMax > outputMax;
    }
    if (useClamping && dataType !== VtkDataTypes.FLOAT && dataType !== VtkDataTypes.DOUBLE) {
      const minMax = publicAPI.getDataTypeMinMax(dataType);
      const clamp2 = (outPtr, inPtr, numscalars, n) => publicAPI.clamp(outPtr, inPtr, numscalars, n, minMax.min, minMax.max);
      return clamp2;
    }
    return publicAPI.convert;
  };
  publicAPI.set = (outPtr, inPtr, numscalars, n) => {
    const count = numscalars * n;
    for (let i = 0; i < n; ++i) {
      outPtr[i] = inPtr[i];
    }
    return count;
  };
  publicAPI.set1 = (outPtr, inPtr, numscalars, n) => {
    outPtr.fill(inPtr[0], 0, n);
    return n;
  };
  publicAPI.getSetPixelsFunc = (dataType, dataSize, numscalars, dataPtr) => numscalars === 1 ? publicAPI.set1 : publicAPI.set;
  publicAPI.getCompositeFunc = (slabMode, slabTrapezoidIntegration) => {
    let composite = null;
    switch (slabMode) {
      case SlabMode2.MIN:
        composite = getImageResliceCompositeMinValue;
        break;
      case SlabMode2.MAX:
        composite = getImageResliceCompositeMaxValue;
        break;
      case SlabMode2.MEAN:
        if (slabTrapezoidIntegration) {
          composite = getImageResliceCompositeMeanTrap;
        } else {
          composite = getImageResliceCompositeMeanValue;
        }
        break;
      case SlabMode2.SUM:
        if (slabTrapezoidIntegration) {
          composite = getImageResliceCompositeSumTrap;
        } else {
          composite = getImageResliceCompositeSumValue;
        }
        break;
    }
    return composite;
  };
  publicAPI.applyTransform = (newTrans, inPoint, inOrigin, inInvSpacing) => {
    inPoint[3] = 1;
    vec4_exports.transformMat4(inPoint, inPoint, newTrans);
    inPoint[0] -= inOrigin[0];
    inPoint[1] -= inOrigin[1];
    inPoint[2] -= inOrigin[2];
    inPoint[0] *= inInvSpacing[0];
    inPoint[1] *= inInvSpacing[1];
    inPoint[2] *= inInvSpacing[2];
  };
  publicAPI.rescaleScalars = (floatData, components, n, scalarShift, scalarScale) => {
    const m = n * components;
    for (let i = 0; i < m; ++i) {
      floatData[i] = (floatData[i] + scalarShift) * scalarScale;
    }
  };
  publicAPI.isPermutationMatrix = (matrix) => {
    for (let i = 0; i < 3; i++) {
      if (matrix[4 * i + 3] !== 0) {
        return false;
      }
    }
    if (matrix[4 * 3 + 3] !== 1) {
      return false;
    }
    for (let j = 0; j < 3; j++) {
      let k = 0;
      for (let i = 0; i < 3; i++) {
        if (matrix[4 * j + i] !== 0) {
          k++;
        }
      }
      if (k !== 1) {
        return false;
      }
    }
    return true;
  };
  publicAPI.isIdentityMatrix = (matrix) => {
    for (let i = 0; i < 4; ++i) {
      for (let j = 0; j < 4; ++j) {
        if ((i === j ? 1 : 0) !== matrix[4 * j + i]) {
          return false;
        }
      }
    }
    return true;
  };
  publicAPI.isPerspectiveMatrix = (matrix) => matrix[4 * 0 + 3] !== 0 || matrix[4 * 1 + 3] !== 0 || matrix[4 * 2 + 3] !== 0 || matrix[4 * 3 + 3] !== 1;
  publicAPI.canUseNearestNeighbor = (matrix, outExt) => {
    for (let i = 0; i < 3; i++) {
      let j;
      for (j = 0; j < 3; j++) {
        if (matrix[4 * j + i] !== 0) {
          break;
        }
      }
      if (j >= 3) {
        return false;
      }
      let x = matrix[4 * j + i];
      let y = matrix[4 * 3 + i];
      if (outExt[2 * j] === outExt[2 * j + 1]) {
        y += x * outExt[2 * i];
        x = 0;
      }
      const fx = vtkInterpolationMathFloor(x).error;
      const fy = vtkInterpolationMathFloor(y).error;
      if (fx !== 0 || fy !== 0) {
        return false;
      }
    }
    return true;
  };
}
var DEFAULT_VALUES64 = {
  transformInputSampling: true,
  autoCropOutput: false,
  outputDimensionality: 3,
  outputSpacing: null,
  // automatically computed if null
  outputOrigin: null,
  // automatically computed if null
  outputDirection: null,
  // identity if null
  outputExtent: null,
  // automatically computed if null
  outputScalarType: null,
  wrap: false,
  // don't wrap
  mirror: false,
  // don't mirror
  border: true,
  // apply a border
  interpolationMode: InterpolationMode.NEAREST,
  // only NEAREST supported so far
  slabMode: SlabMode2.MIN,
  slabTrapezoidIntegration: false,
  slabNumberOfSlices: 1,
  slabSliceSpacingFraction: 1,
  optimization: false,
  // not supported yet
  scalarShift: 0,
  // for rescaling the data
  scalarScale: 1,
  backgroundColor: [0, 0, 0, 0],
  resliceAxes: null,
  // resliceTransform: null,
  interpolator: vtkImageInterpolator$1.newInstance(),
  usePermuteExecute: false
  // no supported yet
};
function extend73(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES64, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["outputDimensionality", "outputScalarType", "scalarShift", "scalarScale", "transformInputSampling", "autoCropOutput", "wrap", "mirror", "border", "interpolationMode", "resliceTransform", "slabMode", "slabTrapezoidIntegration", "slabNumberOfSlices", "slabSliceSpacingFraction"]);
  macro.setGetArray(publicAPI, model, ["outputOrigin", "outputSpacing"], 3);
  macro.setGetArray(publicAPI, model, ["outputExtent"], 6);
  macro.setGetArray(publicAPI, model, ["outputDirection"], 9);
  macro.setGetArray(publicAPI, model, ["backgroundColor"], 4);
  macro.get(publicAPI, model, ["resliceAxes"]);
  vtkImageReslice(publicAPI, model);
}
var newInstance73 = macro.newInstance(extend73, "vtkImageReslice");
var vtkImageReslice$1 = {
  newInstance: newInstance73,
  extend: extend73,
  ...Constants8
};

// node_modules/@kitware/vtk.js/Imaging/Core.js
var Core3 = {
  vtkAbstractImageInterpolator: vtkAbstractImageInterpolator$1,
  vtkImageInterpolator: vtkImageInterpolator$1,
  vtkImagePointDataIterator: vtkImagePointDataIterator$1,
  vtkImageReslice: vtkImageReslice$1
};

// node_modules/@kitware/vtk.js/Imaging/Hybrid/SampleFunction.js
var {
  vtkErrorMacro: vtkErrorMacro37
} = macro;
function vtkSampleFunction(publicAPI, model) {
  model.classHierarchy.push("vtkSampleFunction");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    if (!(model.implicitFunction && model.implicitFunction.getMTime)) {
      return superClass.getMTime();
    }
    return Math.max(superClass.getMTime(), model.implicitFunction.getMTime());
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const imp = model.implicitFunction;
    if (!imp) {
      vtkErrorMacro37("An implicit function must be defined");
      return;
    }
    const dims = [model.sampleDimensions[0], model.sampleDimensions[1], model.sampleDimensions[2]];
    const numScalars = dims[0] * dims[1] * dims[2];
    if (numScalars < 1 || dims[1] < 2 || dims[1] < 2 || dims[2] < 2) {
      vtkErrorMacro37("Bad volume dimensions");
      return;
    }
    const volume = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkImageData$1.newInstance();
    const origin3 = [model.modelBounds[0], model.modelBounds[2], model.modelBounds[4]];
    const spacing = [(model.modelBounds[1] - model.modelBounds[0]) / (dims[0] - 1), (model.modelBounds[3] - model.modelBounds[2]) / (dims[1] - 1), (model.modelBounds[5] - model.modelBounds[4]) / (dims[2] - 1)];
    const sliceSize = dims[0] * dims[1];
    volume.setDimensions(dims);
    volume.setOrigin(origin3);
    volume.setSpacing(spacing);
    const s = macro.newTypedArray(model.pointType, numScalars);
    const scalars = vtkDataArray$1.newInstance({
      name: "Scalars",
      values: s,
      numberOfComponents: 1
    });
    volume.getPointData().setScalars(scalars);
    let sValue = 0;
    const xyz = [0, 0, 0];
    for (let k = 0; k < dims[2]; k++) {
      xyz[2] = origin3[2] + k * spacing[2];
      for (let j = 0; j < dims[1]; j++) {
        xyz[1] = origin3[1] + j * spacing[1];
        for (let i = 0; i < dims[0]; i++) {
          xyz[0] = origin3[0] + i * spacing[0];
          sValue = imp.evaluateFunction(xyz);
          s[i + j * dims[0] + k * sliceSize] = sValue;
        }
      }
    }
    outData[0] = volume;
  };
}
var DEFAULT_VALUES65 = {
  implicitFunction: void 0,
  sampleDimensions: [50, 50, 50],
  modelBounds: [-1, 1, -1, 1, -1, 1],
  pointType: "Float32Array"
};
function extend74(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES65, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGetArray(publicAPI, model, ["sampleDimensions"], 3);
  macro.setGetArray(publicAPI, model, ["modelBounds"], 6);
  vtkSampleFunction(publicAPI, model);
}
var newInstance74 = macro.newInstance(extend74, "vtkSampleFunction");
var vtkSampleFunction$1 = {
  newInstance: newInstance74,
  extend: extend74
};

// node_modules/@kitware/vtk.js/Imaging/Hybrid.js
var Hybrid = {
  vtkSampleFunction: vtkSampleFunction$1
};

// node_modules/@kitware/vtk.js/Imaging/index.js
var Imaging = {
  Core: Core3,
  Hybrid
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/CompositeCameraManipulator.js
function vtkCompositeCameraManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkCompositeCameraManipulator");
  publicAPI.computeDisplayCenter = (iObserver, renderer) => {
    const pt = iObserver.computeWorldToDisplay(renderer, model.center[0], model.center[1], model.center[2]);
    model.displayCenter[0] = pt[0];
    model.displayCenter[1] = pt[1];
  };
}
var DEFAULT_VALUES66 = {
  center: [0, 0, 0],
  rotationFactor: 1,
  displayCenter: [0, 0]
};
function extend75(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES66, initialValues);
  macro.setGet(publicAPI, model, ["rotationFactor"]);
  macro.setGetArray(publicAPI, model, ["displayCenter"], 2);
  macro.setGetArray(publicAPI, model, ["center"], 3);
  vtkCompositeCameraManipulator(publicAPI, model);
}
var vtkCompositeCameraManipulator$1 = {
  extend: extend75
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/CompositeGestureManipulator.js
function vtkCompositeGestureManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkCompositeGestureManipulator");
  publicAPI.startInteraction = () => {
  };
  publicAPI.endInteraction = () => {
  };
  publicAPI.onStartPinch = (interactor, scale) => {
  };
  publicAPI.onStartRotate = (interactor, rotation) => {
  };
  publicAPI.onStartPan = (interactor, translation) => {
  };
  publicAPI.onPinch = (interactor, renderer, scale) => {
  };
  publicAPI.onRotate = (interactor, renderer, rotation) => {
  };
  publicAPI.onPan = (interactor, renderer, translation) => {
  };
  publicAPI.onEndPinch = (interactor) => {
  };
  publicAPI.onEndRotate = (interactor) => {
  };
  publicAPI.onEndPan = (interactor) => {
  };
  publicAPI.isPinchEnabled = () => model.pinchEnabled;
  publicAPI.isPanEnabled = () => model.panEnabled;
  publicAPI.isRotateEnabled = () => model.rotateEnabled;
}
var DEFAULT_VALUES67 = {
  pinchEnabled: true,
  panEnabled: true,
  rotateEnabled: true
};
function extend76(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES67, initialValues);
  macro.set(publicAPI, model, ["pinchEnabled", "panEnabled", "rotateEnabled"]);
  macro.setGet(publicAPI, model, ["interactorStyle"]);
  vtkCompositeGestureManipulator(publicAPI, model);
}
var vtkCompositeGestureManipulator$1 = {
  extend: extend76
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/CompositeKeyboardManipulator.js
function vtkCompositeKeyboardManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkCompositeKeyboardManipulator");
  publicAPI.onKeyPress = (interactor, renderer, key) => {
  };
  publicAPI.onKeyDown = (interactor, renderer, key) => {
  };
  publicAPI.onKeyUp = (interactor, renderer, key) => {
  };
}
var DEFAULT_VALUES68 = {};
function extend77(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES68, initialValues);
  vtkCompositeKeyboardManipulator(publicAPI, model);
}
var vtkCompositeKeyboardManipulator$1 = {
  extend: extend77
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/CompositeMouseManipulator.js
function vtkCompositeMouseManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkCompositeMouseManipulator");
  publicAPI.startInteraction = () => {
  };
  publicAPI.endInteraction = () => {
  };
  publicAPI.onButtonDown = (interactor, renderer, position) => {
  };
  publicAPI.onButtonUp = (interactor) => {
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
  };
  publicAPI.onStartScroll = (interactor, renderer, delta) => {
  };
  publicAPI.onScroll = (interactor, renderer, delta) => {
  };
  publicAPI.onEndScroll = (interactor) => {
  };
  publicAPI.isDragEnabled = () => model.dragEnabled;
  publicAPI.isScrollEnabled = () => model.scrollEnabled;
}
var DEFAULT_VALUES69 = {
  button: 1,
  shift: false,
  control: false,
  alt: false,
  dragEnabled: true,
  scrollEnabled: false
};
function extend78(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES69, initialValues);
  macro.setGet(publicAPI, model, ["button", "shift", "control", "alt"]);
  macro.set(publicAPI, model, ["dragEnabled", "scrollEnabled"]);
  vtkCompositeMouseManipulator(publicAPI, model);
}
var vtkCompositeMouseManipulator$1 = {
  extend: extend78
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/CompositeVRManipulator.js
function vtkCompositeVRManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkCompositeVRManipulator");
  publicAPI.onButton3D = (interactorStyle, renderer, state, eventData) => {
  };
  publicAPI.onMove3D = (interactorStyle, renderer, state, eventData) => {
  };
}
var DEFAULT_VALUES70 = {
  // device: null, // Device.RightController
  // input: null, // Input.TrackPad
};
function extend79(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES70, initialValues);
  macro.setGet(publicAPI, model, ["device", "input"]);
  vtkCompositeVRManipulator(publicAPI, model);
}
var vtkCompositeVRManipulator$1 = {
  extend: extend79,
  Device,
  Input
};

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleManipulator.js
var {
  vtkDebugMacro: vtkDebugMacro6
} = macro;
var {
  States: States2
} = vtkInteractorStyle$1;
var START_INTERACTION_EVENT = {
  type: "StartInteractionEvent"
};
var INTERACTION_EVENT = {
  type: "InteractionEvent"
};
var END_INTERACTION_EVENT = {
  type: "EndInteractionEvent"
};
function translateCamera(renderer, rwi, toX, toY, fromX, fromY) {
  const cam = renderer.getActiveCamera();
  let viewFocus = cam.getFocalPoint();
  viewFocus = rwi.getInteractorStyle().computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
  const focalDepth = viewFocus[2];
  const newPickPoint = rwi.getInteractorStyle().computeDisplayToWorld(renderer, toX, toY, focalDepth);
  const oldPickPoint = rwi.getInteractorStyle().computeDisplayToWorld(renderer, fromX, fromY, focalDepth);
  const motionVector = [oldPickPoint[0] - newPickPoint[0], oldPickPoint[1] - newPickPoint[1], oldPickPoint[2] - newPickPoint[2]];
  viewFocus = cam.getFocalPoint();
  const viewPoint = cam.getPosition();
  cam.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
  cam.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
}
function dollyToPosition(fact, position, renderer, rwi) {
  const cam = renderer.getActiveCamera();
  if (cam.getParallelProjection()) {
    const view = rwi.getView();
    const aSize = view.getViewportSize(renderer);
    const viewport = renderer.getViewport();
    const viewSize = view.getSize();
    const w = aSize[0];
    const h = aSize[1];
    const x0 = w / 2;
    const y0 = h / 2;
    const x1 = position.x - viewport[0] * viewSize[0];
    const y1 = position.y - viewport[1] * viewSize[1];
    translateCamera(renderer, rwi, x0, y0, x1, y1);
    cam.setParallelScale(cam.getParallelScale() / fact);
    translateCamera(renderer, rwi, x1, y1, x0, y0);
  } else {
    let viewFocus = cam.getFocalPoint();
    const norm2 = cam.getViewPlaneNormal();
    viewFocus = rwi.getInteractorStyle().computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    const newFp = rwi.getInteractorStyle().computeDisplayToWorld(renderer, position.x, position.y, viewFocus[2]);
    cam.setFocalPoint(newFp[0], newFp[1], newFp[2]);
    cam.dolly(fact);
    renderer.resetCameraClippingRange();
    const newCameraPos = cam.getPosition();
    viewFocus = cam.getFocalPoint();
    const newPoint = [0, 0, 0];
    let t = norm2[0] * (viewFocus[0] - newCameraPos[0]) + norm2[1] * (viewFocus[1] - newCameraPos[1]) + norm2[2] * (viewFocus[2] - newCameraPos[2]);
    t /= norm2[0] ** 2 + norm2[1] ** 2 + norm2[2] ** 2;
    newPoint[0] = newCameraPos[0] + norm2[0] * t;
    newPoint[1] = newCameraPos[1] + norm2[1] * t;
    newPoint[2] = newCameraPos[2] + norm2[2] * t;
    cam.setFocalPoint(newPoint[0], newPoint[1], newPoint[2]);
    renderer.resetCameraClippingRange();
  }
}
function dollyByFactor(interactor, renderer, factor) {
  if (Number.isNaN(factor)) {
    return;
  }
  const camera = renderer.getActiveCamera();
  if (camera.getParallelProjection()) {
    camera.setParallelScale(camera.getParallelScale() / factor);
  } else {
    camera.dolly(factor);
    renderer.resetCameraClippingRange();
  }
  if (interactor.getLightFollowCamera()) {
    renderer.updateLightsGeometryToFollowCamera();
  }
}
var STATIC7 = {
  dollyToPosition,
  translateCamera,
  dollyByFactor
};
function vtkInteractorStyleManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleManipulator");
  model.currentVRManipulators = /* @__PURE__ */ new Map();
  model.mouseManipulators = [];
  model.keyboardManipulators = [];
  model.vrManipulators = [];
  model.gestureManipulators = [];
  model.currentManipulator = null;
  model.currentWheelManipulator = null;
  model.centerOfRotation = [0, 0, 0];
  model.rotationFactor = 1;
  publicAPI.removeAllManipulators = () => {
    publicAPI.removeAllMouseManipulators();
    publicAPI.removeAllKeyboardManipulators();
    publicAPI.removeAllVRManipulators();
    publicAPI.removeAllGestureManipulators();
  };
  publicAPI.removeAllMouseManipulators = () => {
    model.mouseManipulators = [];
  };
  publicAPI.removeAllKeyboardManipulators = () => {
    model.keyboardManipulators = [];
  };
  publicAPI.removeAllVRManipulators = () => {
    model.vrManipulators = [];
  };
  publicAPI.removeAllGestureManipulators = () => {
    model.gestureManipulators = [];
  };
  const removeManipulator = (manipulator2, list) => {
    const index = list.indexOf(manipulator2);
    if (index === -1) {
      return false;
    }
    list.splice(index, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.removeMouseManipulator = (manipulator2) => removeManipulator(manipulator2, model.mouseManipulators);
  publicAPI.removeKeyboardManipulator = (manipulator2) => removeManipulator(manipulator2, model.keyboardManipulators);
  publicAPI.removeVRManipulator = (manipulator2) => removeManipulator(manipulator2, model.vrManipulators);
  publicAPI.removeGestureManipulator = (manipulator2) => removeManipulator(manipulator2, model.gestureManipulators);
  const addManipulator = (manipulator2, list) => {
    const index = list.indexOf(manipulator2);
    if (index !== -1) {
      return false;
    }
    list.push(manipulator2);
    publicAPI.modified();
    return true;
  };
  publicAPI.addMouseManipulator = (manipulator2) => addManipulator(manipulator2, model.mouseManipulators);
  publicAPI.addKeyboardManipulator = (manipulator2) => addManipulator(manipulator2, model.keyboardManipulators);
  publicAPI.addVRManipulator = (manipulator2) => addManipulator(manipulator2, model.vrManipulators);
  publicAPI.addGestureManipulator = (manipulator2) => addManipulator(manipulator2, model.gestureManipulators);
  publicAPI.getNumberOfMouseManipulators = () => model.mouseManipulators.length;
  publicAPI.getNumberOfKeyboardManipulators = () => model.keyboardManipulators.length;
  publicAPI.getNumberOfVRManipulators = () => model.vrManipulators.length;
  publicAPI.getNumberOfGestureManipulators = () => model.gestureManipulators.length;
  publicAPI.resetCurrentManipulator = () => {
    model.currentManipulator = null;
    model.currentWheelManipulator = null;
  };
  publicAPI.handleLeftButtonPress = (callData) => {
    model.previousPosition = callData.position;
    publicAPI.onButtonDown(MouseButton.LeftButton, callData);
  };
  publicAPI.handleMiddleButtonPress = (callData) => {
    model.previousPosition = callData.position;
    publicAPI.onButtonDown(MouseButton.MiddleButton, callData);
  };
  publicAPI.handleRightButtonPress = (callData) => {
    model.previousPosition = callData.position;
    publicAPI.onButtonDown(MouseButton.RightButton, callData);
  };
  publicAPI.handleButton3D = (ed) => {
    if (!ed) {
      return;
    }
    const manipulator2 = publicAPI.findVRManipulator(ed.device, ed.input, ed.pressed);
    if (manipulator2) {
      model.currentVRManipulators.set(ed.device, manipulator2);
      manipulator2.onButton3D(publicAPI, model.getRenderer(ed), model.state, ed);
      if (ed.pressed) {
        publicAPI.startCameraPose();
      } else {
        model.currentVRManipulators.delete(ed.device);
        if (model.currentVRManipulators.size === 0) {
          publicAPI.endCameraPose();
        }
      }
    } else {
      vtkDebugMacro6("No manipulator found");
    }
  };
  publicAPI.handleMove3D = (ed) => {
    const manipulator2 = model.currentVRManipulators.get(ed.device);
    if (manipulator2 && model.state === States2.IS_CAMERA_POSE) {
      manipulator2.onMove3D(publicAPI, model.getRenderer(ed), model.state, ed);
    }
  };
  publicAPI.onButtonDown = (button, callData) => {
    if (model.currentManipulator) {
      return;
    }
    model.currentManipulator = publicAPI.findMouseManipulator(button, callData.shiftKey, callData.controlKey, callData.altKey);
    if (model.currentManipulator) {
      if (model.currentManipulator.setCenter) {
        model.currentManipulator.setCenter(model.centerOfRotation);
      }
      if (model.currentManipulator.setRotationFactor) {
        model.currentManipulator.setRotationFactor(model.rotationFactor);
      }
      model.currentManipulator.startInteraction();
      model.currentManipulator.onButtonDown(model._interactor, model.getRenderer(callData), callData.position);
      model._interactor.requestAnimation(publicAPI.onButtonDown);
      publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
    } else {
      vtkDebugMacro6("No manipulator found");
    }
  };
  publicAPI.findMouseManipulator = (button, shift, control, alt) => {
    let manipulator2 = null;
    let count = model.mouseManipulators.length;
    while (count--) {
      const manip = model.mouseManipulators[count];
      if (manip && manip.getButton() === button && manip.getShift() === shift && manip.getControl() === control && manip.getAlt() === alt && manip.isDragEnabled()) {
        manipulator2 = manip;
      }
    }
    return manipulator2;
  };
  publicAPI.findVRManipulator = (device, input) => {
    let manipulator2 = null;
    let count = model.vrManipulators.length;
    while (count--) {
      const manip = model.vrManipulators[count];
      if (manip && manip.getDevice() === device && manip.getInput() === input) {
        manipulator2 = manip;
      }
    }
    return manipulator2;
  };
  publicAPI.handleLeftButtonRelease = () => {
    publicAPI.onButtonUp(MouseButton.LeftButton);
  };
  publicAPI.handleMiddleButtonRelease = () => {
    publicAPI.onButtonUp(MouseButton.MiddleButton);
  };
  publicAPI.handleRightButtonRelease = () => {
    publicAPI.onButtonUp(MouseButton.RightButton);
  };
  publicAPI.onButtonUp = (button) => {
    if (!model.currentManipulator) {
      return;
    }
    if (model.currentManipulator.getButton && model.currentManipulator.getButton() === button) {
      model.currentManipulator.onButtonUp(model._interactor);
      model.currentManipulator.endInteraction();
      if (!model._interactor.isPointerLocked()) {
        model.currentManipulator = null;
      }
      model._interactor.cancelAnimation(publicAPI.onButtonDown);
      publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
    }
  };
  publicAPI.handleEndPointerLock = () => {
    model.currentManipulator = null;
  };
  publicAPI.handleStartMouseWheel = (callData) => {
    if (model.currentWheelManipulator) {
      return;
    }
    let manipulator2 = null;
    let count = model.mouseManipulators.length;
    while (count--) {
      const manip = model.mouseManipulators[count];
      if (manip && manip.isScrollEnabled() && manip.getShift() === callData.shiftKey && manip.getControl() === callData.controlKey && manip.getAlt() === callData.altKey) {
        manipulator2 = manip;
      }
    }
    if (manipulator2) {
      model.currentWheelManipulator = manipulator2;
      model.currentWheelManipulator.onStartScroll(model._interactor, model.getRenderer(callData), callData.spinY);
      model.currentWheelManipulator.startInteraction();
      model._interactor.requestAnimation(publicAPI.handleStartMouseWheel);
      publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
    } else {
      vtkDebugMacro6("No manipulator found");
    }
  };
  publicAPI.handleEndMouseWheel = () => {
    if (!model.currentWheelManipulator) {
      return;
    }
    if (model.currentWheelManipulator.onEndScroll) {
      model.currentWheelManipulator.onEndScroll(model._interactor);
      model.currentWheelManipulator.endInteraction();
      model.currentWheelManipulator = null;
      model._interactor.cancelAnimation(publicAPI.handleStartMouseWheel);
      publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
    }
  };
  publicAPI.handleMouseWheel = (callData) => {
    if (model.currentWheelManipulator && model.currentWheelManipulator.onScroll) {
      model.currentWheelManipulator.onScroll(model._interactor, model.getRenderer(callData), callData.spinY, model.cachedMousePosition);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  };
  publicAPI.handleMouseMove = (callData) => {
    model.cachedMousePosition = callData.position;
    if (model.currentManipulator && model.currentManipulator.onMouseMove) {
      model.currentManipulator.onMouseMove(model._interactor, model.getRenderer(callData), callData.position);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  };
  publicAPI.handleKeyPress = (callData) => {
    model.keyboardManipulators.filter((m) => m.onKeyPress).forEach((manipulator2) => {
      manipulator2.onKeyPress(model._interactor, model.getRenderer(callData), callData.key);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    });
  };
  publicAPI.handleKeyDown = (callData) => {
    model.keyboardManipulators.filter((m) => m.onKeyDown).forEach((manipulator2) => {
      manipulator2.onKeyDown(model._interactor, model.getRenderer(callData), callData.key);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    });
  };
  publicAPI.handleKeyUp = (callData) => {
    model.keyboardManipulators.filter((m) => m.onKeyUp).forEach((manipulator2) => {
      manipulator2.onKeyUp(model._interactor, model.getRenderer(callData), callData.key);
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    });
  };
  publicAPI.handleStartPinch = (callData) => {
    publicAPI.startDolly();
    let count = model.gestureManipulators.length;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isPinchEnabled()) {
        manipulator2.onStartPinch(model._interactor, callData.scale);
        manipulator2.startInteraction();
      }
    }
    model._interactor.requestAnimation(publicAPI.handleStartPinch);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
  };
  publicAPI.handleEndPinch = () => {
    publicAPI.endDolly();
    let count = model.gestureManipulators.length;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isPinchEnabled()) {
        manipulator2.onEndPinch(model._interactor);
        manipulator2.endInteraction();
      }
    }
    model._interactor.cancelAnimation(publicAPI.handleStartPinch);
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
  };
  publicAPI.handleStartRotate = (callData) => {
    publicAPI.startRotate();
    let count = model.gestureManipulators.length;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isRotateEnabled()) {
        manipulator2.onStartRotate(model._interactor, callData.rotation);
        manipulator2.startInteraction();
      }
    }
    model._interactor.requestAnimation(publicAPI.handleStartRotate);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
  };
  publicAPI.handleEndRotate = () => {
    publicAPI.endRotate();
    let count = model.gestureManipulators.length;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isRotateEnabled()) {
        manipulator2.onEndRotate(model._interactor);
        manipulator2.endInteraction();
      }
    }
    model._interactor.cancelAnimation(publicAPI.handleStartRotate);
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
  };
  publicAPI.handleStartPan = (callData) => {
    publicAPI.startPan();
    let count = model.gestureManipulators.length;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isPanEnabled()) {
        manipulator2.onStartPan(model._interactor, callData.translation);
        manipulator2.startInteraction();
      }
    }
    model._interactor.requestAnimation(publicAPI.handleStartPan);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT);
  };
  publicAPI.handleEndPan = () => {
    publicAPI.endPan();
    let count = model.gestureManipulators.length;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isPanEnabled()) {
        manipulator2.onEndPan(model._interactor);
        manipulator2.endInteraction();
      }
    }
    model._interactor.cancelAnimation(publicAPI.handleStartPan);
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT);
  };
  publicAPI.handlePinch = (callData) => {
    let count = model.gestureManipulators.length;
    let actionCount = 0;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isPinchEnabled()) {
        manipulator2.onPinch(model._interactor, model.getRenderer(callData), callData.scale);
        actionCount++;
      }
    }
    if (actionCount) {
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  };
  publicAPI.handlePan = (callData) => {
    const renderer = model.getRenderer(callData);
    let count = model.gestureManipulators.length;
    let actionCount = 0;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isPanEnabled()) {
        manipulator2.onPan(model._interactor, renderer, callData.translation);
        actionCount++;
      }
    }
    if (actionCount) {
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  };
  publicAPI.handleRotate = (callData) => {
    let count = model.gestureManipulators.length;
    let actionCount = 0;
    while (count--) {
      const manipulator2 = model.gestureManipulators[count];
      if (manipulator2 && manipulator2.isRotateEnabled()) {
        manipulator2.onRotate(model._interactor, model.getRenderer(callData), callData.rotation);
        actionCount++;
      }
    }
    if (actionCount) {
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT);
    }
  };
}
var defaultValues10 = (initialValues) => ({
  cachedMousePosition: null,
  currentManipulator: null,
  currentWheelManipulator: null,
  // mouseManipulators: null,
  // keyboardManipulators: null,
  // vrManipulators: null,
  // gestureManipulators: null,
  centerOfRotation: [0, 0, 0],
  rotationFactor: 1,
  ...initialValues
});
function extend80(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues10(initialValues));
  vtkInteractorStyle$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["rotationFactor"]);
  macro.get(publicAPI, model, ["mouseManipulators", "keyboardManipulators", "vrManipulators", "gestureManipulators"]);
  macro.setGetArray(publicAPI, model, ["centerOfRotation"], 3);
  vtkInteractorStyleManipulator(publicAPI, model);
}
var newInstance75 = macro.newInstance(extend80, "vtkInteractorStyleManipulator");
var vtkInteractorStyleManipulator$1 = {
  newInstance: newInstance75,
  extend: extend80,
  ...STATIC7
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/GestureCameraManipulator.js
function vtkGestureCameraManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkGestureCameraManipulator");
  publicAPI.onStartPinch = (interactor, scale) => {
    model.previousScale = scale;
  };
  publicAPI.onStartRotate = (interactor, rotation) => {
    model.previousRotation = rotation;
  };
  publicAPI.onStartPan = (interactor, translation) => {
    model.previousTranslation = translation;
  };
  publicAPI.onPinch = (interactor, renderer, scale) => {
    vtkInteractorStyleManipulator$1.dollyByFactor(interactor, renderer, scale / model.previousScale);
    model.previousScale = scale;
  };
  publicAPI.onPan = (interactor, renderer, translation) => {
    const camera = renderer.getActiveCamera();
    const style6 = interactor.getInteractorStyle();
    let viewFocus = camera.getFocalPoint();
    viewFocus = style6.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    const focalDepth = viewFocus[2];
    const trans = translation;
    const lastTrans = model.previousTranslation;
    const newPickPoint = style6.computeDisplayToWorld(renderer, viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);
    const oldPickPoint = style6.computeDisplayToWorld(renderer, viewFocus[0], viewFocus[1], focalDepth);
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
    camera.orthogonalizeViewUp();
    model.previousTranslation = translation;
  };
  publicAPI.onRotate = (interactor, renderer, rotation) => {
    const camera = renderer.getActiveCamera();
    camera.roll(rotation - model.previousRotation);
    camera.orthogonalizeViewUp();
    model.previousRotation = rotation;
  };
}
var DEFAULT_VALUES71 = {};
function extend81(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES71, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeGestureManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkGestureCameraManipulator(publicAPI, model);
}
var newInstance76 = macro.newInstance(extend81, "vtkGestureCameraManipulator");
var vtkGestureCameraManipulator$1 = {
  newInstance: newInstance76,
  extend: extend81
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/KeyboardCameraManipulator.js
var {
  vtkErrorMacro: vtkErrorMacro38
} = macro;
var ANIMATION_REQUESTER = "vtkKeyboardCameraManipulator";
function vtkKeyboardCameraManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkKeyboardCameraManipulator");
  const internal = {
    keysDown: [],
    direction: [0, 0, 0],
    skipUpdateDirection: false,
    animationSub: null,
    cameraModifiedSub: null
  };
  publicAPI.inMotion = () => internal.animationSub !== null;
  publicAPI.resetMovementSpeed = () => {
    const {
      renderer
    } = model;
    const bounds2 = renderer.computeVisiblePropBounds();
    const divisor = 500;
    model.movementSpeed = vtkBoundingBox.getMaxLength(bounds2) / divisor;
  };
  publicAPI.startMovement = () => {
    if (publicAPI.inMotion()) {
      vtkErrorMacro38("Camera is already in motion!");
      return;
    }
    if (model.movementSpeed === null) {
      publicAPI.resetMovementSpeed();
    }
    const {
      interactor,
      renderer
    } = model;
    const move = () => {
      if (internal.keysDown.length === 0) {
        return;
      }
      internal.skipUpdateDirection = true;
      publicAPI.moveCamera(renderer.getActiveCamera(), internal.direction, model.movementSpeed);
      renderer.resetCameraClippingRange();
      if (interactor.getLightFollowCamera()) {
        renderer.updateLightsGeometryToFollowCamera();
      }
      internal.skipUpdateDirection = false;
    };
    publicAPI.calculateCurrentDirection();
    const camera = renderer.getActiveCamera();
    internal.cameraModifiedSub = camera.onModified(publicAPI.calculateCurrentDirection);
    interactor.requestAnimation(ANIMATION_REQUESTER);
    internal.animationSub = interactor.onAnimation(() => move());
  };
  publicAPI.endMovement = () => {
    if (internal.animationSub) {
      internal.animationSub.unsubscribe();
      internal.animationSub = null;
    }
    model._interactor.cancelAnimation(ANIMATION_REQUESTER);
    if (internal.cameraModifiedSub) {
      internal.cameraModifiedSub.unsubscribe();
      internal.cameraModifiedSub = null;
    }
  };
  publicAPI.calculateCurrentDirection = () => {
    if (internal.skipUpdateDirection) {
      return;
    }
    internal.direction = [0, 0, 0];
    const {
      renderer
    } = model;
    if (!renderer) {
      return;
    }
    const camera = renderer.getActiveCamera();
    if (!camera) {
      return;
    }
    if (internal.keysDown.length === 0) {
      return;
    }
    let directions = internal.keysDown.map((key) => publicAPI.getDirectionFromKey(key, camera));
    directions = directions.filter((item) => item);
    if (directions.length === 0) {
      return;
    }
    const netDirection = directions.reduce((a2, b2) => {
      add(a2, b2, b2);
      return b2;
    });
    normalize(netDirection);
    internal.direction = netDirection;
  };
  publicAPI.getDirectionFromKey = (key, camera) => {
    let direction3;
    if (model.moveForwardKeys.includes(key)) {
      direction3 = camera.getDirectionOfProjection();
    } else if (model.moveLeftKeys.includes(key)) {
      const dirProj = camera.getDirectionOfProjection();
      direction3 = [0, 0, 0];
      cross(camera.getViewUp(), dirProj, direction3);
    } else if (model.moveBackwardKeys.includes(key)) {
      direction3 = camera.getDirectionOfProjection().map((e2) => -e2);
    } else if (model.moveRightKeys.includes(key)) {
      const dirProj = camera.getDirectionOfProjection();
      direction3 = [0, 0, 0];
      cross(dirProj, camera.getViewUp(), direction3);
    } else if (model.moveUpKeys.includes(key)) {
      direction3 = camera.getViewUp();
    } else if (model.moveDownKeys.includes(key)) {
      direction3 = camera.getViewUp().map((e2) => -e2);
    } else {
      return void 0;
    }
    normalize(direction3);
    return direction3;
  };
  publicAPI.moveCamera = (camera, direction3, speed) => {
    const position = camera.getPosition();
    const focalPoint = camera.getFocalPoint();
    camera.setFocalPoint(focalPoint[0] + direction3[0] * speed, focalPoint[1] + direction3[1] * speed, focalPoint[2] + direction3[2] * speed);
    camera.setPosition(position[0] + direction3[0] * speed, position[1] + direction3[1] * speed, position[2] + direction3[2] * speed);
  };
  publicAPI.onKeyPress = (interactor, renderer, key) => {
  };
  publicAPI.onKeyDown = (interactor, renderer, key) => {
    if (!internal.keysDown.includes(key)) {
      internal.keysDown.push(key);
      publicAPI.calculateCurrentDirection();
    }
    if (!publicAPI.inMotion()) {
      Object.assign(model, {
        interactor,
        renderer
      });
      publicAPI.startMovement();
    }
  };
  publicAPI.onKeyUp = (interactor, renderer, key) => {
    internal.keysDown = internal.keysDown.filter((item) => item.toUpperCase() !== key.toUpperCase());
    publicAPI.calculateCurrentDirection();
    if (internal.keysDown.length === 0) {
      publicAPI.endMovement();
    }
  };
}
var DEFAULT_VALUES72 = {
  // The movementSpeed is the magnitude of the camera translation
  // for each animation frame (which occur each 1/60 second)
  // If null, publicAPI.resetMovementSpeed() will be called when
  // movement starts.
  movementSpeed: null,
  moveForwardKeys: ["w", "W", "ArrowUp"],
  moveLeftKeys: ["a", "A", "ArrowLeft"],
  moveBackwardKeys: ["s", "S", "ArrowDown"],
  moveRightKeys: ["d", "D", "ArrowRight"],
  moveUpKeys: [" "],
  moveDownKeys: ["Shift"],
  interactor: null,
  renderer: null
};
function extend82(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES72, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeKeyboardManipulator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["movementSpeed", "moveForwardKeys", "moveLeftKeys", "moveBackwardKeys", "moveRightKeys", "moveUpKeys", "moveDownKeys", "interactor", "renderer"]);
  vtkKeyboardCameraManipulator(publicAPI, model);
}
var newInstance77 = macro.newInstance(extend82, "vtkKeyboardCameraManipulator");
var vtkKeyboardCameraManipulator$1 = {
  newInstance: newInstance77,
  extend: extend82
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseBoxSelectorManipulator.js
var OUTSIDE_BOUNDS = [-2, -1, -2, -1];
var DEFAULT_STYLE = {
  position: "absolute",
  zIndex: 1,
  border: "2px solid #F44336",
  backgroundColor: "rgba(0, 0, 0, 0.1)",
  borderRadius: "4px",
  boxSizing: "border-box"
};
function applyStyle(element, style6) {
  Object.keys(style6).forEach((name2) => {
    element.style[name2] = style6[name2];
  });
}
function vtkMouseBoxSelectionManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseBoxSelectionManipulator");
  let view = null;
  let container = null;
  let previousPosition = null;
  let currentPosition = null;
  let div = null;
  let inDOM = false;
  function getBounds() {
    if (!previousPosition || !currentPosition) {
      return OUTSIDE_BOUNDS;
    }
    return [Math.min(previousPosition.x, currentPosition.x), Math.max(previousPosition.x, currentPosition.x), Math.min(previousPosition.y, currentPosition.y), Math.max(previousPosition.y, currentPosition.y)];
  }
  function applyStyleToDiv() {
    if (!view || !container) {
      return;
    }
    const [viewWidth, viewHeight] = view.getSize();
    const {
      width: width2,
      height: height2
    } = container.getBoundingClientRect();
    const [xMin, xMax, yMin, yMax] = getBounds();
    div.style.left = `${width2 * xMin / viewWidth}px`;
    div.style.top = `${height2 - height2 * yMax / viewHeight}px`;
    div.style.width = `${width2 * (xMax - xMin) / viewWidth}px`;
    div.style.height = `${height2 * (yMax - yMin) / viewHeight}px`;
  }
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    previousPosition = position;
    if (model.renderSelection) {
      if (!view) {
        view = interactor.getView();
      }
      if (!container && (view == null ? void 0 : view.getContainer)) {
        container = view.getContainer();
      }
      if (!container) {
        container = model.container;
      }
      if (!div) {
        div = document.createElement("div");
        applyStyle(div, model.selectionStyle);
      }
      applyStyleToDiv();
      if (container && !inDOM) {
        inDOM = true;
        container.appendChild(div);
      }
    }
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!previousPosition) {
      return;
    }
    if (!position) {
      return;
    }
    currentPosition = position;
    publicAPI.invokeBoxSelectInput({
      view,
      container,
      selection: getBounds()
    });
    if (model.renderSelection) {
      applyStyleToDiv();
    }
  };
  publicAPI.onButtonUp = (interactor, renderer) => {
    if (!previousPosition || !currentPosition && !model.boxChangeOnClick) {
      return;
    }
    if (!currentPosition) {
      currentPosition = previousPosition;
    }
    publicAPI.invokeBoxSelectChange({
      view,
      container,
      selection: getBounds()
    });
    if (inDOM) {
      div.parentElement.removeChild(div);
      inDOM = false;
    }
    view = null;
    container = null;
    previousPosition = null;
    currentPosition = null;
  };
}
function DEFAULT_VALUES73(initialValues) {
  return {
    // container: null,
    boxChangeOnClick: false,
    renderSelection: true,
    ...initialValues,
    selectionStyle: {
      ...DEFAULT_STYLE,
      ...initialValues.selectionStyle
    }
  };
}
function extend83(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES73(initialValues));
  obj(publicAPI, model);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  event(publicAPI, model, "BoxSelectChange");
  event(publicAPI, model, "BoxSelectInput");
  setGet(publicAPI, model, ["renderSelection", "boxChangeOnClick", "selectionStyle", "container"]);
  vtkMouseBoxSelectionManipulator(publicAPI, model);
}
var newInstance78 = newInstance(extend83, "vtkMouseBoxSelectionManipulator");
var vtkMouseBoxSelectorManipulator = {
  newInstance: newInstance78,
  extend: extend83
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraAxisRotateManipulator.js
function vtkMouseCameraAxisRotateManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraAxisRotateManipulator");
  const negCameraDir = new Float64Array(3);
  const newCamPos = new Float64Array(3);
  const newFp = new Float64Array(3);
  const newViewUp = new Float64Array(3);
  const trans = new Float64Array(16);
  const rotation = new Float64Array(16);
  const v2 = new Float64Array(3);
  const centerNeg = new Float64Array(3);
  const negRotationAxis = new Float64Array(3);
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.previousPosition = position;
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const camera = renderer.getActiveCamera();
    const cameraPos = camera.getPosition();
    const cameraFp = camera.getFocalPoint();
    const cameraViewUp = camera.getViewUp();
    const cameraDirection = camera.getDirectionOfProjection();
    vec3_exports.negate(negCameraDir, cameraDirection);
    mat4_exports.identity(trans);
    mat4_exports.identity(rotation);
    const {
      center,
      rotationFactor,
      rotationAxis
    } = model;
    vec3_exports.negate(negRotationAxis, rotationAxis);
    const dx = model.previousPosition.x - position.x;
    const dy = model.previousPosition.y - position.y;
    const size = interactor.getView().getViewportSize(renderer);
    const azimuthDelta = radiansFromDegrees(360 * dx / size[0] * rotationFactor);
    mat4_exports.rotate(rotation, rotation, azimuthDelta, rotationAxis);
    cross(cameraDirection, cameraViewUp, v2);
    let elevationDelta = radiansFromDegrees(-360 * dy / size[1] * rotationFactor);
    const angleToPosHalf = Math.acos(vec3_exports.dot(negCameraDir, rotationAxis));
    const angleToNegHalf = Math.acos(vec3_exports.dot(negCameraDir, negRotationAxis));
    const inPosHalf = angleToPosHalf <= angleToNegHalf;
    const elevationToAxis = Math.min(angleToPosHalf, angleToNegHalf);
    if (model.useHalfAxis && !inPosHalf) {
      elevationDelta = Math.PI / 2 - angleToPosHalf;
    } else if (inPosHalf && elevationToAxis + elevationDelta < 0) {
      elevationDelta = -elevationToAxis;
    } else if (!inPosHalf && angleToPosHalf + elevationDelta > Math.PI) {
      elevationDelta = elevationToAxis;
    }
    mat4_exports.rotate(rotation, rotation, elevationDelta, v2);
    mat4_exports.translate(trans, trans, center);
    mat4_exports.multiply(trans, trans, rotation);
    vec3_exports.negate(centerNeg, center);
    mat4_exports.translate(trans, trans, centerNeg);
    vec3_exports.transformMat4(newCamPos, cameraPos, trans);
    vec3_exports.transformMat4(newFp, cameraFp, trans);
    vec3_exports.transformMat4(newViewUp, cameraViewUp, rotation);
    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);
    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);
    camera.setViewUp(newViewUp);
    renderer.resetCameraClippingRange();
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
    model.previousPosition = position;
  };
}
var DEFAULT_VALUES74 = {
  rotationAxis: [0, 0, 1],
  useHalfAxis: true
};
function extend84(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES74, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["rotationAxis", "useHalfAxis"]);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkMouseCameraAxisRotateManipulator(publicAPI, model);
}
var newInstance79 = macro.newInstance(extend84, "vtkMouseCameraAxisRotateManipulator");
var vtkMouseCameraAxisRotateManipulator$1 = {
  newInstance: newInstance79,
  extend: extend84
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraSliceManipulator.js
function vtkMouseCameraSliceManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraSliceManipulator");
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.previousPosition = position;
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const dy = position.y - model.previousPosition.y;
    const camera = renderer.getActiveCamera();
    const range = camera.getClippingRange();
    let distance = camera.getDistance();
    let viewportHeight = 0;
    if (camera.getParallelProjection()) {
      viewportHeight = 2 * camera.getParallelScale();
    } else {
      const angle = radiansFromDegrees(camera.getViewAngle());
      viewportHeight = 2 * distance * Math.tan(0.5 * angle);
    }
    const size = interactor.getView().getViewportSize(renderer);
    const delta = dy * viewportHeight / size[1];
    distance += delta;
    if (distance < range[0]) {
      distance = range[0] + viewportHeight * 1e-3;
    }
    if (distance > range[1]) {
      distance = range[1] - viewportHeight * 1e-3;
    }
    camera.setDistance(distance);
    model.previousPosition = position;
  };
  publicAPI.onScroll = (interactor, renderer, delta) => {
    if (!delta) {
      return;
    }
    let scrollDelta = 1 - delta;
    scrollDelta *= 25;
    const camera = renderer.getActiveCamera();
    const range = camera.getClippingRange();
    let distance = camera.getDistance();
    distance += scrollDelta;
    if (distance < range[0]) {
      distance = range[0];
    }
    if (distance > range[1]) {
      distance = range[1];
    }
    camera.setDistance(distance);
  };
}
var DEFAULT_VALUES75 = {};
function extend85(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES75, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkMouseCameraSliceManipulator(publicAPI, model);
}
var newInstance80 = macro.newInstance(extend85, "vtkMouseCameraSliceManipulator");
var vtkMouseCameraSliceManipulator$1 = {
  newInstance: newInstance80,
  extend: extend85
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractPicker.js
function vtkAbstractPicker(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractPicker");
  publicAPI.initialize = () => {
    model.renderer = null;
    model.selectionPoint[0] = 0;
    model.selectionPoint[1] = 0;
    model.selectionPoint[2] = 0;
    model.pickPosition[0] = 0;
    model.pickPosition[1] = 0;
    model.pickPosition[2] = 0;
  };
  publicAPI.initializePickList = () => {
    model.pickList = [];
  };
  publicAPI.addPickList = (actor) => {
    model.pickList.push(actor);
  };
  publicAPI.deletePickList = (actor) => {
    const i = model.pickList.indexOf(actor);
    if (i !== -1) {
      model.pickList.splice(i, 1);
    }
  };
}
var DEFAULT_VALUES76 = {
  renderer: null,
  selectionPoint: [0, 0, 0],
  pickPosition: [0, 0, 0],
  pickFromList: false,
  pickList: []
};
function extend86(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES76, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["renderer"]);
  macro.getArray(publicAPI, model, ["selectionPoint", "pickPosition"]);
  macro.setGet(publicAPI, model, ["pickFromList", "pickList"]);
  vtkAbstractPicker(publicAPI, model);
}
var newInstance81 = macro.newInstance(extend86, "vtkAbstractPicker");
var vtkAbstractPicker$1 = {
  newInstance: newInstance81,
  extend: extend86
};

// node_modules/@kitware/vtk.js/Rendering/Core/Picker.js
var {
  vtkErrorMacro: vtkErrorMacro39
} = macro;
var {
  vtkWarningMacro: vtkWarningMacro9
} = macro;
function vtkPicker(publicAPI, model) {
  model.classHierarchy.push("vtkPicker");
  const superClass = {
    ...publicAPI
  };
  function initialize() {
    superClass.initialize();
    model.actors = [];
    model.pickedPositions = [];
    model.mapperPosition[0] = 0;
    model.mapperPosition[1] = 0;
    model.mapperPosition[2] = 0;
    model.mapper = null;
    model.dataSet = null;
    model.globalTMin = Number.MAX_VALUE;
  }
  function computeTolerance(selectionZ, aspect, renderer) {
    let tolerance = 0;
    const view = renderer.getRenderWindow().getViews()[0];
    const viewport = renderer.getViewport();
    const winSize = view.getSize();
    let x = winSize[0] * viewport[0];
    let y = winSize[1] * viewport[1];
    const normalizedLeftDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);
    const windowLowerLeft = renderer.normalizedDisplayToWorld(normalizedLeftDisplay[0], normalizedLeftDisplay[1], normalizedLeftDisplay[2], aspect);
    x = winSize[0] * viewport[2];
    y = winSize[1] * viewport[3];
    const normalizedRightDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);
    const windowUpperRight = renderer.normalizedDisplayToWorld(normalizedRightDisplay[0], normalizedRightDisplay[1], normalizedRightDisplay[2], aspect);
    for (let i = 0; i < 3; i++) {
      tolerance += (windowUpperRight[i] - windowLowerLeft[i]) * (windowUpperRight[i] - windowLowerLeft[i]);
    }
    return Math.sqrt(tolerance);
  }
  function pick3DInternal(renderer, tolerance, p1World, p2World) {
    const p1Mapper = new Float64Array(4);
    const p2Mapper = new Float64Array(4);
    const ray = [];
    const hitPosition = [];
    const props = model.pickFromList ? model.pickList : renderer.getActors();
    const transformScale = new Float64Array(3);
    const pickedPosition = new Float64Array(3);
    props.forEach((prop) => {
      var _a, _b, _c;
      const mapper = prop.getMapper();
      const propIsFullyTranslucent = ((_c = (_a = prop.getProperty) == null ? void 0 : (_b = _a.call(prop)).getOpacity) == null ? void 0 : _c.call(_b)) === 0;
      const pickable = prop.getNestedPickable() && prop.getNestedVisibility() && !propIsFullyTranslucent;
      if (!pickable) {
        return;
      }
      model.transformMatrix = prop.getMatrix().slice(0);
      mat4_exports.transpose(model.transformMatrix, model.transformMatrix);
      mat4_exports.invert(model.transformMatrix, model.transformMatrix);
      vec4_exports.transformMat4(p1Mapper, p1World, model.transformMatrix);
      vec4_exports.transformMat4(p2Mapper, p2World, model.transformMatrix);
      vec3_exports.scale(p1Mapper, p1Mapper, 1 / p1Mapper[3]);
      vec3_exports.scale(p2Mapper, p2Mapper, 1 / p2Mapper[3]);
      subtract(p2Mapper, p1Mapper, ray);
      const bounds2 = mapper ? vtkBoundingBox.inflate(mapper.getBounds(), tolerance) : [...vtkBoundingBox.INIT_BOUNDS];
      if (vtkBoundingBox.intersectBox(bounds2, p1Mapper, ray, hitPosition, [])) {
        mat4_exports.getScaling(transformScale, model.transformMatrix);
        const t = model.intersectWithLine(p1Mapper, p2Mapper, tolerance * 0.333 * (transformScale[0] + transformScale[1] + transformScale[2]), prop, mapper);
        if (t < Number.MAX_VALUE) {
          pickedPosition[0] = (1 - t) * p1World[0] + t * p2World[0];
          pickedPosition[1] = (1 - t) * p1World[1] + t * p2World[1];
          pickedPosition[2] = (1 - t) * p1World[2] + t * p2World[2];
          const actorIndex = model.actors.indexOf(prop);
          if (actorIndex !== -1) {
            const previousPickedPosition = model.pickedPositions[actorIndex];
            if (distance2BetweenPoints(p1World, pickedPosition) < distance2BetweenPoints(p1World, previousPickedPosition)) {
              model.pickedPositions[actorIndex] = pickedPosition.slice(0);
            }
          } else {
            model.actors.push(prop);
            model.pickedPositions.push(pickedPosition.slice(0));
          }
        }
      }
    });
    const tempArray = [];
    for (let i = 0; i < model.pickedPositions.length; i++) {
      tempArray.push({
        actor: model.actors[i],
        pickedPosition: model.pickedPositions[i],
        distance2: distance2BetweenPoints(p1World, model.pickedPositions[i])
      });
    }
    tempArray.sort((a2, b2) => {
      const keyA = a2.distance2;
      const keyB = b2.distance2;
      if (keyA < keyB) return -1;
      if (keyA > keyB) return 1;
      return 0;
    });
    model.pickedPositions = [];
    model.actors = [];
    tempArray.forEach((obj2) => {
      model.pickedPositions.push(obj2.pickedPosition);
      model.actors.push(obj2.actor);
    });
  }
  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {
    if (!mapper) {
      return Number.MAX_VALUE;
    }
    const center = mapper.getCenter();
    const ray = vec3_exports.subtract(new Float64Array(3), p2, p1);
    const rayFactor = dot(ray, ray);
    if (rayFactor === 0) {
      return 2;
    }
    const t = (ray[0] * (center[0] - p1[0]) + ray[1] * (center[1] - p1[1]) + ray[2] * (center[2] - p1[2])) / rayFactor;
    return t;
  };
  publicAPI.pick = (selection, renderer) => {
    if (selection.length !== 3) {
      vtkWarningMacro9("vtkPicker.pick - selection needs three components");
    }
    if (!renderer) {
      vtkErrorMacro39("vtkPicker.pick - renderer cannot be null");
      throw new Error("renderer cannot be null");
    }
    initialize();
    const selectionX = selection[0];
    const selectionY = selection[1];
    let selectionZ = selection[2];
    model.renderer = renderer;
    model.selectionPoint[0] = selectionX;
    model.selectionPoint[1] = selectionY;
    model.selectionPoint[2] = selectionZ;
    const p1World = new Float64Array(4);
    const p2World = new Float64Array(4);
    const camera = renderer.getActiveCamera();
    const cameraPos = camera.getPosition();
    const cameraFP = camera.getFocalPoint();
    const view = renderer.getRenderWindow().getViews()[0];
    const dims = view.getViewportSize(renderer);
    if (dims[1] === 0) {
      vtkWarningMacro9("vtkPicker.pick - viewport area is 0");
      return;
    }
    const aspect = dims[0] / dims[1];
    let displayCoords = [];
    displayCoords = renderer.worldToNormalizedDisplay(cameraFP[0], cameraFP[1], cameraFP[2], aspect);
    displayCoords = view.normalizedDisplayToDisplay(displayCoords[0], displayCoords[1], displayCoords[2]);
    selectionZ = displayCoords[2];
    const normalizedDisplay = view.displayToNormalizedDisplay(selectionX, selectionY, selectionZ);
    const worldCoords = renderer.normalizedDisplayToWorld(normalizedDisplay[0], normalizedDisplay[1], normalizedDisplay[2], aspect);
    for (let i = 0; i < 3; i++) {
      model.pickPosition[i] = worldCoords[i];
    }
    const ray = [];
    for (let i = 0; i < 3; i++) {
      ray[i] = model.pickPosition[i] - cameraPos[i];
    }
    const cameraDOP = [];
    for (let i = 0; i < 3; i++) {
      cameraDOP[i] = cameraFP[i] - cameraPos[i];
    }
    normalize(cameraDOP);
    const rayLength = dot(cameraDOP, ray);
    if (rayLength === 0) {
      vtkWarningMacro9("Picker::Pick Cannot process points");
      return;
    }
    const clipRange = camera.getClippingRange();
    let tF;
    let tB;
    if (camera.getParallelProjection()) {
      tF = clipRange[0] - rayLength;
      tB = clipRange[1] - rayLength;
      for (let i = 0; i < 3; i++) {
        p1World[i] = model.pickPosition[i] + tF * cameraDOP[i];
        p2World[i] = model.pickPosition[i] + tB * cameraDOP[i];
      }
    } else {
      tF = clipRange[0] / rayLength;
      tB = clipRange[1] / rayLength;
      for (let i = 0; i < 3; i++) {
        p1World[i] = cameraPos[i] + tF * ray[i];
        p2World[i] = cameraPos[i] + tB * ray[i];
      }
    }
    p1World[3] = 1;
    p2World[3] = 1;
    const tolerance = computeTolerance(selectionZ, aspect, renderer) * model.tolerance;
    pick3DInternal(model.renderer, tolerance, p1World, p2World);
  };
  publicAPI.pick3DPoint = (selectionPoint, focalPoint, renderer) => {
    if (!renderer) {
      throw new Error("renderer cannot be null");
    }
    initialize();
    model.renderer = renderer;
    vec3_exports.copy(model.selectionPoint, selectionPoint);
    const view = renderer.getRenderWindow().getViews()[0];
    const dims = view.getViewportSize(renderer);
    if (dims[1] === 0) {
      vtkWarningMacro9("vtkPicker.pick3DPoint - viewport area is 0");
      return;
    }
    const aspect = dims[0] / dims[1];
    const tolerance = computeTolerance(model.selectionPoint[2], aspect, renderer) * model.tolerance;
    pick3DInternal(renderer, tolerance, selectionPoint, focalPoint);
  };
}
var DEFAULT_VALUES77 = {
  tolerance: 0.025,
  mapperPosition: [0, 0, 0],
  mapper: null,
  dataSet: null,
  actors: [],
  pickedPositions: [],
  transformMatrix: null,
  globalTMin: Number.MAX_VALUE
};
function extend87(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES77, initialValues);
  vtkAbstractPicker$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["tolerance"]);
  macro.setGetArray(publicAPI, model, ["mapperPosition"], 3);
  macro.get(publicAPI, model, ["mapper", "dataSet", "actors", "pickedPositions"]);
  macro.event(publicAPI, model, "pickChange");
  vtkPicker(publicAPI, model);
}
var newInstance82 = macro.newInstance(extend87, "vtkPicker");
var vtkPicker$1 = {
  newInstance: newInstance82,
  extend: extend87
};

// node_modules/@kitware/vtk.js/Rendering/Core/PointPicker.js
var {
  vtkErrorMacro: vtkErrorMacro40
} = macro;
function vtkPointPicker(publicAPI, model) {
  model.classHierarchy.push("vtkPointPicker");
  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {
    let tMin = Number.MAX_VALUE;
    if (mapper.isA("vtkImageMapper") || mapper.isA("vtkImageArrayMapper")) {
      const pickData = mapper.intersectWithLineForPointPicking(p1, p2);
      if (pickData) {
        tMin = pickData.t;
        model.pointIJK = pickData.ijk;
      }
    } else if (mapper.isA("vtkMapper")) {
      tMin = model.intersectActorWithLine(p1, p2, tolerance, mapper);
    }
    return tMin;
  };
  model.intersectActorWithLine = (p1, p2, tolerance, mapper) => {
    const input = mapper.getInputData();
    let ptId = 0;
    const numPts = input.getPoints().getNumberOfPoints();
    if (numPts <= ptId) {
      return 2;
    }
    const ray = [];
    for (let i = 0; i < 3; i++) {
      ray[i] = p2[i] - p1[i];
    }
    const rayFactor = dot(ray, ray);
    if (rayFactor === 0) {
      vtkErrorMacro40("Cannot process points");
      return 2;
    }
    let t;
    let minPtId = -1;
    let tMin = Number.MAX_VALUE;
    let minPtDist = Number.MAX_VALUE;
    const projXYZ = [];
    const x = [];
    const points = input.getPoints();
    if (model.useCells) {
      const cellData = input.getPolys().getData();
      const nbPointsPerCell = cellData[0];
      const nbCells = input.getPolys().getNumberOfCells();
      for (let cellID = 0; cellID < nbCells; cellID++) {
        const firstPointIndex = cellID * nbPointsPerCell + 1;
        const lastPointIndex = firstPointIndex + nbPointsPerCell;
        for (let pointIndex = firstPointIndex; pointIndex < lastPointIndex; pointIndex++) {
          const pointDataIndex = cellData[pointIndex];
          points.getPoint(pointDataIndex, x);
          t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor;
          if (t >= 0 && t <= 1 && t <= tMin + model.tolerance) {
            let maxDist = 0;
            for (let i = 0; i < 3; i++) {
              projXYZ[i] = p1[i] + t * ray[i];
              const dist = Math.abs(x[i] - projXYZ[i]);
              if (dist > maxDist) {
                maxDist = dist;
              }
            }
            if (maxDist <= tolerance && maxDist < minPtDist) {
              minPtId = ptId;
              x[0];
              x[1];
              x[2];
              minPtDist = maxDist;
              tMin = t;
            }
          }
        }
      }
    } else {
      for (ptId = 0; ptId < numPts; ptId++) {
        points.getPoint(ptId, x);
        t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor;
        if (t >= 0 && t <= 1 && t <= tMin + model.tolerance) {
          let maxDist = 0;
          for (let i = 0; i < 3; i++) {
            projXYZ[i] = p1[i] + t * ray[i];
            const dist = Math.abs(x[i] - projXYZ[i]);
            if (dist > maxDist) {
              maxDist = dist;
            }
          }
          if (maxDist <= tolerance && maxDist < minPtDist) {
            minPtId = ptId;
            x[0];
            x[1];
            x[2];
            minPtDist = maxDist;
            tMin = t;
          }
        }
      }
    }
    if (minPtId > -1 && tMin < model.globalTMin) {
      model.globalTMin = tMin;
      model.pointId = minPtId;
    }
    return tMin;
  };
}
var DEFAULT_VALUES78 = {
  pointId: -1,
  pointIJK: [],
  useCells: false
};
function extend88(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES78, initialValues);
  vtkPicker$1.extend(publicAPI, model, initialValues);
  macro.getArray(publicAPI, model, ["pointIJK"]);
  macro.get(publicAPI, model, ["pointId"]);
  macro.setGet(publicAPI, model, ["useCells"]);
  vtkPointPicker(publicAPI, model);
}
var newInstance83 = macro.newInstance(extend88, "vtkPointPicker");
var vtkPointPicker$1 = {
  newInstance: newInstance83,
  extend: extend88
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraUnicamRotateManipulator.js
var {
  States: States3
} = vtkInteractorStyleConstants;
function vtkMouseCameraUnicamRotateManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraUnicamRotateManipulator");
  model.picker = vtkPointPicker$1.newInstance();
  model.downPoint = [0, 0, 0];
  model.isDot = false;
  model.state = States3.IS_NONE;
  const sphereSource = vtkSphereSource$1.newInstance();
  sphereSource.setThetaResolution(6);
  sphereSource.setPhiResolution(6);
  const sphereMapper = vtkMapper$1.newInstance();
  sphereMapper.setInputConnection(sphereSource.getOutputPort());
  model.focusSphere = vtkActor$1.newInstance();
  model.focusSphere.setMapper(sphereMapper);
  model.focusSphere.getProperty().setColor(0.89, 0.66, 0.41);
  model.focusSphere.getProperty().setAmbient(1);
  model.focusSphere.getProperty().setDiffuse(0);
  model.focusSphere.getProperty().setRepresentationToWireframe();
  const updateAndRender = (interactor) => {
    if (!interactor) {
      return;
    }
    if (model.useWorldUpVec) {
      const camera = interactor.findPokedRenderer().getActiveCamera();
      if (!areEquals(model.worldUpVec, camera.getViewPlaneNormal())) {
        camera.setViewUp(model.worldUpVec);
      }
    }
    interactor.render();
  };
  const normalize$1 = (position, interactor) => {
    const renderer = interactor.findPokedRenderer();
    const [width2, height2] = interactor.getView().getViewportSize(renderer);
    const nx = -1 + 2 * position.x / width2;
    const ny = -1 + 2 * position.y / height2;
    return {
      x: nx,
      y: ny
    };
  };
  const rotateCamera = (camera, cx, cy, cz, ax, ay, az, angle) => {
    const cameraPosition = camera.getPosition();
    const cameraFocalPoint = camera.getFocalPoint();
    const cameraViewUp = camera.getViewUp();
    cameraPosition[3] = 1;
    cameraFocalPoint[3] = 1;
    cameraViewUp[3] = 0;
    const transform = mat4_exports.identity(new Float64Array(16));
    mat4_exports.translate(transform, transform, [cx, cy, cz]);
    mat4_exports.rotate(transform, transform, angle, [ax, ay, az]);
    mat4_exports.translate(transform, transform, [-cx, -cy, -cz]);
    const newCameraPosition = [];
    const newCameraFocalPoint = [];
    vec3_exports.transformMat4(newCameraPosition, cameraPosition, transform);
    vec3_exports.transformMat4(newCameraFocalPoint, cameraFocalPoint, transform);
    mat4_exports.identity(transform);
    mat4_exports.rotate(transform, transform, angle, [ax, ay, az]);
    const newCameraViewUp = [];
    vec3_exports.transformMat4(newCameraViewUp, cameraViewUp, transform);
    camera.setPosition(...newCameraPosition);
    camera.setFocalPoint(...newCameraFocalPoint);
    camera.setViewUp(...newCameraViewUp);
  };
  const rotate = (interactor, position) => {
    const renderer = interactor.findPokedRenderer();
    const normalizedPosition = normalize$1(position, interactor);
    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);
    const center = model.focusSphere.getPosition();
    let normalizedCenter = interactor.getView().worldToDisplay(...center, renderer);
    normalizedCenter = normalize$1({
      x: center[0],
      y: center[1]
    }, interactor);
    normalizedCenter = [normalizedCenter.x, normalizedCenter.y, center[2]];
    const radsq = (1 + Math.abs(normalizedCenter[0])) ** 2;
    const op = [normalizedPreviousPosition.x, 0, 0];
    const oe = [normalizedPosition.x, 0, 0];
    const opsq = op[0] ** 2;
    const oesq = oe[0] ** 2;
    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);
    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);
    const nop = [op[0], 0, lop];
    normalize(nop);
    const noe = [oe[0], 0, loe];
    normalize(noe);
    const dot$1 = dot(nop, noe);
    if (Math.abs(dot$1) > 1e-4) {
      const angle = -2 * Math.acos(clampValue(dot$1, -1, 1)) * Math.sign(normalizedPosition.x - normalizedPreviousPosition.x) * publicAPI.getRotationFactor();
      const camera = renderer.getActiveCamera();
      const upVec = model.useWorldUpVec ? model.worldUpVec : camera.getViewUp();
      normalize(upVec);
      rotateCamera(camera, ...center, ...upVec, angle);
      const dVec = [];
      const cameraPosition = camera.getPosition();
      subtract(cameraPosition, position, dVec);
      let rDist = (normalizedPosition.y - normalizedPreviousPosition.y) * publicAPI.getRotationFactor();
      normalize(dVec);
      const atV = camera.getViewPlaneNormal();
      const upV = camera.getViewUp();
      const rightV = [];
      cross(upV, atV, rightV);
      normalize(rightV);
      if (model.useWorldUpVec) {
        const OVER_THE_TOP_THRESHOLD = 0.99;
        if (dot(upVec, atV) > OVER_THE_TOP_THRESHOLD && rDist < 0) {
          rDist = 0;
        }
        if (dot(upVec, atV) < -OVER_THE_TOP_THRESHOLD && rDist > 0) {
          rDist = 0;
        }
      }
      rotateCamera(camera, ...center, ...rightV, rDist);
      if (model.useWorldUpVec && !areEquals(upVec, camera.getViewPlaneNormal())) {
        camera.setViewUp(...upVec);
      }
      model.previousPosition = position;
      renderer.resetCameraClippingRange();
      updateAndRender(interactor);
    }
  };
  const placeFocusSphere = (interactor) => {
    const renderer = interactor.findPokedRenderer();
    model.focusSphere.setPosition(...model.downPoint);
    const camera = renderer.getActiveCamera();
    const cameraPosition = camera.getPosition();
    const cameraToPointVec = [];
    subtract(model.downPoint, cameraPosition, cameraToPointVec);
    if (camera.getParallelProjection()) {
      multiplyScalar(cameraToPointVec, camera.getParallelScale());
    }
    const atV = camera.getDirectionOfProjection();
    normalize(atV);
    const scale = 0.02 * dot(atV, cameraToPointVec) * model.focusSphereRadiusFactor;
    model.focusSphere.setScale(scale, scale, scale);
  };
  const placeAndDisplayFocusSphere = (interactor) => {
    placeFocusSphere(interactor);
    interactor.findPokedRenderer().addActor(model.focusSphere);
    model.isDot = true;
  };
  const hideFocusSphere = (interactor) => {
    interactor.findPokedRenderer().removeActor(model.focusSphere);
    model.isDot = false;
  };
  const pickWithPointPicker = (interactor, position) => {
    const renderer = interactor.findPokedRenderer();
    model.picker.pick([position.x, position.y, position.z], renderer);
    const pickedPositions = model.picker.getPickedPositions();
    if (pickedPositions.length === 0) {
      return model.picker.getPickPosition();
    }
    const cameraPosition = renderer.getActiveCamera().getPosition();
    pickedPositions.sort((pointA, pointB) => distance2BetweenPoints(pointA, cameraPosition) - distance2BetweenPoints(pointB, cameraPosition));
    return pickedPositions[0];
  };
  const pickPoint = (interactor, position) => {
    const renderer = interactor.findPokedRenderer();
    let selections = null;
    if (model.useHardwareSelector) {
      const selector = interactor.getView().getSelector();
      selector.setCaptureZValues(true);
      selector.setFieldAssociation(FieldAssociations.FIELD_ASSOCIATION_POINTS);
      selector.attach(interactor.getView(), renderer);
      selector.setArea(position.x, position.y, position.x, position.y);
      selections = selector.select();
    }
    if (selections && selections.length !== 0) {
      return Array.from(selections[0].getProperties().worldPosition);
    }
    return pickWithPointPicker(interactor, position);
  };
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.buttonPressed = true;
    model.startPosition = position;
    model.previousPosition = position;
    const normalizedPosition = normalize$1(position, interactor);
    const borderRatio = 0.1;
    if (Math.abs(normalizedPosition.x) > 1 - borderRatio || Math.abs(normalizedPosition.y) > 1 - borderRatio) {
      model.state = States3.IS_ROTATE;
      placeAndDisplayFocusSphere(interactor);
      return;
    }
    model.downPoint = pickPoint(interactor, position);
    if (model.isDot) {
      model.state = States3.IS_ROTATE;
    } else {
      model.state = States3.IS_NONE;
      if (model.displayFocusSphereOnButtonDown) {
        placeAndDisplayFocusSphere(interactor);
      }
    }
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!model.buttonPressed) {
      return;
    }
    model.state = States3.IS_ROTATE;
    rotate(interactor, position);
    model.previousPosition = position;
  };
  publicAPI.onButtonUp = (interactor) => {
    const renderer = interactor.findPokedRenderer();
    model.buttonPressed = false;
    if (model.state === States3.IS_ROTATE && !model.isDot) {
      return;
    }
    if (model.state === States3.IS_ROTATE) {
      hideFocusSphere(interactor);
    } else if (model.state === States3.IS_NONE) {
      placeAndDisplayFocusSphere(interactor);
    }
    renderer.resetCameraClippingRange();
    updateAndRender(interactor);
  };
  publicAPI.getFocusSphereColor = () => {
    model.focusSphere.getProperty().getColor();
  };
  publicAPI.setFocusSphereColor = (r, g, b2) => {
    model.focusSphere.getProperty().setColor(r, g, b2);
  };
}
var DEFAULT_VALUES79 = {
  focusSphereRadiusFactor: 1,
  displayFocusSphereOnButtonDown: true,
  useHardwareSelector: true,
  useWorldUpVec: true,
  // set WorldUpVector to be z-axis by default
  worldUpVec: [0, 0, 1]
};
function extend89(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES79, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["focusSphereRadiusFactor", "displayFocusSphereOnButtonDown", "useHardwareSelector", "useWorldUpVec"]);
  macro.get(publicAPI, model, ["state"]);
  macro.getArray(publicAPI, model, ["downPoint"], 3);
  macro.setGetArray(publicAPI, model, ["worldUpVec"], 3);
  vtkMouseCameraUnicamRotateManipulator(publicAPI, model);
}
var newInstance84 = macro.newInstance(extend89, "vtkMouseCameraUnicamRotateManipulator");
var vtkMouseCameraUnicamRotateManipulator$1 = {
  newInstance: newInstance84,
  extend: extend89
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraUnicamManipulator.js
var {
  States: States4
} = vtkInteractorStyleConstants;
function vtkMouseCameraUnicamManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraUnicamManipulator");
  model.state = States4.IS_NONE;
  model.rotateManipulator = vtkMouseCameraUnicamRotateManipulator$1.newInstance({
    button: model.button,
    shift: model.shift,
    control: model.control,
    alt: model.alt,
    dragEnabled: model.dragEnabled,
    scrollEnabled: model.scrollEnabled,
    displayFocusSphereOnButtonDown: false
  });
  const normalize$1 = (position, interactor) => {
    const renderer = interactor.findPokedRenderer();
    const [width2, height2] = interactor.getView().getViewportSize(renderer);
    const nx = -1 + 2 * position.x / width2;
    const ny = -1 + 2 * position.y / height2;
    return {
      x: nx,
      y: ny
    };
  };
  const getRightVAndUpV = (downPoint, interactor) => {
    const camera = interactor.findPokedRenderer().getActiveCamera();
    const cameraPosition = camera.getPosition();
    const cameraToPointVec = [0, 0, 0];
    subtract(downPoint, cameraPosition, cameraToPointVec);
    if (camera.getParallelProjection()) {
      multiplyScalar(cameraToPointVec, camera.getParallelScale());
    }
    const atV = camera.getViewPlaneNormal();
    normalize(atV);
    const l = dot(cameraToPointVec, atV);
    const viewAngle = radiansFromDegrees(camera.getViewAngle());
    const renderer = interactor.findPokedRenderer();
    const [width2, height2] = interactor.getView().getViewportSize(renderer);
    const scaleX = width2 / height2 * (2 * l * Math.tan(viewAngle / 2) / 2);
    const scaleY = 2 * l * Math.tan(viewAngle / 2) / 2;
    const upV = camera.getViewUp();
    const rightV = [];
    cross(upV, atV, rightV);
    cross(atV, rightV, upV);
    normalize(rightV);
    normalize(upV);
    multiplyScalar(rightV, scaleX);
    multiplyScalar(upV, scaleY);
    return {
      rightV,
      upV
    };
  };
  const choose = (interactor, position) => {
    const normalizedPosition = normalize$1(position, interactor);
    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);
    const delta = {
      x: normalizedPosition.x - normalizedPreviousPosition.x,
      y: normalizedPosition.y - normalizedPreviousPosition.y
    };
    model.previousPosition = position;
    const deltaT = Date.now() / 1e3 - model.time;
    model.dist += Math.sqrt(delta.x ** 2 + delta.y ** 2);
    const sDelta = {
      x: position.x - model.startPosition.x,
      y: position.y - model.startPosition.y
    };
    const len = Math.sqrt(sDelta.x ** 2 + sDelta.y ** 2);
    if (Math.abs(sDelta.y) / len > 0.9 && deltaT > 0.05) {
      model.state = States4.IS_DOLLY;
    } else if (deltaT >= 0.1 || model.dist >= 0.03) {
      if (Math.abs(sDelta.x) / len > 0.6) {
        model.state = States4.IS_PAN;
      } else {
        model.state = States4.IS_DOLLY;
      }
    }
  };
  const pan = (interactor, position) => {
    const renderer = interactor.findPokedRenderer();
    const normalizedPosition = normalize$1(position, interactor);
    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);
    const delta = {
      x: normalizedPosition.x - normalizedPreviousPosition.x,
      y: normalizedPosition.y - normalizedPreviousPosition.y
    };
    const camera = renderer.getActiveCamera();
    model.previousPosition = position;
    const {
      rightV,
      upV
    } = getRightVAndUpV(model.downPoint, interactor);
    const offset = [];
    for (let index = 0; index < 3; index++) {
      offset[index] = delta.x * rightV[index] + delta.y * upV[index];
    }
    camera.translate(...offset);
    renderer.resetCameraClippingRange();
    interactor.render();
  };
  const dolly = (interactor, position) => {
    const renderer = interactor.findPokedRenderer();
    const normalizedPosition = normalize$1(position, interactor);
    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);
    const delta = {
      x: normalizedPosition.x - normalizedPreviousPosition.x,
      y: normalizedPosition.y - normalizedPreviousPosition.y
    };
    const camera = renderer.getActiveCamera();
    const cameraPosition = camera.getPosition();
    if (camera.getParallelProjection()) {
      camera.zoom(1 - delta.y);
    } else {
      const offset1 = [];
      subtract(model.downPoint, cameraPosition, offset1);
      multiplyScalar(offset1, delta.y * -4);
      camera.translate(...offset1);
    }
    const {
      rightV: offset2
    } = getRightVAndUpV(model.downPoint, interactor);
    multiplyScalar(offset2, delta.x);
    camera.translate(...offset2);
    renderer.resetCameraClippingRange();
    interactor.render();
  };
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.buttonPressed = true;
    model.startPosition = position;
    model.previousPosition = position;
    model.time = Date.now() / 1e3;
    model.dist = 0;
    model.rotateManipulator.onButtonDown(interactor, renderer, position);
    model.downPoint = model.rotateManipulator.getDownPoint();
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!model.buttonPressed) {
      return;
    }
    if (model.rotateManipulator.getState() === States4.IS_ROTATE) {
      model.rotateManipulator.onMouseMove(interactor, renderer, position);
    } else {
      switch (model.state) {
        case States4.IS_NONE:
          choose(interactor, position);
          break;
        case States4.IS_PAN:
          pan(interactor, position);
          break;
        case States4.IS_DOLLY:
          dolly(interactor, position);
          break;
      }
    }
    model.previousPosition = position;
  };
  publicAPI.onButtonUp = (interactor) => {
    model.buttonPressed = false;
    if (model.state === States4.IS_NONE) {
      model.rotateManipulator.onButtonUp(interactor);
    }
    model.state = States4.IS_NONE;
  };
  publicAPI.getUseWorldUpVec = () => model.rotateManipulator.getUseWorldUpVec();
  publicAPI.setUseWorldUpVec = (useWorldUpVec) => {
    model.rotateManipulator.setUseWorldUpVec(useWorldUpVec);
  };
  publicAPI.getWorldUpVec = () => model.rotateManipulator.getWorldUpVec();
  publicAPI.setWorldUpVec = (x, y, z) => {
    model.rotateManipulator.setWorldUpVec(x, y, z);
  };
  publicAPI.getUseHardwareSelector = () => model.rotateManipulator.getUseHardwareSelector();
  publicAPI.setUseHardwareSelector = (useHardwareSelector) => {
    model.rotateManipulator.setUseHardwareSelector(useHardwareSelector);
  };
  publicAPI.getFocusSphereColor = () => {
    model.rotateManipulator.getFocusSphereColor();
  };
  publicAPI.setFocusSphereColor = (r, g, b2) => {
    model.rotateManipulator.setFocusSphereColor(r, g, b2);
  };
  publicAPI.getFocusSphereRadiusFactor = () => model.rotateManipulator.getFocusSphereRadiusFactor();
  publicAPI.setFocusSphereRadiusFactor = (focusSphereRadiusFactor) => {
    model.rotateManipulator.setFocusSphereRadiusFactor(focusSphereRadiusFactor);
  };
}
var DEFAULT_VALUES80 = {};
function extend90(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES80, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkMouseCameraUnicamManipulator(publicAPI, model);
}
var newInstance85 = macro.newInstance(extend90, "vtkMouseCameraUnicamManipulator");
var vtkMouseCameraUnicamManipulator$1 = {
  newInstance: newInstance85,
  extend: extend90
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballFirstPersonManipulator.js
var ANIMATION_REQUESTER2 = "vtkMouseCameraTrackballFirstPersonManipulator";
function vtkMouseCameraTrackballFirstPersonManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraTrackballFirstPersonManipulator");
  const internal = {
    interactor: null,
    renderer: null
  };
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    if (model.usePointerLock && !interactor.isPointerLocked()) {
      Object.assign(internal, {
        interactor,
        renderer
      });
      interactor.requestPointerLock();
    }
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const sensitivity = model.sensitivity;
    const yaw = -position.movementX * sensitivity;
    const pitch = -position.movementY * sensitivity;
    Object.assign(internal, {
      interactor,
      renderer
    });
    publicAPI.moveCamera(yaw, pitch);
  };
  publicAPI.moveCamera = (yaw, pitch) => {
    const {
      renderer,
      interactor
    } = internal;
    const camera = renderer.getActiveCamera();
    const numSteps = model.numAnimationSteps;
    const yawStep = yaw / numSteps;
    const pitchStep = pitch / numSteps;
    const now = performance.now().toString();
    const animationRequester = `${ANIMATION_REQUESTER2}.${now}`;
    let curStep = 0;
    let animationSub = null;
    const performStep = () => {
      camera.yaw(yawStep);
      camera.pitch(pitchStep);
      camera.orthogonalizeViewUp();
      curStep += 1;
      if (curStep === numSteps) {
        animationSub.unsubscribe();
        renderer.resetCameraClippingRange();
        if (interactor.getLightFollowCamera()) {
          renderer.updateLightsGeometryToFollowCamera();
        }
        const cancelRequest = () => {
          internal.interactor.cancelAnimation(animationRequester);
        };
        setTimeout(cancelRequest, 0);
      }
    };
    interactor.requestAnimation(animationRequester);
    animationSub = interactor.onAnimation(() => performStep());
  };
}
var DEFAULT_VALUES81 = {
  numAnimationSteps: 5,
  sensitivity: 0.05,
  usePointerLock: true
};
function extend91(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES81, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["numAnimationSteps", "sensitivity", "usePointerLock"]);
  vtkMouseCameraTrackballFirstPersonManipulator(publicAPI, model);
}
var newInstance86 = macro.newInstance(extend91, "vtkMouseCameraTrackballFirstPersonManipulator");
var vtkMouseCameraTrackballFirstPersonManipulator$1 = {
  newInstance: newInstance86,
  extend: extend91
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballRotateManipulator.js
function vtkMouseCameraTrackballRotateManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraTrackballRotateManipulator");
  const newCamPos = new Float64Array(3);
  const newFp = new Float64Array(3);
  const newViewUp = new Float64Array(3);
  const trans = new Float64Array(16);
  const v2 = new Float64Array(3);
  const centerNeg = new Float64Array(3);
  const direction3 = new Float64Array(3);
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.previousPosition = position;
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const camera = renderer.getActiveCamera();
    const cameraPos = camera.getPosition();
    const cameraFp = camera.getFocalPoint();
    mat4_exports.identity(trans);
    const {
      center,
      rotationFactor
    } = model;
    if (model.useFocalPointAsCenterOfRotation) {
      center[0] = cameraFp[0];
      center[1] = cameraFp[1];
      center[2] = cameraFp[2];
    }
    const dx = model.previousPosition.x - position.x;
    const dy = model.previousPosition.y - position.y;
    const size = interactor.getView().getViewportSize(renderer);
    const viewUp = camera.getViewUp();
    if (model.useWorldUpVec) {
      const centerOfRotation = new Float64Array(3);
      vec3_exports.copy(centerOfRotation, model.worldUpVec);
      multiplyScalar(centerOfRotation, dot(cameraPos, model.worldUpVec) / dot(model.worldUpVec, model.worldUpVec));
      add(center, centerOfRotation, centerOfRotation);
      mat4_exports.translate(trans, trans, centerOfRotation);
      mat4_exports.rotate(trans, trans, radiansFromDegrees(360 * dx / size[0] * rotationFactor), model.worldUpVec);
      centerOfRotation[0] = -centerOfRotation[0];
      centerOfRotation[1] = -centerOfRotation[1];
      centerOfRotation[2] = -centerOfRotation[2];
      mat4_exports.translate(trans, trans, centerOfRotation);
      mat4_exports.translate(trans, trans, center);
    } else {
      mat4_exports.translate(trans, trans, center);
      mat4_exports.rotate(trans, trans, radiansFromDegrees(360 * dx / size[0] * rotationFactor), viewUp);
    }
    cross(camera.getDirectionOfProjection(), viewUp, v2);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(-360 * dy / size[1] * rotationFactor), v2);
    centerNeg[0] = -center[0];
    centerNeg[1] = -center[1];
    centerNeg[2] = -center[2];
    mat4_exports.translate(trans, trans, centerNeg);
    vec3_exports.transformMat4(newCamPos, cameraPos, trans);
    vec3_exports.transformMat4(newFp, cameraFp, trans);
    direction3[0] = viewUp[0] + cameraPos[0];
    direction3[1] = viewUp[1] + cameraPos[1];
    direction3[2] = viewUp[2] + cameraPos[2];
    vec3_exports.transformMat4(newViewUp, direction3, trans);
    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);
    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);
    camera.setViewUp(newViewUp[0] - newCamPos[0], newViewUp[1] - newCamPos[1], newViewUp[2] - newCamPos[2]);
    camera.orthogonalizeViewUp();
    renderer.resetCameraClippingRange();
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
    model.previousPosition = position;
  };
}
var DEFAULT_VALUES82 = {
  useWorldUpVec: false,
  // set WorldUpVector to be y-axis by default
  worldUpVec: [0, 1, 0],
  useFocalPointAsCenterOfRotation: false
};
function extend92(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES82, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["useWorldUpVec"]);
  macro.setGetArray(publicAPI, model, ["worldUpVec"], 3);
  macro.setGet(publicAPI, model, ["useFocalPointAsCenterOfRotation"]);
  vtkMouseCameraTrackballRotateManipulator(publicAPI, model);
}
var newInstance87 = macro.newInstance(extend92, "vtkMouseCameraTrackballRotateManipulator");
var vtkMouseCameraTrackballRotateManipulator$1 = {
  newInstance: newInstance87,
  extend: extend92
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballRollManipulator.js
function vtkMouseCameraTrackballRollManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraTrackballRollManipulator");
  const axis = new Float64Array(3);
  const direction3 = new Float64Array(3);
  const centerNeg = new Float64Array(3);
  const transform = new Float64Array(16);
  const newCamPos = new Float64Array(3);
  const newFp = new Float64Array(3);
  const newViewUp = new Float64Array(3);
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.previousPosition = position;
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const camera = renderer.getActiveCamera();
    const cameraPos = camera.getPosition();
    const cameraFp = camera.getFocalPoint();
    const viewUp = camera.getViewUp();
    axis[0] = cameraFp[0] - cameraPos[0];
    axis[1] = cameraFp[1] - cameraPos[1];
    axis[2] = cameraFp[2] - cameraPos[2];
    publicAPI.computeDisplayCenter(interactor.getInteractorStyle(), renderer);
    const x1 = model.previousPosition.x - model.displayCenter[0];
    const x2 = position.x - model.displayCenter[0];
    const y1 = model.previousPosition.y - model.displayCenter[1];
    const y2 = position.y - model.displayCenter[1];
    if (x2 === 0 && y2 === 0 || x1 === 0 && y1 === 0) {
      return;
    }
    const angle = degreesFromRadians((x1 * y2 - y1 * x2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));
    const {
      center
    } = model;
    mat4_exports.identity(transform);
    centerNeg[0] = -center[0];
    centerNeg[1] = -center[1];
    centerNeg[2] = -center[2];
    mat4_exports.translate(transform, transform, center);
    mat4_exports.rotate(transform, transform, radiansFromDegrees(angle), axis);
    mat4_exports.translate(transform, transform, centerNeg);
    vec3_exports.transformMat4(newCamPos, cameraPos, transform);
    vec3_exports.transformMat4(newFp, cameraFp, transform);
    direction3[0] = viewUp[0] + cameraPos[0];
    direction3[1] = viewUp[1] + cameraPos[1];
    direction3[2] = viewUp[2] + cameraPos[2];
    vec3_exports.transformMat4(newViewUp, direction3, transform);
    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);
    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);
    camera.setViewUp(newViewUp[0] - newCamPos[0], newViewUp[1] - newCamPos[1], newViewUp[2] - newCamPos[2]);
    camera.orthogonalizeViewUp();
    renderer.resetCameraClippingRange();
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
    model.previousPosition = position;
  };
}
var DEFAULT_VALUES83 = {};
function extend93(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES83, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkMouseCameraTrackballRollManipulator(publicAPI, model);
}
var newInstance88 = macro.newInstance(extend93, "vtkMouseCameraTrackballRollManipulator");
var vtkMouseCameraTrackballRollManipulator$1 = {
  newInstance: newInstance88,
  extend: extend93
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballMultiRotateManipulator.js
function max(x, y) {
  return x < y ? y : x;
}
function sqr(x) {
  return x * x;
}
function vtkMouseCameraTrackballMultiRotateManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraTrackballMultiRotateManipulator");
  const rotateManipulator = vtkMouseCameraTrackballRotateManipulator$1.newInstance();
  const rollManipulator = vtkMouseCameraTrackballRollManipulator$1.newInstance();
  let currentManipulator = null;
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    const viewSize = interactor.getView().getViewportSize(renderer);
    const viewCenter = [0.5 * viewSize[0], 0.5 * viewSize[1]];
    const rotateRadius = 0.9 * max(viewCenter[0], viewCenter[1]);
    const dist2 = sqr(viewCenter[0] - position.x) + sqr(viewCenter[1] - position.y);
    if (rotateRadius * rotateRadius > dist2) {
      currentManipulator = rotateManipulator;
    } else {
      currentManipulator = rollManipulator;
    }
    currentManipulator.setButton(publicAPI.getButton());
    currentManipulator.setShift(publicAPI.getShift());
    currentManipulator.setControl(publicAPI.getControl());
    currentManipulator.setCenter(publicAPI.getCenter());
    currentManipulator.onButtonDown(interactor, position);
  };
  publicAPI.onButtonUp = (interactor) => {
    if (currentManipulator) {
      currentManipulator.onButtonUp(interactor);
    }
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (currentManipulator) {
      currentManipulator.onMouseMove(interactor, renderer, position);
    }
  };
}
var DEFAULT_VALUES84 = {};
function extend94(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES84, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkMouseCameraTrackballMultiRotateManipulator(publicAPI, model);
}
var newInstance89 = macro.newInstance(extend94, "vtkMouseCameraTrackballMultiRotateManipulator");
var vtkMouseCameraTrackballMultiRotateManipulator$1 = {
  newInstance: newInstance89,
  extend: extend94
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballPanManipulator.js
function vtkMouseCameraTrackballPanManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraTrackballPanManipulator");
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.previousPosition = position;
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const pos = position;
    const lastPos = model.previousPosition;
    model.previousPosition = position;
    const camera = renderer.getActiveCamera();
    const camPos = camera.getPosition();
    const fp = camera.getFocalPoint();
    if (camera.getParallelProjection()) {
      camera.orthogonalizeViewUp();
      const up = camera.getViewUp();
      const vpn = camera.getViewPlaneNormal();
      const right = [0, 0, 0];
      cross(vpn, up, right);
      const height2 = interactor.getView().getViewportSize(renderer)[1];
      let dx = (pos.x - lastPos.x) / height2;
      let dy = (lastPos.y - pos.y) / height2;
      const scale = camera.getParallelScale();
      dx *= scale * 2;
      dy *= scale * 2;
      let tmp = right[0] * dx + up[0] * dy;
      camPos[0] += tmp;
      fp[0] += tmp;
      tmp = right[1] * dx + up[1] * dy;
      camPos[1] += tmp;
      fp[1] += tmp;
      tmp = right[2] * dx + up[2] * dy;
      camPos[2] += tmp;
      fp[2] += tmp;
      camera.setPosition(camPos[0], camPos[1], camPos[2]);
      camera.setFocalPoint(fp[0], fp[1], fp[2]);
    } else {
      const {
        center
      } = model;
      const style6 = interactor.getInteractorStyle();
      const focalDepth = style6.computeWorldToDisplay(renderer, center[0], center[1], center[2])[2];
      const worldPoint = style6.computeDisplayToWorld(renderer, pos.x, pos.y, focalDepth);
      const lastWorldPoint = style6.computeDisplayToWorld(renderer, lastPos.x, lastPos.y, focalDepth);
      const newCamPos = [camPos[0] + (lastWorldPoint[0] - worldPoint[0]), camPos[1] + (lastWorldPoint[1] - worldPoint[1]), camPos[2] + (lastWorldPoint[2] - worldPoint[2])];
      const newFp = [fp[0] + (lastWorldPoint[0] - worldPoint[0]), fp[1] + (lastWorldPoint[1] - worldPoint[1]), fp[2] + (lastWorldPoint[2] - worldPoint[2])];
      camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);
      camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);
    }
    renderer.resetCameraClippingRange();
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}
var DEFAULT_VALUES85 = {};
function extend95(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES85, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkMouseCameraTrackballPanManipulator(publicAPI, model);
}
var newInstance90 = macro.newInstance(extend95, "vtkMouseCameraTrackballPanManipulator");
var vtkMouseCameraTrackballPanManipulator$1 = {
  newInstance: newInstance90,
  extend: extend95
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballZoomManipulator.js
function vtkMouseCameraTrackballZoomManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraTrackballZoomManipulator");
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.previousPosition = position;
    const size = interactor.getView().getViewportSize(renderer);
    const camera = renderer.getActiveCamera();
    const direction3 = model.flipDirection ? -1 : 1;
    if (camera.getParallelProjection()) {
      model.zoomScale = 1.5 / size[1] * direction3;
    } else {
      const range = camera.getClippingRange();
      model.zoomScale = 1.5 * (range[1] / size[1]) * direction3;
    }
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const dy = model.previousPosition.y - position.y;
    const camera = renderer.getActiveCamera();
    if (camera.getParallelProjection()) {
      const k = dy * model.zoomScale;
      camera.setParallelScale((1 - k) * camera.getParallelScale());
    } else {
      const cameraPos = camera.getPosition();
      const cameraFp = camera.getFocalPoint();
      const norm2 = camera.getDirectionOfProjection();
      const k = dy * model.zoomScale;
      let tmp = k * norm2[0];
      cameraPos[0] += tmp;
      cameraFp[0] += tmp;
      tmp = k * norm2[1];
      cameraPos[1] += tmp;
      cameraFp[1] += tmp;
      tmp = k * norm2[2];
      cameraPos[2] += tmp;
      cameraFp[2] += tmp;
      if (!camera.getFreezeFocalPoint()) {
        camera.setFocalPoint(cameraFp[0], cameraFp[1], cameraFp[2]);
      }
      camera.setPosition(cameraPos[0], cameraPos[1], cameraPos[2]);
      renderer.resetCameraClippingRange();
    }
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
    model.previousPosition = position;
  };
  publicAPI.onScroll = (interactor, renderer, delta) => {
    if (!delta) {
      return;
    }
    const camera = renderer.getActiveCamera();
    const dyf = 1 - delta / 10;
    if (camera.getParallelProjection()) {
      camera.setParallelScale(camera.getParallelScale() / dyf);
    } else {
      camera.dolly(dyf);
      renderer.resetCameraClippingRange();
    }
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}
var DEFAULT_VALUES86 = {
  zoomScale: 0,
  flipDirection: false
};
function extend96(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES86, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  vtkCompositeCameraManipulator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["flipDirection"]);
  vtkMouseCameraTrackballZoomManipulator(publicAPI, model);
}
var newInstance91 = macro.newInstance(extend96, "vtkMouseCameraTrackballZoomManipulator");
var vtkMouseCameraTrackballZoomManipulator$1 = {
  newInstance: newInstance91,
  extend: extend96
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballZoomToMouseManipulator.js
function vtkMouseCameraTrackballZoomToMouseManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseCameraTrackballZoomToMouseManipulator");
  const superOnButtonDown = publicAPI.onButtonDown;
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    superOnButtonDown(interactor, renderer, position);
    model.zoomPosition = position;
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!position) {
      return;
    }
    const dy = model.previousPosition.y - position.y;
    const k = dy * model.zoomScale;
    vtkInteractorStyleManipulator$1.dollyToPosition(1 - k, model.zoomPosition, renderer, interactor);
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
    model.previousPosition = position;
  };
  publicAPI.onScroll = (interactor, renderer, delta, position) => {
    if (!delta || !position) {
      return;
    }
    const dyf = 1 - delta * 0.1;
    vtkInteractorStyleManipulator$1.dollyToPosition(dyf, position, renderer, interactor);
    if (interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}
var DEFAULT_VALUES87 = {
  zoomPosition: null
};
function extend97(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES87, initialValues);
  vtkMouseCameraTrackballZoomManipulator$1.extend(publicAPI, model, initialValues);
  vtkMouseCameraTrackballZoomToMouseManipulator(publicAPI, model);
}
var newInstance92 = macro.newInstance(extend97, "vtkMouseCameraTrackballZoomToMouseManipulator");
var vtkMouseCameraTrackballZoomToMouseManipulator$1 = {
  newInstance: newInstance92,
  extend: extend97
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseRangeManipulator.js
function vtkMouseRangeManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkMouseRangeManipulator");
  const incrementalDelta = /* @__PURE__ */ new Map();
  function scaleDeltaToRange(listener, normalizedDelta) {
    return normalizedDelta * ((listener.max - listener.min) / (listener.step + 1));
  }
  function processDelta(listener, delta) {
    const oldValue = listener.getValue();
    let scalingFactor = listener.exponentialScroll ? listener.scale ** Math.log2(Math.abs(model.interactionNetDelta) + 2) : listener.scale;
    scalingFactor = Math.abs(scalingFactor) * Math.sign(listener.scale);
    const newDelta = delta * scalingFactor + incrementalDelta.get(listener);
    const stepsToDifference = Math.floor(Math.abs(newDelta / listener.step));
    let value = oldValue + listener.step * stepsToDifference * Math.sign(newDelta);
    value = Math.max(value, listener.min);
    value = Math.min(value, listener.max);
    if (value !== oldValue) {
      listener.setValue(value);
      incrementalDelta.set(listener, 0);
    } else if (value === listener.min && newDelta < 0 || value === listener.max && newDelta > 0) {
      incrementalDelta.set(listener, 0);
    } else {
      incrementalDelta.set(listener, newDelta);
    }
  }
  publicAPI.setHorizontalListener = function(min, max2, step, getValue, setValue) {
    let scale = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
    let exponentialScroll = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;
    model.horizontalListener = {
      min,
      max: max2,
      step,
      getValue: getFn,
      setValue,
      scale,
      exponentialScroll
    };
    incrementalDelta.set(model.horizontalListener, 0);
    publicAPI.modified();
  };
  publicAPI.setVerticalListener = function(min, max2, step, getValue, setValue) {
    let scale = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
    let exponentialScroll = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;
    model.verticalListener = {
      min,
      max: max2,
      step,
      getValue: getFn,
      setValue,
      scale,
      exponentialScroll
    };
    incrementalDelta.set(model.verticalListener, 0);
    publicAPI.modified();
  };
  publicAPI.setScrollListener = function(min, max2, step, getValue, setValue) {
    let scale = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
    let exponentialScroll = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    if (step < 0) {
      vtkWarningMacro("Value of step cannot be negative. If you want to invert the scrolling direction, use a negative scale value instead.");
    }
    const stepSize = Math.abs(step);
    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;
    model.scrollListener = {
      min,
      max: max2,
      step: stepSize,
      getValue: getFn,
      setValue,
      scale,
      exponentialScroll
    };
    incrementalDelta.set(model.scrollListener, 0);
    publicAPI.modified();
  };
  publicAPI.removeHorizontalListener = () => {
    if (model.horizontalListener) {
      incrementalDelta.delete(model.horizontalListener);
      delete model.horizontalListener;
      publicAPI.modified();
    }
  };
  publicAPI.removeVerticalListener = () => {
    if (model.verticalListener) {
      incrementalDelta.delete(model.verticalListener);
      delete model.verticalListener;
      publicAPI.modified();
    }
  };
  publicAPI.removeScrollListener = () => {
    if (model.scrollListener) {
      incrementalDelta.delete(model.scrollListener);
      delete model.scrollListener;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllListeners = () => {
    publicAPI.removeHorizontalListener();
    publicAPI.removeVerticalListener();
    publicAPI.removeScrollListener();
  };
  publicAPI.onButtonDown = (interactor, renderer, position) => {
    model.previousPosition = position;
    model.interactionNetDelta = 0;
    const glRenderWindow = interactor.getView();
    const ratio = glRenderWindow.getContainerSize()[0] / glRenderWindow.getSize()[0];
    const size = glRenderWindow.getViewportSize(renderer);
    model.containerSize = size.map((v) => v * ratio);
  };
  publicAPI.onButtonUp = (interactor) => {
    interactor.exitPointerLock();
  };
  publicAPI.startPointerLockEvent = (interactor, renderer) => {
    const handlePointerLockMove = (event2) => {
      publicAPI.onPointerLockMove(interactor, renderer, event2);
    };
    document.addEventListener("mousemove", handlePointerLockMove);
    let subscription = null;
    const endInteraction = () => {
      document.removeEventListener("mousemove", handlePointerLockMove);
      subscription == null ? void 0 : subscription.unsubscribe();
    };
    subscription = interactor == null ? void 0 : interactor.onEndPointerLock(endInteraction);
  };
  publicAPI.onPointerLockMove = (interactor, renderer, event2) => {
    if (!interactor.isPointerLocked()) return;
    if (model.previousPosition == null) return;
    model.previousPosition.x += event2.movementX;
    model.previousPosition.y += event2.movementY;
    publicAPI.onMouseMove(interactor, renderer, model.previousPosition);
  };
  publicAPI.onMouseMove = (interactor, renderer, position) => {
    if (!model.verticalListener && !model.horizontalListener) {
      return;
    }
    if (model.usePointerLock && !interactor.isPointerLocked()) {
      interactor.requestPointerLock();
      publicAPI.startPointerLockEvent(interactor, renderer);
    }
    if (!position) {
      return;
    }
    if (model.horizontalListener) {
      const dxNorm = (position.x - model.previousPosition.x) / model.containerSize[0];
      const dx = scaleDeltaToRange(model.horizontalListener, dxNorm);
      model.interactionNetDelta += dx;
      processDelta(model.horizontalListener, dx);
    }
    if (model.verticalListener) {
      const dyNorm = (position.y - model.previousPosition.y) / model.containerSize[1];
      const dy = scaleDeltaToRange(model.verticalListener, dyNorm);
      model.interactionNetDelta += dy;
      processDelta(model.verticalListener, dy);
    }
    model.previousPosition = position;
  };
  publicAPI.onScroll = (interactor, renderer, delta) => {
    if (!model.scrollListener || !delta) {
      return;
    }
    model.interactionNetDelta += delta * model.scrollListener.step;
    processDelta(model.scrollListener, delta * model.scrollListener.step);
  };
  publicAPI.onStartScroll = () => {
    model.interactionNetDelta = 0;
  };
}
var DEFAULT_VALUES88 = {
  horizontalListener: null,
  verticalListener: null,
  scrollListener: null
};
function extend98(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES88, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeMouseManipulator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["usePointerLock"]);
  vtkMouseRangeManipulator(publicAPI, model);
}
var newInstance93 = macro.newInstance(extend98, "vtkMouseRangeManipulator");
var vtkMouseRangeManipulator$1 = {
  newInstance: newInstance93,
  extend: extend98
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators/VRButtonPanManipulator.js
function vtkVRButtonPanManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkVRButtonPanManipulator");
  publicAPI.onButton3D = (interactorStyle, renderer, state, eventData) => {
    if (eventData.pressed) {
      interactorStyle.startCameraPose();
    } else if (state === States.IS_CAMERA_POSE) {
      interactorStyle.endCameraPose();
    }
  };
  publicAPI.onMove3D = (interactorStyle, renderer, state, eventData) => {
    if (state !== States.IS_CAMERA_POSE) {
      return;
    }
    const camera = renderer.getActiveCamera();
    const oldTrans = camera.getPhysicalTranslation();
    const speed = eventData.gamepad.axes[1];
    const pscale = speed * 0.05 * camera.getPhysicalScale();
    const dir = camera.physicalOrientationToWorldDirection(eventData.orientation);
    camera.setPhysicalTranslation(oldTrans[0] + dir[0] * pscale, oldTrans[1] + dir[1] * pscale, oldTrans[2] + dir[2] * pscale);
  };
}
var DEFAULT_VALUES89 = {
  device: Device.RightController,
  input: Input.TrackPad
};
function extend99(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES89, initialValues);
  macro.obj(publicAPI, model);
  vtkCompositeVRManipulator$1.extend(publicAPI, model, initialValues);
  vtkVRButtonPanManipulator(publicAPI, model);
}
var newInstance94 = macro.newInstance(extend99, "vtkVRButtonPanManipulator");
var vtkVRButtonPanManipulator$1 = {
  newInstance: newInstance94,
  extend: extend99
};

// node_modules/@kitware/vtk.js/Interaction/Manipulators.js
var Manipulators = {
  vtkCompositeCameraManipulator: vtkCompositeCameraManipulator$1,
  vtkCompositeGestureManipulator: vtkCompositeGestureManipulator$1,
  vtkCompositeKeyboardManipulator: vtkCompositeKeyboardManipulator$1,
  vtkCompositeMouseManipulator: vtkCompositeMouseManipulator$1,
  vtkCompositeVRManipulator: vtkCompositeVRManipulator$1,
  vtkGestureCameraManipulator: vtkGestureCameraManipulator$1,
  vtkKeyboardCameraManipulator: vtkKeyboardCameraManipulator$1,
  vtkMouseBoxSelectorManipulator,
  vtkMouseCameraAxisRotateManipulator: vtkMouseCameraAxisRotateManipulator$1,
  vtkMouseCameraSliceManipulator: vtkMouseCameraSliceManipulator$1,
  vtkMouseCameraUnicamManipulator: vtkMouseCameraUnicamManipulator$1,
  vtkMouseCameraUnicamRotateManipulator: vtkMouseCameraUnicamRotateManipulator$1,
  vtkMouseCameraTrackballFirstPersonManipulator: vtkMouseCameraTrackballFirstPersonManipulator$1,
  vtkMouseCameraTrackballMultiRotateManipulator: vtkMouseCameraTrackballMultiRotateManipulator$1,
  vtkMouseCameraTrackballPanManipulator: vtkMouseCameraTrackballPanManipulator$1,
  vtkMouseCameraTrackballRollManipulator: vtkMouseCameraTrackballRollManipulator$1,
  vtkMouseCameraTrackballRotateManipulator: vtkMouseCameraTrackballRotateManipulator$1,
  vtkMouseCameraTrackballZoomManipulator: vtkMouseCameraTrackballZoomManipulator$1,
  vtkMouseCameraTrackballZoomToMouseManipulator: vtkMouseCameraTrackballZoomToMouseManipulator$1,
  vtkMouseRangeManipulator: vtkMouseRangeManipulator$1,
  vtkVRButtonPanManipulator: vtkVRButtonPanManipulator$1
};

// node_modules/@kitware/vtk.js/Interaction/Misc/DeviceOrientationToCamera.js
var listeners = [];
var orientation = {
  device: {},
  screen: window.orientation || 0,
  supported: !!window.DeviceMotionEvent,
  update: false
};
var SCREEN_ORIENTATION_MAP = {
  "landscape-primary": 90,
  "landscape-secondary": -90,
  "portrait-secondary": 180,
  "portrait-primary": 0
};
function isEventValid(evt) {
  return Number.isFinite(evt.alpha);
}
function onDeviceOrientationChangeEvent(evt) {
  orientation.device = evt;
  if (!Number.isFinite(evt.alpha)) {
    orientation.supported = false;
  }
}
function onScreenOrientationChangeEvent() {
  orientation.screen = SCREEN_ORIENTATION_MAP[window.screen.orientation || window.screen.mozOrientation] || window.orientation || 0;
}
function addWindowListeners() {
  window.addEventListener("orientationchange", onScreenOrientationChangeEvent, false);
  window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent, false);
  orientation.update = true;
  listeners.filter((i) => !!i).forEach((i) => i.renderWindowInteractor.requestAnimation(i));
}
function removeWindowListeners() {
  window.removeEventListener("orientationchange", onScreenOrientationChangeEvent, false);
  window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent, false);
  orientation.update = false;
  listeners.filter((i) => !!i).forEach((i) => i.renderWindowInteractor.cancelAnimation(i));
}
function addCameraToSynchronize(renderWindowInteractor, camera, onCameraUpdate) {
  function onAnimation() {
    if (orientation.update && isEventValid(orientation.device)) {
      const {
        alpha,
        beta,
        gamma
      } = orientation.device;
      const {
        screen
      } = orientation;
      camera.setDeviceAngles(alpha, beta, gamma, screen);
      if (onCameraUpdate) {
        onCameraUpdate();
      }
    }
  }
  const subscription = renderWindowInteractor.onAnimation(onAnimation);
  const listener = {
    subscription,
    renderWindowInteractor
  };
  const listenerId = listeners.length;
  listeners.push(listener);
  if (orientation.update) {
    listener.renderWindowInteractor.requestAnimation(listener);
  }
  return listenerId;
}
function removeCameraToSynchronize(id) {
  let cancelAnimation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  const listener = listeners[id];
  if (listener) {
    listener.subscription.unsubscribe();
    if (cancelAnimation) {
      listener.renderWindowInteractor.cancelAnimation(listener);
    }
  }
  listeners[id] = null;
}
function isDeviceOrientationSupported() {
  return orientation.supported;
}
var vtkDeviceOrientationToCamera = {
  addCameraToSynchronize,
  addWindowListeners,
  isDeviceOrientationSupported,
  removeCameraToSynchronize,
  removeWindowListeners
};

// node_modules/@kitware/vtk.js/Interaction/Misc.js
var Misc = {
  vtkDeviceOrientationToCamera
};

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleImage.js
function vtkInteractorStyleImage(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleImage");
  publicAPI.superHandleMouseMove = publicAPI.handleMouseMove;
  publicAPI.handleMouseMove = (callData) => {
    const pos = callData.position;
    const renderer = model.getRenderer(callData);
    switch (model.state) {
      case States.IS_WINDOW_LEVEL:
        publicAPI.windowLevel(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States.IS_SLICE:
        publicAPI.slice(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
    }
    publicAPI.superHandleMouseMove(callData);
  };
  publicAPI.superHandleLeftButtonPress = publicAPI.handleLeftButtonPress;
  publicAPI.handleLeftButtonPress = (callData) => {
    const pos = callData.position;
    if (!callData.shiftKey && !callData.controlKey) {
      model.windowLevelStartPosition[0] = pos.x;
      model.windowLevelStartPosition[1] = pos.y;
      publicAPI.setCurrentImageNumber(model.currentImageNumber);
      const property = model.currentImageProperty;
      if (property) {
        model.windowLevelInitial[0] = property.getColorWindow();
        model.windowLevelInitial[1] = property.getColorLevel();
      }
      publicAPI.startWindowLevel();
    } else if (model.interactionMode === "IMAGE3D" && callData.shiftKey) {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startDolly();
      } else {
        publicAPI.startRotate();
      }
    } else if (model.interactionMode === "IMAGE_SLICING" && callData.controlKey) {
      model.lastSlicePosition = pos.y;
      publicAPI.startSlice();
    } else {
      publicAPI.superHandleLeftButtonPress(callData);
    }
  };
  publicAPI.superHandleLeftButtonRelease = publicAPI.handleLeftButtonRelease;
  publicAPI.handleLeftButtonRelease = () => {
    switch (model.state) {
      case States.IS_WINDOW_LEVEL:
        publicAPI.endWindowLevel();
        break;
      case States.IS_SLICE:
        publicAPI.endSlice();
        break;
      default:
        publicAPI.superHandleLeftButtonRelease();
        break;
    }
  };
  publicAPI.handleStartMouseWheel = () => {
    publicAPI.startSlice();
  };
  publicAPI.handleEndMouseWheel = () => {
    publicAPI.endSlice();
  };
  publicAPI.handleMouseWheel = (callData) => {
    const camera = model.getRenderer(callData).getActiveCamera();
    let distance = camera.getDistance();
    distance += callData.spinY;
    const range = camera.getClippingRange();
    if (distance < range[0]) {
      distance = range[0];
    }
    if (distance > range[1]) {
      distance = range[1];
    }
    camera.setDistance(distance);
    const props = model.getRenderer(callData).getViewProps().filter((prop) => prop.isA("vtkImageSlice"));
    props.forEach((prop) => {
      if (prop.getMapper().isA("vtkImageResliceMapper")) {
        const p = prop.getMapper().getSlicePlane();
        if (p) {
          p.push(callData.spinY);
          p.modified();
          prop.getMapper().modified();
        }
      }
    });
  };
  publicAPI.windowLevel = (renderer, position) => {
    model.windowLevelCurrentPosition[0] = position.x;
    model.windowLevelCurrentPosition[1] = position.y;
    const rwi = model._interactor;
    if (model.currentImageProperty) {
      const size = rwi.getView().getViewportSize(renderer);
      const mWindow = model.windowLevelInitial[0];
      const level = model.windowLevelInitial[1];
      let dx = (model.windowLevelCurrentPosition[0] - model.windowLevelStartPosition[0]) * 4 / size[0];
      let dy = (model.windowLevelStartPosition[1] - model.windowLevelCurrentPosition[1]) * 4 / size[1];
      if (Math.abs(mWindow) > 0.01) {
        dx *= mWindow;
      } else {
        dx *= mWindow < 0 ? -0.01 : 0.01;
      }
      if (Math.abs(level) > 0.01) {
        dy *= level;
      } else {
        dy *= level < 0 ? -0.01 : 0.01;
      }
      if (mWindow < 0) {
        dx *= -1;
      }
      if (level < 0) {
        dy *= -1;
      }
      let newWindow = dx + mWindow;
      const newLevel = level - dy;
      if (newWindow < 0.01) {
        newWindow = 0.01;
      }
      model.currentImageProperty.setColorWindow(newWindow);
      model.currentImageProperty.setColorLevel(newLevel);
    }
  };
  publicAPI.slice = (renderer, position) => {
    const rwi = model._interactor;
    const dy = position.y - model.lastSlicePosition;
    const camera = renderer.getActiveCamera();
    const range = camera.getClippingRange();
    let distance = camera.getDistance();
    let viewportHeight = 0;
    if (camera.getParallelProjection()) {
      viewportHeight = 2 * camera.getParallelScale();
    } else {
      const angle = radiansFromDegrees(camera.getViewAngle());
      viewportHeight = 2 * distance * Math.tan(0.5 * angle);
    }
    const size = rwi.getView().getSize();
    const delta = dy * viewportHeight / size[1];
    distance += delta;
    if (distance < range[0]) {
      distance = range[0] + viewportHeight * 1e-3;
    }
    if (distance > range[1]) {
      distance = range[1] - viewportHeight * 1e-3;
    }
    camera.setDistance(distance);
    model.lastSlicePosition = position.y;
  };
  publicAPI.setCurrentImageNumber = (i) => {
    if (i === null) {
      return;
    }
    const renderer = model._interactor.getCurrentRenderer();
    if (!renderer) {
      return;
    }
    model.currentImageNumber = i;
    function propMatch(j, prop, targetIndex2) {
      return j === targetIndex2 && prop.getNestedPickable();
    }
    const props = renderer.getViewProps().filter((prop) => prop.isA("vtkImageSlice"));
    let targetIndex = i;
    if (i < 0) {
      targetIndex += props.length;
    }
    const imageProp = props.find((prop, index) => propMatch(index, prop, targetIndex));
    if (imageProp) {
      publicAPI.setCurrentImageProperty(imageProp.getProperty());
    }
  };
  publicAPI.setCurrentImageProperty = (imageProperty) => {
    model.currentImageProperty = imageProperty;
  };
}
var DEFAULT_VALUES90 = {
  windowLevelStartPosition: [0, 0],
  windowLevelCurrentPosition: [0, 0],
  lastSlicePosition: 0,
  windowLevelInitial: [1, 0.5],
  // currentImageProperty: null,
  currentImageNumber: -1,
  interactionMode: "IMAGE2D",
  xViewRightVector: [0, 1, 0],
  xViewUpVector: [0, 0, -1],
  yViewRightVector: [1, 0, 0],
  yViewUpVector: [0, 0, -1],
  zViewRightVector: [1, 0, 0],
  zViewUpVector: [0, 1, 0]
};
function extend100(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES90, initialValues);
  vtkInteractorStyleTrackballCamera$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["interactionMode"]);
  macro.get(publicAPI, model, ["currentImageProperty"]);
  vtkInteractorStyleImage(publicAPI, model);
}
var newInstance95 = macro.newInstance(extend100, "vtkInteractorStyleImage");
var vtkInteractorStyleImage$1 = {
  newInstance: newInstance95,
  extend: extend100
};

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleMPRSlice.js
function clamp(value, min, max2) {
  if (value < min) {
    return min;
  }
  if (value > max2) {
    return max2;
  }
  return value;
}
function vtkInteractorStyleMPRSlice(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleMPRSlice");
  model.trackballManipulator = vtkMouseCameraTrackballRotateManipulator$1.newInstance({
    button: 1
  });
  model.panManipulator = vtkMouseCameraTrackballPanManipulator$1.newInstance({
    button: 1,
    shift: true
  });
  model.zoomManipulator = vtkMouseCameraTrackballZoomManipulator$1.newInstance({
    button: 3
  });
  model.scrollManipulator = vtkMouseRangeManipulator$1.newInstance({
    scrollEnabled: true,
    dragEnabled: false
  });
  const cache = {
    sliceNormal: [0, 0, 0],
    sliceRange: [0, 0]
  };
  let cameraSub = null;
  function updateScrollManipulator() {
    const range = publicAPI.getSliceRange();
    model.scrollManipulator.removeScrollListener();
    model.scrollManipulator.setScrollListener(range[0], range[1], 1, publicAPI.getSlice, publicAPI.setSlice);
  }
  function setManipulators() {
    publicAPI.removeAllMouseManipulators();
    publicAPI.addMouseManipulator(model.trackballManipulator);
    publicAPI.addMouseManipulator(model.panManipulator);
    publicAPI.addMouseManipulator(model.zoomManipulator);
    publicAPI.addMouseManipulator(model.scrollManipulator);
    updateScrollManipulator();
  }
  const superSetInteractor = publicAPI.setInteractor;
  publicAPI.setInteractor = (interactor) => {
    superSetInteractor(interactor);
    if (cameraSub) {
      cameraSub.unsubscribe();
      cameraSub = null;
    }
    if (interactor) {
      const renderer = interactor.getCurrentRenderer();
      const camera = renderer.getActiveCamera();
      cameraSub = camera.onModified(() => {
        updateScrollManipulator();
        publicAPI.modified();
      });
    }
  };
  publicAPI.handleMouseMove = macro.chain(publicAPI.handleMouseMove, () => {
    const renderer = model._interactor.getCurrentRenderer();
    const camera = renderer.getActiveCamera();
    const dist = camera.getDistance();
    camera.setClippingRange(dist, dist + 0.1);
  });
  const superSetVolumeMapper = publicAPI.setVolumeMapper;
  publicAPI.setVolumeMapper = (mapper) => {
    if (superSetVolumeMapper(mapper)) {
      const renderer = model._interactor.getCurrentRenderer();
      const camera = renderer.getActiveCamera();
      if (mapper) {
        camera.setFreezeFocalPoint(true);
        publicAPI.setSliceNormal(...publicAPI.getSliceNormal());
      } else {
        camera.setFreezeFocalPoint(false);
      }
    }
  };
  publicAPI.getSlice = () => {
    const renderer = model._interactor.getCurrentRenderer();
    const camera = renderer.getActiveCamera();
    const sliceNormal = publicAPI.getSliceNormal();
    const transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections(sliceNormal, [1, 0, 0]);
    const fp = camera.getFocalPoint();
    transform.apply(fp);
    return fp[0];
  };
  publicAPI.setSlice = (slice) => {
    const renderer = model._interactor.getCurrentRenderer();
    const camera = renderer.getActiveCamera();
    if (model.volumeMapper) {
      const range = publicAPI.getSliceRange();
      const clampedSlice = clamp(slice, ...range);
      const center = model.volumeMapper.getCenter();
      const distance = camera.getDistance();
      const dop = camera.getDirectionOfProjection();
      normalize(dop);
      const midPoint = (range[1] + range[0]) / 2;
      const zeroPoint = [center[0] - dop[0] * midPoint, center[1] - dop[1] * midPoint, center[2] - dop[2] * midPoint];
      const slicePoint = [zeroPoint[0] + dop[0] * clampedSlice, zeroPoint[1] + dop[1] * clampedSlice, zeroPoint[2] + dop[2] * clampedSlice];
      const newPos = [slicePoint[0] - dop[0] * distance, slicePoint[1] - dop[1] * distance, slicePoint[2] - dop[2] * distance];
      camera.setPosition(...newPos);
      camera.setFocalPoint(...slicePoint);
    }
  };
  publicAPI.getSliceRange = () => {
    if (model.volumeMapper) {
      const sliceNormal = publicAPI.getSliceNormal();
      if (areEquals(sliceNormal, cache.sliceNormal)) {
        return cache.sliceRange;
      }
      const sliceOrientation = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections(sliceNormal, [1, 0, 0]);
      const imageAlongSliceNormal = mat4_exports.create();
      mat4_exports.multiply(imageAlongSliceNormal, sliceOrientation.getMatrix(), model.volumeMapper.getInputData().getIndexToWorld());
      const transformedBounds = vtkBoundingBox.transformBounds(model.volumeMapper.getInputData().getSpatialExtent(), imageAlongSliceNormal);
      const minX = transformedBounds[0];
      const maxX = transformedBounds[1];
      cache.sliceNormal = sliceNormal;
      cache.sliceRange = [minX, maxX];
      return cache.sliceRange;
    }
    return [0, 0];
  };
  publicAPI.getSliceNormal = () => {
    if (model.volumeMapper) {
      const renderer = model._interactor.getCurrentRenderer();
      const camera = renderer.getActiveCamera();
      return camera.getDirectionOfProjection();
    }
    return [0, 0, 0];
  };
  publicAPI.setSliceNormal = function() {
    const renderer = model._interactor.getCurrentRenderer();
    const camera = renderer.getActiveCamera();
    for (var _len = arguments.length, normal = new Array(_len), _key = 0; _key < _len; _key++) {
      normal[_key] = arguments[_key];
    }
    normalize(normal);
    if (model.volumeMapper) {
      const bounds2 = model.volumeMapper.getBounds();
      const diagonal = Math.sqrt(distance2BetweenPoints([bounds2[0], bounds2[2], bounds2[4]], [bounds2[1], bounds2[3], bounds2[5]]));
      const center = [(bounds2[0] + bounds2[1]) / 2, (bounds2[2] + bounds2[3]) / 2, (bounds2[4] + bounds2[5]) / 2];
      const angle = 90;
      const dist = diagonal / (2 * Math.tan(angle / 360 * Math.PI));
      const cameraPos = [center[0] - normal[0] * dist, center[1] - normal[1] * dist, center[2] - normal[2] * dist];
      const oldDop = camera.getDirectionOfProjection();
      const transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections(oldDop, normal);
      const viewUp = [0, 1, 0];
      transform.apply(viewUp);
      camera.setPosition(...cameraPos);
      camera.setDistance(dist);
      camera.setDirectionOfProjection(...normal);
      camera.setViewUp(...viewUp);
      camera.setViewAngle(angle);
      camera.setClippingRange(dist, dist + 0.1);
      publicAPI.setCenterOfRotation(center);
    }
  };
  setManipulators();
}
var DEFAULT_VALUES91 = {};
function extend101(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES91, initialValues);
  vtkInteractorStyleManipulator$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["volumeMapper"]);
  vtkInteractorStyleMPRSlice(publicAPI, model);
}
var newInstance96 = macro.newInstance(extend101, "vtkInteractorStyleMPRSlice");
var vtkInteractorStyleMPRSlice$1 = {
  newInstance: newInstance96,
  extend: extend101
};

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleRemoteMouse.js
var START_INTERACTION_EVENT2 = {
  type: "StartInteractionEvent"
};
var INTERACTION_EVENT2 = {
  type: "InteractionEvent"
};
var END_INTERACTION_EVENT2 = {
  type: "EndInteractionEvent"
};
function vtkInteractorStyleRemoteMouse(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleRemoteMouse");
  function createRemoteEvent(callData) {
    const {
      buttonLeft,
      buttonMiddle,
      buttonRight
    } = model;
    const shiftKey = callData.shiftKey ? 1 : 0;
    const ctrlKey = callData.controlKey ? 1 : 0;
    const altKey = callData.altKey ? 1 : 0;
    const metaKey = callData.metaKey ? 1 : 0;
    const action = buttonLeft || buttonMiddle || buttonRight ? "down" : "up";
    const [width2, height2] = model._interactor.getView().getSizeByReference();
    let {
      x,
      y
    } = callData.position;
    x /= width2;
    y /= height2;
    return {
      action,
      x,
      y,
      buttonLeft,
      buttonMiddle,
      buttonRight,
      shiftKey,
      altKey,
      ctrlKey,
      metaKey,
      ...model.remoteEventAddOn
    };
  }
  publicAPI.handleLeftButtonPress = (callData) => {
    model.previousPosition = callData.position;
    model.buttonLeft = 1;
    publicAPI.onButtonDown(1, callData);
  };
  publicAPI.handleMiddleButtonPress = (callData) => {
    model.previousPosition = callData.position;
    model.buttonMiddle = 1;
    publicAPI.onButtonDown(2, callData);
  };
  publicAPI.handleRightButtonPress = (callData) => {
    model.previousPosition = callData.position;
    model.buttonRight = 1;
    publicAPI.onButtonDown(3, callData);
  };
  publicAPI.handleLeftButtonRelease = (callData) => {
    model.buttonLeft = 0;
    publicAPI.onButtonUp(1, callData);
  };
  publicAPI.handleMiddleButtonRelease = (callData) => {
    model.buttonMiddle = 0;
    publicAPI.onButtonUp(2, callData);
  };
  publicAPI.handleRightButtonRelease = (callData) => {
    model.buttonRight = 0;
    publicAPI.onButtonUp(3, callData);
  };
  publicAPI.onButtonDown = (button, callData) => {
    model._interactor.requestAnimation(publicAPI.onButtonDown);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT2);
    publicAPI.invokeRemoteMouseEvent(createRemoteEvent(callData));
  };
  publicAPI.onButtonUp = (button, callData) => {
    publicAPI.invokeRemoteMouseEvent(createRemoteEvent(callData));
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT2);
    model._interactor.cancelAnimation(publicAPI.onButtonDown);
  };
  publicAPI.handleStartMouseWheel = (callData) => {
    model._interactor.requestAnimation(publicAPI.handleStartMouseWheel);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT2);
    publicAPI.invokeRemoteWheelEvent({
      type: "StartMouseWheel",
      ...createRemoteEvent(callData),
      spinY: callData.spinY
    });
  };
  publicAPI.handleMouseWheel = (callData) => {
    let needToSend = true;
    if (model.wheelThrottleDelay) {
      const ts = Date.now();
      needToSend = model.wheelThrottleDelay < ts - model.wheelLastThrottleTime;
      if (needToSend) {
        model.wheelLastThrottleTime = ts;
      }
    }
    if (needToSend) {
      publicAPI.invokeRemoteWheelEvent({
        type: "MouseWheel",
        ...createRemoteEvent(callData),
        spinY: callData.spinY
      });
      publicAPI.invokeInteractionEvent(INTERACTION_EVENT2);
    }
  };
  publicAPI.handleEndMouseWheel = () => {
    publicAPI.invokeRemoteWheelEvent({
      type: "EndMouseWheel",
      ...model.remoteEventAddOn
    });
    model._interactor.cancelAnimation(publicAPI.handleStartMouseWheel);
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT2);
  };
  publicAPI.handleMouseMove = (callData) => {
    const ts = Date.now();
    const needToSend = model.throttleDelay < ts - model.lastThrottleTime;
    if (needToSend && (model.sendMouseMove || model.buttonLeft || model.buttonMiddle || model.buttonRight)) {
      model.lastThrottleTime = ts;
      publicAPI.invokeRemoteMouseEvent(createRemoteEvent(callData));
    }
    publicAPI.invokeInteractionEvent(INTERACTION_EVENT2);
  };
  publicAPI.handleKeyPress = () => {
  };
  publicAPI.handleStartPinch = (callData) => {
    publicAPI.startDolly();
    const {
      scale
    } = callData;
    model._interactor.requestAnimation(publicAPI.handleStartPinch);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT2);
    publicAPI.invokeRemoteGestureEvent({
      type: "StartPinch",
      scale,
      ...model.remoteEventAddOn
    });
  };
  publicAPI.handlePinch = (callData) => {
    const {
      scale
    } = callData;
    publicAPI.invokeRemoteGestureEvent({
      type: "Pinch",
      scale,
      ...model.remoteEventAddOn
    });
  };
  publicAPI.handleEndPinch = () => {
    publicAPI.endDolly();
    publicAPI.invokeRemoteGestureEvent({
      type: "EndPinch",
      ...model.remoteEventAddOn
    });
    model._interactor.cancelAnimation(publicAPI.handleStartPinch);
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT2);
  };
  publicAPI.handleStartRotate = (callData) => {
    publicAPI.startRotate();
    const {
      rotation
    } = callData;
    model._interactor.requestAnimation(publicAPI.handleStartRotate);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT2);
    publicAPI.invokeRemoteGestureEvent({
      type: "StartRotate",
      rotation,
      ...model.remoteEventAddOn
    });
  };
  publicAPI.handleRotate = (callData) => {
    const {
      rotation
    } = callData;
    publicAPI.invokeRemoteGestureEvent({
      type: "Rotate",
      rotation,
      ...model.remoteEventAddOn
    });
  };
  publicAPI.handleEndRotate = () => {
    publicAPI.endRotate();
    publicAPI.invokeRemoteGestureEvent({
      type: "EndRotate",
      ...model.remoteEventAddOn
    });
    model._interactor.cancelAnimation(publicAPI.handleStartRotate);
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT2);
  };
  publicAPI.handleStartPan = (callData) => {
    publicAPI.startPan();
    const {
      translation
    } = callData;
    model._interactor.requestAnimation(publicAPI.handleStartPan);
    publicAPI.invokeStartInteractionEvent(START_INTERACTION_EVENT2);
    publicAPI.invokeRemoteGestureEvent({
      type: "StartPan",
      translation,
      ...model.remoteEventAddOn
    });
  };
  publicAPI.handlePan = (callData) => {
    const {
      translation
    } = callData;
    publicAPI.invokeRemoteGestureEvent({
      type: "Pan",
      translation,
      ...model.remoteEventAddOn
    });
  };
  publicAPI.handleEndPan = () => {
    publicAPI.endPan();
    publicAPI.invokeRemoteGestureEvent({
      type: "EndPan",
      ...model.remoteEventAddOn
    });
    model._interactor.cancelAnimation(publicAPI.handleStartPan);
    publicAPI.invokeEndInteractionEvent(END_INTERACTION_EVENT2);
  };
}
var DEFAULT_VALUES92 = {
  buttonLeft: 0,
  buttonMiddle: 0,
  buttonRight: 0,
  sendMouseMove: false,
  throttleDelay: 33.3,
  // 33.3 millisecond <=> 30 events/second
  lastThrottleTime: 0,
  wheelThrottleDelay: 0,
  wheelLastThrottleTime: 0
  // remoteEventAddOn: null,
};
function extend102(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES92, initialValues);
  vtkInteractorStyle$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["sendMouseMove", "remoteEventAddOn", "throttleDelay", "wheelThrottleDelay"]);
  macro.event(publicAPI, model, "RemoteMouseEvent");
  macro.event(publicAPI, model, "RemoteWheelEvent");
  macro.event(publicAPI, model, "RemoteGestureEvent");
  vtkInteractorStyleRemoteMouse(publicAPI, model);
}
var newInstance97 = macro.newInstance(extend102, "vtkInteractorStyleRemoteMouse");
var vtkInteractorStyleRemoteMouse$1 = {
  newInstance: newInstance97,
  extend: extend102
};

// node_modules/@kitware/vtk.js/Interaction/Style.js
var Style = {
  vtkInteractorStyleImage: vtkInteractorStyleImage$1,
  vtkInteractorStyleManipulator: vtkInteractorStyleManipulator$1,
  vtkInteractorStyleMPRSlice: vtkInteractorStyleMPRSlice$1,
  vtkInteractorStyleRemoteMouse: vtkInteractorStyleRemoteMouse$1,
  vtkInteractorStyleTrackballCamera: vtkInteractorStyleTrackballCamera$1
};

// node_modules/@kitware/vtk.js/vendor/style-inject/dist/style-inject.es.js
function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style6 = document.createElement("style");
  style6.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style6, head.firstChild);
    } else {
      head.appendChild(style6);
    }
  } else {
    head.appendChild(style6);
  }
  if (style6.styleSheet) {
    style6.styleSheet.cssText = css;
  } else {
    style6.appendChild(document.createTextNode(css));
  }
}

// node_modules/@kitware/vtk.js/Interaction/UI/CornerAnnotation/CornerAnnotation.module.css.js
var css_248z = ".CornerAnnotation-module_container__2mZcn {\n  display: flex;\n  align-items: stretch;\n  justify-content: space-between;\n  flex-direction: column;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  z-index: 100;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.CornerAnnotation-module_row__23t97 {\n  flex: 1;\n  display: flex;\n  justify-content: space-between;\n  flex-direction: row;\n}\n\n.CornerAnnotation-module_topRow__1OP5f {\n  align-items: flex-start;\n}\n\n.CornerAnnotation-module_middleRow__1xYK_ {\n  align-items: center;\n}\n\n.CornerAnnotation-module_bottomRow__1V34_ {\n  align-items: flex-end;\n}\n\n.CornerAnnotation-module_item__BavOy {\n  flex: 1;\n  padding: 5px;\n}\n\n.CornerAnnotation-module_east__xyYFe {\n  text-align: right;\n}\n\n.CornerAnnotation-module_west__3DsS- {\n  text-align: left;\n}\n\n.CornerAnnotation-module_north__2jPzf {\n  text-align: center;\n}\n\n.CornerAnnotation-module_south__FZyGo {\n  text-align: center;\n}\n\n.CornerAnnotation-module_northEast__-GjXi {\n}\n\n.CornerAnnotation-module_northWest__23pUR {\n}\n\n.CornerAnnotation-module_southEast__tmLmN {\n}\n\n.CornerAnnotation-module_southWest__FLNPM {\n}\n\n";
var style = { "container": "CornerAnnotation-module_container__2mZcn", "row": "CornerAnnotation-module_row__23t97", "topRow": "CornerAnnotation-module_topRow__1OP5f CornerAnnotation-module_row__23t97", "middleRow": "CornerAnnotation-module_middleRow__1xYK_ CornerAnnotation-module_row__23t97", "bottomRow": "CornerAnnotation-module_bottomRow__1V34_ CornerAnnotation-module_row__23t97", "item": "CornerAnnotation-module_item__BavOy", "east": "CornerAnnotation-module_east__xyYFe CornerAnnotation-module_item__BavOy", "west": "CornerAnnotation-module_west__3DsS- CornerAnnotation-module_item__BavOy", "north": "CornerAnnotation-module_north__2jPzf CornerAnnotation-module_item__BavOy", "south": "CornerAnnotation-module_south__FZyGo CornerAnnotation-module_item__BavOy", "northEast": "CornerAnnotation-module_northEast__-GjXi CornerAnnotation-module_east__xyYFe CornerAnnotation-module_item__BavOy", "northWest": "CornerAnnotation-module_northWest__23pUR CornerAnnotation-module_west__3DsS- CornerAnnotation-module_item__BavOy", "southEast": "CornerAnnotation-module_southEast__tmLmN CornerAnnotation-module_east__xyYFe CornerAnnotation-module_item__BavOy", "southWest": "CornerAnnotation-module_southWest__FLNPM CornerAnnotation-module_west__3DsS- CornerAnnotation-module_item__BavOy" };
styleInject(css_248z);

// node_modules/@kitware/vtk.js/Interaction/UI/CornerAnnotation.js
function noOp() {
}
var KEY_MAPPING = {
  nw: "northWestContainer",
  n: "northContainer",
  ne: "northEastContainer",
  w: "westContainer",
  e: "eastContainer",
  sw: "southWestContainer",
  s: "southContainer",
  se: "southEastContainer"
};
function get2(path, obj2) {
  let fb = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : `\${${path}}`;
  return path.split(".").reduce((res, key) => res[key] !== void 0 ? res[key] : fb, obj2);
}
function applyTemplate(template, map, fallback) {
  return template.replace(/\${([^{]+)}/g, (match) => {
    const path = match.substr(2, match.length - 3).trim();
    return get2(path, map, fallback);
  });
}
function vtkCornerAnnotation(publicAPI, model) {
  model.classHierarchy.push("vtkCornerAnnotation");
  if (!model.templates) {
    model.templates = {};
  }
  if (!model.metadata) {
    model.metadata = {};
  }
  model.annotationContainer = document.createElement("div");
  model.annotationContainer.setAttribute("class", style.container);
  model.annotationContainer.innerHTML = `
    <div class="${style.topRow}">
      <div class="js-nw ${style.northWest}"></div>
      <div class="js-n ${style.north}"></div>
      <div class="js-ne ${style.northEast}"></div>
    </div>
    <div class="${style.middleRow}">
      <div class="js-w ${style.west}"></div>
      <div class="js-e ${style.east}"></div>
    </div>
    <div class="${style.bottomRow}">
      <div class="js-sw ${style.southWest}"></div>
      <div class="js-s ${style.south}"></div>
      <div class="js-se ${style.southEast}"></div>
    </div>`;
  model.northWestContainer = model.annotationContainer.querySelector(".js-nw");
  model.northContainer = model.annotationContainer.querySelector(".js-n");
  model.northEastContainer = model.annotationContainer.querySelector(".js-ne");
  model.westContainer = model.annotationContainer.querySelector(".js-w");
  model.eastContainer = model.annotationContainer.querySelector(".js-e");
  model.southWestContainer = model.annotationContainer.querySelector(".js-sw");
  model.southContainer = model.annotationContainer.querySelector(".js-s");
  model.southEastContainer = model.annotationContainer.querySelector(".js-se");
  function updateAnnotations() {
    const keys = Object.keys(model.templates);
    let count = keys.length;
    while (count--) {
      const el = model[KEY_MAPPING[keys[count]]];
      const fn = model.templates[keys[count]];
      if (el && fn) {
        el.innerHTML = fn(model.metadata);
      }
    }
  }
  publicAPI.setContainer = (el) => {
    if (model.container && model.container !== el) {
      model.container.removeChild(model.annotationContainer);
    }
    if (model.container !== el) {
      model.container = el;
      if (model.container) {
        model.container.appendChild(model.annotationContainer);
        publicAPI.resize();
      }
      publicAPI.modified();
    }
  };
  publicAPI.resize = noOp;
  publicAPI.updateTemplates = (templates) => {
    model.templates = Object.assign(model.templates, templates);
    updateAnnotations();
    publicAPI.modified();
  };
  publicAPI.updateMetadata = (metadata) => {
    model.metadata = Object.assign(model.metadata, metadata);
    updateAnnotations();
    publicAPI.modified();
  };
}
var DEFAULT_VALUES93 = {
  templates: null,
  metadata: null
};
function extend103(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES93, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["annotationContainer", "northWestContainer", "northContainer", "northEastContainer", "westContainer", "eastContainer", "southWestContainer", "southContainer", "southEastContainer", "metadata"]);
  vtkCornerAnnotation(publicAPI, model);
}
var newInstance98 = macro.newInstance(extend103, "vtkCornerAnnotation");
var vtkCornerAnnotation$1 = {
  newInstance: newInstance98,
  extend: extend103,
  applyTemplate
};

// node_modules/@kitware/vtk.js/Interaction/UI/FPSMonitor/FPSMonitor.module.css.js
var css_248z2 = ".FPSMonitor-module_verticalContainer__1oES5 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n\n.FPSMonitor-module_horizontalContainer__3dO_q {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n\n.FPSMonitor-module_leftPane__3PHsp {\n  flex: none;\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n\n.FPSMonitor-module_rightPane__30Een {\n  flex: 1;\n  display: grid;\n  grid-template-columns: auto auto;\n  grid-auto-rows: 1.5em;\n  grid-column-gap: 5px;\n  grid-row-gap: 2px;\n  padding: 10px;\n}\n\n.FPSMonitor-module_title__3a5vQ {\n  flex: 1;\n  font-weight: bold;\n  padding: 5px 10px 0 10px;\n}\n\n.FPSMonitor-module_graph__lvtIQ {\n  flex: none;\n  border: solid 1px black;\n  margin: 10px ;\n  border-radius: 2px;\n  overflow: hidden;\n}\n\n.FPSMonitor-module_label__3saqc {\n  font-weight: bold;\n  text-transform: capitalize;\n  text-align: right;\n  align-self: center;\n}\n\n.FPSMonitor-module_value__2WrfF {\n  font-style: italic;\n  text-align: center;\n  align-self: center;\n}\n";
var style2 = { "verticalContainer": "FPSMonitor-module_verticalContainer__1oES5", "horizontalContainer": "FPSMonitor-module_horizontalContainer__3dO_q", "leftPane": "FPSMonitor-module_leftPane__3PHsp", "rightPane": "FPSMonitor-module_rightPane__30Een", "title": "FPSMonitor-module_title__3a5vQ", "graph": "FPSMonitor-module_graph__lvtIQ", "label": "FPSMonitor-module_label__3saqc", "value": "FPSMonitor-module_value__2WrfF" };
styleInject(css_248z2);

// node_modules/@kitware/vtk.js/Interaction/UI/FPSMonitor.js
var noOp2 = Function.prototype;
function formatNumbers(n) {
  const sections = [];
  let size = n;
  while (size > 1e3) {
    sections.push(`000${size % 1e3}`.slice(-3));
    size = Math.floor(size / 1e3);
  }
  if (size > 0) {
    sections.push(size);
  }
  sections.reverse();
  return sections.join("'");
}
function vtkFPSMonitor(publicAPI, model) {
  model.classHierarchy.push("vtkFPSMonitor");
  model.fpsMonitorContainer = document.createElement("div");
  model.fpsMonitorContainer.setAttribute("class", model.orientationClass);
  model.fpsMonitorContainer.innerHTML = `
    <div class="${style2.leftPane}">
      <div class="js-title ${style2.title}">Mean N/A - Current N/A</div>
      <canvas class="js-graph ${style2.graph}"></canvas>
    </div>
    <div class="js-info ${style2.rightPane}">
    </div>`;
  model.canvas = model.fpsMonitorContainer.querySelector(".js-graph");
  model.title = model.fpsMonitorContainer.querySelector(".js-title");
  model.info = model.fpsMonitorContainer.querySelector(".js-info");
  function renderTitle() {
    model.title.style.display = model.titleVisibility ? "block" : "none";
    if (!model.titleVisibility) {
      return;
    }
    const nextFPS = model.buffer[model.buffer.length - 1];
    const newTxt = `Mean: ${Math.round(model.fpsSum / model.buffer.length)} - Current: ${Math.round(nextFPS)}`;
    if (newTxt !== model.lastText) {
      model.lastText = newTxt;
      model.title.innerHTML = newTxt;
    }
  }
  function renderInfo() {
    model.info.style.display = model.infoVisibility ? "grid" : "none";
    if (!model.infoVisibility) {
      return;
    }
    const infoItems = [];
    if (model.renderWindow) {
      const realView = model.renderWindow.getViews()[0];
      if (realView && realView.getSize) {
        infoItems.push(`<label class="${style2.label}">Resolution</label><span class="${style2.value}">${realView.getSize().join("x")}</span>`);
      }
      const stats = {
        ...model.renderWindow.getStatistics(),
        ...model.addOnStats
      };
      const keys = Object.keys(stats);
      keys.sort();
      for (let i = 0; i < keys.length; i++) {
        if (keys[i] === "str") {
          continue;
        }
        if (stats[keys[i]]) {
          infoItems.push(`<label class="${style2.label}">${keys[i]}</label><span class="${style2.value}">${formatNumbers(stats[keys[i]])}</span>`);
        }
      }
    }
    model.info.innerHTML = infoItems.join("");
  }
  function renderCanvas() {
    model.canvas.style.display = model.canvasVisibility ? "block" : "none";
    if (!model.canvasVisibility) {
      return;
    }
    model.canvas.setAttribute("width", model.bufferSize);
    model.canvas.setAttribute("height", model.graphHeight);
    const ctx = model.canvas.getContext("2d");
    const {
      width: width2,
      height: height2
    } = model.canvas;
    ctx.clearRect(0, 0, width2, height2);
    ctx.strokeStyle = "green";
    ctx.beginPath();
    ctx.moveTo(0, height2 - model.buffer[0]);
    for (let i = 1; i < model.buffer.length; i++) {
      ctx.lineTo(i, height2 - model.buffer[i]);
    }
    ctx.stroke();
    ctx.strokeStyle = "black";
    ctx.beginPath();
    ctx.moveTo(0, height2 - 60);
    ctx.lineTo(width2, height2 - 60);
    ctx.stroke();
  }
  function frameChanged() {
    if (!model.interactor) {
      return;
    }
    const nextFPS = 1 / model.interactor.getLastFrameTime();
    model.buffer.push(nextFPS);
    model.fpsSum += nextFPS;
    while (model.buffer.length > model.bufferSize) {
      model.fpsSum -= model.buffer.shift();
    }
    renderTitle();
    renderInfo();
    renderCanvas();
  }
  publicAPI.update = () => {
    publicAPI.render();
  };
  publicAPI.setRenderWindow = (rw) => {
    while (model.subscriptions.length) {
      model.subscriptions.pop().unsubscribe();
    }
    model.renderWindow = rw;
    model.interactor = rw ? rw.getInteractor() : null;
    if (model.interactor) {
      model.subscriptions.push(model.interactor.onAnimation(frameChanged));
    }
  };
  publicAPI.setContainer = (el) => {
    if (model.container && model.container !== el) {
      model.container.removeChild(model.fpsMonitorContainer);
    }
    if (model.container !== el) {
      model.container = el;
      if (model.container) {
        model.container.appendChild(model.fpsMonitorContainer);
        publicAPI.resize();
      }
      publicAPI.modified();
    }
  };
  publicAPI.render = () => {
    renderTitle();
    renderInfo();
    renderCanvas();
  };
  publicAPI.resize = noOp2;
  publicAPI.setOrientationToHorizontal = () => {
    model.fpsMonitorContainer.classList.remove(model.orientationClass);
    model.orientationClass = style2.horizontalContainer;
    model.fpsMonitorContainer.classList.add(model.orientationClass);
  };
  publicAPI.setOrientationToVertical = () => {
    model.fpsMonitorContainer.classList.remove(model.orientationClass);
    model.orientationClass = style2.verticalContainer;
    model.fpsMonitorContainer.classList.add(model.orientationClass);
  };
  publicAPI.setOrientation = function() {
    let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "horizontal";
    if (mode === "horizontal") {
      publicAPI.setOrientationToHorizontal();
    } else {
      publicAPI.setOrientationToVertical();
    }
  };
  publicAPI.setAddOnStats = (addOn) => {
    if (!model.addOnStats) {
      model.addOnStats = {};
    }
    Object.assign(model.addOnStats, addOn);
    renderInfo();
  };
  publicAPI.setMonitorVisibility = function() {
    let title = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    let graph = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let info = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    publicAPI.setCanvasVisibility(graph);
    publicAPI.setInfoVisibility(info);
    publicAPI.setTitleVisibility(title);
  };
  const superDelete = publicAPI.delete;
  publicAPI.delete = () => {
    publicAPI.setRenderWindow(null);
    publicAPI.setContainer(null);
    superDelete();
  };
  model.subscriptions.push(publicAPI.onModified(publicAPI.update));
}
var DEFAULT_VALUES94 = {
  bufferSize: 200,
  graphHeight: 120,
  buffer: [60],
  subscriptions: [],
  fpsSum: 0,
  orientationClass: style2.horizontalContainer,
  canvasVisibility: true,
  titleVisibility: true,
  infoVisibility: true
};
function extend104(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES94, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["fpsMonitorContainer", "renderWindow", "addOnStats"]);
  macro.setGet(publicAPI, model, ["bufferSize", "canvasVisibility", "infoVisibility", "titleVisibility"]);
  vtkFPSMonitor(publicAPI, model);
}
var newInstance99 = macro.newInstance(extend104, "vtkFPSMonitor");
var vtkFPSMonitor$1 = {
  newInstance: newInstance99,
  extend: extend104
};

// node_modules/@kitware/vtk.js/Interaction/UI/Icons/Contrast.svg.js
var svgEdge = '<svg viewBox="0 0 180 180" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient x1="100%" y1="50%" x2="0%" y2="50%" id="a"><stop stop-color="#FFF" offset="0%"/><stop stop-color="#FFF" offset="49.416%"/><stop offset="49.677%"/><stop offset="100%"/></linearGradient></defs><circle cx="90" cy="90" r="80" stroke-width="10" stroke="#000" fill="url(#a)" fill-rule="evenodd"/></svg>';

// node_modules/@kitware/vtk.js/Interaction/UI/Icons/Logo.svg.js
var svgLogo = '<svg viewBox="0 0 196 196" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M67.77 157.024a86.095 86.095 0 0 1-2.3 9.306c-.977 3.206-2.44 6.116-4.392 8.73-1.952 2.614-4.531 4.758-7.738 6.43-3.206 1.674-7.284 2.51-12.233 2.51-6.343 0-11.501-1.55-15.474-4.653-3.974-3.102-6.518-7.301-7.633-12.599l16.102-5.228c.279 1.882 1.01 3.485 2.196 4.81 1.185 1.324 2.753 1.986 4.705 1.986 3.067 0 5.262-1.08 6.587-3.24 1.324-2.162 2.265-4.88 2.823-8.156l8.574-48.933h17.565l-8.783 49.037Zm58.029-31.053c-1.394-1.883-3.137-3.311-5.228-4.287-2.091-.976-4.426-1.464-7.005-1.464-1.185 0-2.44.157-3.764.47a10.815 10.815 0 0 0-3.608 1.569 9.806 9.806 0 0 0-2.718 2.77c-.732 1.116-1.098 2.475-1.098 4.078 0 2.091.819 3.747 2.457 4.967 1.638 1.22 3.921 2.352 6.849 3.398 3.206 1.115 6.064 2.352 8.573 3.712 2.51 1.359 4.636 2.91 6.378 4.652 1.743 1.743 3.067 3.712 3.974 5.908.906 2.196 1.359 4.688 1.359 7.476 0 4.461-.924 8.26-2.77 11.397-1.848 3.136-4.236 5.698-7.163 7.685-2.928 1.986-6.204 3.433-9.829 4.339-3.624.906-7.214 1.359-10.769 1.359-2.649 0-5.298-.244-7.946-.732a42.608 42.608 0 0 1-7.633-2.143 31.681 31.681 0 0 1-6.796-3.608c-2.092-1.463-3.869-3.136-5.333-5.018l12.86-10.456c1.465 2.23 3.625 4.043 6.483 5.437 2.858 1.394 5.751 2.091 8.679 2.091 1.533 0 3.014-.157 4.443-.47 1.43-.314 2.701-.837 3.817-1.569a8.267 8.267 0 0 0 2.666-2.823c.662-1.15.993-2.527.993-4.13 0-2.579-1.045-4.618-3.136-6.117-2.092-1.498-4.88-2.84-8.365-4.025a58.492 58.492 0 0 1-6.849-2.823c-2.126-1.046-3.973-2.335-5.541-3.869-1.569-1.533-2.823-3.363-3.764-5.489-.941-2.126-1.412-4.688-1.412-7.685 0-3.764.784-7.162 2.353-10.194a23.324 23.324 0 0 1 6.43-7.738c2.719-2.126 5.89-3.764 9.515-4.914 3.624-1.15 7.493-1.725 11.606-1.725 2.16 0 4.356.21 6.587.627a35.853 35.853 0 0 1 6.43 1.83 28.502 28.502 0 0 1 5.699 2.98c1.742 1.185 3.206 2.544 4.39 4.078L125.8 125.97Z" fill="#8A8B8A"/><rect fill="#1C4678" transform="rotate(45 169.749 159.749)" x="152.249" y="142.249" width="35" height="35" rx="17.5"/><path fill="#1C4678" d="m7.775 11 20.483 86.069h22.53l34.24-71.408H63.841L42.91 70.03 28.259 11zM88.663 25.344h50.476l-8.093 16.562-17.246-.049-9.652 54.62H85.609l9.572-54.535H80.99zM141.366 25.344l16.072.066-4.414 24.987h2.388l16.856-25.053h20.975l-22.442 33.403 13.203 54.063h-20.94l-10.652-44.43h-2.296l-5.125 28.135h-21.024l9.763-55.043z"/><path fill="#8A8B8A" d="M3 11h3.182l20.864 85.944h-3.187zM58.102 25.344h2.788L43.747 61.155l-.955-3.866zM88.608 44.469h2.883l-9.157 52.096H79.4zM126.785 44.469h2.924l-9.186 52.046H117.6zM166.38 25.344h3.594l-12.582 18.854 1.316-7.545zM150.902 74.75l8.917 37.613h-3.311l-7.075-29.073z"/></g></svg>';

// node_modules/@kitware/vtk.js/Interaction/UI/Icons/Spacing.svg.js
var svgSpacing = '<svg viewBox="0 0 180 180" xmlns="http://www.w3.org/2000/svg"><g stroke="#000" stroke-width="10" fill="none" fill-rule="evenodd" stroke-linecap="square"><path d="M10 90h160M10 133.488V47M170 133.488V47M90 133.488V47"/></g></svg>';

// node_modules/@kitware/vtk.js/Interaction/UI/Icons/Tint.svg.js
var Tint = '<svg viewBox="0 0 180 180" xmlns="http://www.w3.org/2000/svg"><path d="M90 24c20 29.485 45 58.5 45 86s-17.5 46.485-45 46.485S45 137.5 45 110s25-56.515 45-86Z" stroke="#000" stroke-width="10" fill="#000" fill-rule="evenodd"/></svg>';

// node_modules/@kitware/vtk.js/Interaction/UI/Icons.js
var vtkIcons = {
  Contrast: svgEdge,
  Logo: svgLogo,
  Spacing: svgSpacing,
  Tint
};

// node_modules/@kitware/vtk.js/Interaction/UI/Slider/Constants.js
var SliderOrientation = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
var Constants9 = {
  SliderOrientation
};

// node_modules/@kitware/vtk.js/Interaction/UI/Slider/Slider.module.css.js
var css_248z3 = ".Slider-module_cursor__1JXd9 {\n  position: absolute;\n  border-radius: 50%;\n  box-sizing: border-box;\n  cursor: move;\n}\n";
var style3 = { "cursor": "Slider-module_cursor__1JXd9" };
styleInject(css_248z3);

// node_modules/@kitware/vtk.js/Interaction/UI/Slider.js
function findClosestValue(value, values) {
  let distance = Number.MAX_VALUE;
  let index = -1;
  let count = values.length;
  while (count--) {
    const dist = Math.abs(values[count] - value);
    if (dist < distance) {
      distance = dist;
      index = count;
    }
  }
  return index !== -1 ? values[index] : void 0;
}
function vtkSlider(publicAPI, model) {
  model.classHierarchy.push("vtkSlider");
  model.el = document.createElement("div");
  model.el.setAttribute("class", style3.cursor);
  function getDisplacementRatio() {
    return (model.containerSizes[1] - model.containerSizes[0]) * (model.value - model.values[0]) / (model.values[model.values.length - 1] - model.values[0]);
  }
  function updateCursorPosition() {
    if (!model.container) {
      return;
    }
    const cursorSize = model.containerSizes[0];
    const position = getDisplacementRatio();
    if (Number.isNaN(position) || Number.isNaN(cursorSize)) {
      return;
    }
    model.el.style.width = `${cursorSize}px`;
    model.el.style.height = `${cursorSize}px`;
    if (model.orientation === Constants9.SliderOrientation.VERTICAL) {
      model.el.style.left = "0";
      model.el.style.top = `${position}px`;
      model.el.style.cursor = "row-resize";
    } else {
      model.el.style.top = "0";
      model.el.style.left = `${position}px`;
      model.el.style.cursor = "col-resize";
    }
  }
  let isDragging = false;
  let offset = 0;
  let ratio = 0;
  function handleDragEvents(enable) {
    const rootElm = document.querySelector("body");
    const method = enable ? "addEventListener" : "removeEventListener";
    rootElm[method]("mousemove", onMouseMove);
    rootElm[method]("mouseleave", onMouseOut);
    rootElm[method]("mouseup", onMouseUp);
  }
  function onMouseMove(e2) {
    e2.preventDefault();
    if (isDragging) {
      const newRatio = ratio + ((model.orientation ? e2.clientX : e2.clientY) - offset) / (model.containerSizes[1] - model.containerSizes[0]);
      const value = newRatio * model.range + model.values[0];
      const newValue = findClosestValue(value, model.values);
      if (newValue !== void 0) {
        publicAPI.setValue(newValue);
      }
    }
  }
  function onMouseOut(e2) {
    isDragging = false;
  }
  function onMouseUp(e2) {
    handleDragEvents(false);
    if (!isDragging) {
      const isClick = !((model.orientation ? e2.clientX : e2.clientY) - offset);
      if (isClick) {
        const absValue = model.values[0] + model.range * (offset - model.container.getBoundingClientRect()[model.orientation ? "left" : "top"] - 0.5 * model.containerSizes[0]) / (model.containerSizes[1] - model.containerSizes[0]);
        const newValue = findClosestValue(absValue, model.values);
        if (newValue !== void 0) {
          publicAPI.setValue(newValue);
        }
      }
    }
    isDragging = false;
  }
  function onMouseDown(e2) {
    handleDragEvents(true);
    e2.preventDefault();
    isDragging = e2.target === model.el;
    offset = model.orientation ? e2.clientX : e2.clientY;
    ratio = (model.value - model.values[0]) / model.range;
  }
  function bindEvents() {
    model.container.addEventListener("mousedown", onMouseDown);
  }
  function unbindEvents() {
    handleDragEvents(false);
    model.container.removeEventListener("mousedown", onMouseDown);
  }
  publicAPI.setContainer = (el) => {
    if (model.container && model.container !== el) {
      model.container.removeChild(model.el);
      unbindEvents();
    }
    if (model.container !== el) {
      model.container = el;
      if (model.container) {
        model.container.appendChild(model.el);
        publicAPI.resize();
        bindEvents();
      }
      publicAPI.modified();
    }
  };
  publicAPI.resize = () => {
    if (model.container) {
      const dims = model.container.getBoundingClientRect();
      const width2 = Math.floor(dims.width);
      const height2 = Math.floor(dims.height);
      const min = Math.min(width2, height2);
      const max2 = Math.max(width2, height2);
      publicAPI.setOrientation(height2 === max2 ? Constants9.SliderOrientation.VERTICAL : Constants9.SliderOrientation.HORIZONTAL);
      model.containerSizes = [min, max2];
      updateCursorPosition();
    }
  };
  publicAPI.setValue = (v) => {
    if (model.value !== v && model.values[0] <= v && v <= model.values.slice(-1)[0]) {
      model.value = v;
      updateCursorPosition();
      publicAPI.modified();
      publicAPI.invokeValueChange(v);
      return true;
    }
    return false;
  };
  publicAPI.setValues = (values) => {
    if (model.values !== values) {
      model.values = values;
      model.range = values[values.length - 1] - values[0];
      updateCursorPosition();
      publicAPI.modified();
    }
  };
  publicAPI.generateValues = (min, max2, nbSteps) => {
    const step = (max2 - min) / (nbSteps - 1);
    model.values = [];
    for (let i = 0; i < nbSteps; i++) {
      model.values.push(min + i * step);
    }
    model.range = max2 - min;
    updateCursorPosition();
    publicAPI.modified();
  };
  publicAPI.updateCursorStyle = (cursorStyle) => {
    model.cursorStyle = {
      ...model.cursorStyle,
      ...cursorStyle
    };
    const keys = Object.keys(model.cursorStyle);
    let count = keys.length;
    while (count--) {
      model.el.style[keys[count]] = model.cursorStyle[keys[count]];
    }
  };
  publicAPI.updateCursorStyle();
}
var DEFAULT_VALUES95 = {
  orientation: Constants9.SliderOrientation.VERTICAL,
  value: 0.5,
  values: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],
  range: 1,
  containerSizes: [10, 100],
  cursorStyle: {
    border: "solid 4px #aaa",
    backgroundColor: "#ccc",
    transform: "scale(0.7)"
  }
};
function extend105(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES95, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["orientation", "value", "values"]);
  macro.set(publicAPI, model, ["orientation"]);
  macro.event(publicAPI, model, "ValueChange");
  vtkSlider(publicAPI, model);
}
var newInstance100 = macro.newInstance(extend105, "vtkSlider");
var vtkSlider$1 = {
  newInstance: newInstance100,
  extend: extend105,
  ...Constants9
};

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/LiteColorMaps.json.js
var vtkColorMaps = [
  {
    ColorSpace: "Diverging",
    Name: "Cool to Warm",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.23137254902,
      0.298039215686,
      0.752941176471,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.705882352941,
      0.0156862745098,
      0.149019607843
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Warm to Cool",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.705882352941,
      0.0156862745098,
      0.149019607843,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.23137254902,
      0.298039215686,
      0.752941176471
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Desaturated",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.278431372549,
      0.278431372549,
      0.858823529412,
      0.143,
      0,
      0,
      0.360784313725,
      0.285,
      0,
      1,
      1,
      0.429,
      0,
      0.501960784314,
      0,
      0.571,
      1,
      1,
      0,
      0.714,
      1,
      0.380392156863,
      0,
      0.857,
      0.419607843137,
      0,
      0,
      1,
      0.878431372549,
      0.301960784314,
      0.301960784314
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Cold and Hot",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      1,
      1,
      0.45,
      0,
      0,
      1,
      0.5,
      0,
      0,
      0.501960784314,
      0.55,
      1,
      0,
      0,
      1,
      1,
      1,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black-Body Radiation",
    NanColor: [
      0,
      0.498039215686,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.4,
      0.901960784314,
      0,
      0,
      0.8,
      0.901960784314,
      0.901960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "X Ray",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Grayscale",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Blue and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0,
      0,
      0.501960784314,
      0.666,
      0,
      0.501960784314,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Orange and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0.501960784314,
      0,
      0,
      0.666,
      1,
      0.501960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_bright",
    RGBPoints: [
      -1,
      0.32549,
      0.14902,
      0.960784,
      -0.866221,
      0.297047,
      0.375586,
      0.963836,
      -0.732441,
      0.180302,
      0.536818,
      0.964627,
      -0.598662,
      0.1302,
      0.649207,
      0.929647,
      -0.464883,
      0.0445143,
      0.749654,
      0.855998,
      -0.331104,
      0.0271325,
      0.830713,
      0.721527,
      -0.197324,
      0.259504,
      0.866145,
      0.543555,
      -0.0635452,
      0.428364,
      0.890725,
      0.329819,
      0.0702341,
      0.568503,
      0.898508,
      0.187623,
      0.204013,
      0.738259,
      0.890317,
      0.0825461,
      0.337793,
      0.84546,
      0.86136,
      0.0147555,
      0.471572,
      0.912191,
      0.808018,
      0,
      0.605351,
      0.962848,
      0.710445,
      0,
      0.73913,
      0.999469,
      0.600258,
      0.0176284,
      0.87291,
      0.994156,
      0.445975,
      0.193912,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_dark",
    RGBPoints: [
      -1,
      0,
      0,
      0.423499,
      -0.866221,
      0,
      0.119346,
      0.529237,
      -0.732441,
      0,
      0.238691,
      0.634976,
      -0.598662,
      0,
      0.346852,
      0.68788,
      -0.464883,
      0,
      0.45022,
      0.718141,
      -0.331104,
      0,
      0.553554,
      0.664839,
      -0.197324,
      0,
      0.651082,
      0.519303,
      -0.0635452,
      0.115841,
      0.72479,
      0.352857,
      0.0702341,
      0.326771,
      0.781195,
      0.140187,
      0.204013,
      0.522765,
      0.798524,
      0.0284624,
      0.337793,
      0.703162,
      0.788685,
      885756e-8,
      0.471572,
      0.845118,
      0.751133,
      0,
      0.605351,
      0.955734,
      0.690825,
      0,
      0.73913,
      0.995402,
      0.567916,
      0.0618524,
      0.87291,
      0.987712,
      0.403398,
      0.164851,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  }
];

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMapsLite.js
var presetMap = /* @__PURE__ */ Object.create(null);
vtkColorMaps.filter((p) => p.RGBPoints).filter((p) => p.ColorSpace !== "CIELAB").forEach((p) => {
  presetMap[p.Name] = p;
});
var rgbPresetNames = Object.keys(presetMap);
rgbPresetNames.sort();
function getPresetByName(name2) {
  return presetMap[name2];
}
function addPreset(preset) {
  if (!preset.RGBPoints || preset.ColorSpace === "CIELAB") {
    return;
  }
  if (!presetMap[preset.Name]) {
    rgbPresetNames.push(preset.Name);
    rgbPresetNames.sort();
  }
  presetMap[preset.Name] = preset;
}
function removePresetByName(name2) {
  const index = rgbPresetNames.indexOf(name2);
  if (index > -1) {
    rgbPresetNames.splice(index, 1);
  }
  delete presetMap[name2];
}
var vtkColorMaps2 = {
  addPreset,
  removePresetByName,
  getPresetByName,
  rgbPresetNames
};

// node_modules/@kitware/vtk.js/Interaction/Widgets/PiecewiseGaussianWidget.js
var import_webworker_promise2 = __toESM(require_src(), 1);

// node_modules/@kitware/vtk.js/_virtual/rollup-plugin-worker-loader__module_Sources/Interaction/Widgets/PiecewiseGaussianWidget/ComputeHistogram.worker.js
var WorkerFactory2 = createInlineWorkerFactory(
  /* rollup-plugin-web-worker-loader */
  function() {
    (function() {
      "__worker_loader_strict__";
      var register = { exports: {} };
      var _createClass$1 = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck$1(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var TinyEmitter$1 = function() {
        function TinyEmitter2() {
          _classCallCheck$1(this, TinyEmitter2);
          Object.defineProperty(this, "__listeners", {
            value: {},
            enumerable: false,
            writable: false
          });
        }
        _createClass$1(TinyEmitter2, [{
          key: "emit",
          value: function emit(eventName) {
            if (!this.__listeners[eventName]) return this;
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.__listeners[eventName][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var handler = _step.value;
                handler.apply(void 0, args);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return this;
          }
        }, {
          key: "once",
          value: function once(eventName, handler) {
            var _this = this;
            var once2 = function once3() {
              _this.off(eventName, once3);
              handler.apply(void 0, arguments);
            };
            return this.on(eventName, once2);
          }
        }, {
          key: "on",
          value: function on(eventName, handler) {
            if (!this.__listeners[eventName]) this.__listeners[eventName] = [];
            this.__listeners[eventName].push(handler);
            return this;
          }
        }, {
          key: "off",
          value: function off(eventName, handler) {
            if (handler) this.__listeners[eventName] = this.__listeners[eventName].filter(function(h) {
              return h !== handler;
            });
            else this.__listeners[eventName] = [];
            return this;
          }
        }]);
        return TinyEmitter2;
      }();
      var tinyEmitter = TinyEmitter$1;
      var _createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var _get = function get3(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === void 0) {
          var parent = Object.getPrototypeOf(object);
          if (parent === null) {
            return void 0;
          } else {
            return get3(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === void 0) {
            return void 0;
          }
          return getter.call(receiver);
        }
      };
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      function _defineProperty(obj2, key, value) {
        if (key in obj2) {
          Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj2[key] = value;
        }
        return obj2;
      }
      var TinyEmitter = tinyEmitter;
      var MESSAGE_RESULT = 0;
      var MESSAGE_EVENT = 1;
      var RESULT_ERROR = 0;
      var RESULT_SUCCESS = 1;
      var DEFAULT_HANDLER = "main";
      var isPromise = function isPromise2(o) {
        return (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && o !== null && typeof o.then === "function" && typeof o.catch === "function";
      };
      function RegisterPromise(fn) {
        var handlers = _defineProperty({}, DEFAULT_HANDLER, fn);
        var sendPostMessage = self.postMessage.bind(self);
        var server = new (function(_TinyEmitter) {
          _inherits(WorkerRegister, _TinyEmitter);
          function WorkerRegister() {
            _classCallCheck(this, WorkerRegister);
            return _possibleConstructorReturn(this, (WorkerRegister.__proto__ || Object.getPrototypeOf(WorkerRegister)).apply(this, arguments));
          }
          _createClass(WorkerRegister, [{
            key: "emit",
            value: function emit(eventName) {
              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (args.length == 1 && args[0] instanceof TransferableResponse) {
                sendPostMessage({ eventName, args }, args[0].transferable);
              } else {
                sendPostMessage({ eventName, args });
              }
              return this;
            }
          }, {
            key: "emitLocally",
            value: function emitLocally(eventName) {
              var _get2;
              for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              (_get2 = _get(WorkerRegister.prototype.__proto__ || Object.getPrototypeOf(WorkerRegister.prototype), "emit", this)).call.apply(_get2, [this, eventName].concat(args));
            }
          }, {
            key: "operation",
            value: function operation(name2, handler) {
              handlers[name2] = handler;
              return this;
            }
          }]);
          return WorkerRegister;
        }(TinyEmitter))();
        var run = function run2(messageId, payload, handlerName) {
          var onSuccess = function onSuccess2(result2) {
            if (result2 && result2 instanceof TransferableResponse) {
              sendResult(messageId, RESULT_SUCCESS, result2.payload, result2.transferable);
            } else {
              sendResult(messageId, RESULT_SUCCESS, result2);
            }
          };
          var onError = function onError2(e2) {
            sendResult(messageId, RESULT_ERROR, {
              message: e2.message,
              stack: e2.stack
            });
          };
          try {
            var result = runFn(messageId, payload, handlerName);
            if (isPromise(result)) {
              result.then(onSuccess).catch(onError);
            } else {
              onSuccess(result);
            }
          } catch (e2) {
            onError(e2);
          }
        };
        var runFn = function runFn2(messageId, payload, handlerName) {
          var handler = handlers[handlerName || DEFAULT_HANDLER];
          if (!handler) throw new Error("Not found handler for this request");
          return handler(payload, sendEvent.bind(null, messageId));
        };
        var sendResult = function sendResult2(messageId, success, payload) {
          var transferable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
          sendPostMessage([MESSAGE_RESULT, messageId, success, payload], transferable);
        };
        var sendEvent = function sendEvent2(messageId, eventName, payload) {
          if (!eventName) throw new Error("eventName is required");
          if (typeof eventName !== "string") throw new Error("eventName should be string");
          sendPostMessage([MESSAGE_EVENT, messageId, eventName, payload]);
        };
        self.addEventListener("message", function(_ref) {
          var data2 = _ref.data;
          if (Array.isArray(data2)) {
            run.apply(void 0, _toConsumableArray(data2));
          } else if (data2 && data2.eventName) {
            server.emitLocally.apply(server, [data2.eventName].concat(_toConsumableArray(data2.args)));
          }
        });
        return server;
      }
      var TransferableResponse = function TransferableResponse2(payload, transferable) {
        _classCallCheck(this, TransferableResponse2);
        this.payload = payload;
        this.transferable = transferable;
      };
      register.exports = RegisterPromise;
      register.exports.TransferableResponse = TransferableResponse;
      var registerWebworker = register.exports;
      registerWebworker(function(message, emit) {
        var array = message.array;
        var min = message.min;
        var max2 = message.max;
        var offset = message.component || 0;
        var step = message.numberOfComponents || 1;
        var numberOfBins = message.numberOfBins;
        var delta = max2 - min;
        var histogram = new Float32Array(numberOfBins);
        histogram.fill(0);
        var len = array.length;
        for (var i = offset; i < len; i += step) {
          var idx = Math.floor((numberOfBins - 1) * (Number(array[i]) - min) / delta);
          histogram[idx] += 1;
        }
        return Promise.resolve(new registerWebworker.TransferableResponse(histogram, [histogram.buffer]));
      });
    })();
  },
  null
);

// node_modules/@kitware/vtk.js/Interaction/Widgets/PiecewiseGaussianWidget.js
var MIN_GAUSSIAN_WIDTH = 1e-3;
var ACTION_TO_CURSOR = {
  adjustPosition: "-webkit-grab",
  adjustHeight: "row-resize",
  adjustBias: "crosshair",
  adjustWidth: "col-resize",
  adjustZoom: "col-resize"
};
var TOUCH_CLICK = [];
var ACTIONS = {
  adjustPosition(x, y, _ref) {
    let {
      originalXY,
      gaussian,
      originalGaussian
    } = _ref;
    const xOffset = originalGaussian.position - originalXY[0];
    gaussian.position = x + xOffset;
    return true;
  },
  adjustHeight(x, y, _ref2) {
    let {
      model,
      gaussian
    } = _ref2;
    gaussian.height = 1 - y;
    gaussian.height = Math.min(1, Math.max(model.gaussianMinimumHeight, gaussian.height));
    return true;
  },
  adjustBias(x, y, _ref3) {
    let {
      originalXY,
      gaussian,
      originalGaussian
    } = _ref3;
    gaussian.xBias = originalGaussian.xBias - (originalXY[0] - x) / gaussian.height;
    gaussian.yBias = originalGaussian.yBias + 4 * (originalXY[1] - y) / gaussian.height;
    gaussian.xBias = Math.max(-1, Math.min(1, gaussian.xBias));
    gaussian.yBias = Math.max(0, Math.min(2, gaussian.yBias));
    return true;
  },
  adjustWidth(x, y, _ref4) {
    let {
      originalXY,
      gaussian,
      originalGaussian,
      gaussianSide
    } = _ref4;
    gaussian.width = gaussianSide < 0 ? originalGaussian.width - (originalXY[0] - x) : originalGaussian.width + (originalXY[0] - x);
    if (gaussian.width < MIN_GAUSSIAN_WIDTH) {
      gaussian.width = MIN_GAUSSIAN_WIDTH;
    }
    return true;
  },
  adjustZoom(x, y, _ref5) {
    let {
      rangeZoom,
      publicAPI
    } = _ref5;
    const delta = rangeZoom[1] - rangeZoom[0];
    const absNormX = (x - rangeZoom[0]) / delta;
    const minDelta = Math.abs(absNormX - rangeZoom[0]);
    const maxDelta = Math.abs(absNormX - rangeZoom[1]);
    const meanDelta = Math.abs(absNormX - 0.5 * (rangeZoom[0] + rangeZoom[1]));
    if (meanDelta < Math.min(minDelta, maxDelta)) {
      const halfDelta = delta * 0.5;
      rangeZoom[0] = Math.min(Math.max(absNormX - halfDelta, 0), rangeZoom[1] - 0.1);
      rangeZoom[1] = Math.max(Math.min(absNormX + halfDelta, 1), rangeZoom[0] + 0.1);
    } else if (minDelta < maxDelta) {
      rangeZoom[0] = Math.min(Math.max(absNormX, 0), rangeZoom[1] - 0.1);
    } else {
      rangeZoom[1] = Math.max(Math.min(absNormX, 1), rangeZoom[0] + 0.1);
    }
    publicAPI.invokeZoomChange(rangeZoom);
    return false;
  }
};
function computeOpacities(gaussians) {
  let sampling = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 256;
  const opacities = [];
  while (opacities.length < sampling) {
    opacities.push(0);
  }
  let count = gaussians.length;
  while (count--) {
    const {
      position,
      height: height2,
      width: width2,
      xBias,
      yBias
    } = gaussians[count];
    for (let i = 0; i < sampling; i++) {
      const x = i / (sampling - 1);
      if (x > position + width2 || x < position - width2) {
        if (opacities[i] < 0) {
          opacities[i] = 0;
        }
        continue;
      }
      const correctedWidth = width2 < MIN_GAUSSIAN_WIDTH ? MIN_GAUSSIAN_WIDTH : width2;
      let x0 = 0;
      if (xBias === 0 || x === position + xBias) {
        x0 = x;
      } else if (x > position + xBias) {
        if (correctedWidth === xBias) {
          x0 = position;
        } else {
          x0 = position + (x - position - xBias) * (correctedWidth / (correctedWidth - xBias));
        }
      } else if (-correctedWidth === xBias) {
        x0 = position;
      } else {
        x0 = position - (x - position - xBias) * (correctedWidth / (correctedWidth + xBias));
      }
      const x1 = (x0 - position) / correctedWidth;
      const h0a = Math.exp(-(4 * x1 * x1));
      const h0b = 1 - x1 * x1;
      const h0c = 1;
      let h1;
      if (yBias < 1) {
        h1 = yBias * h0b + (1 - yBias) * h0a;
      } else {
        h1 = (2 - yBias) * h0b + (yBias - 1) * h0c;
      }
      const h2 = height2 * h1;
      if (h2 > opacities[i]) {
        opacities[i] = h2;
      }
    }
  }
  return opacities;
}
function applyGaussianToPiecewiseFunction(gaussians, sampling, rangeToUse, piecewiseFunction) {
  const opacities = computeOpacities(gaussians, sampling);
  const nodes = [];
  const delta = (rangeToUse[1] - rangeToUse[0]) / (opacities.length - 1);
  const midpoint = 0.5;
  const sharpness = 0;
  for (let index = 0; index < opacities.length; index++) {
    const x = rangeToUse[0] + delta * index;
    const y = opacities[index];
    nodes.push({
      x,
      y,
      midpoint,
      sharpness
    });
  }
  piecewiseFunction.setNodes(nodes);
}
function drawChart(ctx, area, values) {
  let style6 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
    lineWidth: 1,
    strokeStyle: "#000"
  };
  const verticalScale = area[3];
  const horizontalScale = area[2] / (values.length - 1);
  const fill = !!style6.fillStyle;
  const offset = verticalScale + area[1];
  ctx.lineWidth = style6.lineWidth;
  ctx.strokeStyle = style6.strokeStyle;
  ctx.beginPath();
  ctx.moveTo(area[0], area[1] + area[3]);
  for (let index = 0; index < values.length; index++) {
    ctx.lineTo(area[0] + index * horizontalScale, Math.max(area[1], offset - values[index] * verticalScale));
  }
  if (fill) {
    ctx.fillStyle = style6.fillStyle;
    ctx.lineTo(area[0] + area[2], area[1] + area[3]);
    if (style6.clip) {
      ctx.clip();
      return;
    }
    ctx.fill();
  }
  ctx.stroke();
}
function updateColorCanvas(colorTransferFunction, width2, rangeToUse, canvas) {
  const workCanvas = canvas || document.createElement("canvas");
  workCanvas.setAttribute("width", width2);
  workCanvas.setAttribute("height", 256);
  const ctx = workCanvas.getContext("2d");
  const rgba = colorTransferFunction.getUint8Table(rangeToUse[0], rangeToUse[1], width2, 4);
  const pixelsArea = ctx.getImageData(0, 0, width2, 256);
  for (let lineIdx = 0; lineIdx < 256; lineIdx++) {
    pixelsArea.data.set(rgba, lineIdx * 4 * width2);
  }
  const nbValues = 256 * width2 * 4;
  const lineSize = width2 * 4;
  for (let i = 3; i < nbValues; i += 4) {
    pixelsArea.data[i] = 255 - Math.floor(i / lineSize);
  }
  ctx.putImageData(pixelsArea, 0, 0);
  return workCanvas;
}
function updateColorCanvasFromImage(img, width2, canvas) {
  const workCanvas = canvas || document.createElement("canvas");
  workCanvas.setAttribute("width", width2);
  workCanvas.setAttribute("height", 256);
  const ctx = workCanvas.getContext("2d");
  ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, width2, 256);
  return workCanvas;
}
function normalizeCoordinates(x, y, subRectangeArea) {
  let zoomRange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0, 1];
  return [zoomRange[0] + (x - subRectangeArea[0]) / subRectangeArea[2] * (zoomRange[1] - zoomRange[0]), (y - subRectangeArea[1]) / subRectangeArea[3]];
}
function findGaussian(x, gaussians) {
  const distances = gaussians.map((g) => Math.abs(g.position - x));
  const min = Math.min(...distances);
  return distances.indexOf(min);
}
function createListener(callback) {
  let preventDefault = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return (e2) => {
    const {
      offsetX,
      offsetY
    } = e2;
    if (preventDefault) {
      e2.preventDefault();
    }
    callback(offsetX, offsetY);
  };
}
function createTouchClickListener() {
  const id = TOUCH_CLICK.length;
  for (var _len = arguments.length, callbacks = new Array(_len), _key = 0; _key < _len; _key++) {
    callbacks[_key] = arguments[_key];
  }
  TOUCH_CLICK.push({
    callbacks,
    timeout: 0,
    deltaT: 200,
    count: 0,
    ready: false
  });
  return id;
}
function processTouchClicks() {
  TOUCH_CLICK.filter((t) => t.ready).forEach((touchHandle) => {
    touchHandle.callbacks.forEach((callback) => {
      if (callback.touches === touchHandle.touches && callback.clicks === touchHandle.count) {
        callback.action(...touchHandle.singleTouche);
      }
    });
    touchHandle.ts = 0;
    touchHandle.count = 0;
    touchHandle.touches = 0;
    touchHandle.ready = false;
  });
}
function createTouchListener(id, callback) {
  let nbTouches = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  let preventDefault = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  return (e2) => {
    const targetBounds = e2.target.getBoundingClientRect();
    const relativeTouches = Array.prototype.map.call(e2.touches, (t) => [t.pageX - targetBounds.left, t.pageY - targetBounds.top]);
    const singleTouche = relativeTouches.reduce((a2, b2) => [a2[0] + b2[0], a2[1] + b2[1]], [0, 0]).map((v) => v / e2.touches.length);
    if (e2.type === "touchstart") {
      clearTimeout(TOUCH_CLICK[id].timeout);
      TOUCH_CLICK[id].ts = e2.timeStamp;
      TOUCH_CLICK[id].singleTouche = singleTouche;
      TOUCH_CLICK[id].touches = e2.touches.length;
    } else if (e2.type === "touchmove") {
      TOUCH_CLICK[id].ts = 0;
      TOUCH_CLICK[id].count = 0;
      TOUCH_CLICK[id].ready = false;
    } else if (e2.type === "touchend") {
      if (e2.timeStamp - TOUCH_CLICK[id].ts < TOUCH_CLICK[id].deltaT) {
        TOUCH_CLICK[id].count += 1;
        TOUCH_CLICK[id].ready = true;
        if (preventDefault) {
          e2.preventDefault();
        }
        TOUCH_CLICK[id].timeout = setTimeout(processTouchClicks, TOUCH_CLICK[id].deltaT);
      } else {
        TOUCH_CLICK[id].ready = false;
      }
    }
    if (e2.touches.length === nbTouches) {
      callback(...singleTouche);
      if (preventDefault) {
        e2.preventDefault();
      }
    }
  };
}
function listenerSelector(condition, ok, ko) {
  return (e2) => condition() ? ok(e2) : ko(e2);
}
function rescaleArray(array, focusArea) {
  if (!focusArea) {
    return array;
  }
  const maxIdx = array.length - 1;
  const idxRange = focusArea.map((v) => Math.round(v * maxIdx));
  return array.slice(idxRange[0], idxRange[1] + 1);
}
function rescaleValue(value, focusArea) {
  if (!focusArea) {
    return value;
  }
  return (value - focusArea[0]) / (focusArea[1] - focusArea[0]);
}
var STATIC8 = {
  applyGaussianToPiecewiseFunction,
  computeOpacities,
  createListener,
  drawChart,
  findGaussian,
  listenerSelector,
  normalizeCoordinates
};
function vtkPiecewiseGaussianWidget(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseGaussianWidget");
  if (!model.canvas) {
    model.canvas = document.createElement("canvas");
  }
  publicAPI.setContainer = (el) => {
    if (model.container && model.container !== el) {
      model.container.removeChild(model.canvas);
    }
    if (model.container !== el) {
      model.container = el;
      if (model.container) {
        model.container.appendChild(model.canvas);
      }
      publicAPI.modified();
    }
  };
  publicAPI.setGaussians = (gaussians) => {
    if (model.gaussians === gaussians) {
      return;
    }
    model.gaussians = gaussians;
    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
    publicAPI.invokeOpacityChange(publicAPI);
    publicAPI.modified();
  };
  publicAPI.addGaussian = (position, height2, width2, xBias, yBias) => {
    const nextIndex = model.gaussians.length;
    model.gaussians.push({
      position,
      height: height2,
      width: width2,
      xBias,
      yBias
    });
    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
    publicAPI.invokeOpacityChange(publicAPI);
    publicAPI.modified();
    return nextIndex;
  };
  publicAPI.removeGaussian = (index) => {
    model.gaussians.splice(index, 1);
    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
    publicAPI.invokeOpacityChange(publicAPI);
    publicAPI.modified();
  };
  publicAPI.setSize = (width2, height2) => {
    model.canvas.setAttribute("width", width2);
    model.canvas.setAttribute("height", height2);
    if (model.size[0] !== width2 || model.size[1] !== height2) {
      model.size = [width2, height2];
      model.colorCanvasMTime = 0;
      publicAPI.modified();
    }
  };
  publicAPI.updateStyle = (style6) => {
    model.style = {
      ...model.style,
      ...style6
    };
    publicAPI.modified();
  };
  publicAPI.setDataArray = function(array) {
    let {
      numberOfBinToConsiders = 1,
      numberOfBinsToSkip = 1,
      numberOfComponents = 1,
      component = 0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.histogram = null;
    model.histogramArray = array;
    model.dataRange = arrayRange(array, component, numberOfComponents);
    const [min, max2] = model.dataRange;
    const maxNumberOfWorkers = 4;
    let arrayStride = Math.floor(array.length / maxNumberOfWorkers) || 1;
    arrayStride += arrayStride % numberOfComponents;
    let arrayIndex = 0;
    const workerChunks = [];
    const workers = [];
    while (arrayIndex < array.length) {
      const worker = new WorkerFactory2();
      workers.push(worker);
      const workerPromise = new import_webworker_promise2.default(worker);
      const arrayStart = arrayIndex;
      const arrayEnd = Math.min(arrayIndex + arrayStride, array.length - 1);
      const subArray = new array.constructor(array.slice(arrayStart, arrayEnd + 1));
      workerChunks.push(workerPromise.postMessage({
        array: subArray,
        component,
        numberOfComponents,
        min,
        max: max2,
        numberOfBins: model.numberOfBins
      }, [subArray.buffer]));
      arrayIndex += arrayStride;
    }
    Promise.all(workerChunks).then((subHistograms) => {
      workers.forEach((worker) => worker.terminate());
      model.histogram = new Float32Array(model.numberOfBins);
      model.histogram.fill(0);
      subHistograms.forEach((subHistogram) => {
        for (let i = 0, len = subHistogram.length; i < len; ++i) {
          model.histogram[i] += subHistogram[i];
        }
      });
      const sampleSize = Math.min(numberOfBinToConsiders, model.histogram.length - numberOfBinsToSkip);
      const sortedArray = Array.from(model.histogram);
      sortedArray.sort((a2, b2) => Number(a2) - Number(b2));
      for (let i = 0; i < numberOfBinsToSkip; i++) {
        sortedArray.pop();
      }
      while (sortedArray.length > sampleSize) {
        sortedArray.shift();
      }
      const mean3 = sortedArray.reduce((a2, b2) => a2 + b2, 0) / sampleSize;
      for (let i = 0, len = model.histogram.length; i < len; ++i) {
        model.histogram[i] /= mean3;
      }
      publicAPI.modified();
      setTimeout(publicAPI.render, 0);
    });
    publicAPI.modified();
  };
  publicAPI.onClick = (x, y) => {
    const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);
    if (xNormalized < 0 && model.style.iconSize > 1) {
      const delta = model.style.iconSize + model.style.padding;
      let offset = delta;
      let buttonIdx = 0;
      while (y > offset) {
        buttonIdx += 1;
        offset += delta;
      }
      switch (buttonIdx) {
        case 0: {
          const gaussianIdx = publicAPI.addGaussian(0, 1, 0.1, 0, 0);
          const gaussian = model.gaussians[gaussianIdx];
          const originalGaussian = {
            ...gaussian
          };
          const action = ACTIONS.adjustPosition;
          model.activeGaussian = gaussianIdx;
          model.selectedGaussian = gaussianIdx;
          macro.setImmediate(() => {
            publicAPI.onDown(x, y);
            model.dragAction = {
              originalXY: [0, 0],
              action,
              gaussian,
              originalGaussian
            };
          });
          break;
        }
        case 1: {
          if (model.selectedGaussian !== -1) {
            publicAPI.removeGaussian(model.selectedGaussian);
          }
          break;
        }
        default: {
          model.selectedGaussian = -1;
          model.dragAction = null;
        }
      }
    } else if (xNormalized < 0 || xNormalized > 1 || yNormalized < 0 || yNormalized > 1) {
      model.selectedGaussian = -1;
      model.dragAction = null;
    } else {
      const newSelected = findGaussian(xNormalized, model.gaussians);
      if (newSelected !== model.selectedGaussian) {
        model.selectedGaussian = newSelected;
        publicAPI.modified();
      }
    }
    return true;
  };
  publicAPI.onHover = (x, y) => {
    const tolerance = 20 / model.canvas.height;
    const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);
    const [xNormalizedAbs] = normalizeCoordinates(x, y, model.graphArea);
    const newActive = xNormalized < 0 ? model.selectedGaussian : findGaussian(xNormalized, model.gaussians);
    model.canvas.style.cursor = "default";
    const gaussian = model.gaussians[newActive];
    if (model.enableRangeZoom && xNormalizedAbs >= 0 && y < model.graphArea[1] - 6) {
      const thirdDelta = (model.rangeZoom[1] - model.rangeZoom[0]) / 3;
      if (xNormalizedAbs < model.rangeZoom[0] + thirdDelta || xNormalizedAbs > model.rangeZoom[1] - thirdDelta) {
        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustZoom;
      } else {
        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustPosition;
      }
      model.dragAction = {
        rangeZoom: model.rangeZoom,
        action: ACTIONS.adjustZoom
      };
    } else if (gaussian && xNormalizedAbs >= 0) {
      const invY = 1 - yNormalized;
      let actionName = null;
      if (invY > gaussian.height + tolerance) {
        actionName = "adjustPosition";
      } else if (invY > gaussian.height - tolerance) {
        if (Math.abs(xNormalized - gaussian.position) < tolerance) {
          actionName = "adjustHeight";
        } else {
          actionName = "adjustPosition";
        }
      } else if (invY > gaussian.height * 0.5 + tolerance) {
        actionName = "adjustPosition";
      } else if (invY > gaussian.height * 0.5 - tolerance) {
        if (Math.abs(xNormalized - gaussian.position) < tolerance) {
          actionName = "adjustBias";
        } else {
          actionName = "adjustPosition";
        }
      } else if (invY > tolerance) {
        actionName = "adjustPosition";
      } else {
        actionName = "adjustWidth";
      }
      model.canvas.style.cursor = ACTION_TO_CURSOR[actionName];
      const action = ACTIONS[actionName];
      const originalGaussian = {
        ...gaussian
      };
      model.dragAction = {
        originalXY: [xNormalized, yNormalized],
        action,
        gaussian,
        originalGaussian
      };
    }
    if (newActive !== model.activeGaussian) {
      model.activeGaussian = newActive;
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.onDown = (x, y) => {
    if (!model.mouseIsDown) {
      publicAPI.invokeAnimation(true);
    }
    model.mouseIsDown = true;
    const xNormalized = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null)[0];
    const newSelected = findGaussian(xNormalized, model.gaussians);
    model.gaussianSide = 0;
    const gaussian = model.gaussians[newSelected];
    if (gaussian) {
      model.gaussianSide = gaussian.position - xNormalized;
    }
    if (newSelected !== model.selectedGaussian && xNormalized > 0) {
      model.selectedGaussian = newSelected;
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.onDrag = (x, y) => {
    if (model.dragAction) {
      const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);
      const {
        action
      } = model.dragAction;
      if (action(xNormalized, yNormalized, {
        gaussianSide: model.gaussianSide,
        model,
        publicAPI,
        ...model.dragAction
      })) {
        model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
        publicAPI.invokeOpacityChange(publicAPI, true);
      }
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.onUp = (x, y) => {
    if (model.mouseIsDown) {
      publicAPI.invokeAnimation(false);
    }
    model.mouseIsDown = false;
    return true;
  };
  publicAPI.onLeave = (x, y) => {
    publicAPI.onUp(x, y);
    model.canvas.style.cursor = "default";
    model.activeGaussian = -1;
    publicAPI.modified();
    return true;
  };
  publicAPI.onAddGaussian = (x, y) => {
    const [xNormalized, yNormalized] = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null);
    if (xNormalized >= 0) {
      publicAPI.addGaussian(xNormalized, 1 - yNormalized, 0.1, 0, 0);
    }
    return true;
  };
  publicAPI.onRemoveGaussian = (x, y) => {
    const xNormalized = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null)[0];
    const newSelected = findGaussian(xNormalized, model.gaussians);
    if (xNormalized >= 0 && newSelected !== -1) {
      publicAPI.removeGaussian(newSelected);
    }
    return true;
  };
  publicAPI.bindMouseListeners = () => {
    if (!model.listeners) {
      const isDown = () => !!model.mouseIsDown;
      const touchId = createTouchClickListener({
        clicks: 1,
        touches: 1,
        action: publicAPI.onClick
      }, {
        clicks: 2,
        touches: 1,
        action: publicAPI.onAddGaussian
      }, {
        clicks: 2,
        touches: 2,
        action: publicAPI.onRemoveGaussian
      });
      model.listeners = {
        mousemove: listenerSelector(isDown, createListener(publicAPI.onDrag), createListener(publicAPI.onHover)),
        dblclick: createListener(publicAPI.onAddGaussian),
        contextmenu: createListener(publicAPI.onRemoveGaussian),
        click: createListener(publicAPI.onClick),
        mouseup: createListener(publicAPI.onUp),
        mousedown: createListener(publicAPI.onDown),
        mouseout: createListener(publicAPI.onLeave),
        touchstart: createTouchListener(touchId, macro.chain(publicAPI.onHover, publicAPI.onDown)),
        touchmove: listenerSelector(isDown, createTouchListener(touchId, publicAPI.onDrag), createTouchListener(touchId, publicAPI.onHover)),
        touchend: createTouchListener(touchId, publicAPI.onUp, 0)
        // touchend have 0 touch event...
      };
      Object.keys(model.listeners).forEach((eventType) => {
        model.canvas.addEventListener(eventType, model.listeners[eventType], false);
      });
    }
  };
  publicAPI.unbindMouseListeners = () => {
    if (model.listeners) {
      Object.keys(model.listeners).forEach((eventType) => {
        model.canvas.removeEventListener(eventType, model.listeners[eventType]);
      });
      delete model.listeners;
    }
  };
  publicAPI.render = () => {
    const ctx = model.canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    const [width2, height2] = model.size;
    const offset = model.style.padding;
    const graphArea = [Math.floor(model.style.iconSize + offset), Math.floor(offset), Math.ceil(width2 - 2 * offset - model.style.iconSize), Math.ceil(height2 - 2 * offset)];
    const zoomControlHeight = model.style.zoomControlHeight;
    if (model.enableRangeZoom) {
      graphArea[1] += Math.floor(zoomControlHeight);
      graphArea[3] -= Math.floor(zoomControlHeight);
    }
    model.graphArea = graphArea;
    ctx.clearRect(0, 0, width2, height2);
    ctx.lineJoin = "round";
    ctx.fillStyle = model.style.backgroundColor;
    ctx.fillRect(...graphArea);
    if (model.style.iconSize > 1) {
      const halfSize = Math.round(model.style.iconSize / 2 - model.style.strokeWidth);
      const center = Math.round(halfSize + offset + model.style.strokeWidth);
      ctx.beginPath();
      ctx.lineWidth = model.style.buttonStrokeWidth;
      ctx.strokeStyle = model.style.buttonStrokeColor;
      ctx.arc(center - offset / 2, center, halfSize, 0, 2 * Math.PI, false);
      ctx.fillStyle = model.style.buttonFillColor;
      ctx.fill();
      ctx.stroke();
      ctx.moveTo(center - halfSize + model.style.strokeWidth + 2 - offset / 2, center);
      ctx.lineTo(center + halfSize - model.style.strokeWidth - 2 - offset / 2, center);
      ctx.stroke();
      ctx.moveTo(center - offset / 2, center - halfSize + model.style.strokeWidth + 2);
      ctx.lineTo(center - offset / 2, center + halfSize - model.style.strokeWidth - 2);
      ctx.stroke();
      if (model.selectedGaussian === -1) {
        ctx.fillStyle = model.style.buttonDisableFillColor;
        ctx.lineWidth = model.style.buttonDisableStrokeWidth;
        ctx.strokeStyle = model.style.buttonDisableStrokeColor;
      } else {
        ctx.fillStyle = model.style.buttonFillColor;
        ctx.lineWidth = model.style.buttonStrokeWidth;
        ctx.strokeStyle = model.style.buttonStrokeColor;
      }
      ctx.beginPath();
      ctx.arc(center - offset / 2, center + offset / 2 + model.style.iconSize, halfSize, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.moveTo(center - halfSize + model.style.strokeWidth + 2 - offset / 2, center + offset / 2 + model.style.iconSize);
      ctx.lineTo(center + halfSize - model.style.strokeWidth - 2 - offset / 2, center + offset / 2 + model.style.iconSize);
      ctx.stroke();
    }
    if (model.histogram) {
      drawChart(ctx, graphArea, rescaleArray(model.histogram, model.rangeZoom), {
        lineWidth: 1,
        strokeStyle: model.style.histogramColor,
        fillStyle: model.style.histogramColor
      });
    }
    drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {
      lineWidth: model.style.strokeWidth,
      strokeStyle: model.style.strokeColor
    });
    if (model.colorTransferFunction && model.colorTransferFunction.getSize()) {
      const rangeToUse = model.dataRange || model.colorTransferFunction.getMappingRange();
      if (!model.colorCanvas || model.colorCanvasMTime !== model.colorTransferFunction.getMTime()) {
        model.colorCanvasMTime = model.colorTransferFunction.getMTime();
        model.colorCanvas = updateColorCanvas(model.colorTransferFunction, graphArea[2], rangeToUse, model.colorCanvas);
      }
      ctx.save();
      drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {
        lineWidth: 1,
        strokeStyle: "rgba(0,0,0,0)",
        fillStyle: "rgba(0,0,0,1)",
        clip: true
      });
      if (model.enableRangeZoom) {
        ctx.drawImage(model.colorCanvas, model.rangeZoom[0] * graphArea[2], 0, graphArea[2], graphArea[3], graphArea[0], graphArea[1], graphArea[2] / (model.rangeZoom[1] - model.rangeZoom[0]), graphArea[3]);
      } else {
        ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);
      }
      ctx.restore();
    } else if (model.backgroundImage) {
      model.colorCanvas = updateColorCanvasFromImage(model.backgroundImage, graphArea[2], model.colorCanvas);
      ctx.save();
      drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {
        lineWidth: 1,
        strokeStyle: "rgba(0,0,0,0)",
        fillStyle: "rgba(0,0,0,1)",
        clip: true
      });
      ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);
      ctx.restore();
    }
    if (model.enableRangeZoom) {
      ctx.fillStyle = model.style.zoomControlColor;
      ctx.beginPath();
      ctx.rect(graphArea[0] + model.rangeZoom[0] * graphArea[2], 0, (model.rangeZoom[1] - model.rangeZoom[0]) * graphArea[2], zoomControlHeight);
      ctx.fill();
    }
    const activeGaussian = model.gaussians[model.activeGaussian] || model.gaussians[model.selectedGaussian];
    if (activeGaussian) {
      const activeOpacities = computeOpacities([activeGaussian], graphArea[2]);
      drawChart(ctx, graphArea, rescaleArray(activeOpacities, model.enableRangeZoom && model.rangeZoom), {
        lineWidth: model.style.activeStrokeWidth,
        strokeStyle: model.style.activeColor
      });
      const xCenter = graphArea[0] + rescaleValue(activeGaussian.position, model.enableRangeZoom && model.rangeZoom) * graphArea[2];
      const yTop = graphArea[1] + (1 - activeGaussian.height) * graphArea[3];
      const yMiddle = graphArea[1] + (1 - 0.5 * activeGaussian.height) * graphArea[3];
      const yBottom = graphArea[1] + graphArea[3];
      let widthInPixel = activeGaussian.width * graphArea[2];
      if (model.enableRangeZoom) {
        widthInPixel /= model.rangeZoom[1] - model.rangeZoom[0];
      }
      ctx.lineWidth = model.style.handleWidth;
      ctx.strokeStyle = model.style.handleColor;
      ctx.fillStyle = model.style.backgroundColor;
      ctx.beginPath();
      ctx.moveTo(xCenter, graphArea[1] + (1 - activeGaussian.height) * graphArea[3]);
      ctx.lineTo(xCenter, graphArea[1] + graphArea[3]);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(xCenter, yTop, 6, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      const radius = Math.min(widthInPixel * 0.1, activeGaussian.height * graphArea[3] * 0.2);
      ctx.beginPath();
      ctx.rect(xCenter - radius, yMiddle - radius, radius * 2, radius * 2);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      const sliderWidth = widthInPixel * 0.8;
      ctx.rect(xCenter - sliderWidth, yBottom - 5, 2 * sliderWidth, 10);
      ctx.fill();
      ctx.stroke();
    }
  };
  publicAPI.getOpacityNodes = (dataRange) => {
    const rangeToUse = dataRange || model.dataRange;
    const delta = (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);
    const nodes = [];
    const midpoint = 0.5;
    const sharpness = 0;
    for (let index = 0; index < model.opacities.length; index++) {
      const x = rangeToUse[0] + delta * index;
      const y = model.opacities[index];
      nodes.push({
        x,
        y,
        midpoint,
        sharpness
      });
    }
    return nodes;
  };
  publicAPI.applyOpacity = (piecewiseFunction, dataRange) => {
    const nodes = publicAPI.getOpacityNodes(dataRange);
    piecewiseFunction.setNodes(nodes);
  };
  publicAPI.getOpacityRange = (dataRange) => {
    const rangeToUse = dataRange || model.dataRange;
    const delta = (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);
    let minIndex = model.opacities.length - 1;
    let maxIndex = 0;
    for (let index = 0; index < model.opacities.length; index++) {
      if (model.opacities[index] > 0) {
        minIndex = Math.min(minIndex, index);
      }
      if (model.opacities[index] > 0) {
        maxIndex = Math.max(maxIndex, index);
      }
    }
    return [rangeToUse[0] + minIndex * delta, rangeToUse[0] + maxIndex * delta];
  };
  const enableZoom = publicAPI.setEnableRangeZoom;
  publicAPI.setEnableRangeZoom = (v) => {
    const change = enableZoom(v);
    if (change) {
      model.colorCanvasMTime = 0;
      model.rangeZoom = [0, 1];
    }
    return change;
  };
  const rangeZoom = publicAPI.setRangeZoom;
  publicAPI.setRangeZoom = function() {
    const change = rangeZoom(...arguments);
    if (change) {
      model.colorCanvasMTime = 0;
    }
    return change;
  };
  publicAPI.onModified(() => publicAPI.render());
  publicAPI.setSize(...model.size);
}
var DEFAULT_VALUES96 = {
  histogram: [],
  numberOfBins: 256,
  histogramArray: null,
  dataRange: [0, 1],
  gaussians: [],
  opacities: [],
  size: [600, 300],
  piecewiseSize: 256,
  colorCanvasMTime: 0,
  gaussianMinimumHeight: 0.05,
  style: {
    backgroundColor: "rgba(255, 255, 255, 1)",
    histogramColor: "rgba(200, 200, 200, 0.5)",
    strokeColor: "rgb(0, 0, 0)",
    activeColor: "rgb(0, 0, 150)",
    buttonDisableFillColor: "rgba(255, 255, 255, 0.5)",
    buttonDisableStrokeColor: "rgba(0, 0, 0, 0.5)",
    buttonStrokeColor: "rgba(0, 0, 0, 1)",
    buttonFillColor: "rgba(255, 255, 255, 1)",
    handleColor: "rgb(0, 150, 0)",
    strokeWidth: 2,
    activeStrokeWidth: 3,
    buttonStrokeWidth: 1.5,
    handleWidth: 3,
    iconSize: 20,
    padding: 10,
    zoomControlHeight: 10,
    zoomControlColor: "#999"
  },
  activeGaussian: -1,
  selectedGaussian: -1,
  enableRangeZoom: true,
  rangeZoom: [0, 1]
  // normalized value
};
function extend106(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES96, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["piecewiseSize", "numberOfBins", "colorTransferFunction", "backgroundImage", "enableRangeZoom", "gaussianMinimumHeight"]);
  macro.setGetArray(publicAPI, model, ["rangeZoom"], 2);
  macro.get(publicAPI, model, ["size", "canvas", "gaussians"]);
  macro.event(publicAPI, model, "opacityChange");
  macro.event(publicAPI, model, "animation");
  macro.event(publicAPI, model, "zoomChange");
  vtkPiecewiseGaussianWidget(publicAPI, model);
}
var newInstance101 = macro.newInstance(extend106, "vtkPiecewiseGaussianWidget");
var vtkPiecewiseGaussianWidget$1 = {
  newInstance: newInstance101,
  extend: extend106,
  ...STATIC8
};

// node_modules/@kitware/vtk.js/Interaction/UI/VolumeController/VolumeController.module.css.js
var css_248z4 = ".VolumeController-module_container__2HNSO {\n  display: flex;\n  align-items: stretch;\n  flex-direction: column;\n  justify-content: space-between;\n  position: absolute;\n  top: 5px;\n  left: 5px;\n  background: rgba(128, 128, 128, 0.5);\n  border-radius: 5px;\n  padding: 2px;\n  border: 0.5px solid black;\n  box-sizing: border-box;\n}\n\n.VolumeController-module_line__3rtqL {\n  display: flex;\n  flex-direction: row;\n  flex: 1;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.VolumeController-module_button__2T-xL {\n  cursor: pointer;\n  width: 1rem;\n  margin-left: 5px;\n  margin-right: 5px;\n}\n\n.VolumeController-module_button__2T-xL svg {\n  width: 1rem;\n  height: 1rem;\n}\n\n.VolumeController-module_sliderEntry__27XSC {\n  flex: 1;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n\n.VolumeController-module_sliderIcon__U8YAZ {\n  height: 1rem;\n}\n\n.VolumeController-module_slider__3PS68 {\n  flex: 1;\n  min-height: 1rem;\n  width: 5px;\n}\n\n.VolumeController-module_piecewiseEditor__2_jav {\n  flex: 1;\n}\n\n.VolumeController-module_select__7mbfS {\n  flex: 1;\n  border: none;\n  background: transparent;\n  color: white;\n  border: none;\n  -moz-appearance: none;\n  width: 5px;\n}\n\n.VolumeController-module_select__7mbfS select:focus {\n  outline: none;\n  border: none;\n}\n\n.VolumeController-module_presets__1h4j5 {\n}\n\n.VolumeController-module_shadow__29K9t {\n}\n\n.VolumeController-module_buttonDarkBG__3W1zO {\n}\n\n.VolumeController-module_presetsDarkBG__2ZI2W {\n  color: white;\n}\n\n.VolumeController-module_presetsDarkBG__2ZI2W option {\n  color: black;\n}\n\n.VolumeController-module_shadowDarkBG__WHYZ- {\n  color: white;\n}\n\n.VolumeController-module_shadowDarkBG__WHYZ- option {\n  color: black;\n}\n\n.VolumeController-module_buttonBrightBG__2dstz {\n}\n\n.VolumeController-module_presetsBrightBG__3_VRC {\n  color: black;\n}\n\n.VolumeController-module_presetsBrightBG__3_VRC option {\n  color: white;\n}\n\n.VolumeController-module_shadowBrightBG__YCHpe {\n  color: black;\n}\n\n.VolumeController-module_shadowBrightBG__YCHpe option {\n  color: white;\n}\n";
var style4 = { "container": "VolumeController-module_container__2HNSO", "line": "VolumeController-module_line__3rtqL", "button": "VolumeController-module_button__2T-xL", "sliderEntry": "VolumeController-module_sliderEntry__27XSC", "sliderIcon": "VolumeController-module_sliderIcon__U8YAZ VolumeController-module_button__2T-xL", "slider": "VolumeController-module_slider__3PS68", "piecewiseEditor": "VolumeController-module_piecewiseEditor__2_jav", "select": "VolumeController-module_select__7mbfS", "presets": "VolumeController-module_presets__1h4j5 VolumeController-module_select__7mbfS", "shadow": "VolumeController-module_shadow__29K9t VolumeController-module_select__7mbfS", "buttonDarkBG": "VolumeController-module_buttonDarkBG__3W1zO VolumeController-module_button__2T-xL", "presetsDarkBG": "VolumeController-module_presetsDarkBG__2ZI2W VolumeController-module_presets__1h4j5 VolumeController-module_select__7mbfS", "shadowDarkBG": "VolumeController-module_shadowDarkBG__WHYZ- VolumeController-module_shadow__29K9t VolumeController-module_select__7mbfS", "buttonBrightBG": "VolumeController-module_buttonBrightBG__2dstz VolumeController-module_button__2T-xL", "presetsBrightBG": "VolumeController-module_presetsBrightBG__3_VRC VolumeController-module_presets__1h4j5 VolumeController-module_select__7mbfS", "shadowBrightBG": "VolumeController-module_shadowBrightBG__YCHpe VolumeController-module_shadow__29K9t VolumeController-module_select__7mbfS" };
styleInject(css_248z4);

// node_modules/@kitware/vtk.js/Interaction/UI/VolumeController.js
var PRESETS_OPTIONS = vtkColorMaps2.rgbPresetNames.map((name2) => `<option value="${name2}">${name2}</option>`);
function vtkVolumeController(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeController");
  model.el = document.createElement("div");
  model.el.setAttribute("class", style4.container);
  model.widget = vtkPiecewiseGaussianWidget$1.newInstance({
    numberOfBins: 256,
    size: model.size
  });
  function updateUseShadow() {
    const useShadow = !!Number(model.el.querySelector(".js-shadow").value);
    model.actor.getProperty().setShade(useShadow);
    model.renderWindow.render();
  }
  function updateColorMapPreset() {
    const sourceDS = model.actor.getMapper().getInputData();
    if (!sourceDS) {
      return;
    }
    const dataArray = sourceDS.getPointData().getScalars() || sourceDS.getPointData().getArrays()[0];
    const dataRange = model.rescaleColorMap ? model.colorDataRange : dataArray.getRange();
    const preset = vtkColorMaps2.getPresetByName(model.el.querySelector(".js-color-preset").value);
    const lookupTable = model.actor.getProperty().getRGBTransferFunction(0);
    lookupTable.applyColorMap(preset);
    lookupTable.setMappingRange(...dataRange);
    lookupTable.updateRange();
    model.renderWindow.render();
  }
  function updateSpacing() {
    const value = Number(model.el.querySelector(".js-spacing").value);
    const sourceDS = model.actor.getMapper().getInputData();
    const sampleDistance = 0.7 * Math.sqrt(sourceDS.getSpacing().map((v) => v * v).reduce((a2, b2) => a2 + b2, 0));
    model.actor.getMapper().setSampleDistance(sampleDistance * 2 ** (value * 3 - 1.5));
    model.renderWindow.render();
  }
  function updateEdgeGradient() {
    const value = Number(model.el.querySelector(".js-edge").value);
    if (value === 0) {
      model.actor.getProperty().setUseGradientOpacity(0, false);
    } else {
      const sourceDS = model.actor.getMapper().getInputData();
      const dataArray = sourceDS.getPointData().getScalars() || sourceDS.getPointData().getArrays()[0];
      const dataRange = dataArray.getRange();
      model.actor.getProperty().setUseGradientOpacity(0, true);
      const minV = Math.max(0, value - 0.3) / 0.7;
      model.actor.getProperty().setGradientOpacityMinimumValue(0, (dataRange[1] - dataRange[0]) * 0.2 * minV * minV);
      model.actor.getProperty().setGradientOpacityMaximumValue(0, (dataRange[1] - dataRange[0]) * 1 * value * value);
    }
    model.renderWindow.render();
  }
  publicAPI.setupContent = function(renderWindow, actor, isBackgroundDark) {
    let useShadow = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "1";
    let presetName = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "erdc_rainbow_bright";
    publicAPI.setActor(actor);
    publicAPI.setRenderWindow(renderWindow);
    const sourceDS = model.actor.getMapper().getInputData();
    const dataArray = sourceDS.getPointData().getScalars() || sourceDS.getPointData().getArrays()[0];
    const lookupTable = model.actor.getProperty().getRGBTransferFunction(0);
    const piecewiseFunction = model.actor.getProperty().getScalarOpacity(0);
    const stylePostFix = isBackgroundDark ? "DarkBG" : "BrightBG";
    const localStyle = {};
    ["button", "presets", "shadow"].forEach((name2) => {
      localStyle[name2] = style4[`${name2}${stylePostFix}`];
    });
    model.el.innerHTML = `
      <div class="${style4.line}">
        <div class="${localStyle.button} js-button">${svgLogo}</div>
        <select class="${localStyle.shadow} js-shadow js-toggle">
          <option value="1">Use Shadow</option>
          <option value="0">No Shadow</option>
        </select>
        <select class="${localStyle.presets} js-color-preset js-toggle">
          ${PRESETS_OPTIONS}
        </select>
      </div>
      <div class="${style4.line} js-toggle">
        <div class="${style4.sliderEntry}">
          <div class="${style4.sliderIcon}">${svgSpacing}</div>
          <input type="range" min="0" max="1" value="0.4" step="0.01" class="${style4.slider} js-spacing" />
        </div>
        <div class="${style4.sliderEntry}">
          <div class="${style4.sliderIcon}">${svgEdge}</div>
          <input type="range" min="0" max="1" value="0.2" step="0.01" class="${style4.slider} js-edge" />
        </div>
      </div>
      <div class="${style4.piecewiseEditor} js-pwf js-toggle"></div>
    `;
    const domToggleButton = model.el.querySelector(".js-button");
    const domShadow = model.el.querySelector(".js-shadow");
    const domPreset = model.el.querySelector(".js-color-preset");
    const domSpacing = model.el.querySelector(".js-spacing");
    const domEdge = model.el.querySelector(".js-edge");
    const widgetContainer = model.el.querySelector(".js-pwf");
    model.widget.updateStyle({
      backgroundColor: "rgba(255, 255, 255, 0.6)",
      histogramColor: "rgba(100, 100, 100, 0.5)",
      strokeColor: "rgb(0, 0, 0)",
      activeColor: "rgb(255, 255, 255)",
      handleColor: "rgb(50, 150, 50)",
      buttonDisableFillColor: "rgba(255, 255, 255, 0.5)",
      buttonDisableStrokeColor: "rgba(0, 0, 0, 0.5)",
      buttonStrokeColor: "rgba(0, 0, 0, 1)",
      buttonFillColor: "rgba(255, 255, 255, 1)",
      strokeWidth: 2,
      activeStrokeWidth: 3,
      buttonStrokeWidth: 1.5,
      handleWidth: 3,
      iconSize: 0,
      padding: 10
    });
    model.widget.addGaussian(0.5, 1, 0.5, 0.5, 0.4);
    model.widget.setDataArray(dataArray.getData());
    model.widget.setColorTransferFunction(lookupTable);
    model.widget.applyOpacity(piecewiseFunction);
    model.widget.setContainer(widgetContainer);
    model.widget.bindMouseListeners();
    model.colorDataRange = model.widget.getOpacityRange();
    domToggleButton.addEventListener("click", publicAPI.toggleVisibility);
    domShadow.addEventListener("change", updateUseShadow);
    domPreset.addEventListener("change", updateColorMapPreset);
    domSpacing.addEventListener("input", updateSpacing);
    domEdge.addEventListener("input", updateEdgeGradient);
    model.widget.onOpacityChange(() => {
      model.widget.applyOpacity(piecewiseFunction);
      model.colorDataRange = model.widget.getOpacityRange();
      if (model.rescaleColorMap) {
        updateColorMapPreset();
      }
      if (!model.renderWindow.getInteractor().isAnimating()) {
        model.renderWindow.render();
      }
    });
    model.widget.onAnimation((start) => {
      if (start) {
        model.renderWindow.getInteractor().requestAnimation(model.widget);
      } else {
        model.renderWindow.getInteractor().cancelAnimation(model.widget);
        model.renderWindow.render();
      }
    });
    lookupTable.onModified(() => {
      model.widget.render();
      if (!model.renderWindow.getInteractor().isAnimating()) {
        model.renderWindow.render();
      }
    });
    domShadow.value = Number(useShadow) ? "1" : "0";
    domPreset.value = presetName;
    updateUseShadow();
    updateColorMapPreset();
    updateSpacing();
    updateEdgeGradient();
  };
  publicAPI.setContainer = (el) => {
    if (model.container && model.container !== el) {
      model.container.removeChild(model.el);
    }
    if (model.container !== el) {
      model.container = el;
      if (model.container) {
        model.container.appendChild(model.el);
      }
      publicAPI.modified();
    }
  };
  const rescaleColorMap = publicAPI.setRescaleColorMap;
  publicAPI.setRescaleColorMap = (value) => {
    if (rescaleColorMap(value)) {
      updateColorMapPreset();
      return true;
    }
    return false;
  };
  publicAPI.toggleVisibility = () => {
    publicAPI.setExpanded(!publicAPI.getExpanded());
  };
  publicAPI.setExpanded = (expanded) => {
    const elements = model.el.querySelectorAll(".js-toggle");
    let count = elements.length;
    model.expanded = expanded;
    if (model.expanded) {
      while (count--) {
        elements[count].style.display = "flex";
      }
    } else {
      while (count--) {
        elements[count].style.display = "none";
      }
    }
  };
  publicAPI.getExpanded = () => model.expanded;
  publicAPI.setSize = model.widget.setSize;
  publicAPI.render = model.widget.render;
  publicAPI.onAnimation = model.widget.onAnimation;
  publicAPI.onModified(publicAPI.render);
  publicAPI.setSize(...model.size);
}
var DEFAULT_VALUES97 = {
  size: [600, 300],
  expanded: true,
  rescaleColorMap: false
};
function extend107(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES97, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["actor", "renderWindow", "rescaleColorMap"]);
  macro.get(publicAPI, model, ["widget"]);
  vtkVolumeController(publicAPI, model);
}
var newInstance102 = macro.newInstance(extend107, "vtkVolumeController");
var vtkVolumeController$1 = {
  newInstance: newInstance102,
  extend: extend107
};

// node_modules/@kitware/vtk.js/Interaction/UI.js
var UI = {
  vtkCornerAnnotation: vtkCornerAnnotation$1,
  vtkFPSMonitor: vtkFPSMonitor$1,
  vtkIcons,
  vtkSlider: vtkSlider$1,
  vtkVolumeController: vtkVolumeController$1
};

// node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget/Constants.js
var Corners = {
  TOP_LEFT: "TOP_LEFT",
  TOP_RIGHT: "TOP_RIGHT",
  BOTTOM_LEFT: "BOTTOM_LEFT",
  BOTTOM_RIGHT: "BOTTOM_RIGHT"
};
var Constants10 = {
  Corners
};

// node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js
var {
  vtkErrorMacro: vtkErrorMacro41
} = macro;
var {
  Corners: Corners2
} = Constants10;
function vtkOrientationMarkerWidget(publicAPI, model) {
  model.classHierarchy.push("vtkOrientationMarkerWidget");
  const superClass = {
    ...publicAPI
  };
  const previousCameraInput = [];
  const selfRenderer = vtkRenderer$1.newInstance();
  const resizeObserver = new ResizeObserver((entries) => {
    publicAPI.updateViewport();
  });
  let onCameraChangedSub = null;
  let onCameraModifiedSub = null;
  let onAnimationSub = null;
  let onEndAnimationSub = null;
  let selfSubscription = null;
  function onCameraModified() {
    if (!model._interactor.isAnimating()) {
      publicAPI.updateMarkerOrientation();
    }
  }
  model._onParentRendererChanged = () => publicAPI.updateViewport();
  publicAPI.computeViewport = () => {
    const parentRen = model.parentRenderer || model._interactor.getCurrentRenderer();
    const [xMin, yMin, xMax, yMax] = parentRen.getViewport();
    const view = model._interactor.getView();
    const canvasSize = view.getSize();
    const [viewXSize, viewYSize] = view.getViewportSize(parentRen);
    const minViewSize = Math.min(viewXSize, viewYSize);
    let pixelSize = model.viewportSize * minViewSize;
    pixelSize = Math.max(Math.min(model.minPixelSize, minViewSize), Math.min(model.maxPixelSize, pixelSize));
    const xFrac = pixelSize / canvasSize[0];
    const yFrac = pixelSize / canvasSize[1];
    switch (model.viewportCorner) {
      case Corners2.TOP_LEFT:
        return [xMin, yMax - yFrac, xMin + xFrac, yMax];
      case Corners2.TOP_RIGHT:
        return [xMax - xFrac, yMax - yFrac, xMax, yMax];
      case Corners2.BOTTOM_LEFT:
        return [xMin, yMin, xMin + xFrac, yMin + yFrac];
      case Corners2.BOTTOM_RIGHT:
        return [xMax - xFrac, yMin, xMax, yMin + yFrac];
      default:
        vtkErrorMacro41("Invalid widget corner");
        return null;
    }
  };
  publicAPI.updateViewport = () => {
    if (model.enabled) {
      selfRenderer.setViewport(...publicAPI.computeViewport());
      model._interactor.render();
    }
  };
  publicAPI.updateMarkerOrientation = () => {
    const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
    const currentCamera = ren.getActiveCamera();
    if (!currentCamera) {
      return;
    }
    const position = currentCamera.getReferenceByName("position");
    const focalPoint = currentCamera.getReferenceByName("focalPoint");
    const viewUp = currentCamera.getReferenceByName("viewUp");
    if (previousCameraInput[0] !== position[0] || previousCameraInput[1] !== position[1] || previousCameraInput[2] !== position[2] || previousCameraInput[3] !== focalPoint[0] || previousCameraInput[4] !== focalPoint[1] || previousCameraInput[5] !== focalPoint[2] || previousCameraInput[6] !== viewUp[0] || previousCameraInput[7] !== viewUp[1] || previousCameraInput[8] !== viewUp[2]) {
      previousCameraInput[0] = position[0];
      previousCameraInput[1] = position[1];
      previousCameraInput[2] = position[2];
      previousCameraInput[3] = focalPoint[0];
      previousCameraInput[4] = focalPoint[1];
      previousCameraInput[5] = focalPoint[2];
      previousCameraInput[6] = viewUp[0];
      previousCameraInput[7] = viewUp[1];
      previousCameraInput[8] = viewUp[2];
      const activeCamera = selfRenderer.getActiveCamera();
      activeCamera.setPosition(position[0], position[1], position[2]);
      activeCamera.setFocalPoint(focalPoint[0], focalPoint[1], focalPoint[2]);
      activeCamera.setViewUp(viewUp[0], viewUp[1], viewUp[2]);
      selfRenderer.resetCamera();
    }
  };
  publicAPI.setEnabled = (enabling) => {
    var _a, _b;
    if (enabling) {
      if (model.enabled) {
        return;
      }
      if (!model.actor) {
        vtkErrorMacro41("Must set actor before enabling orientation marker.");
        return;
      }
      if (!model._interactor) {
        vtkErrorMacro41("Must set interactor before enabling orientation marker.");
        return;
      }
      const ren = model.parentRenderer || model._interactor.getCurrentRenderer();
      const renderWindow = ren.getRenderWindow();
      renderWindow.addRenderer(selfRenderer);
      if (renderWindow.getNumberOfLayers() < 2) {
        renderWindow.setNumberOfLayers(2);
      }
      selfRenderer.setLayer(renderWindow.getNumberOfLayers() - 1);
      selfRenderer.setInteractive(model.interactiveRenderer);
      selfRenderer.addViewProp(model.actor);
      model.actor.setVisibility(true);
      onCameraChangedSub = ren.onEvent((event2) => {
        if (event2.type === "ActiveCameraEvent") {
          if (onCameraModifiedSub) {
            onCameraModifiedSub.unsubscribe();
          }
          onCameraModifiedSub = event2.camera.onModified(onCameraModified);
        }
      });
      onCameraModifiedSub = ren.getActiveCamera().onModified(onCameraModified);
      onAnimationSub = model._interactor.onAnimation(publicAPI.updateMarkerOrientation);
      onEndAnimationSub = model._interactor.onEndAnimation(publicAPI.updateMarkerOrientation);
      resizeObserver.observe(model._interactor.getView().getCanvas());
      publicAPI.updateViewport();
      publicAPI.updateMarkerOrientation();
      model.enabled = true;
    } else {
      if (!model.enabled) {
        return;
      }
      model.enabled = false;
      resizeObserver.disconnect();
      onCameraChangedSub.unsubscribe();
      onCameraChangedSub = null;
      onCameraModifiedSub.unsubscribe();
      onCameraModifiedSub = null;
      onAnimationSub.unsubscribe();
      onAnimationSub = null;
      onEndAnimationSub.unsubscribe();
      onEndAnimationSub = null;
      model.actor.setVisibility(false);
      selfRenderer.removeViewProp(model.actor);
      const renderWindow = (_b = (_a = model._interactor) == null ? void 0 : _a.findPokedRenderer()) == null ? void 0 : _b.getRenderWindow();
      if (renderWindow) {
        renderWindow.removeRenderer(selfRenderer);
      }
    }
    publicAPI.modified();
  };
  publicAPI.setViewportCorner = (corner2) => {
    if (corner2 === model.viewportCorner) {
      return;
    }
    model.viewportCorner = corner2;
    publicAPI.updateViewport();
  };
  publicAPI.setViewportSize = (sizeFactor) => {
    const viewportSize = Math.min(1, Math.max(0, sizeFactor));
    if (viewportSize === model.viewportSize) {
      return;
    }
    model.viewportSize = viewportSize;
    publicAPI.updateViewport();
  };
  publicAPI.setActor = (actor) => {
    const previousState = model.enabled;
    publicAPI.setEnabled(false);
    model.actor = actor;
    publicAPI.setEnabled(previousState);
  };
  publicAPI.getRenderer = () => selfRenderer;
  publicAPI.delete = () => {
    superClass.delete();
    if (selfSubscription) {
      selfSubscription.unsubscribe();
      selfSubscription = null;
    }
    if (onCameraChangedSub) {
      onCameraChangedSub.unsubscribe();
      onCameraChangedSub = null;
    }
    if (onCameraModifiedSub) {
      onCameraModifiedSub.unsubscribe();
      onCameraModifiedSub = null;
    }
    if (onAnimationSub) {
      onAnimationSub.unsubscribe();
      onAnimationSub = null;
    }
    if (onEndAnimationSub) {
      onEndAnimationSub.unsubscribe();
      onEndAnimationSub = null;
    }
    resizeObserver.disconnect();
  };
  selfSubscription = publicAPI.onModified(publicAPI.updateViewport);
}
var DEFAULT_VALUES98 = {
  // actor: null,
  // _interactor: null,
  viewportCorner: Constants10.Corners.BOTTOM_LEFT,
  viewportSize: 0.2,
  minPixelSize: 50,
  maxPixelSize: 200,
  parentRenderer: null,
  interactiveRenderer: false
};
function extend108(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES98, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["enabled", "viewportCorner", "viewportSize", "interactiveRenderer"]);
  macro.setGet(publicAPI, model, ["_interactor", "minPixelSize", "maxPixelSize", "parentRenderer"]);
  macro.get(publicAPI, model, ["actor"]);
  macro.moveToProtected(publicAPI, model, ["interactor"]);
  vtkOrientationMarkerWidget(publicAPI, model);
}
var newInstance103 = macro.newInstance(extend108, "vtkOrientationMarkerWidget");
var vtkOrientationMarkerWidget$1 = {
  newInstance: newInstance103,
  extend: extend108,
  ...Constants10
};

// node_modules/@kitware/vtk.js/Interaction/Widgets.js
var Widgets = {
  vtkOrientationMarkerWidget: vtkOrientationMarkerWidget$1,
  vtkPiecewiseGaussianWidget: vtkPiecewiseGaussianWidget$1
};

// node_modules/@kitware/vtk.js/Interaction/index.js
var Interaction = {
  Manipulators,
  Misc,
  Style,
  UI,
  Widgets
};

// node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/HtmlDataAccessHelper.js
var {
  vtkErrorMacro: vtkErrorMacro42,
  vtkDebugMacro: vtkDebugMacro7
} = macro;
var requestCount = 0;
function getContent(url) {
  const el = document.querySelector(`.webResource[data-url="${url}"]`);
  return el ? el.innerHTML : null;
}
function getElement(url) {
  return document.querySelector(`.webResource[data-url="${url}"]`);
}
function removeLeadingSlash(str) {
  return str[0] === "/" ? str.substr(1) : str;
}
function fetchText(instance, url) {
  return new Promise((resolve, reject) => {
    const txt = getContent(url);
    if (txt === null) {
      reject(new Error(`No such text ${url}`));
    } else {
      resolve(txt);
    }
  });
}
function fetchJSON(instance, url) {
  return new Promise((resolve, reject) => {
    const txt = getContent(removeLeadingSlash(url));
    if (txt === null) {
      reject(new Error(`No such JSON ${url}`));
    } else {
      resolve(JSON.parse(txt));
    }
  });
}
function fetchArray(instance, baseURL, array) {
  let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  return new Promise((resolve, reject) => {
    const url = removeLeadingSlash([baseURL, array.ref.basepath, options.compression ? `${array.ref.id}.gz` : array.ref.id].join("/"));
    const txt = getContent(url);
    if (txt === null) {
      reject(new Error(`No such array ${url}`));
    } else {
      if (array.dataType === "string") {
        let bText = atob(txt);
        if (options.compression) {
          bText = strFromU8(decompressSync(bText));
        }
        array.values = JSON.parse(bText);
      } else {
        const uint8array = new Uint8Array(Base64.toArrayBuffer(txt));
        array.buffer = new ArrayBuffer(uint8array.length);
        const view = new Uint8Array(array.buffer);
        view.set(uint8array);
        if (options.compression) {
          if (array.dataType === "string" || array.dataType === "JSON") {
            array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));
          } else {
            array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;
          }
        }
        if (array.ref.encode === "JSON") {
          array.values = JSON.parse(array.buffer);
        } else {
          if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
            vtkDebugMacro7(`Swap bytes of ${array.name}`);
            Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);
          }
          array.values = macro.newTypedArray(array.dataType, array.buffer);
        }
        if (array.values.length !== array.size) {
          vtkErrorMacro42(`Error in FetchArray: ${array.name} does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);
        }
      }
      delete array.ref;
      if (--requestCount === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
        instance.invokeBusy(false);
      }
      if (instance == null ? void 0 : instance.modified) {
        instance.modified();
      }
      resolve(array);
    }
  });
}
function fetchImage(instance, url) {
  return new Promise((resolve, reject) => {
    const img = getElement(url);
    if (img) {
      resolve(img);
    } else {
      reject(new Error(`No such image ${url}`));
    }
  });
}
var HtmlDataAccessHelper = {
  fetchJSON,
  fetchText,
  fetchArray,
  fetchImage
};
registerType("html", (options) => HtmlDataAccessHelper);

// node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/HttpDataAccessHelper.js
var {
  vtkErrorMacro: vtkErrorMacro43,
  vtkDebugMacro: vtkDebugMacro8
} = macro;
var requestCount2 = 0;
function openAsyncXHR(method, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const xhr = new XMLHttpRequest();
  xhr.open(method, url, true);
  if (options.headers) {
    Object.entries(options.headers).forEach((_ref) => {
      let [key, value] = _ref;
      return xhr.setRequestHeader(key, value);
    });
  }
  if (options.progressCallback) {
    xhr.addEventListener("progress", options.progressCallback);
  }
  return xhr;
}
function fetchBinary(url) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (options && options.compression && options.compression !== "gz") {
    vtkErrorMacro43("Supported algorithms are: [gz]");
    vtkErrorMacro43(`Unkown compression algorithm: ${options.compression}`);
  }
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR("GET", url, options);
    xhr.onreadystatechange = (e2) => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200 || xhr.status === 0) {
          if (options.compression) {
            resolve(decompressSync(new Uint8Array(xhr.response)).buffer);
          } else {
            resolve(xhr.response);
          }
        } else {
          reject({
            xhr,
            e: e2
          });
        }
      }
    };
    xhr.responseType = "arraybuffer";
    xhr.send();
  });
}
function fetchArray2(instance, baseURL, array) {
  let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (array.ref && !array.ref.pending) {
    return new Promise((resolve, reject) => {
      let url = null;
      if (array.ref.url) {
        url = array.ref.url;
      } else {
        url = [baseURL, array.ref.basepath, options.compression ? `${array.ref.id}.gz` : array.ref.id].join("/");
      }
      const xhr = openAsyncXHR("GET", url, options);
      xhr.onreadystatechange = (e2) => {
        if (xhr.readyState === 1) {
          array.ref.pending = true;
          if (++requestCount2 === 1 && (instance == null ? void 0 : instance.invokeBusy)) {
            instance.invokeBusy(true);
          }
        }
        if (xhr.readyState === 4) {
          array.ref.pending = false;
          if (xhr.status === 200 || xhr.status === 0) {
            array.buffer = xhr.response;
            if (options.compression) {
              if (array.dataType === "string" || array.dataType === "JSON") {
                array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));
              } else {
                array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;
              }
            }
            if (array.ref.encode === "JSON") {
              array.values = JSON.parse(array.buffer);
            } else {
              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
                vtkDebugMacro8(`Swap bytes of ${array.name}`);
                Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);
              }
              array.values = macro.newTypedArray(array.dataType, array.buffer);
            }
            if (array.values.length !== array.size) {
              vtkErrorMacro43(`Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);
            }
            delete array.ref;
            if (--requestCount2 === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
              instance.invokeBusy(false);
            }
            if (instance == null ? void 0 : instance.modified) {
              instance.modified();
            }
            resolve(array);
          } else {
            reject({
              xhr,
              e: e2
            });
          }
        }
      };
      xhr.responseType = options.compression || array.dataType !== "string" ? "arraybuffer" : "text";
      xhr.send();
    });
  }
  return Promise.resolve(array);
}
function fetchJSON2(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR("GET", url, options);
    xhr.onreadystatechange = (e2) => {
      if (xhr.readyState === 1) {
        if (++requestCount2 === 1 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(true);
        }
      }
      if (xhr.readyState === 4) {
        if (--requestCount2 === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(false);
        }
        if (xhr.status === 200 || xhr.status === 0) {
          if (options.compression) {
            resolve(JSON.parse(strFromU8(decompressSync(new Uint8Array(xhr.response)))));
          } else {
            resolve(JSON.parse(xhr.responseText));
          }
        } else {
          reject({
            xhr,
            e: e2
          });
        }
      }
    };
    xhr.responseType = options.compression ? "arraybuffer" : "text";
    xhr.send();
  });
}
function fetchText2(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (options && options.compression && options.compression !== "gz") {
    vtkErrorMacro43("Supported algorithms are: [gz]");
    vtkErrorMacro43(`Unkown compression algorithm: ${options.compression}`);
  }
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR("GET", url, options);
    xhr.onreadystatechange = (e2) => {
      if (xhr.readyState === 1) {
        if (++requestCount2 === 1 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(true);
        }
      }
      if (xhr.readyState === 4) {
        if (--requestCount2 === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(false);
        }
        if (xhr.status === 200 || xhr.status === 0) {
          if (options.compression) {
            resolve(strFromU8(decompressSync(new Uint8Array(xhr.response))));
          } else {
            resolve(xhr.responseText);
          }
        } else {
          reject({
            xhr,
            e: e2
          });
        }
      }
    };
    xhr.responseType = options.compression ? "arraybuffer" : "text";
    xhr.send();
  });
}
function fetchImage2(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return new Promise((resolve, reject) => {
    const img = new Image();
    if (options.crossOrigin) {
      img.crossOrigin = options.crossOrigin;
    }
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}
var HttpDataAccessHelper = {
  fetchArray: fetchArray2,
  fetchJSON: fetchJSON2,
  fetchText: fetchText2,
  fetchBinary,
  // Only for HTTP
  fetchImage: fetchImage2
};
registerType("http", (options) => HttpDataAccessHelper);

// node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/JSZipDataAccessHelper.js
var {
  vtkErrorMacro: vtkErrorMacro44,
  vtkDebugMacro: vtkDebugMacro9
} = macro;
function toMimeType(url) {
  const ext = url.split(".").pop().toLowerCase();
  if (ext === "jpg") {
    return "jpeg";
  }
  return ext;
}
function handleUint8Array(array, compression, done) {
  return (uint8array) => {
    array.buffer = new ArrayBuffer(uint8array.length);
    const view = new Uint8Array(array.buffer);
    view.set(uint8array);
    if (compression) {
      if (array.dataType === "string" || array.dataType === "JSON") {
        array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));
      } else {
        array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;
      }
    }
    if (array.ref.encode === "JSON") {
      array.values = JSON.parse(array.buffer);
    } else {
      if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
        vtkDebugMacro9(`Swap bytes of ${array.name}`);
        Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);
      }
      array.values = macro.newTypedArray(array.dataType, array.buffer);
    }
    if (array.values.length !== array.size) {
      vtkErrorMacro44(`Error in FetchArray: ${array.name} does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);
    }
    done();
  };
}
function handleString(array, compression, done) {
  return (string) => {
    if (compression) {
      array.values = JSON.parse(strFromU8(decompressSync(string)));
    } else {
      array.values = JSON.parse(string);
    }
    done();
  };
}
function removeLeadingSlash2(str) {
  return str[0] === "/" ? str.substr(1) : str;
}
function normalizePath(str) {
  return new URL(str, "http://any").pathname;
}
function cleanUpPath(str) {
  return removeLeadingSlash2(normalizePath(str));
}
function unpack(zipContent) {
  return new Promise((resolve, reject) => {
    if (typeof zipContent === "string") {
      resolve(strToU8(zipContent));
    } else if (zipContent instanceof Blob) {
      resolve(zipContent.arrayBuffer().then((ab) => new Uint8Array(ab)));
    } else if (zipContent instanceof ArrayBuffer) {
      resolve(new Uint8Array(zipContent));
    } else if ((zipContent == null ? void 0 : zipContent.buffer) instanceof ArrayBuffer) {
      resolve(new Uint8Array(zipContent.buffer));
    } else {
      reject(new Error("Invalid datatype to unpack."));
    }
  });
}
function create(createOptions) {
  let ready = false;
  let requestCount3 = 0;
  let decompressedFiles = null;
  let fullRootPath = "";
  unpack(createOptions.zipContent).then((zipFileData) => {
    decompressedFiles = unzipSync(zipFileData);
    ready = true;
    const metaFiles = [];
    Object.keys(decompressedFiles).forEach((relativePath) => {
      if (relativePath.endsWith("index.json")) {
        metaFiles.push(relativePath);
      }
    });
    metaFiles.sort((a2, b2) => a2.length - b2.length);
    fullRootPath = metaFiles[0].replace(/index\.json$/, "");
    if (createOptions.callback) {
      createOptions.callback(decompressedFiles);
    }
  });
  return {
    fetchArray(instance, baseURL, array) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return new Promise((resolve, reject) => {
        if (!ready) {
          vtkErrorMacro44("ERROR!!! zip not ready...");
        }
        const url = cleanUpPath([baseURL, array.ref.basepath, options.compression ? `${array.ref.id}.gz` : array.ref.id].join("/"));
        if (++requestCount3 === 1 && (instance == null ? void 0 : instance.invokeBusy)) {
          instance.invokeBusy(true);
        }
        function doneCleanUp() {
          delete array.ref;
          if (--requestCount3 === 0 && (instance == null ? void 0 : instance.invokeBusy)) {
            instance.invokeBusy(false);
          }
          if (instance == null ? void 0 : instance.modified) {
            instance.modified();
          }
          resolve(array);
        }
        const fileData = decompressedFiles[`${fullRootPath}${url}`];
        if (array.dataType === "string" && !options.compression) {
          const handler = handleString(array, options.compression, doneCleanUp);
          handler(strFromU8(fileData));
        } else {
          const handler = handleUint8Array(array, options.compression, doneCleanUp);
          handler(fileData);
        }
      });
    },
    fetchJSON(instance, url) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro44("ERROR!!! zip not ready...");
      }
      const fileData = decompressedFiles[`${fullRootPath}${path}`];
      if (options.compression) {
        if (options.compression === "gz") {
          const str = strFromU8(decompressSync(fileData));
          return Promise.resolve(JSON.parse(str));
        }
        return Promise.reject(new Error("Invalid compression"));
      }
      return Promise.resolve(JSON.parse(strFromU8(fileData)));
    },
    fetchText(instance, url) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro44("ERROR!!! zip not ready...");
      }
      const fileData = decompressedFiles[`${fullRootPath}${path}`];
      if (options.compression) {
        if (options.compression === "gz") {
          return Promise.resolve(strFromU8(unzipSync(fileData)));
        }
        return Promise.reject(new Error("Invalid compression"));
      }
      return Promise.resolve(strFromU8(fileData));
    },
    fetchImage(instance, url) {
      const path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro44("ERROR!!! zip not ready...");
      }
      const fileData = decompressedFiles[`${fullRootPath}${path}`];
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        const str = fromArrayBuffer(fileData.buffer);
        img.src = `data:image/${toMimeType(path)};base64,${str}`;
      });
    },
    fetchBinary(instance, url) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro44("ERROR!!! zip not ready...");
      }
      const fileData = decompressedFiles[`${fullRootPath}${path}`];
      if (options.compression) {
        if (options.compression === "gz") {
          return Promise.resolve(decompressSync(fileData).buffer);
        }
        return Promise.reject(new Error("Invalid compression"));
      }
      return Promise.resolve(fileData.buffer);
    }
  };
}
var JSZipDataAccessHelper = {
  create
};
registerType("zip", (options) => JSZipDataAccessHelper.create(options));

// node_modules/@kitware/vtk.js/IO/Core/HttpDataSetReader.js
var fieldDataLocations = ["pointData", "cellData", "fieldData"];
var ARRAY_BUILDERS = {
  vtkDataArray: vtkDataArray$1,
  vtkStringArray: vtkStringArray$1
};
var cachedArraysAndPromises = {};
var cachedArraysMetaData = {};
var MiB = 1024 * 1024;
var GEOMETRY_ARRAYS = {
  vtkPolyData(dataset) {
    const arrayToDownload = [];
    arrayToDownload.push(dataset.points);
    ["verts", "lines", "polys", "strips"].forEach((cellName) => {
      if (dataset[cellName]) {
        arrayToDownload.push(dataset[cellName]);
      }
    });
    return arrayToDownload;
  },
  vtkImageData(dataset) {
    return [];
  },
  vtkUnstructuredGrid(dataset) {
    const arrayToDownload = [];
    arrayToDownload.push(dataset.points);
    arrayToDownload.push(dataset.cells);
    arrayToDownload.push(dataset.cellTypes);
    return arrayToDownload;
  },
  vtkRectilinearGrid(dataset) {
    const arrayToDownload = [];
    arrayToDownload.push(dataset.xCoordinates);
    arrayToDownload.push(dataset.yCoordinates);
    arrayToDownload.push(dataset.zCoordinates);
    return arrayToDownload;
  }
};
function processDataSet(publicAPI, model, dataset, fetchArray3, resolve, reject, loadData) {
  const enable = model.enableArray;
  model.arrays = [];
  fieldDataLocations.forEach((location) => {
    if (dataset[location]) {
      dataset[location].arrays.map((i) => i.data).forEach((array) => {
        model.arrays.push({
          name: array.name,
          enable,
          location,
          array,
          registration: array.ref.registration || "addArray"
        });
      });
      dataset[location].arrays = [];
    }
  });
  const pendingPromises = [];
  const {
    progressCallback
  } = model;
  const compression = model.fetchGzip ? "gz" : null;
  GEOMETRY_ARRAYS[dataset.vtkClass](dataset).forEach((array) => {
    pendingPromises.push(fetchArray3(array, {
      compression,
      progressCallback
    }));
  });
  function success() {
    model.dataset = vtk(dataset);
    if (!loadData) {
      model.output[0] = model.dataset;
      resolve(publicAPI, model.output[0]);
    } else {
      publicAPI.loadData().then(() => {
        model.output[0] = model.dataset;
        resolve(publicAPI, model.output[0]);
      });
    }
  }
  if (pendingPromises.length) {
    Promise.all(pendingPromises).then(success, (err) => {
      reject(err);
    });
  } else {
    success();
  }
}
function vtkHttpDataSetReader(publicAPI, model) {
  model.classHierarchy.push("vtkHttpDataSetReader");
  model.output[0] = vtk({
    vtkClass: "vtkPolyData"
  });
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchArray3(array) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const arrayId = `${array.ref.id}|${array.vtkClass}`;
    if (!cachedArraysAndPromises[arrayId]) {
      cachedArraysAndPromises[arrayId] = model.dataAccessHelper.fetchArray(publicAPI, model.baseURL, array, options).then((newArray) => {
        if (!model.maxCacheSize) {
          delete cachedArraysAndPromises[arrayId];
          return newArray;
        }
        cachedArraysAndPromises[arrayId] = newArray;
        cachedArraysMetaData[arrayId] = {
          lastAccess: /* @__PURE__ */ new Date()
        };
        if (model.maxCacheSize < 0) {
          return newArray;
        }
        const cachedArrays = {};
        Object.keys(cachedArraysMetaData).forEach((arrId) => {
          cachedArrays[arrId] = {
            array: cachedArraysAndPromises[arrId],
            lastAccess: cachedArraysMetaData[arrId].lastAccess
          };
        });
        const sortedArrayCache = Object.entries(cachedArrays).sort((a2, b2) => Math.sign(b2[1].lastAccess - a2[1].lastAccess));
        const cacheSizeLimit = model.maxCacheSize * MiB;
        let cacheSize = Object.values(cachedArrays).reduce((accSize, entry) => accSize + entry.array.values.byteLength, 0);
        while (cacheSize > cacheSizeLimit && sortedArrayCache.length > 0) {
          const [oldId, entry] = sortedArrayCache.pop();
          delete cachedArraysAndPromises[oldId];
          delete cachedArraysMetaData[oldId];
          cacheSize -= entry.array.values.byteLength;
        }
        if (!cachedArraysMetaData[arrayId]) {
          macro.vtkWarningMacro("Cache size is too small for the dataset");
        }
        return newArray;
      });
    } else {
      Promise.resolve(cachedArraysAndPromises[arrayId]).then((cachedArray) => {
        if (array !== cachedArray) {
          if (model.maxCacheSize) {
            cachedArraysMetaData[arrayId].lastAccess = /* @__PURE__ */ new Date();
          }
          Object.assign(array, cachedArray);
          delete array.ref;
        }
      });
    }
    return Promise.resolve(cachedArraysAndPromises[arrayId]);
  }
  publicAPI.updateMetadata = function() {
    let loadData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (model.compression === "zip") {
      return new Promise((resolve, reject) => {
        DataAccessHelper.get("http").fetchBinary(model.url).then((zipContent) => {
          model.dataAccessHelper = DataAccessHelper.get("zip", {
            zipContent,
            callback: (zip) => {
              model.baseURL = "";
              model.dataAccessHelper.fetchJSON(publicAPI, "index.json").then((dataset) => {
                publicAPI.parseObject(dataset, {
                  loadData,
                  deepCopy: false
                }).then(resolve, reject);
              }, (error) => {
                reject(error);
              });
            }
          });
        }, (error) => {
          reject(error);
        });
      });
    }
    return new Promise((resolve, reject) => {
      model.dataAccessHelper.fetchJSON(publicAPI, model.url).then((dataset) => {
        publicAPI.parseObject(dataset, {
          loadData,
          deepCopy: false
        }).then(resolve, reject);
      }, (error) => {
        reject(error);
      });
    });
  };
  publicAPI.setUrl = function(url) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (url.indexOf("index.json") === -1 && !options.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.json`;
    } else {
      model.url = url;
      const path = url.split("/");
      path.pop();
      model.baseURL = path.join("/");
    }
    model.compression = options.compression;
    return publicAPI.updateMetadata(!!options.loadData);
  };
  publicAPI.parseObject = (manifest, _ref) => {
    let {
      loadData,
      baseUrl,
      deepCopy = true
    } = _ref;
    if (baseUrl) {
      model.baseURL = baseUrl;
    }
    const dataset = deepCopy ? structuredClone(manifest) : manifest;
    return new Promise((resolve, reject) => {
      processDataSet(publicAPI, model, dataset, fetchArray3, resolve, reject, loadData);
    });
  };
  publicAPI.loadData = () => {
    const datasetObj = model.dataset;
    const arrayToFecth = model.arrays.filter((array) => array.enable).filter((array) => array.array.ref).map((array) => array.array);
    return new Promise((resolve, reject) => {
      const error = (e2) => {
        reject(e2);
      };
      const processNext = () => {
        if (arrayToFecth.length) {
          const {
            progressCallback
          } = model;
          const compression = model.fetchGzip ? "gz" : null;
          fetchArray3(arrayToFecth.pop(), {
            compression,
            progressCallback
          }).then(processNext, error);
        } else if (datasetObj) {
          model.arrays.filter((metaArray) => metaArray.registration && !metaArray.array.ref).forEach((metaArray) => {
            const newArray = ARRAY_BUILDERS[metaArray.array.vtkClass].newInstance(metaArray.array);
            datasetObj[`get${macro.capitalize(metaArray.location)}`]()[metaArray.registration](newArray);
            delete metaArray.registration;
          });
          datasetObj.modified();
          resolve(publicAPI, datasetObj);
        }
      };
      processNext();
    });
  };
  publicAPI.requestData = (inData, outData) => {
  };
  publicAPI.enableArray = function(location, name2) {
    let enable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const activeArray = model.arrays.filter((array) => array.name === name2 && array.location === location);
    if (activeArray.length === 1) {
      activeArray[0].enable = enable;
    }
  };
  publicAPI.getCachedArrayIds = () => Object.keys(cachedArraysMetaData);
  publicAPI.clearCache = () => Object.keys(cachedArraysMetaData).forEach((k) => {
    delete cachedArraysAndPromises[k];
    delete cachedArraysMetaData[k];
  });
  publicAPI.isBusy = () => !!model.requestCount;
}
var DEFAULT_VALUES99 = {
  enableArray: true,
  fetchGzip: false,
  arrays: [],
  url: null,
  baseURL: null,
  requestCount: 0,
  arrayCachingEnabled: true,
  maxCacheSize: 2048
  // dataAccessHelper: null,
};
function extend109(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES99, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["enableArray", "fetchGzip", "url", "baseURL", "dataAccessHelper", "maxCacheSize"]);
  macro.set(publicAPI, model, ["dataAccessHelper", "progressCallback", "maxCacheSize"]);
  macro.getArray(publicAPI, model, ["arrays"]);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, "busy");
  vtkHttpDataSetReader(publicAPI, model);
  if (model.progressCallback === void 0) {
    model.progressCallback = null;
  }
}
var newInstance104 = macro.newInstance(extend109, "vtkHttpDataSetReader");
var vtkHttpDataSetReader$1 = {
  newInstance: newInstance104,
  extend: extend109
};

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js
var ColorSpace = {
  RGB: 0,
  HSV: 1,
  LAB: 2,
  DIVERGING: 3
};
var Scale = {
  LINEAR: 0,
  LOG10: 1
};
var Constants11 = {
  ColorSpace,
  Scale
};

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js
var {
  ColorSpace: ColorSpace2,
  Scale: Scale2
} = Constants11;
var {
  ScalarMappingTarget
} = vtkScalarsToColors$1;
var {
  vtkDebugMacro: vtkDebugMacro10,
  vtkErrorMacro: vtkErrorMacro45,
  vtkWarningMacro: vtkWarningMacro10
} = macro;
function vtkColorTransferFunctionLabToMsh(lab, msh) {
  const L = lab[0];
  const a2 = lab[1];
  const b2 = lab[2];
  const M = Math.sqrt(L * L + a2 * a2 + b2 * b2);
  const s = M > 1e-3 ? Math.acos(L / M) : 0;
  const h = s > 1e-3 ? Math.atan2(b2, a2) : 0;
  msh[0] = M;
  msh[1] = s;
  msh[2] = h;
}
function vtkColorTransferFunctionMshToLab(msh, lab) {
  const M = msh[0];
  const s = msh[1];
  const h = msh[2];
  lab[0] = M * Math.cos(s);
  lab[1] = M * Math.sin(s) * Math.cos(h);
  lab[2] = M * Math.sin(s) * Math.sin(h);
}
function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
  if (msh[0] >= unsatM - 0.1) {
    return msh[2];
  }
  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
  if (msh[2] > -0.3 * Math.PI) {
    return msh[2] + hueSpin;
  }
  return msh[2] - hueSpin;
}
function vtkColorTransferFunctionAngleDiff(a1, a2) {
  let adiff = a1 - a2;
  if (adiff < 0) {
    adiff = -adiff;
  }
  while (adiff >= 2 * Math.PI) {
    adiff -= 2 * Math.PI;
  }
  if (adiff > Math.PI) {
    adiff = 2 * Math.PI - adiff;
  }
  return adiff;
}
function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
  const lab1 = [];
  const lab2 = [];
  rgb2lab(rgb1, lab1);
  rgb2lab(rgb2, lab2);
  const msh1 = [];
  const msh2 = [];
  vtkColorTransferFunctionLabToMsh(lab1, msh1);
  vtkColorTransferFunctionLabToMsh(lab2, msh2);
  let localS = s;
  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
    let Mmid = Math.max(msh1[0], msh2[0]);
    Mmid = Math.max(88, Mmid);
    if (s < 0.5) {
      msh2[0] = Mmid;
      msh2[1] = 0;
      msh2[2] = 0;
      localS *= 2;
    } else {
      msh1[0] = Mmid;
      msh1[1] = 0;
      msh1[2] = 0;
      localS = 2 * localS - 1;
    }
  }
  if (msh1[1] < 0.05 && msh2[1] > 0.05) {
    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
  }
  const mshTmp = [];
  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];
  const labTmp = [];
  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
  lab2rgb(labTmp, result);
}
function vtkColorTransferFunction(publicAPI, model) {
  model.classHierarchy.push("vtkColorTransferFunction");
  publicAPI.getSize = () => model.nodes.length;
  publicAPI.addRGBPoint = (x, r, g, b2) => publicAPI.addRGBPointLong(x, r, g, b2, 0.5, 0);
  publicAPI.addRGBPointLong = function(x, r, g, b2) {
    let midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro45("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro45("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    const node = {
      x,
      r,
      g,
      b: b2,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0);
  publicAPI.addHSVPointLong = function(x, h, s, v) {
    let midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    const rgb = [];
    const hsv = [h, s, v];
    hsv2rgb(hsv, rgb);
    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);
  };
  publicAPI.setNodes = (nodes) => {
    if (model.nodes !== nodes) {
      const before = JSON.stringify(model.nodes);
      model.nodes = nodes;
      const after = JSON.stringify(model.nodes);
      if (publicAPI.sortAndUpdateRange() || before !== after) {
        publicAPI.modified();
        return true;
      }
    }
    return false;
  };
  publicAPI.sortAndUpdateRange = () => {
    const before = JSON.stringify(model.nodes);
    model.nodes.sort((a2, b2) => a2.x - b2.x);
    const after = JSON.stringify(model.nodes);
    const modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked && before !== after) {
      publicAPI.modified();
      return true;
    }
    return modifiedInvoked;
  };
  publicAPI.updateRange = () => {
    const oldRange = [2];
    oldRange[0] = model.mappingRange[0];
    oldRange[1] = model.mappingRange[1];
    const size = model.nodes.length;
    if (size) {
      model.mappingRange[0] = model.nodes[0].x;
      model.mappingRange[1] = model.nodes[size - 1].x;
    } else {
      model.mappingRange[0] = 0;
      model.mappingRange[1] = 0;
    }
    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = (x) => {
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    const retVal = i;
    if (i >= model.nodes.length) {
      return -1;
    }
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.movePoint = (oldX, newX) => {
    if (oldX === newX) {
      return;
    }
    publicAPI.removePoint(newX);
    for (let i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === oldX) {
        model.nodes[i].x = newX;
        publicAPI.sortAndUpdateRange();
        break;
      }
    }
  };
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0);
    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0);
    publicAPI.modified();
  };
  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {
    const hsv1 = [h1, s1, v1];
    const hsv2 = [h2, s2, v2];
    const rgb1 = [];
    const rgb2 = [];
    hsv2rgb(hsv1, rgb1);
    hsv2rgb(hsv2, rgb2);
    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
  };
  publicAPI.mapValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return [Math.floor(255 * rgb[0] + 0.5), Math.floor(255 * rgb[1] + 0.5), Math.floor(255 * rgb[2] + 0.5), 255];
  };
  publicAPI.getColor = (x, rgb) => {
    if (model.indexedLookup) {
      const numNodes = publicAPI.getSize();
      const idx = publicAPI.getAnnotatedValueIndexInternal(x);
      if (idx < 0 || numNodes === 0) {
        const nanColor = publicAPI.getNanColorByReference();
        rgb[0] = nanColor[0];
        rgb[1] = nanColor[1];
        rgb[2] = nanColor[2];
      } else {
        const nodeVal = [];
        publicAPI.getNodeValue(idx % numNodes, nodeVal);
        rgb[0] = nodeVal[1];
        rgb[1] = nodeVal[2];
        rgb[2] = nodeVal[3];
      }
      return;
    }
    publicAPI.getTable(x, x, 1, rgb);
  };
  publicAPI.getRedValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[0];
  };
  publicAPI.getGreenValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[1];
  };
  publicAPI.getBlueValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[2];
  };
  publicAPI.logScaleEnabled = () => model.scale === Scale2.LOG10;
  publicAPI.usingLogScale = () => publicAPI.logScaleEnabled() && model.mappingRange[0] > 0;
  publicAPI.getTable = (xStart_, xEnd_, size, table) => {
    const usingLogScale = publicAPI.usingLogScale();
    const xStart = usingLogScale ? Math.log10(Number(xStart_)) : Number(xStart_);
    const xEnd = usingLogScale ? Math.log10(Number(xEnd_)) : Number(xEnd_);
    if (isNan(xStart) || isNan(xEnd)) {
      for (let i = 0; i < size; i++) {
        table[i * 3 + 0] = model.nanColor[0];
        table[i * 3 + 1] = model.nanColor[1];
        table[i * 3 + 2] = model.nanColor[2];
      }
      return;
    }
    let idx = 0;
    const numNodes = model.nodes.length;
    let lastR = 0;
    let lastG = 0;
    let lastB = 0;
    if (numNodes !== 0) {
      lastR = model.nodes[numNodes - 1].r;
      lastG = model.nodes[numNodes - 1].g;
      lastB = model.nodes[numNodes - 1].b;
    }
    let x = 0;
    let x1 = 0;
    let x2 = 0;
    const rgb1 = [0, 0, 0];
    const rgb2 = [0, 0, 0];
    let midpoint = 0;
    let sharpness = 0;
    const tmpVec = [];
    let scaledMappingRange = model.mappingRange;
    if (usingLogScale) {
      scaledMappingRange = [Math.log10(model.mappingRange[0]), Math.log10(model.mappingRange[1])];
    }
    for (let i = 0; i < size; i++) {
      const tidx = 3 * i;
      if (size > 1) {
        x = xStart + i / (size - 1) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      if (model.discretize) {
        const range = scaledMappingRange;
        if (x >= range[0] && x <= range[1]) {
          const numberOfValues = model.numberOfValues;
          const deltaRange = range[1] - range[0];
          if (numberOfValues <= 1) {
            x = range[0] + deltaRange / 2;
          } else {
            const xn = (x - range[0]) / deltaRange;
            const discretizeIndex = floor(numberOfValues * xn);
            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
          }
        }
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          rgb1[0] = model.nodes[idx - 1].r;
          rgb2[0] = model.nodes[idx].r;
          rgb1[1] = model.nodes[idx - 1].g;
          rgb2[1] = model.nodes[idx].g;
          rgb1[2] = model.nodes[idx - 1].b;
          rgb2[2] = model.nodes[idx].b;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (x > scaledMappingRange[1]) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseAboveRangeColor()) {
            table[tidx] = model.aboveRangeColor[0];
            table[tidx + 1] = model.aboveRangeColor[1];
            table[tidx + 2] = model.aboveRangeColor[2];
          } else {
            table[tidx] = lastR;
            table[tidx + 1] = lastG;
            table[tidx + 2] = lastB;
          }
        }
      } else if (x < scaledMappingRange[0] || isInf(x) && x < 0) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseBelowRangeColor()) {
            table[tidx] = model.belowRangeColor[0];
            table[tidx + 1] = model.belowRangeColor[1];
            table[tidx + 2] = model.belowRangeColor[2];
          } else if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          }
        }
      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {
        if (numNodes > 0) {
          table[tidx] = model.nodes[0].r;
          table[tidx + 1] = model.nodes[0].g;
          table[tidx + 2] = model.nodes[0].b;
        } else {
          table[tidx] = 0;
          table[tidx + 1] = 0;
          table[tidx + 2] = 0;
        }
      } else {
        let s = 0;
        s = (x - x1) / (x2 - x1);
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = rgb1[0];
            table[tidx + 1] = rgb1[1];
            table[tidx + 2] = rgb1[2];
            continue;
          } else {
            table[tidx] = rgb2[0];
            table[tidx + 1] = rgb2[1];
            table[tidx + 2] = rgb2[2];
            continue;
          }
        }
        if (sharpness < 0.01) {
          if (model.colorSpace === ColorSpace2.RGB) {
            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
          } else if (model.colorSpace === ColorSpace2.HSV) {
            const hsv1 = [];
            const hsv2 = [];
            rgb2hsv(rgb1, hsv1);
            rgb2hsv(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1;
              } else {
                hsv2[0] -= 1;
              }
            }
            const hsvTmp = [];
            hsvTmp[0] = (1 - s) * hsv1[0] + s * hsv2[0];
            if (hsvTmp[0] < 0) {
              hsvTmp[0] += 1;
            }
            hsvTmp[1] = (1 - s) * hsv1[1] + s * hsv2[1];
            hsvTmp[2] = (1 - s) * hsv1[2] + s * hsv2[2];
            hsv2rgb(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.LAB) {
            const lab1 = [];
            const lab2 = [];
            rgb2lab(rgb1, lab1);
            rgb2lab(rgb2, lab2);
            const labTmp = [];
            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];
            lab2rgb(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro45("ColorSpace set to invalid value.", model.colorSpace);
          }
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * (s * 2) ** (1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * ((1 - s) * 2) ** (1 + 10 * sharpness);
        }
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;
        let slope;
        let t;
        if (model.colorSpace === ColorSpace2.RGB) {
          for (let j = 0; j < 3; j++) {
            slope = rgb2[j] - rgb1[j];
            t = (1 - sharpness) * slope;
            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
          }
        } else if (model.colorSpace === ColorSpace2.HSV) {
          const hsv1 = [];
          const hsv2 = [];
          rgb2hsv(rgb1, hsv1);
          rgb2hsv(rgb2, hsv2);
          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
            if (hsv1[0] > hsv2[0]) {
              hsv1[0] -= 1;
            } else {
              hsv2[0] -= 1;
            }
          }
          const hsvTmp = [];
          for (let j = 0; j < 3; j++) {
            slope = hsv2[j] - hsv1[j];
            t = (1 - sharpness) * slope;
            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;
            if (j === 0 && hsvTmp[j] < 0) {
              hsvTmp[j] += 1;
            }
          }
          hsv2rgb(hsvTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.LAB) {
          const lab1 = [];
          const lab2 = [];
          rgb2lab(rgb1, lab1);
          rgb2lab(rgb2, lab2);
          const labTmp = [];
          for (let j = 0; j < 3; j++) {
            slope = lab2[j] - lab1[j];
            t = (1 - sharpness) * slope;
            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;
          }
          lab2rgb(labTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.DIVERGING) {
          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else {
          vtkErrorMacro45("ColorSpace set to invalid value.");
        }
        for (let j = 0; j < 3; j++) {
          table[tidx + j] = table[tidx + j] < 0 ? 0 : table[tidx + j];
          table[tidx + j] = table[tidx + j] > 1 ? 1 : table[tidx + j];
        }
      }
    }
  };
  publicAPI.getUint8Table = function(xStart, xEnd, size) {
    let withAlpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {
      return model.table;
    }
    if (model.nodes.length === 0) {
      vtkErrorMacro45("Attempting to lookup a value with no points in the function");
      return model.table;
    }
    const nbChannels = withAlpha ? 4 : 3;
    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {
      model.table = new Uint8Array(size * nbChannels);
      model.tableSize = size;
      model.tableWithAlpha = withAlpha;
    }
    const tmpTable = [];
    publicAPI.getTable(xStart, xEnd, size, tmpTable);
    for (let i = 0; i < size; i++) {
      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255 + 0.5);
      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255 + 0.5);
      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255 + 0.5);
      if (withAlpha) {
        model.table[i * nbChannels + 3] = 255;
      }
    }
    model.buildTime.modified();
    return model.table;
  };
  publicAPI.buildFunctionFromArray = (array) => {
    publicAPI.removeAllPoints();
    const numComponents = array.getNumberOfComponents();
    for (let i = 0; i < array.getNumberOfTuples(); i++) {
      switch (numComponents) {
        case 3: {
          model.nodes.push({
            x: i,
            r: array.getComponent(i, 0),
            g: array.getComponent(i, 1),
            b: array.getComponent(i, 2),
            midpoint: 0.5,
            sharpness: 0
          });
          break;
        }
        case 4: {
          model.nodes.push({
            x: array.getComponent(i, 0),
            r: array.getComponent(i, 1),
            g: array.getComponent(i, 2),
            b: array.getComponent(i, 3),
            midpoint: 0.5,
            sharpness: 0
          });
          break;
        }
        case 5: {
          model.nodes.push({
            x: i,
            r: array.getComponent(i, 0),
            g: array.getComponent(i, 1),
            b: array.getComponent(i, 2),
            midpoint: array.getComponent(i, 4),
            sharpness: array.getComponent(i, 5)
          });
          break;
        }
        case 6: {
          model.nodes.push({
            x: array.getComponent(i, 0),
            r: array.getComponent(i, 1),
            g: array.getComponent(i, 2),
            b: array.getComponent(i, 3),
            midpoint: array.getComponent(i, 4),
            sharpness: array.getComponent(i, 5)
          });
          break;
        }
      }
    }
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {
    let inc = 0;
    publicAPI.removeAllPoints();
    if (size > 1) {
      inc = (xEnd - xStart) / (size - 1);
    }
    for (let i = 0; i < size; i++) {
      const node = {
        x: xStart + inc * i,
        r: table[i * 3],
        g: table[i * 3 + 1],
        b: table[i * 3 + 2],
        sharpness: 0,
        midpoint: 0.5
      };
      model.nodes.push(node);
    }
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.getNodeValue = (index, val) => {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro45("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].r;
    val[2] = model.nodes[index].g;
    val[3] = model.nodes[index].b;
    val[4] = model.nodes[index].midpoint;
    val[5] = model.nodes[index].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = (index, val) => {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro45("Index out of range!");
      return -1;
    }
    const oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].r = val[1];
    model.nodes[index].g = val[2];
    model.nodes[index].b = val[3];
    model.nodes[index].midpoint = val[4];
    model.nodes[index].sharpness = val[5];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.getNumberOfAvailableColors = () => {
    var _a;
    if (model.indexedLookup && publicAPI.getSize()) {
      return publicAPI.getSize();
    }
    if (model.tableSize) {
      return model.tableSize;
    }
    const nNodes = ((_a = model.nodes) == null ? void 0 : _a.length) ?? 0;
    return Math.max(4094, nNodes);
  };
  publicAPI.getIndexedColor = (idx, rgba) => {
    const n = publicAPI.getSize();
    if (n > 0 && idx >= 0) {
      const nodeValue = [];
      publicAPI.getNodeValue(idx % n, nodeValue);
      for (let j = 0; j < 3; ++j) {
        rgba[j] = nodeValue[j + 1];
      }
      rgba[3] = 1;
      return;
    }
    const nanColor = publicAPI.getNanColorByReference();
    rgba[0] = nanColor[0];
    rgba[1] = nanColor[1];
    rgba[2] = nanColor[2];
    rgba[3] = 1;
  };
  publicAPI.fillFromDataPointer = (nb, ptr) => {
    if (nb <= 0 || !ptr) {
      return;
    }
    publicAPI.removeAllPoints();
    for (let i = 0; i < nb; i++) {
      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
    }
  };
  publicAPI.setMappingRange = (min, max2) => {
    const range = [min, max2];
    const scaledRange = [min, max2];
    const originalRange = publicAPI.getRange();
    const logScaleEnabled = publicAPI.logScaleEnabled();
    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
      return;
    }
    if (range[1] === range[0]) {
      vtkErrorMacro45("attempt to set zero width color range");
      return;
    }
    if (logScaleEnabled) {
      if (range[0] <= 0) {
        console.warn("attempt to set log scale color range with non-positive minimum");
      } else {
        scaledRange[0] = Math.log10(range[0]);
        scaledRange[1] = Math.log10(range[1]);
      }
    }
    const scale = (scaledRange[1] - scaledRange[0]) / (originalRange[1] - originalRange[0]);
    const shift = scaledRange[0] - originalRange[0] * scale;
    for (let i = 0; i < model.nodes.length; ++i) {
      model.nodes[i].x = model.nodes[i].x * scale + shift;
    }
    model.mappingRange[0] = range[0];
    model.mappingRange[1] = range[1];
    publicAPI.modified();
  };
  publicAPI.adjustRange = (range) => {
    const functionRange = publicAPI.getRange();
    const rgb = [];
    if (functionRange[0] < range[0]) {
      publicAPI.getColor(range[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    }
    if (functionRange[1] > range[1]) {
      publicAPI.getColor(range[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    }
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d2 = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d2);
  };
  publicAPI.findMinimumXDistance = () => {
    if (model.nodes.length < 2) {
      return -1;
    }
    let distance = Number.MAX_VALUE;
    for (let i = 0; i < model.nodes.length - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkDebugMacro10("Transfer Function Has No Points!");
      return;
    }
    if (model.indexedLookup) {
      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
    } else {
      publicAPI.mapData(input, output, outFormat, inputOffset);
    }
  };
  publicAPI.mapData = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkWarningMacro10("Transfer Function Has No Points!");
      return;
    }
    const alpha = Math.floor(publicAPI.getAlpha() * 255 + 0.5);
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    const rgb = [];
    if (outFormat === ScalarMappingTarget.RGBA) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 4] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255 + 0.5);
        outputV[i * 4 + 3] = alpha;
      }
    }
    if (outFormat === ScalarMappingTarget.RGB) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 3] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
        outputV[i * 2 + 1] = alpha;
      }
    }
  };
  publicAPI.applyColorMap = (colorMap) => {
    const oldColorSpace = JSON.stringify(model.colorSpace);
    if (colorMap.ColorSpace) {
      model.colorSpace = ColorSpace2[colorMap.ColorSpace.toUpperCase()];
      if (model.colorSpace === void 0) {
        vtkErrorMacro45(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);
        model.colorSpace = ColorSpace2.RGB;
      }
    }
    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);
    const oldNanColor = isModified || JSON.stringify(model.nanColor);
    if (colorMap.NanColor) {
      model.nanColor = [].concat(colorMap.NanColor);
      while (model.nanColor.length < 4) {
        model.nanColor.push(1);
      }
    }
    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);
    const oldNodes = isModified || JSON.stringify(model.nodes);
    if (colorMap.RGBPoints) {
      const size = colorMap.RGBPoints.length;
      model.nodes = [];
      const midpoint = 0.5;
      const sharpness = 0;
      for (let i = 0; i < size; i += 4) {
        model.nodes.push({
          x: colorMap.RGBPoints[i],
          r: colorMap.RGBPoints[i + 1],
          g: colorMap.RGBPoints[i + 2],
          b: colorMap.RGBPoints[i + 3],
          midpoint,
          sharpness
        });
      }
    }
    const modifiedInvoked = publicAPI.sortAndUpdateRange();
    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));
    if (callModified) publicAPI.modified();
    return modifiedInvoked || callModified;
  };
}
var DEFAULT_VALUES100 = {
  clamping: true,
  colorSpace: ColorSpace2.RGB,
  hSVWrap: true,
  scale: Scale2.LINEAR,
  nanColor: null,
  belowRangeColor: null,
  aboveRangeColor: null,
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  allowDuplicateScalars: false,
  table: null,
  tableSize: 0,
  buildTime: null,
  nodes: null,
  discretize: false,
  numberOfValues: 256
};
function extend110(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES100, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  model.table = [];
  model.nodes = [];
  model.nanColor = [0.5, 0, 0, 1];
  model.belowRangeColor = [0, 0, 0, 1];
  model.aboveRangeColor = [1, 1, 1, 1];
  model.buildTime = {};
  macro.obj(model.buildTime);
  macro.get(publicAPI, model, ["buildTime", "mappingRange"]);
  macro.setGet(publicAPI, model, ["useAboveRangeColor", "useBelowRangeColor", "discretize", "numberOfValues", {
    type: "enum",
    name: "colorSpace",
    enum: ColorSpace2
  }, {
    type: "enum",
    name: "scale",
    enum: Scale2
  }]);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkColorTransferFunction(publicAPI, model);
}
var newInstance105 = macro.newInstance(extend110, "vtkColorTransferFunction");
var vtkColorTransferFunction$1 = {
  newInstance: newInstance105,
  extend: extend110,
  ...Constants11
};

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var InterpolationType = {
  NEAREST: 0,
  LINEAR: 1,
  FAST_LINEAR: 2
};
var OpacityMode = {
  FRACTIONAL: 0,
  PROPORTIONAL: 1
};
var ColorMixPreset = {
  DEFAULT: 0,
  ADDITIVE: 1,
  COLORIZE: 2,
  CUSTOM: 3
};
var FilterMode = {
  OFF: 0,
  NORMALIZED: 1,
  RAW: 2
};
var Constants12 = {
  InterpolationType,
  OpacityMode,
  ColorMixPreset,
  FilterMode
};

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty.js
var {
  InterpolationType: InterpolationType2,
  OpacityMode: OpacityMode2,
  FilterMode: FilterMode2,
  ColorMixPreset: ColorMixPreset2
} = Constants12;
var {
  vtkErrorMacro: vtkErrorMacro46
} = macro;
var VTK_MAX_VRCOMP = 4;
function vtkVolumeProperty(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeProperty");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index = 0; index < VTK_MAX_VRCOMP; index++) {
      if (model.componentData[index].colorChannels === 1) {
        if (model.componentData[index].grayTransferFunction) {
          time = model.componentData[index].grayTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      } else if (model.componentData[index].colorChannels === 3) {
        if (model.componentData[index].rGBTransferFunction) {
          time = model.componentData[index].rGBTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
      if (model.componentData[index].scalarOpacity) {
        time = model.componentData[index].scalarOpacity.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index].gradientOpacity) {
        if (!model.componentData[index].disableGradientOpacity) {
          time = model.componentData[index].gradientOpacity.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
    }
    return mTime;
  };
  publicAPI.getColorChannels = (index) => {
    if (index < 0 || index > 3) {
      vtkErrorMacro46("Bad index - must be between 0 and 3");
      return 0;
    }
    return model.componentData[index].colorChannels;
  };
  publicAPI.setGrayTransferFunction = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index].grayTransferFunction !== func) {
      model.componentData[index].grayTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 1) {
      model.componentData[index].colorChannels = 1;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getGrayTransferFunction = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.componentData[index].grayTransferFunction === null) {
      model.componentData[index].grayTransferFunction = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index].grayTransferFunction.addPoint(0, 0);
      model.componentData[index].grayTransferFunction.addPoint(1024, 1);
      if (model.componentData[index].colorChannels !== 1) {
        model.componentData[index].colorChannels = 1;
      }
      publicAPI.modified();
    }
    return model.componentData[index].grayTransferFunction;
  };
  publicAPI.setRGBTransferFunction = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index].rGBTransferFunction !== func) {
      model.componentData[index].rGBTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 3) {
      model.componentData[index].colorChannels = 3;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getRGBTransferFunction = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.componentData[index].rGBTransferFunction === null) {
      model.componentData[index].rGBTransferFunction = vtkColorTransferFunction$1.newInstance();
      model.componentData[index].rGBTransferFunction.addRGBPoint(0, 0, 0, 0);
      model.componentData[index].rGBTransferFunction.addRGBPoint(1024, 1, 1, 1);
      if (model.componentData[index].colorChannels !== 3) {
        model.componentData[index].colorChannels = 3;
      }
      publicAPI.modified();
    }
    return model.componentData[index].rGBTransferFunction;
  };
  publicAPI.setScalarOpacity = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.componentData[index].scalarOpacity !== func) {
      model.componentData[index].scalarOpacity = func;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getScalarOpacity = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.componentData[index].scalarOpacity === null) {
      model.componentData[index].scalarOpacity = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index].scalarOpacity.addPoint(0, 1);
      model.componentData[index].scalarOpacity.addPoint(1024, 1);
      publicAPI.modified();
    }
    return model.componentData[index].scalarOpacity;
  };
  publicAPI.setComponentWeight = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro46("Invalid index");
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index].componentWeight !== val) {
      model.componentData[index].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro46("Invalid index");
      return 0;
    }
    return model.componentData[index].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType2.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType2.LINEAR);
  publicAPI.setInterpolationTypeToFastLinear = () => publicAPI.setInterpolationType(InterpolationType2.FAST_LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macro.enumToString(InterpolationType2, model.interpolationType);
  const sets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode", "forceNearestInterpolation"];
  sets.forEach((val) => {
    const cap = macro.capitalize(val);
    publicAPI[`set${cap}`] = (index, value) => {
      if (model.componentData[index][`${val}`] !== value) {
        model.componentData[index][`${val}`] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  });
  const gets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode", "forceNearestInterpolation"];
  gets.forEach((val) => {
    const cap = macro.capitalize(val);
    publicAPI[`get${cap}`] = (index) => model.componentData[index][`${val}`];
  });
  publicAPI.setAverageIPScalarRange = (min, max2) => {
    console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange");
    publicAPI.setIpScalarRange(min, max2);
  };
  publicAPI.getFilterModeAsString = () => macro.enumToString(FilterMode2, model.filterMode);
  publicAPI.setFilterModeToOff = () => {
    publicAPI.setFilterMode(FilterMode2.OFF);
  };
  publicAPI.setFilterModeToNormalized = () => {
    publicAPI.setFilterMode(FilterMode2.NORMALIZED);
  };
  publicAPI.setFilterModeToRaw = () => {
    publicAPI.setFilterMode(FilterMode2.RAW);
  };
  publicAPI.setGlobalIlluminationReach = (gl) => superClass.setGlobalIlluminationReach(clampValue(gl, 0, 1));
  publicAPI.setVolumetricScatteringBlending = (vsb) => superClass.setVolumetricScatteringBlending(clampValue(vsb, 0, 1));
  publicAPI.setAnisotropy = (at) => superClass.setAnisotropy(clampValue(at, -0.99, 0.99));
  publicAPI.setLAOKernelSize = (ks) => superClass.setLAOKernelSize(floor(clampValue(ks, 1, 32)));
  publicAPI.setLAOKernelRadius = (kr) => superClass.setLAOKernelRadius(kr >= 1 ? kr : 1);
}
var defaultValues11 = (initialValues) => ({
  colorMixPreset: ColorMixPreset2.DEFAULT,
  independentComponents: true,
  interpolationType: InterpolationType2.FAST_LINEAR,
  shade: false,
  ambient: 0.1,
  diffuse: 0.7,
  specular: 0.2,
  specularPower: 10,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1,
  // Properties moved from volume mapper
  ipScalarRange: [-1e6, 1e6],
  filterMode: FilterMode2.OFF,
  // ignored by WebGL so no behavior change
  preferSizeOverAccuracy: false,
  // Whether to use halfFloat representation of float, when it is inaccurate
  computeNormalFromOpacity: false,
  // volume shadow parameters
  volumetricScatteringBlending: 0,
  globalIlluminationReach: 0,
  anisotropy: 0,
  // local ambient occlusion
  localAmbientOcclusion: false,
  LAOKernelSize: 15,
  LAOKernelRadius: 7,
  updatedExtents: [],
  ...initialValues
});
function extend111(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues11(initialValues));
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0; i < VTK_MAX_VRCOMP; ++i) {
      model.componentData.push({
        colorChannels: 1,
        grayTransferFunction: null,
        rGBTransferFunction: null,
        scalarOpacity: null,
        scalarOpacityUnitDistance: 1,
        opacityMode: OpacityMode2.FRACTIONAL,
        gradientOpacityMinimumValue: 0,
        gradientOpacityMinimumOpacity: 0,
        gradientOpacityMaximumValue: 1,
        gradientOpacityMaximumOpacity: 1,
        useGradientOpacity: false,
        componentWeight: 1,
        forceNearestInterpolation: false
      });
    }
  }
  macro.setGet(publicAPI, model, [
    "colorMixPreset",
    "independentComponents",
    "interpolationType",
    "shade",
    "ambient",
    "diffuse",
    "specular",
    "specularPower",
    "useLabelOutline",
    "labelOutlineOpacity",
    // Properties moved from volume mapper
    "filterMode",
    "preferSizeOverAccuracy",
    "computeNormalFromOpacity",
    "volumetricScatteringBlending",
    "globalIlluminationReach",
    "anisotropy",
    "localAmbientOcclusion",
    "LAOKernelSize",
    "LAOKernelRadius",
    "updatedExtents"
  ]);
  macro.setGetArray(publicAPI, model, ["ipScalarRange"], 2);
  macro.setGetArray(publicAPI, model, ["labelOutlineThickness"]);
  vtkVolumeProperty(publicAPI, model);
}
var newInstance106 = macro.newInstance(extend111, "vtkVolumeProperty");
var vtkVolumeProperty$1 = {
  newInstance: newInstance106,
  extend: extend111,
  ...Constants12
};

// node_modules/@kitware/vtk.js/Rendering/Core/Volume.js
function vtkVolume(publicAPI, model) {
  model.classHierarchy.push("vtkVolume");
  publicAPI.getVolumes = () => [publicAPI];
  publicAPI.makeProperty = vtkVolumeProperty$1.newInstance;
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
}
var DEFAULT_VALUES101 = {
  mapper: null
};
function extend112(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES101, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.setGet(publicAPI, model, ["mapper"]);
  vtkVolume(publicAPI, model);
}
var newInstance107 = macro.newInstance(extend112, "vtkVolume");
var vtkVolume$1 = {
  newInstance: newInstance107,
  extend: extend112
};

// node_modules/@kitware/vtk.js/IO/Core/HttpDataSetSeriesReader.js
var HTTP_DATA_ACCESS = DataAccessHelper.get("http");
function processDataSet2(publicAPI, model, dataset, resolve, reject, loadData) {
  model.readers = [];
  const pendingPromises = [];
  dataset.series.forEach((timeStep) => {
    const newReader = vtkHttpDataSetReader$1.newInstance({
      fetchGzip: model.fetchGzip,
      dataAccessHelper: model.dataAccessHelper
    });
    pendingPromises.push(newReader.setUrl(`${model.baseURL}/${timeStep.url}`, {
      loadData
    }));
    model.readers.push({
      timeStep: timeStep.timeStep,
      reader: newReader
    });
  });
  return Promise.all(pendingPromises).then(() => {
    const range = publicAPI.getTimeRange();
    if (range && range.length !== 0) {
      publicAPI.setUpdateTimeStep(range[0]);
    }
    resolve(publicAPI);
  }, (error) => {
    reject(error);
  });
}
function vtkHttpDataSetSeriesReader(publicAPI, model) {
  model.classHierarchy.push("vtkHttpDataSetSeriesReader");
  model.output[0] = vtk({
    vtkClass: "vtkPolyData"
  });
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = HTTP_DATA_ACCESS;
  }
  model.currentReader = null;
  publicAPI.updateMetaData = function() {
    let loadData = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (model.compression === "zip") {
      return new Promise((resolve, reject) => {
        HTTP_DATA_ACCESS.fetchBinary(model.baseURL).then((zipContent) => {
          model.dataAccessHelper = DataAccessHelper.get("zip", {
            zipContent,
            callback: (zip) => {
              model.baseURL = "";
              model.dataAccessHelper.fetchJSON(publicAPI, "index.json").then((dataset) => {
                processDataSet2(publicAPI, model, dataset, resolve, reject, loadData);
              }, (error) => {
                reject(error);
              });
            }
          });
        });
      });
    }
    return new Promise((resolve, reject) => {
      model.dataAccessHelper.fetchJSON(publicAPI, model.url).then((dataset) => processDataSet2(publicAPI, model, dataset, resolve, reject, loadData), (error) => {
        reject(error);
      });
    });
  };
  publicAPI.setUrl = function(url) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!url.endsWith("index.json") && !options.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.json`;
    } else {
      model.url = url;
      const path = url.split("/");
      path.pop();
      model.baseURL = path.join("/");
    }
    model.compression = options.compression;
    return publicAPI.updateMetaData(options.loadData);
  };
  publicAPI.getTimeSteps = () => model.readers.map((reader) => reader.timeStep).sort();
  publicAPI.getTimeRange = () => {
    const timeSteps = publicAPI.getTimeSteps();
    const length = timeSteps.length;
    if (length >= 1) {
      return [timeSteps[0], timeSteps[length - 1]];
    }
    return [];
  };
  publicAPI.setUpdateTimeStep = (timeStep) => {
    const reader = model.readers.reduce((newReader, currentReader) => {
      if (currentReader.timeStep <= timeStep) {
        return currentReader;
      }
      return newReader;
    });
    if (reader === void 0) {
      return;
    }
    model.currentReader = reader.reader;
    model.output[0] = model.currentReader.getOutputData();
    model.output[0].modified();
    publicAPI.modified();
  };
  publicAPI.requestData = (inData, outData) => {
    if (model.currentReader) {
      outData[0] = model.currentReader.getOutputData();
    }
  };
  publicAPI.enableArray = function(location, name2) {
    let enable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (model.currentReader) {
      model.currentReader.reader.enableArray(location, name2, enable);
    }
  };
  publicAPI.loadData = () => {
    if (model.currentReader) {
      model.currentReader.reader.loadData();
    }
  };
}
var DEFAULT_VALUES102 = {
  fetchGzip: false,
  url: null,
  baseURL: null,
  dataAccessHelper: null
};
function extend113(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES102, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.set(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkHttpDataSetSeriesReader(publicAPI, model);
}
var newInstance108 = macro.newInstance(extend113, "vtkHttpDataSetSeriesReader");
var vtkHttpDataSetSeriesReader$1 = {
  newInstance: newInstance108,
  extend: extend113
};

// node_modules/@kitware/vtk.js/Rendering/Misc/TextureLODsDownloader.js
var {
  vtkErrorMacro: vtkErrorMacro47
} = macro;
var getRemoteFileSize = (url) => (
  // This function only works if the server provides a 'Content-Length'.
  // For some reason, the 'Content-Length' header does not appear to be
  // given for CORS HEAD requests on firefox. So this will not work on
  // firefox if the images do not have the same origin as the html file.
  // TODO: figure out how to make this work for CORS requests on firefox.
  new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("HEAD", url, true);
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          const size = xhr.getResponseHeader("Content-Length");
          resolve(size);
        } else {
          console.log("Failed to get remote file size of", url);
          reject(xhr);
        }
      }
    };
    xhr.send();
  })
);
function vtkTextureLODsDownloader(publicAPI, model) {
  model.classHierarchy.push("vtkTextureLODsDownloader");
  const internal = {
    downloadStack: []
  };
  publicAPI.startDownloads = () => {
    if (!model.texture) {
      vtkErrorMacro47("Texture was not set.");
      return;
    }
    if (!model.files || model.files.length === 0) {
      vtkErrorMacro47("No files set.");
      return;
    }
    let baseUrl = model.baseUrl;
    if (baseUrl && !baseUrl.endsWith("/")) {
      baseUrl += "/";
    }
    internal.downloadStack = [];
    model.files.forEach((file) => internal.downloadStack.push(`${baseUrl}${file}`));
    const downloadNextTexture = () => {
      if (internal.downloadStack.length === 0) {
        return;
      }
      const asyncDownloadNextTexture = () => {
        setTimeout(downloadNextTexture, model.waitTimeBetweenDownloads);
      };
      const img = new Image();
      if (model.crossOrigin) {
        img.crossOrigin = model.crossOrigin;
      }
      const url = internal.downloadStack.shift();
      getRemoteFileSize(url).then((size) => {
        if (!size || size / 1024 > model.maxTextureLODSize) {
          if (!size) {
            console.log("Failed to get image size");
          } else {
            console.log("Skipping image", url, ", because it is larger", "than the max texture size:", model.maxTextureLODSize, "KiB");
          }
          asyncDownloadNextTexture();
          return;
        }
        img.src = url;
        img.decode().then(() => {
          model.texture.setImage(img);
          if (model.stepFinishedCallback) {
            model.stepFinishedCallback();
          }
          asyncDownloadNextTexture();
        }).catch((encodingError) => {
          console.log("Failed to decode image:", img.src);
          console.log("Error is:", encodingError);
          asyncDownloadNextTexture();
        });
      }).catch((xhr) => {
        console.log("Failed to get size of:", url);
        console.log("status was:", xhr.status);
        console.log("statusText was:", xhr.statusText);
        asyncDownloadNextTexture();
      });
    };
    setTimeout(downloadNextTexture, model.waitTimeToStart);
  };
}
var DEFAULT_VALUES103 = {
  baseUrl: "",
  files: [],
  texture: null,
  crossOrigin: void 0,
  // The max texture LOD file size in KiB
  maxTextureLODSize: 5e4,
  stepFinishedCallback: null,
  // These are in milliseconds
  waitTimeToStart: 4e3,
  waitTimeBetweenDownloads: 0
};
function extend114(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES103, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["baseUrl", "files", "texture", "crossOrigin", "maxTextureLODSize", "stepFinishedCallback", "waitTimeToStart", "waitTimeBetweenDownloads"]);
  vtkTextureLODsDownloader(publicAPI, model);
}
var newInstance109 = macro.newInstance(extend114, "vtkTextureLODsDownloader");
var vtkTextureLODsDownloader$1 = {
  newInstance: newInstance109,
  extend: extend114
};

// node_modules/@kitware/vtk.js/IO/Misc/HttpDataSetLODsLoader.js
var {
  vtkErrorMacro: vtkErrorMacro48
} = macro;
function vtkHttpDataSetLODsLoader(publicAPI, model) {
  model.classHierarchy.push("vtkHttpDataSetLODsLoader");
  const internal = {
    downloadStack: []
  };
  publicAPI.startDownloads = () => {
    if (!model.mapper) {
      vtkErrorMacro48("Mapper was not set.");
      return;
    }
    if (!model.files || model.files.length === 0) {
      vtkErrorMacro48("No files set.");
      return;
    }
    let baseUrl = model.baseUrl;
    if (baseUrl && !baseUrl.endsWith("/")) {
      baseUrl += "/";
    }
    internal.downloadStack = [];
    model.files.forEach((file) => internal.downloadStack.push(`${baseUrl}${file}`));
    const downloadNextSource = () => {
      const url = internal.downloadStack.shift();
      const nextSource = vtkHttpDataSetReader$1.newInstance({
        dataAccessHelper: DataAccessHelper.get("http")
      });
      model.currentSource = nextSource;
      const options = {
        compression: "zip",
        loadData: true,
        fullpath: true
      };
      nextSource.setUrl(url, options).then(() => {
        model.mapper.setInputConnection(nextSource.getOutputPort());
        if (model.sceneItem) {
          const settings = model.sceneItem.defaultSettings;
          if (settings.mapper) {
            if (settings.mapper.colorByArrayName) {
              nextSource.enableArray(settings.mapper.colorByArrayName, settings.mapper.colorByArrayName);
            }
          }
          model.sceneItem.source = nextSource;
        }
        if (model.stepFinishedCallback) {
          model.stepFinishedCallback();
        }
        if (internal.downloadStack.length !== 0) {
          setTimeout(downloadNextSource, model.waitTimeBetweenDownloads);
        }
      });
    };
    setTimeout(downloadNextSource, model.waitTimeToStart);
  };
}
var DEFAULT_VALUES104 = {
  baseUrl: "",
  // The currentSource is set internally to the most recently
  // created source. It might be useful to access it in a callback
  // via 'getCurrentSource'.
  currentSource: null,
  files: [],
  mapper: null,
  sceneItem: null,
  stepFinishedCallback: null,
  // These are in milliseconds
  waitTimeToStart: 4e3,
  waitTimeBetweenDownloads: 0
};
function extend115(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES104, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["baseUrl", "files", "mapper", "sceneItem", "stepFinishedCallback", "waitTimeToStart", "waitTimeBetweenDownloads"]);
  macro.get(publicAPI, model, ["currentSource"]);
  vtkHttpDataSetLODsLoader(publicAPI, model);
}
var newInstance110 = macro.newInstance(extend115, "vtkHttpDataSetLODsLoader");
var vtkHttpDataSetLODsLoader$1 = {
  newInstance: newInstance110,
  extend: extend115
};

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper.js
var {
  BlendMode: BlendMode2
} = Constants2;
function createRadonTransferFunction(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption, maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption, outputTransferFunction) {
  let ofun = null;
  if (outputTransferFunction) {
    ofun = outputTransferFunction;
    ofun.removeAllPoints();
  } else {
    ofun = vtkPiecewiseFunction$1.newInstance();
  }
  ofun.addPointLong(-1024, 0, 1, 1);
  ofun.addPoint(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption);
  ofun.addPoint(maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption);
  return ofun;
}
var methodNamesMovedToVolumeProperties = ["getAnisotropy", "getComputeNormalFromOpacity", "getFilterMode", "getFilterModeAsString", "getGlobalIlluminationReach", "getIpScalarRange", "getIpScalarRangeByReference", "getLAOKernelRadius", "getLAOKernelSize", "getLocalAmbientOcclusion", "getPreferSizeOverAccuracy", "getVolumetricScatteringBlending", "setAnisotropy", "setAverageIPScalarRange", "setComputeNormalFromOpacity", "setFilterMode", "setFilterModeToNormalized", "setFilterModeToOff", "setFilterModeToRaw", "setGlobalIlluminationReach", "setIpScalarRange", "setIpScalarRangeFrom", "setLAOKernelRadius", "setLAOKernelSize", "setLocalAmbientOcclusion", "setPreferSizeOverAccuracy", "setVolumetricScatteringBlending"];
var STATIC9 = {
  createRadonTransferFunction
};
function vtkVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getBounds = () => {
    if (!model.static) {
      publicAPI.update();
    }
    model.bounds = [...publicAPI.getInputData().getBounds()];
    return model.bounds;
  };
  publicAPI.setBlendModeToComposite = () => {
    publicAPI.setBlendMode(BlendMode2.COMPOSITE_BLEND);
  };
  publicAPI.setBlendModeToMaximumIntensity = () => {
    publicAPI.setBlendMode(BlendMode2.MAXIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToMinimumIntensity = () => {
    publicAPI.setBlendMode(BlendMode2.MINIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAverageIntensity = () => {
    publicAPI.setBlendMode(BlendMode2.AVERAGE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAdditiveIntensity = () => {
    publicAPI.setBlendMode(BlendMode2.ADDITIVE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToRadonTransform = () => {
    publicAPI.setBlendMode(BlendMode2.RADON_TRANSFORM_BLEND);
  };
  publicAPI.getBlendModeAsString = () => macro.enumToString(BlendMode2, model.blendMode);
  publicAPI.setVolumeShadowSamplingDistFactor = (vsdf) => superClass.setVolumeShadowSamplingDistFactor(vsdf >= 1 ? vsdf : 1);
  methodNamesMovedToVolumeProperties.forEach((removedMethodName) => {
    const removedMethod = () => {
      throw new Error(`The method "volumeMapper.${removedMethodName}()" doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:
volumeActor.getProperty().${removedMethodName}()
`);
    };
    publicAPI[removedMethodName] = removedMethod;
  });
}
var defaultValues12 = (initialValues) => ({
  bounds: [...vtkBoundingBox.INIT_BOUNDS],
  sampleDistance: 1,
  imageSampleDistance: 1,
  maximumSamplesPerRay: 1e3,
  autoAdjustSampleDistances: true,
  initialInteractionScale: 1,
  interactionSampleDistanceFactor: 1,
  blendMode: BlendMode2.COMPOSITE_BLEND,
  volumeShadowSamplingDistFactor: 5,
  colorTextureWidth: 1024,
  opacityTextureWidth: 1024,
  labelOutlineTextureWidth: 1024,
  ...initialValues
});
function extend116(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues12(initialValues));
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["sampleDistance", "imageSampleDistance", "maximumSamplesPerRay", "autoAdjustSampleDistances", "initialInteractionScale", "interactionSampleDistanceFactor", "blendMode", "volumeShadowSamplingDistFactor", "colorTextureWidth", "opacityTextureWidth", "labelOutlineTextureWidth"]);
  macro.event(publicAPI, model, "lightingActivated");
  vtkVolumeMapper(publicAPI, model);
}
var newInstance111 = macro.newInstance(extend116, "vtkVolumeMapper");
var vtkVolumeMapper$1 = {
  newInstance: newInstance111,
  extend: extend116,
  ...STATIC9
};

// node_modules/@kitware/vtk.js/Interaction/Animations/TimeStepBasedAnimationHandler.js
function vtkTimeStepBasedAnimationHandler(publicAPI, model) {
  publicAPI.setCurrentTimeStep = (time) => {
    if (!model.timeSteps || model.timeSteps.length === 0) {
      return;
    }
    if (model.timeSteps.includes(time)) {
      model.currentTimeStep = time;
    } else if (time <= model.timeSteps[0]) {
      model.currentTimeStep = model.timeSteps[0];
    } else {
      model.currentTimeStep = model.timeSteps.find((prevTime, index, array) => {
        if (index === array.length - 1) {
          return true;
        }
        return time >= prevTime && time < array[index + 1];
      });
    }
    publicAPI.update();
  };
  publicAPI.setData = (data2) => {
    model.data = data2;
    if (data2.timeSteps) {
      model.timeSteps = data2.timeSteps.map((timeStep) => timeStep.time);
      model.timeRange = [model.timeSteps[0], model.timeSteps[model.timeSteps.length - 1]];
      model.currentTimeStep = model.timeSteps[0];
    }
  };
  publicAPI.setScene = (scene, originalMetadata, applySettings2, renderer) => {
    model.scene = scene;
    model.originalMetadata = originalMetadata;
    model.applySettings = applySettings2;
    model.renderer = renderer;
  };
  publicAPI.setCameraParameters = (params) => {
    if (model.renderers) {
      model.renderers.forEach((renderer) => {
        const camera = renderer.getActiveCamera();
        if (camera) {
          camera.set(params);
        }
      });
    }
  };
  publicAPI.setBackground = (color4) => {
    if (model.renderers) {
      model.renderers.forEach((renderer) => {
        renderer.setBackground(color4);
      });
    }
  };
  publicAPI.update = () => {
    if (!model.data || !model.scene) {
      return;
    }
    const currentScene = model.data.timeSteps.find((scene) => scene.time === model.currentTimeStep);
    if (currentScene.camera) {
      const camera = {
        ...model.originalMetadata.camera
      };
      Object.assign(camera, currentScene.camera);
      publicAPI.setCameraParameters(camera);
    }
    if (currentScene.background) {
      publicAPI.setBackground(currentScene.background);
    }
    if (model.scene) {
      model.scene.forEach((sceneItem) => {
        if (sceneItem.source.setUpdateTimeStep && sceneItem.source.getTimeSteps().includes(model.currentTimeStep)) {
          sceneItem.source.setUpdateTimeStep(model.currentTimeStep);
        }
        const id = sceneItem.id;
        if (currentScene[id]) {
          const settings = {
            ...sceneItem.defaultSettings
          };
          Object.assign(settings, currentScene[id]);
          model.applySettings(sceneItem, settings);
        }
      });
    }
  };
  publicAPI.addRenderer = (renderer) => {
    if (renderer && !model.renderers.includes(renderer)) {
      model.renderers.push(renderer);
    }
  };
}
var DEFAULT_VALUES105 = {
  timeSteps: [0],
  timeRange: [0, 0],
  currentTimeStep: 0,
  scene: null,
  data: null,
  renderers: [],
  applySettings: null,
  originalMetadata: null
};
function extend117(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES105, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["applySettings", "currentTimeStep", "data", "originalMetada", "scene", "timeRange", "timeSteps"]);
  macro.setGet(publicAPI, model, ["renderers"]);
  vtkTimeStepBasedAnimationHandler(publicAPI, model);
}
var newInstance112 = macro.newInstance(extend117, "vtkTimeStepBasedAnimationHandler");
var vtkTimeStepBasedAnimationHandler$1 = {
  newInstance: newInstance112,
  extend: extend117
};

// node_modules/@kitware/vtk.js/IO/Core/HttpSceneLoader.js
var {
  vtkErrorMacro: vtkErrorMacro49
} = macro;
var itemCount = 1;
function applySettings(sceneItem, settings) {
  if (settings.actor) {
    sceneItem.actor.set(settings.actor);
  }
  if (settings.actorRotation) {
    sceneItem.actor.rotateWXYZ(settings.actorRotation[0], settings.actorRotation[1], settings.actorRotation[2], settings.actorRotation[3]);
  }
  if (settings.volumeRotation) {
    sceneItem.volume.rotateWXYZ(settings.volumeRotation[0], settings.volumeRotation[1], settings.volumeRotation[2], settings.volumeRotation[3]);
  }
  if (settings.property) {
    if (settings.volume) {
      const volumePropertySettings = {
        ...settings.property
      };
      delete volumePropertySettings.components;
      sceneItem.volume.getProperty().set(volumePropertySettings);
      if (settings.property.components) {
        const volumeProperty = sceneItem.volume.getProperty();
        sceneItem.volumeComponents.forEach((component, componentIndex) => {
          volumeProperty.setScalarOpacityUnitDistance(componentIndex, settings.property.components[componentIndex].scalarOpacityUnitDistance);
          if (component.rgbTransferFunction) {
            volumeProperty.setRGBTransferFunction(componentIndex, component.rgbTransferFunction);
          }
          if (component.grayTransferFunction) {
            volumeProperty.setGrayTransferFunction(componentIndex, component.grayTransferFunction);
          }
          if (component.scalarOpacity) {
            volumeProperty.setScalarOpacity(componentIndex, component.scalarOpacity);
          }
        });
      }
    } else {
      sceneItem.actor.getProperty().set(settings.property);
    }
  }
  if (settings.mapper) {
    if (settings.mapper.colorByArrayName) {
      sceneItem.source.enableArray(settings.mapper.colorByArrayName, settings.mapper.colorByArrayName);
      sceneItem.source.loadData();
    }
    sceneItem.mapper.set(settings.mapper);
    if (settings.mapper.colorByArrayName && settings.luts[settings.mapper.colorByArrayName]) {
      sceneItem.mapper.setLookupTable(settings.luts[settings.mapper.colorByArrayName]);
      sceneItem.mapper.setUseLookupTableScalarRange(true);
    }
  }
  if (settings.lookupTable) {
    sceneItem.mapper.getLookupTable().set(settings.lookupTable);
    sceneItem.mapper.getLookupTable().build();
  }
  if (settings.textureLODs) {
    sceneItem.textureLODs = settings.textureLODs;
  }
  if (settings.sourceLODs) {
    sceneItem.sourceLODs = settings.sourceLODs;
  }
}
function isImage(str) {
  const ext = str.split(".").pop().toLowerCase();
  return ["jpg", "png", "jpeg"].indexOf(ext) !== -1;
}
function loadColorTransferFunction(item) {
  const tf = vtkColorTransferFunction$1.newInstance(item);
  if (item.nodes) {
    tf.removeAllPoints();
    item.nodes.forEach((_ref) => {
      let [x, r, g, b2, midpoint, sharpness] = _ref;
      tf.addRGBPointLong(x, r, g, b2, midpoint, sharpness);
    });
  }
  return tf;
}
function loadPiecewiseFunction(item) {
  const pwf = vtkPiecewiseFunction$1.newInstance(item);
  if (item.points) {
    pwf.removeAllPoints();
    item.points.forEach((_ref2) => {
      let [x, y, midpoint, sharpness] = _ref2;
      return pwf.addPointLong(x, y, midpoint, sharpness);
    });
  }
  return pwf;
}
function initializeVolumeComponents(components) {
  return components.map((component) => {
    const ret = {};
    if (component.rgbTransferFunction) {
      ret.rgbTransferFunction = loadColorTransferFunction(component.rgbTransferFunction);
    } else if (component.grayTransferFunction) {
      ret.grayTransferFunction = loadPiecewiseFunction(component.grayTransferFunction);
    }
    if (component.scalarOpacity) {
      ret.scalarOpacity = loadPiecewiseFunction(component.scalarOpacity);
    }
    return ret;
  });
}
function defineLoadFuctionForReader(type) {
  return (item, model, publicAPI) => {
    const source = type.newInstance({
      fetchGzip: model.fetchGzip,
      dataAccessHelper: model.dataAccessHelper
    });
    let mapper;
    if (item.volume) {
      mapper = vtkVolumeMapper$1.newInstance();
    } else {
      mapper = vtkMapper$1.newInstance();
    }
    const sceneItem = {
      name: item.name || `Item ${itemCount++}`,
      source,
      mapper,
      defaultSettings: item
    };
    if (item.volume) {
      const volume = vtkVolume$1.newInstance();
      sceneItem.volume = volume;
      if (model.renderer) {
        model.renderer.addVolume(volume);
      }
      if (item.property && item.property.components) {
        sceneItem.volumeComponents = initializeVolumeComponents(item.property.components);
      }
      volume.setMapper(mapper);
    } else {
      const actor = vtkActor$1.newInstance();
      sceneItem.actor = actor;
      if (item.texture && item.texture in model.usedTextures) {
        actor.addTexture(model.usedTextures[item.texture]);
      } else if (item.texture) {
        const url = [model.baseURL, item.texture].join("/");
        const texture = vtkTexture$1.newInstance();
        texture.setInterpolate(true);
        texture.setRepeat(true);
        actor.addTexture(texture);
        sceneItem.texture = texture;
        model.usedTextures[item.texture] = texture;
        if (isImage(item.texture)) {
          model.dataAccessHelper.fetchImage({}, url, {
            crossOrigin: "anonymous"
          }).then((img) => {
            texture.setImage(img);
          });
        } else {
          const textureSource = type.newInstance({
            fetchGzip: model.fetchGzip,
            dataAccessHelper: model.dataAccessHelper
          });
          textureSource.setUrl(url, {
            loadData: true
          }).then(() => {
            texture.setInputData(textureSource.getOutputData());
          });
        }
      }
      const {
        textureLODs
      } = item;
      if (textureLODs && textureLODs.files && textureLODs.files.length !== 0) {
        const textureLODsStr = JSON.stringify(textureLODs);
        if (textureLODsStr in model.usedTextureLODs) {
          actor.addTexture(model.usedTextureLODs[textureLODsStr]);
        } else {
          sceneItem.textureLODsDownloader = vtkTextureLODsDownloader$1.newInstance();
          const textureDownloader = sceneItem.textureLODsDownloader;
          const texture = vtkTexture$1.newInstance();
          texture.setInterpolate(true);
          actor.addTexture(texture);
          model.usedTextureLODs[textureLODsStr] = texture;
          textureDownloader.setTexture(texture);
          textureDownloader.setCrossOrigin("anonymous");
          textureDownloader.setBaseUrl(textureLODs.baseUrl);
          textureDownloader.setFiles(textureLODs.files);
          if (model.startLODLoaders) {
            textureDownloader.startDownloads();
          }
        }
      }
      if (model.renderer) {
        model.renderer.addActor(actor);
      }
      actor.setMapper(mapper);
    }
    mapper.setInputConnection(source.getOutputPort());
    source.setUrl([model.baseURL, item[item.type].url].join("/"), {
      loadData: true
    }).then(() => publicAPI.invokeReady());
    applySettings(sceneItem, item);
    model.scene.push(sceneItem);
    const {
      sourceLODs
    } = item;
    if (sourceLODs && sourceLODs.files && sourceLODs.files.length !== 0) {
      sceneItem.dataSetLODsLoader = vtkHttpDataSetLODsLoader$1.newInstance();
      const {
        dataSetLODsLoader
      } = sceneItem;
      dataSetLODsLoader.setMapper(mapper);
      dataSetLODsLoader.setSceneItem(sceneItem);
      dataSetLODsLoader.setBaseUrl(sourceLODs.baseUrl);
      dataSetLODsLoader.setFiles(sourceLODs.files);
      if (model.startLODLoaders) {
        dataSetLODsLoader.startDownloads();
      }
    }
    return sceneItem;
  };
}
function loadTimeStepBasedAnimationHandler(data2, model) {
  model.animationHandler = vtkTimeStepBasedAnimationHandler$1.newInstance({
    scene: model.scene,
    originalMetadata: model.metadata,
    applySettings
  });
  if (model.animationHandler && model.renderer) {
    model.animationHandler.addRenderer(model.renderer);
  }
  model.animationHandler.setData(data2);
}
var TYPE_MAPPING = {
  httpDataSetReader: defineLoadFuctionForReader(vtkHttpDataSetReader$1),
  vtkHttpDataSetReader: defineLoadFuctionForReader(vtkHttpDataSetReader$1),
  httpDataSetSeriesReader: defineLoadFuctionForReader(vtkHttpDataSetSeriesReader$1),
  vtkHttpDataSetSeriesReader: defineLoadFuctionForReader(vtkHttpDataSetSeriesReader$1)
};
var ANIMATION_TYPE_MAPPING = {
  timeStepBasedAnimationHandler: loadTimeStepBasedAnimationHandler,
  vtkTimeStepBasedAnimationHandler: loadTimeStepBasedAnimationHandler
};
function updateDatasetTypeMapping(typeName, handler) {
  TYPE_MAPPING[typeName] = handler;
}
function vtkHttpSceneLoader(publicAPI, model) {
  const originalSceneParameters = {};
  if (!model.usedTextures) {
    model.usedTextures = {};
  }
  if (!model.usedTextureLODs) {
    model.usedTextureLODs = {};
  }
  model.classHierarchy.push("vtkHttpSceneLoader");
  if (!model.scene) {
    model.scene = [];
  }
  function setCameraParameters(params) {
    if (model.renderer) {
      const camera = model.renderer.getActiveCamera();
      if (camera) {
        camera.set(params);
      } else {
        vtkErrorMacro49("No active camera to update");
      }
    }
  }
  function setBackground(color4) {
    if (model.renderer) {
      model.renderer.setBackground(color4);
    }
  }
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  publicAPI.update = () => {
    model.dataAccessHelper.fetchJSON(publicAPI, model.url).then((data2) => {
      if (data2.fetchGzip !== void 0) {
        model.fetchGzip = data2.fetchGzip;
      }
      if (data2.background && model.renderer) {
        setBackground(data2.background);
      }
      if (data2.camera) {
        originalSceneParameters.camera = data2.camera;
        setCameraParameters(data2.camera);
      }
      const luts = {};
      if (data2.lookupTables) {
        Object.keys(data2.lookupTables).forEach((fieldName) => {
          const config = data2.lookupTables[fieldName];
          const lookupTable = loadColorTransferFunction(config);
          luts[fieldName] = lookupTable;
        });
      }
      if (data2.scene) {
        data2.scene.forEach((item) => {
          const builder = TYPE_MAPPING[item.type];
          if (builder) {
            builder({
              luts,
              ...item
            }, model, publicAPI);
          }
        });
        global.scene = model.scene;
        model.usedTextures = {};
        model.usedTextureLODs = {};
      }
      model.metadata = data2;
      if (data2.animation) {
        const animationLoader = ANIMATION_TYPE_MAPPING[data2.animation.type];
        animationLoader({
          ...data2.animation
        }, model, publicAPI, setCameraParameters, setBackground);
      }
    }, (error) => {
      vtkErrorMacro49(`Error fetching scene ${error}`);
    });
  };
  publicAPI.resetScene = () => {
    if (originalSceneParameters.camera) {
      setCameraParameters(originalSceneParameters.camera);
    }
  };
  publicAPI.setUrl = (url) => {
    if (url.indexOf("index.json") === -1) {
      model.baseURL = url;
      model.url = `${url}/index.json`;
    } else {
      model.url = url;
      const path = url.split("/");
      path.pop();
      model.baseURL = path.join("/");
    }
    return publicAPI.update();
  };
}
var DEFAULT_VALUES106 = {
  fetchGzip: false,
  url: null,
  baseURL: null,
  animationHandler: null,
  // Whether or not to automatically start texture LOD and poly LOD
  // downloads when they are read.
  startLODLoaders: true
};
function extend118(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES106, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["fetchGzip", "url", "baseURL", "scene", "metadata", "animationHandler"]);
  macro.setGet(publicAPI, model, ["renderer"]);
  macro.event(publicAPI, model, "ready");
  vtkHttpSceneLoader(publicAPI, model);
}
var newInstance113 = macro.newInstance(extend118, "vtkHttpSceneLoader");
var vtkHttpSceneLoader$1 = {
  newInstance: newInstance113,
  extend: extend118,
  applySettings,
  updateDatasetTypeMapping
};

// node_modules/@kitware/vtk.js/IO/Core/ImageStream/DefaultProtocol.js
function createMethods(session) {
  return {
    subscribeToImageStream: (callback) => session.subscribe("viewport.image.push.subscription", callback),
    unsubscribeToImageStream: (subscription) => session.unsubscribe(subscription),
    registerView: (viewId) => session.call("viewport.image.push.observer.add", [viewId]),
    unregisterView: (viewId) => session.call("viewport.image.push.observer.remove", [viewId]),
    enableView: (viewId, enabled) => session.call("viewport.image.push.enabled", [viewId, enabled]),
    render: function() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        size: [400, 400],
        view: -1
      };
      return session.call("viewport.image.push", [options]);
    },
    resetCamera: function() {
      let view = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      return session.call("viewport.camera.reset", [view]);
    },
    invalidateCache: (viewId) => session.call("viewport.image.push.invalidate.cache", [viewId]),
    setQuality: function(viewId, quality) {
      let ratio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      return session.call("viewport.image.push.quality", [viewId, quality, ratio]);
    },
    setSize: function(viewId) {
      let width2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 400;
      let height2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 400;
      return session.call("viewport.image.push.original.size", [viewId, width2, height2]);
    },
    setServerAnimationFPS: function() {
      let fps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;
      return session.call("viewport.image.animation.fps.max", [fps]);
    },
    getServerAnimationFPS: () => session.call("viewport.image.animation.fps.get", []),
    startAnimation: function() {
      let viewId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      return session.call("viewport.image.animation.start", [viewId]);
    },
    stopAnimation: function() {
      let viewId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      return session.call("viewport.image.animation.stop", [viewId]);
    },
    updateCamera: function(viewId, focalPoint, viewUp, position) {
      let forceUpdate = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      return session.call("viewport.camera.update", [viewId ?? -1, focalPoint, viewUp, position, forceUpdate]);
    },
    updateCameraParameters: function() {
      let viewId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      let parameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let forceUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      return session.call("viewport.camera.update.params", [viewId, parameters, forceUpdate]);
    }
  };
}

// node_modules/@kitware/vtk.js/IO/Core/ImageStream/ViewStream.js
function vtkViewStream(publicAPI, model) {
  model.classHierarchy.push("vtkViewStream");
  model.imageDecodingPool = [new Image(), new Image()];
  model.eventPool = [];
  model.nextPoolImageIndex = 0;
  model.urlToRevoke = [];
  model.activeURL = null;
  model.fps = [];
  model.lastTime = Date.now();
  model.lastImageEvent = null;
  function imageLoaded(e2) {
    if (model.deleted) return;
    const id = Number(this.dataset.id);
    publicAPI.invokeImageReady(model.eventPool[id]);
  }
  function prepareDecodingPool() {
    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    while (model.imageDecodingPool.length < size) {
      model.imageDecodingPool.push(new Image());
    }
    for (let i = 0; i < model.imageDecodingPool.length; i++) {
      model.imageDecodingPool[i].dataset.id = i;
      model.imageDecodingPool[i].onload = imageLoaded;
    }
  }
  function decodeImage(event2) {
    model.eventPool[model.nextPoolImageIndex] = event2;
    event2.image = model.imageDecodingPool[model.nextPoolImageIndex++];
    model.nextPoolImageIndex %= model.imageDecodingPool.length;
    event2.image.src = event2.url;
  }
  publicAPI.pushCamera = () => {
    const focalPoint = model.camera.getReferenceByName("focalPoint");
    const viewUp = model.camera.getReferenceByName("viewUp");
    const position = model.camera.getReferenceByName("position");
    const parallelProjection = model.camera.getParallelProjection();
    const viewAngle = model.camera.getViewAngle();
    const parallelScale = model.camera.getParallelScale();
    let promise = null;
    if (model.useCameraParameters) {
      promise = model.protocol.updateCameraParameters(model.viewId, {
        focalPoint,
        viewUp,
        position,
        parallelProjection,
        viewAngle,
        parallelScale
      }, false);
    } else {
      promise = model.protocol.updateCamera(model.viewId, focalPoint, viewUp, position, false);
    }
    if (model.isAnimating) {
      setTimeout(publicAPI.pushCamera, 1e3 / model.cameraUpdateRate);
    }
    return promise;
  };
  publicAPI.invalidateCache = () => model.protocol.invalidateCache(model.viewId);
  publicAPI.render = () => model.protocol.render({
    view: model.viewId,
    size: model.size
  });
  publicAPI.resetCamera = () => model.protocol.resetCamera(model.viewId);
  publicAPI.startAnimation = () => model.protocol.startAnimation(model.viewId);
  publicAPI.stopAnimation = () => model.protocol.stopAnimation(model.viewId);
  publicAPI.setSize = (width2, height2) => {
    let changeDetected = false;
    if (model.size[0] !== width2 || model.size[1] !== height2) {
      model.size = [width2, height2];
      changeDetected = true;
    }
    if (changeDetected) {
      publicAPI.modified();
      if (model.protocol) {
        return model.protocol.setSize(model.viewId, width2, height2);
      }
    }
    return Promise.resolve(false);
  };
  publicAPI.startInteraction = () => {
    const promises = [model.protocol.setQuality(model.viewId, model.interactiveQuality, model.interactiveRatio)];
    if (model.camera) {
      promises.push(publicAPI.startAnimation());
      model.isAnimating = true;
      promises.push(publicAPI.pushCamera());
    }
    return Promise.all(promises);
  };
  publicAPI.endInteraction = () => {
    const promises = [];
    promises.push(model.protocol.setQuality(model.viewId, model.stillQuality, model.stillRatio));
    if (model.camera) {
      promises.push(publicAPI.stopAnimation());
      model.isAnimating = false;
      promises.push(publicAPI.pushCamera());
    } else {
      promises.push(publicAPI.render());
    }
    return Promise.all(promises);
  };
  publicAPI.setViewId = (id) => {
    if (model.viewId === id || !model.protocol) {
      return false;
    }
    if (model.viewId) {
      model.protocol.unregisterView(model.viewId);
    }
    model.viewId = id;
    if (model.viewId) {
      model.protocol.registerView(model.viewId).then((_ref) => {
        let {
          viewId
        } = _ref;
        model.viewId = viewId;
      });
    }
    return true;
  };
  publicAPI.processMessage = (msg) => {
    if (msg.id != model.viewId) {
      return;
    }
    const imgBlob = new Blob([msg.image], {
      type: model.mimeType
    });
    if (model.activeURL) {
      model.urlToRevoke.push(model.activeURL);
      model.activeURL = null;
      while (model.urlToRevoke.length > 60) {
        const url = model.urlToRevoke.shift();
        window.URL.revokeObjectURL(url);
      }
    }
    model.activeURL = URL.createObjectURL(imgBlob);
    const time = Date.now();
    const fps = Math.floor(1e4 / (time - model.lastTime)) / 10;
    model.fps.push(fps);
    model.lastTime = time;
    model.lastImageEvent = {
      url: model.activeURL,
      fps,
      metadata: {
        size: msg.size,
        id: msg.id,
        memory: msg.memsize,
        workTime: msg.workTime
      }
    };
    if (model.decodeImage) {
      decodeImage(model.lastImageEvent);
    } else {
      publicAPI.invokeImageReady(model.lastImageEvent);
    }
    while (model.fps.length > model.fpsWindowSize) {
      model.fps.shift();
    }
  };
  publicAPI.delete = macro.chain(() => {
    model.unregisterViewStream(publicAPI);
    publicAPI.setViewId(null);
    while (model.urlToRevoke.length) {
      window.URL.revokeObjectURL(model.urlToRevoke.pop());
    }
  }, publicAPI.delete);
  prepareDecodingPool();
}
var DEFAULT_VALUES107 = {
  // protocol: null,
  // api: null,
  cameraUpdateRate: 30,
  decodeImage: true,
  fpsWindowSize: 250,
  interactiveQuality: 80,
  interactiveRatio: 1,
  isAnimating: false,
  mimeType: "image/jpeg",
  size: [-1, -1],
  stillQuality: 100,
  stillRatio: 1,
  useCameraParameters: false,
  viewId: null
};
function extend119(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES107, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "ImageReady");
  macro.get(publicAPI, model, ["viewId", "size", "fps", "lastImageEvent"]);
  macro.setGet(publicAPI, model, ["camera", "cameraUpdateRate", "decodeImage", "fpsWindowSize", "interactiveQuality", "interactiveRatio", "stillQuality", "stillRatio", "useCameraParameters"]);
  vtkViewStream(publicAPI, model);
  Object.assign(publicAPI, model.sharedAPI);
}
var newInstance114 = macro.newInstance(extend119, "vtkViewStream");
var ViewStream = {
  newInstance: newInstance114,
  extend: extend119
};

// node_modules/@kitware/vtk.js/IO/Core/ImageStream.js
function vtkImageStream(publicAPI, model) {
  model.classHierarchy.push("vtkImageStream");
  function onImage(data2) {
    const message = data2[0];
    if (!message || !message.image) {
      return;
    }
    for (let i = 0; i < model.viewStreams.length; i++) {
      model.viewStreams[i].processMessage(message);
    }
  }
  publicAPI.setServerAnimationFPS = function() {
    let maxFPS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;
    let changeDetected = false;
    if (model.serverAnimationFPS !== maxFPS) {
      model.serverAnimationFPS = maxFPS;
      changeDetected = true;
    }
    if (!model.protocol) {
      return Promise.resolve(true);
    }
    if (changeDetected) {
      publicAPI.modified();
    }
    return model.protocol.setServerAnimationFPS(maxFPS);
  };
  publicAPI.connect = function(session) {
    let protocol = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createMethods;
    if (model.connected || !session || !protocol) {
      return;
    }
    model.protocol = protocol(session);
    model.protocol.subscribeToImageStream(onImage).promise.then((subscription) => {
      model.renderTopicSubscription = subscription;
      model.connected = true;
    }).catch((e2) => {
      model.connected = false;
      console.error(e2);
    });
  };
  publicAPI.disconnect = () => {
    if (model.protocol && model.connected && model.renderTopicSubscription) {
      model.protocol.unsubscribeToImageStream(model.renderTopicSubscription);
      model.renderTopicSubscription = null;
    }
    model.connected = false;
  };
  publicAPI.registerViewStream = (view) => {
    model.viewStreams.push(view);
  };
  publicAPI.unregisterViewStream = (view) => {
    model.viewStreams = model.viewStreams.filter((v) => v !== view);
  };
  publicAPI.createViewStream = function() {
    let viewId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "-1";
    let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [400, 400];
    const {
      setServerAnimationFPS,
      getServerAnimationFPS,
      unregisterViewStream
    } = publicAPI;
    const viewStream = ViewStream.newInstance({
      protocol: model.protocol,
      unregisterViewStream,
      sharedAPI: {
        setServerAnimationFPS,
        getServerAnimationFPS
      }
    });
    viewStream.setViewId(viewId);
    viewStream.setSize(size[0], size[1]);
    publicAPI.registerViewStream(viewStream);
    return viewStream;
  };
  publicAPI.delete = macro.chain(() => {
    while (model.viewStreams.length) {
      model.viewStreams.pop().delete();
    }
    publicAPI.disconnect();
  }, publicAPI.delete);
}
var DEFAULT_VALUES108 = {
  // protocol: null,
  viewStreams: [],
  serverAnimationFPS: -1
};
function extend120(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES108, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["serverAnimationFPS", "protocol"]);
  vtkImageStream(publicAPI, model);
}
var newInstance115 = macro.newInstance(extend120, "vtkImageStream");
var vtkImageStream$1 = {
  newInstance: newInstance115,
  extend: extend120
};

// node_modules/@kitware/vtk.js/IO/Core/ResourceLoader.js
var LOADED_URLS = [];
function loadScript(url) {
  return new Promise((resolve, reject) => {
    if (LOADED_URLS.indexOf(url) === -1) {
      LOADED_URLS.push(url);
      const newScriptTag = document.createElement("script");
      newScriptTag.type = "text/javascript";
      newScriptTag.src = url;
      newScriptTag.onload = resolve;
      newScriptTag.onerror = reject;
      document.body.appendChild(newScriptTag);
    } else {
      resolve(false);
    }
  });
}
function loadCSS(url) {
  return new Promise((resolve, reject) => {
    if (LOADED_URLS.indexOf(url) === -1) {
      LOADED_URLS.push(url);
      const newScriptTag = document.createElement("link");
      newScriptTag.rel = "stylesheet";
      newScriptTag.href = url;
      newScriptTag.onload = resolve;
      newScriptTag.onerror = reject;
      document.head.appendChild(newScriptTag);
    } else {
      resolve(false);
    }
  });
}
var vtkResourceLoader = {
  loadScript,
  loadCSS,
  LOADED_URLS
};

// node_modules/@kitware/vtk.js/IO/Core/WSLinkClient.js
var SMART_CONNECT_CLASS = null;
function setSmartConnectClass(klass) {
  SMART_CONNECT_CLASS = klass;
}
function busy(fn, update2) {
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new Promise((resolve, reject) => {
      update2(1);
      fn(...args).then((response) => {
        update2(-1);
        resolve(response);
      }, (error) => {
        update2(-1);
        reject(error);
      });
    });
  };
}
function busyWrap(methodMap, update2) {
  let skipList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const busyContainer = {};
  Object.keys(methodMap).forEach((methodName) => {
    if (skipList.indexOf(methodName) === -1) {
      busyContainer[methodName] = busy(methodMap[methodName], update2);
    } else {
      busyContainer[methodName] = methodMap[methodName];
    }
  });
  return busyContainer;
}
function vtkWSLinkClient(publicAPI, model) {
  model.classHierarchy.push("vtkWSLinkClient");
  function notifyBusy() {
    publicAPI.invokeBusyChange(model.busyCount);
  }
  function updateBusy() {
    let delta = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    model.busyCount += delta;
    if (model.timeoutId) {
      clearTimeout(model.timeoutId);
      model.timeoutId = 0;
    }
    if (model.busyCount) {
      notifyBusy();
    } else {
      model.timeoutId = setTimeout(notifyBusy, model.notificationTimeout);
    }
  }
  publicAPI.beginBusy = () => updateBusy(1);
  publicAPI.endBusy = () => updateBusy(-1);
  publicAPI.isBusy = () => !!model.busyCount;
  publicAPI.isConnected = () => !!model.connection;
  publicAPI.connect = function() {
    let config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let configDecorator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!SMART_CONNECT_CLASS) {
      return Promise.reject(new Error("Need to provide SmartConnect"));
    }
    if (model.connection) {
      return Promise.reject(new Error("Need to disconnect first"));
    }
    model.config = config;
    model.configDecorator = configDecorator || model.configDecorator;
    return new Promise((resolve, reject) => {
      model.smartConnect = SMART_CONNECT_CLASS.newInstance({
        config,
        configDecorator: model.configDecorator
      });
      model.smartConnect.onConnectionReady((connection) => {
        model.connection = connection;
        model.remote = {};
        model.config = model.smartConnect.getConfig();
        const session = connection.getSession();
        model.protocols = model.protocols || {};
        Object.keys(model.protocols).forEach((name2) => {
          model.remote[name2] = busyWrap(model.protocols[name2](session), updateBusy, model.notBusyList);
        });
        if (model.createImageStream) {
          model.imageStream = vtkImageStream$1.newInstance();
          model.imageStream.connect(session);
        }
        publicAPI.invokeConnectionReady(publicAPI);
        resolve(publicAPI);
      });
      model.smartConnect.onConnectionError((error) => {
        publicAPI.invokeConnectionError(error);
        reject(error);
      });
      model.smartConnect.onConnectionClose((close) => {
        publicAPI.invokeConnectionClose(close);
        reject(close);
      });
      model.smartConnect.connect();
    });
  };
  publicAPI.disconnect = function() {
    let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 60;
    if (model.connection) {
      model.connection.destroy(timeout);
      model.connection = null;
    }
  };
  publicAPI.registerProtocol = (name2, protocol) => {
    model.remote[name2] = busyWrap(protocol(model.connection.getSession()), updateBusy, model.notBusyList);
  };
  publicAPI.unregisterProtocol = (name2) => {
    delete model.remote[name2];
  };
}
var DEFAULT_VALUES109 = {
  // protocols: null,
  // connection: null,
  // config: null,
  // imageStream
  notBusyList: [],
  busyCount: 0,
  timeoutId: 0,
  notificationTimeout: 50,
  createImageStream: true
  // configDecorator: null,
};
function extend121(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES109, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["protocols", "notBusyList", "createImageStream", "configDecorator"]);
  macro.get(publicAPI, model, ["connection", "config", "remote", "imageStream"]);
  macro.event(publicAPI, model, "BusyChange");
  macro.event(publicAPI, model, "ConnectionReady");
  macro.event(publicAPI, model, "ConnectionError");
  macro.event(publicAPI, model, "ConnectionClose");
  vtkWSLinkClient(publicAPI, model);
}
var newInstance116 = macro.newInstance(extend121, "vtkWSLinkClient");
var vtkWSLinkClient$1 = {
  newInstance: newInstance116,
  extend: extend121,
  setSmartConnectClass
};

// node_modules/@kitware/vtk.js/IO/Core.js
var Core4 = {
  BinaryHelper,
  DataAccessHelper,
  vtkHttpDataSetReader: vtkHttpDataSetReader$1,
  vtkHttpSceneLoader: vtkHttpSceneLoader$1,
  vtkImageStream: vtkImageStream$1,
  vtkResourceLoader,
  vtkWSLinkClient: vtkWSLinkClient$1
};

// node_modules/@kitware/vtk.js/IO/Geometry/STLReader.js
var {
  vtkErrorMacro: vtkErrorMacro50
} = macro;
function parseHeader(headerString) {
  const headerSubStr = headerString.split(" ");
  const fieldValues = headerSubStr.filter((e2) => e2.indexOf("=") > -1);
  const header = {};
  for (let i = 0; i < fieldValues.length; ++i) {
    const fieldValueStr = fieldValues[i];
    const fieldValueSubStr = fieldValueStr.split("=");
    if (fieldValueSubStr.length === 2) {
      header[fieldValueSubStr[0]] = fieldValueSubStr[1];
    }
  }
  return header;
}
function addValuesToArray(src, dst) {
  for (let i = 0; i < src.length; i++) {
    dst.push(src[i]);
  }
}
function readTriangle(lines, offset, points, cellArray, cellNormals) {
  const normalLine = lines[offset];
  if (normalLine === void 0) {
    return -1;
  }
  if (normalLine.indexOf("endfacet") !== -1) {
    return offset + 1;
  }
  if (normalLine.indexOf("facet") === -1) {
    return offset + 1;
  }
  let nbVertex = 0;
  let nbConsumedLines = 2;
  const firstVertexIndex = points.length / 3;
  const normal = normalLine.split(/[ \t]+/).filter((i) => i).slice(-3).map(Number);
  addValuesToArray(normal, cellNormals);
  while (lines[offset + nbConsumedLines].indexOf("vertex") !== -1) {
    const line = lines[offset + nbConsumedLines];
    const coords = line.split(/[ \t]+/).filter((i) => i).slice(-3).map(Number);
    addValuesToArray(coords, points);
    nbVertex++;
    nbConsumedLines++;
  }
  cellArray.push(nbVertex);
  for (let i = 0; i < nbVertex; i++) {
    cellArray.push(firstVertexIndex + i);
  }
  while (lines[offset + nbConsumedLines] && lines[offset + nbConsumedLines].indexOf("endfacet") !== -1) {
    nbConsumedLines++;
  }
  return offset + nbConsumedLines + 2;
}
function vtkSTLReader(publicAPI, model) {
  model.classHierarchy.push("vtkSTLReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const compression = option.compression !== void 0 ? option.compression : model.compression;
    const progressCallback = option.progressCallback !== void 0 ? option.progressCallback : model.progressCallback;
    if (option.binary) {
      return model.dataAccessHelper.fetchBinary(url, {
        compression,
        progressCallback
      });
    }
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  function removeDuplicateVertices(tolerance) {
    const polydata = model.output[0];
    const points = polydata.getPoints().getData();
    const faces = polydata.getPolys().getData();
    if (!points || !faces) {
      console.warn("No valid polydata.");
      return;
    }
    const vMap = /* @__PURE__ */ new Map();
    const vIndexMap = /* @__PURE__ */ new Map();
    let vInc = 0;
    let pointsChanged = false;
    for (let i = 0; i < points.length; i += 3) {
      const k1 = (points[i] * 10 ** tolerance).toFixed(0);
      const k2 = (points[i + 1] * 10 ** tolerance).toFixed(0);
      const k3 = (points[i + 2] * 10 ** tolerance).toFixed(0);
      const key = `${k1},${k2},${k3}`;
      if (vMap.get(key) !== void 0) {
        vIndexMap.set(i / 3, vMap.get(key));
        pointsChanged = true;
      } else {
        vIndexMap.set(i / 3, vInc);
        vMap.set(key, vInc);
        vInc++;
      }
    }
    if (pointsChanged) {
      const outVerts = new Float32Array(vMap.size * 3);
      const keys = Array.from(vMap.keys());
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const j = vMap.get(k) * 3;
        const coords = k.split(",").map((e2) => +e2 * 10 ** -tolerance);
        outVerts[j] = coords[0];
        outVerts[j + 1] = coords[1];
        outVerts[j + 2] = coords[2];
      }
      const outFaces = new Int32Array(faces.length);
      for (let i = 0; i < faces.length; i += 4) {
        outFaces[i] = 3;
        outFaces[i + 1] = vIndexMap.get(faces[i + 1]);
        outFaces[i + 2] = vIndexMap.get(faces[i + 2]);
        outFaces[i + 3] = vIndexMap.get(faces[i + 3]);
      }
      polydata.getPoints().setData(outVerts);
      polydata.getPolys().setData(outFaces);
      polydata.modified();
    }
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      binary: true
    };
    model.url = url;
    const path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    return publicAPI.loadData(option);
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const promise = fetchData(model.url, option);
    promise.then(publicAPI.parse);
    return promise;
  };
  publicAPI.parse = (content) => {
    if (typeof content === "string") {
      publicAPI.parseAsText(content);
    } else {
      publicAPI.parseAsArrayBuffer(content);
    }
  };
  publicAPI.parseAsArrayBuffer = (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
    let isBinary = false;
    const dview = new DataView(content, 0, 80 + 4);
    const numTriangles = dview.getUint32(80, true);
    isBinary = 84 + numTriangles * 50 === content.byteLength;
    if (!isBinary) {
      publicAPI.parseAsText(BinaryHelper.arrayBufferToString(content));
      return;
    }
    const headerData = content.slice(0, 80);
    const headerStr = BinaryHelper.arrayBufferToString(headerData);
    const header = parseHeader(headerStr);
    const dataView = new DataView(content, 84);
    const nbFaces = (content.byteLength - 84) / 50;
    const pointValues = new Float32Array(nbFaces * 9);
    const normalValues = new Float32Array(nbFaces * 3);
    const cellValues = new Uint32Array(nbFaces * 4);
    const cellDataValues = new Uint16Array(nbFaces);
    let cellOffset = 0;
    for (let faceIdx = 0; faceIdx < nbFaces; faceIdx++) {
      const offset = faceIdx * 50;
      normalValues[faceIdx * 3 + 0] = dataView.getFloat32(offset + 0, true);
      normalValues[faceIdx * 3 + 1] = dataView.getFloat32(offset + 4, true);
      normalValues[faceIdx * 3 + 2] = dataView.getFloat32(offset + 8, true);
      pointValues[faceIdx * 9 + 0] = dataView.getFloat32(offset + 12, true);
      pointValues[faceIdx * 9 + 1] = dataView.getFloat32(offset + 16, true);
      pointValues[faceIdx * 9 + 2] = dataView.getFloat32(offset + 20, true);
      pointValues[faceIdx * 9 + 3] = dataView.getFloat32(offset + 24, true);
      pointValues[faceIdx * 9 + 4] = dataView.getFloat32(offset + 28, true);
      pointValues[faceIdx * 9 + 5] = dataView.getFloat32(offset + 32, true);
      pointValues[faceIdx * 9 + 6] = dataView.getFloat32(offset + 36, true);
      pointValues[faceIdx * 9 + 7] = dataView.getFloat32(offset + 40, true);
      pointValues[faceIdx * 9 + 8] = dataView.getFloat32(offset + 44, true);
      cellValues[cellOffset++] = 3;
      cellValues[cellOffset++] = faceIdx * 3 + 0;
      cellValues[cellOffset++] = faceIdx * 3 + 1;
      cellValues[cellOffset++] = faceIdx * 3 + 2;
      cellDataValues[faceIdx] = dataView.getUint16(offset + 48, true);
    }
    const orientationField = "SPACE";
    if (orientationField in header && header[orientationField] !== "LPS") {
      const XYZ = header[orientationField];
      const mat4 = new Float32Array(16);
      mat4[15] = 1;
      switch (XYZ[0]) {
        case "L":
          mat4[0] = 1;
          break;
        case "R":
          mat4[0] = -1;
          break;
        default:
          vtkErrorMacro50(`Can not convert STL file from ${XYZ} to LPS space: permutations not supported. Use itk.js STL reader instead.`);
          return;
      }
      switch (XYZ[1]) {
        case "P":
          mat4[5] = 1;
          break;
        case "A":
          mat4[5] = -1;
          break;
        default:
          vtkErrorMacro50(`Can not convert STL file from ${XYZ} to LPS space: permutations not supported. Use itk.js STL reader instead.`);
          return;
      }
      switch (XYZ[2]) {
        case "S":
          mat4[10] = 1;
          break;
        case "I":
          mat4[10] = -1;
          break;
        default:
          vtkErrorMacro50(`Can not convert STL file from ${XYZ} to LPS space: permutations not supported. Use itk.js STL reader instead.`);
          return;
      }
      vtkMatrixBuilder.buildFromDegree().setMatrix(mat4).apply(pointValues).apply(normalValues);
    }
    const polydata = vtkPolyData$1.newInstance();
    polydata.getPoints().setData(pointValues, 3);
    polydata.getPolys().setData(cellValues);
    polydata.getCellData().setScalars(vtkDataArray$1.newInstance({
      name: "Attribute",
      values: cellDataValues
    }));
    polydata.getCellData().setNormals(vtkDataArray$1.newInstance({
      name: "Normals",
      values: normalValues,
      numberOfComponents: 3
    }));
    model.output[0] = polydata;
    if (model.removeDuplicateVertices >= 0) {
      removeDuplicateVertices(model.removeDuplicateVertices);
    }
  };
  publicAPI.parseAsText = (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
    const lines = content.split("\n");
    let offset = 1;
    const points = [];
    const cellArray = [];
    const cellNormals = [];
    while (offset !== -1) {
      offset = readTriangle(lines, offset, points, cellArray, cellNormals);
    }
    const polydata = vtkPolyData$1.newInstance();
    polydata.getPoints().setData(Float32Array.from(points), 3);
    polydata.getPolys().setData(Uint32Array.from(cellArray));
    polydata.getCellData().setNormals(vtkDataArray$1.newInstance({
      name: "Normals",
      values: Float32Array.from(cellNormals),
      numberOfComponents: 3
    }));
    model.output[0] = polydata;
    if (model.removeDuplicateVertices >= 0) {
      removeDuplicateVertices(model.removeDuplicateVertices);
    }
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parse(model.parseData);
  };
}
var DEFAULT_VALUES110 = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
  removeDuplicateVertices: -1
};
function extend122(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES110, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper", "removeDuplicateVertices"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkSTLReader(publicAPI, model);
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}
var newInstance117 = macro.newInstance(extend122, "vtkSTLReader");
var vtkSTLReader$1 = {
  extend: extend122,
  newInstance: newInstance117
};

// node_modules/@kitware/vtk.js/IO/Geometry/PLYReader.js
var PLYFormats = {
  ASCII: "ascii",
  BINARY_BIG_ENDIAN: "binary_big_endian",
  BINARY_LITTLE_ENDIAN: "binary_little_endian"
};
var mapping = {
  diffuse_red: "red",
  diffuse_green: "green",
  diffuse_blue: "blue"
};
var patterns = {
  patternHeader: /ply([\s\S]*)end_header\r?\n/,
  patternBody: /end_header\s([\s\S]*)$/
};
function parseHeader2(data2) {
  let headerText = "";
  let headerLength = 0;
  const result = patterns.patternHeader.exec(data2);
  if (result !== null) {
    headerText = result[1];
    headerLength = result[0].length;
  }
  const header = {
    comments: [],
    elements: [],
    headerLength
  };
  const lines = headerText.split("\n");
  let elem;
  let lineType;
  let lineValues;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    line = line.trim();
    if (line !== "") {
      let property;
      lineValues = line.split(/\s+/);
      lineType = lineValues.shift();
      line = lineValues.join(" ");
      switch (lineType) {
        case "format":
          header.format = lineValues[0];
          header.version = lineValues[1];
          break;
        case "comment":
          header.comments.push(line);
          break;
        case "element":
          if (elem !== void 0) {
            header.elements.push(elem);
          }
          elem = {};
          elem.name = lineValues[0];
          elem.count = parseInt(lineValues[1], 10);
          elem.properties = [];
          break;
        case "property":
          property = {
            type: lineValues[0]
          };
          if (property.type === "list") {
            property.name = lineValues[3];
            property.countType = lineValues[1];
            property.itemType = lineValues[2];
          } else {
            property.name = lineValues[1];
          }
          if (property.name in mapping) {
            property.name = mapping[property.name];
          }
          elem.properties.push(property);
          break;
        case "obj_info":
          header.objInfo = line;
          break;
        default:
          console.warn("unhandled", lineType, lineValues);
          break;
      }
    }
  }
  if (elem !== void 0) {
    header.elements.push(elem);
  }
  return header;
}
function postProcess(buffer, elements, faceTextureTolerance, duplicatePointsForFaceTexture) {
  const vertElement = elements.find((element) => element.name === "vertex");
  const faceElement = elements.find((element) => element.name === "face");
  let nbVerts = 0;
  let nbFaces = 0;
  if (vertElement) {
    nbVerts = vertElement.count;
  }
  if (faceElement) {
    nbFaces = faceElement.count;
  }
  let pointValues = new Float32Array(nbVerts * 3);
  let colorArray = new Uint8Array(nbVerts * 3);
  let tcoordsArray = new Float32Array(nbVerts * 2);
  let normalsArray = new Float32Array(nbVerts * 3);
  const hasColor = buffer.colors.length > 0;
  const hasVertTCoords = buffer.uvs.length > 0;
  const hasNorms = buffer.normals.length > 0;
  const hasFaceTCoords = buffer.faceVertexUvs.length > 0;
  const pointIds = /* @__PURE__ */ new Map();
  let nextPointId = nbVerts;
  for (let vertIdx = 0; vertIdx < nbVerts; vertIdx++) {
    let a2 = vertIdx * 3 + 0;
    let b2 = vertIdx * 3 + 1;
    const c2 = vertIdx * 3 + 2;
    pointValues[a2] = buffer.vertices[a2];
    pointValues[b2] = buffer.vertices[b2];
    pointValues[c2] = buffer.vertices[c2];
    if (hasColor) {
      colorArray[a2] = buffer.colors[a2];
      colorArray[b2] = buffer.colors[b2];
      colorArray[c2] = buffer.colors[c2];
    }
    if (hasVertTCoords) {
      a2 = vertIdx * 2 + 0;
      b2 = vertIdx * 2 + 1;
      tcoordsArray[a2] = buffer.uvs[a2];
      tcoordsArray[b2] = buffer.uvs[b2];
    } else {
      tcoordsArray[vertIdx * 2] = -1;
      tcoordsArray[vertIdx * 2 + 1] = -1;
    }
    if (hasNorms) {
      normalsArray[a2] = buffer.normals[a2];
      normalsArray[b2] = buffer.normals[b2];
      normalsArray[c2] = buffer.normals[c2];
    }
  }
  if (hasFaceTCoords && !hasVertTCoords && nbFaces > 0) {
    let idxVerts = 0;
    let idxCoord = 0;
    if (duplicatePointsForFaceTexture) {
      const extraPoints = [];
      const extraColors = [];
      const extraNormals = [];
      const extraTCoords = [];
      for (let faceIdx = 0; faceIdx < nbFaces; ++faceIdx) {
        const nbFaceVerts = buffer.indices[idxVerts++];
        const texcoords = buffer.faceVertexUvs[idxCoord++];
        if (texcoords && nbFaceVerts * 2 === texcoords.length) {
          for (let vertIdx = 0; vertIdx < nbFaceVerts; ++vertIdx) {
            const vertId = buffer.indices[idxVerts + vertIdx];
            const newTex = [texcoords[vertIdx * 2], texcoords[vertIdx * 2 + 1]];
            const currentTex = [tcoordsArray[vertId * 2], tcoordsArray[vertId * 2 + 1]];
            if (currentTex[0] === -1) {
              tcoordsArray[vertId * 2] = newTex[0];
              tcoordsArray[vertId * 2 + 1] = newTex[1];
              const key = `${newTex[0]},${newTex[1]}`;
              if (!pointIds.has(key)) {
                pointIds.set(key, []);
              }
              pointIds.get(key).push(vertId);
            } else {
              const needsDuplication = Math.abs(currentTex[0] - newTex[0]) > faceTextureTolerance || Math.abs(currentTex[1] - newTex[1]) > faceTextureTolerance;
              if (needsDuplication) {
                const key = `${newTex[0]},${newTex[1]}`;
                let existingPointId = -1;
                if (pointIds.has(key)) {
                  const candidates = pointIds.get(key);
                  for (let i = 0, len = candidates.length; i < len; i++) {
                    const candidateId = candidates[i];
                    const samePosition = Math.abs(pointValues[candidateId * 3] - pointValues[vertId * 3]) <= faceTextureTolerance && Math.abs(pointValues[candidateId * 3 + 1] - pointValues[vertId * 3 + 1]) <= faceTextureTolerance && Math.abs(pointValues[candidateId * 3 + 2] - pointValues[vertId * 3 + 2]) <= faceTextureTolerance;
                    if (samePosition) {
                      existingPointId = candidateId;
                      break;
                    }
                  }
                }
                if (existingPointId === -1) {
                  extraPoints.push(pointValues[vertId * 3], pointValues[vertId * 3 + 1], pointValues[vertId * 3 + 2]);
                  if (hasColor) {
                    extraColors.push(colorArray[vertId * 3], colorArray[vertId * 3 + 1], colorArray[vertId * 3 + 2]);
                  }
                  if (hasNorms) {
                    extraNormals.push(normalsArray[vertId * 3], normalsArray[vertId * 3 + 1], normalsArray[vertId * 3 + 2]);
                  }
                  extraTCoords.push(newTex[0], newTex[1]);
                  if (!pointIds.has(key)) {
                    pointIds.set(key, []);
                  }
                  pointIds.get(key).push(nextPointId);
                  buffer.indices[idxVerts + vertIdx] = nextPointId;
                  nextPointId++;
                } else {
                  buffer.indices[idxVerts + vertIdx] = existingPointId;
                }
              }
            }
          }
        }
        idxVerts += nbFaceVerts;
      }
      if (extraPoints.length > 0) {
        const newPointCount = nbVerts + extraPoints.length / 3;
        const newPointValues = new Float32Array(newPointCount * 3);
        const newTcoordsArray = new Float32Array(newPointCount * 2);
        const newColorArray = hasColor ? new Uint8Array(newPointCount * 3) : null;
        const newNormalsArray = hasNorms ? new Float32Array(newPointCount * 3) : null;
        newPointValues.set(pointValues);
        newTcoordsArray.set(tcoordsArray);
        if (hasColor && newColorArray) {
          newColorArray.set(colorArray);
        }
        if (hasNorms && newNormalsArray) {
          newNormalsArray.set(normalsArray);
        }
        newPointValues.set(extraPoints, nbVerts * 3);
        newTcoordsArray.set(extraTCoords, nbVerts * 2);
        if (hasColor && newColorArray) {
          newColorArray.set(extraColors, nbVerts * 3);
        }
        if (hasNorms && newNormalsArray) {
          newNormalsArray.set(extraNormals, nbVerts * 3);
        }
        pointValues = newPointValues;
        tcoordsArray = newTcoordsArray;
        if (hasColor) {
          colorArray = newColorArray;
        }
        if (hasNorms) {
          normalsArray = newNormalsArray;
        }
      }
    } else {
      for (let faceIdx = 0; faceIdx < nbFaces; ++faceIdx) {
        const nbFaceVerts = buffer.indices[idxVerts++];
        const texcoords = buffer.faceVertexUvs[idxCoord++];
        if (texcoords && nbFaceVerts * 2 === texcoords.length) {
          for (let vertIdx = 0; vertIdx < nbFaceVerts; ++vertIdx) {
            const vert = buffer.indices[idxVerts++];
            tcoordsArray[vert * 2] = texcoords[vertIdx * 2];
            tcoordsArray[vert * 2 + 1] = texcoords[vertIdx * 2 + 1];
          }
        } else {
          idxVerts += nbFaceVerts;
        }
      }
    }
  }
  const polydata = vtkPolyData$1.newInstance();
  polydata.getPoints().setData(pointValues, 3);
  if (nbFaces > 0) {
    polydata.getPolys().setData(Uint32Array.from(buffer.indices));
  } else {
    const verts = new Uint32Array(nbVerts * 2);
    for (let i = 0; i < nbVerts; i++) {
      verts[i * 2] = 1;
      verts[i * 2 + 1] = i;
    }
    polydata.getVerts().setData(verts);
  }
  if (hasColor) {
    polydata.getPointData().setScalars(vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: colorArray,
      name: "RGB"
    }));
  }
  if (hasVertTCoords || hasFaceTCoords) {
    const da = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoordsArray,
      name: "TextureCoordinates"
    });
    const cpd = polydata.getPointData();
    cpd.addArray(da);
    cpd.setActiveTCoords(da.getName());
  }
  if (hasNorms) {
    polydata.getPointData().setNormals(vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      name: "Normals",
      values: normalsArray
    }));
  }
  return polydata;
}
function parseNumber(n, type) {
  let r;
  switch (type) {
    case "char":
    case "uchar":
    case "short":
    case "ushort":
    case "int":
    case "uint":
    case "int8":
    case "uint8":
    case "int16":
    case "uint16":
    case "int32":
    case "uint32":
      r = parseInt(n, 10);
      break;
    case "float":
    case "double":
    case "float32":
    case "float64":
      r = parseFloat(n);
      break;
    default:
      console.log("Unsupported type");
      break;
  }
  return r;
}
function parseElement(properties, line) {
  const values = line.split(/\s+/);
  const element = {};
  for (let i = 0; i < properties.length; i++) {
    if (properties[i].type === "list") {
      const list = [];
      const n = parseNumber(values.shift(), properties[i].countType);
      for (let j = 0; j < n; j++) {
        list.push(parseNumber(values.shift(), properties[i].itemType));
      }
      element[properties[i].name] = list;
    } else {
      element[properties[i].name] = parseNumber(values.shift(), properties[i].type);
    }
  }
  return element;
}
function handleElement(buffer, name2, element) {
  if (name2 === "vertex") {
    buffer.vertices.push(element.x, element.y, element.z);
    if ("nx" in element && "ny" in element && "nz" in element) {
      buffer.normals.push(element.nx, element.ny, element.nz);
    }
    if ("s" in element && "t" in element) {
      buffer.uvs.push(element.s, element.t);
    } else if ("u" in element && "v" in element) {
      buffer.uvs.push(element.u, element.v);
    } else if ("texture_u" in element && "texture_v" in element) {
      buffer.uvs.push(element.texture_u, element.texture_v);
    }
    if ("red" in element && "green" in element && "blue" in element) {
      buffer.colors.push(element.red, element.green, element.blue);
    }
  } else if (name2 === "face") {
    const vertexIndices = element.vertex_indices || element.vertex_index;
    const texcoord = element.texcoord;
    if (vertexIndices && vertexIndices.length > 0) {
      buffer.indices.push(vertexIndices.length);
      vertexIndices.forEach((val, idx) => {
        buffer.indices.push(val);
      });
    }
    buffer.faceVertexUvs.push(texcoord);
  }
}
function binaryRead(dataview, at, type, littleEndian) {
  let r;
  switch (type) {
    case "int8":
    case "char":
      r = [dataview.getInt8(at), 1];
      break;
    case "uint8":
    case "uchar":
      r = [dataview.getUint8(at), 1];
      break;
    case "int16":
    case "short":
      r = [dataview.getInt16(at, littleEndian), 2];
      break;
    case "uint16":
    case "ushort":
      r = [dataview.getUint16(at, littleEndian), 2];
      break;
    case "int32":
    case "int":
      r = [dataview.getInt32(at, littleEndian), 4];
      break;
    case "uint32":
    case "uint":
      r = [dataview.getUint32(at, littleEndian), 4];
      break;
    case "float32":
    case "float":
      r = [dataview.getFloat32(at, littleEndian), 4];
      break;
    case "float64":
    case "double":
      r = [dataview.getFloat64(at, littleEndian), 8];
      break;
    default:
      console.log("Unsupported type");
      break;
  }
  return r;
}
function binaryReadElement(dataview, at, properties, littleEndian) {
  const element = {};
  let result;
  let read = 0;
  for (let i = 0; i < properties.length; i++) {
    if (properties[i].type === "list") {
      const list = [];
      result = binaryRead(dataview, at + read, properties[i].countType, littleEndian);
      const n = result[0];
      read += result[1];
      for (let j = 0; j < n; j++) {
        result = binaryRead(dataview, at + read, properties[i].itemType, littleEndian);
        list.push(result[0]);
        read += result[1];
      }
      element[properties[i].name] = list;
    } else {
      result = binaryRead(dataview, at + read, properties[i].type, littleEndian);
      element[properties[i].name] = result[0];
      read += result[1];
    }
  }
  return [element, read];
}
function vtkPLYReader(publicAPI, model) {
  model.classHierarchy.push("vtkPLYReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      compression,
      progressCallback
    } = model;
    if (option.binary) {
      return model.dataAccessHelper.fetchBinary(url, {
        compression,
        progressCallback
      });
    }
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      binary: true
    };
    model.url = url;
    const path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    model.compression = option.compression;
    return publicAPI.loadData({
      progressCallback: option.progressCallback,
      binary: !!option.binary
    });
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const promise = fetchData(model.url, option);
    promise.then(publicAPI.parse);
    return promise;
  };
  publicAPI.parse = (content) => {
    if (typeof content === "string") {
      publicAPI.parseAsText(content);
    } else {
      publicAPI.parseAsArrayBuffer(content);
    }
  };
  publicAPI.parseAsArrayBuffer = (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    let text2 = content;
    if (content instanceof ArrayBuffer) {
      text2 = BinaryHelper.arrayBufferToString(content);
    }
    const header = parseHeader2(text2);
    const isBinary = header.format !== PLYFormats.ASCII;
    if (!isBinary) {
      publicAPI.parseAsText(text2);
      return;
    }
    model.parseData = content;
    const buffer = {
      indices: [],
      vertices: [],
      normals: [],
      uvs: [],
      faceVertexUvs: [],
      colors: []
    };
    const littleEndian = header.format === PLYFormats.BINARY_LITTLE_ENDIAN;
    const arraybuffer = content instanceof ArrayBuffer ? content : content.buffer;
    const body = new DataView(arraybuffer, header.headerLength);
    let result;
    let loc = 0;
    for (let elem = 0; elem < header.elements.length; elem++) {
      for (let idx = 0; idx < header.elements[elem].count; idx++) {
        result = binaryReadElement(body, loc, header.elements[elem].properties, littleEndian);
        loc += result[1];
        const element = result[0];
        handleElement(buffer, header.elements[elem].name, element);
      }
    }
    const polydata = postProcess(buffer, header.elements, model.faceTextureTolerance, model.duplicatePointsForFaceTexture);
    model.output[0] = polydata;
  };
  publicAPI.parseAsText = (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
    let text2 = content;
    if (content instanceof ArrayBuffer) {
      text2 = BinaryHelper.arrayBufferToString(content);
    }
    const header = parseHeader2(text2);
    const isBinary = header.format !== PLYFormats.ASCII;
    if (isBinary) {
      publicAPI.parseAsArrayBuffer(content);
      return;
    }
    const buffer = {
      indices: [],
      vertices: [],
      normals: [],
      uvs: [],
      faceVertexUvs: [],
      colors: []
    };
    const result = patterns.patternBody.exec(text2);
    let body = "";
    if (result !== null) {
      body = result[1];
    }
    const lines = body.split("\n");
    let elem = 0;
    let idx = 0;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      line = line.trim();
      if (line !== "") {
        if (idx >= header.elements[elem].count) {
          elem++;
          idx = 0;
        }
        const element = parseElement(header.elements[elem].properties, line);
        handleElement(buffer, header.elements[elem].name, element);
        idx++;
      }
    }
    const polydata = postProcess(buffer, header.elements, model.faceTextureTolerance, model.duplicatePointsForFaceTexture);
    model.output[0] = polydata;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parse(model.parseData);
  };
}
var DEFAULT_VALUES111 = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
  faceTextureTolerance: 1e-6,
  duplicatePointsForFaceTexture: true
};
function extend123(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES111, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL", "duplicatePointsForFaceTexture", "faceTextureTolerance"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkPLYReader(publicAPI, model);
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}
var newInstance118 = macro.newInstance(extend123, "vtkPLYReader");
var vtkPLYReader$1 = {
  extend: extend123,
  newInstance: newInstance118
};

// node_modules/@kitware/vtk.js/IO/Geometry/DracoReader.js
var {
  vtkErrorMacro: vtkErrorMacro51
} = macro;
var decoderModule = null;
function setWasmBinary(url, binaryName) {
  const dracoDecoderType = {};
  return new Promise((resolve, reject) => {
    dracoDecoderType.wasmBinaryFile = binaryName;
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.responseType = "arraybuffer";
    xhr.onload = () => {
      if (xhr.status === 200) {
        dracoDecoderType.wasmBinary = xhr.response;
        Promise.resolve(window.DracoDecoderModule(dracoDecoderType)).then((module) => {
          decoderModule = module;
          resolve(true);
        }, reject);
      } else {
        reject(Error(`WASM binary could not be loaded: ${xhr.statusText}`));
      }
    };
    xhr.send(null);
  });
}
async function setDracoDecoder(dracoDecoder) {
  decoderModule = await dracoDecoder({});
}
function getDracoDecoder() {
  return decoderModule;
}
function getDracoDataType(attributeType) {
  switch (attributeType) {
    case Float32Array:
      return decoderModule.DT_FLOAT32;
    case Int8Array:
      return decoderModule.DT_INT8;
    case Int16Array:
      return decoderModule.DT_INT16;
    case Int32Array:
      return decoderModule.DT_INT32;
    case Uint8Array:
      return decoderModule.DT_UINT8;
    case Uint16Array:
      return decoderModule.DT_UINT16;
    case Uint32Array:
      return decoderModule.DT_UINT32;
    default:
      return decoderModule.DT_FLOAT32;
  }
}
function decodeAttribute(decoder, dracoGeometry, attributeName, attributeType, attribute) {
  const numComponents = attribute.num_components();
  const numPoints = dracoGeometry.num_points();
  const numValues = numPoints * numComponents;
  const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
  const dataType = getDracoDataType(attributeType);
  const ptr = decoderModule._malloc(byteLength);
  decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
  const array = new attributeType(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
  decoderModule._free(ptr);
  return {
    name: attributeName,
    array,
    itemSize: numComponents
  };
}
function decodeIndices(decoder, dracoGeometry) {
  const numFaces = dracoGeometry.num_faces();
  const numIndices = numFaces * 3;
  const byteLength = numIndices * 4;
  const ptr = decoderModule._malloc(byteLength);
  decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
  const indices = new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices).slice();
  decoderModule._free(ptr);
  return indices;
}
function getPolyDataFromDracoGeometry(decoder, dracoGeometry) {
  const indices = decodeIndices(decoder, dracoGeometry);
  const nCells = indices.length - 2;
  const cells = vtkCellArray$1.newInstance();
  cells.allocate(4 * indices.length / 3);
  for (let cellId = 0; cellId < nCells; cellId += 3) {
    const cell = indices.slice(cellId, cellId + 3);
    cells.insertNextCell(cell);
  }
  const polyData = vtkPolyData$1.newInstance({
    polys: cells
  });
  const attributeIDs = {
    points: "POSITION",
    normals: "NORMAL",
    scalars: "COLOR",
    tcoords: "TEX_COORD"
  };
  Object.keys(attributeIDs).forEach((attributeName) => {
    const attributeType = Float32Array;
    const attributeID = decoder.GetAttributeId(dracoGeometry, decoderModule[attributeIDs[attributeName]]);
    if (attributeID === -1) return;
    const attribute = decoder.GetAttribute(dracoGeometry, attributeID);
    const attributeResult = decodeAttribute(decoder, dracoGeometry, attributeName, attributeType, attribute);
    const pointData = polyData.getPointData();
    switch (attributeName) {
      case "points":
        polyData.getPoints().setData(attributeResult.array, attributeResult.itemSize);
        break;
      case "normals":
        pointData.setNormals(vtkDataArray$1.newInstance({
          numberOfComponents: attributeResult.itemSize,
          values: attributeResult.array,
          name: "Normals"
        }));
        break;
      case "scalars":
        pointData.setScalars(vtkDataArray$1.newInstance({
          numberOfComponents: attributeResult.itemSize,
          values: attributeResult.array,
          name: "Scalars"
        }));
        break;
      case "tcoords":
        pointData.setTCoords(vtkDataArray$1.newInstance({
          numberOfComponents: attributeResult.itemSize,
          values: attributeResult.array,
          name: "TCoords"
        }));
        break;
    }
  });
  const hasNormals = polyData.getPointData().getNormals();
  if (!hasNormals) {
    const pdn = vtkPolyDataNormals$1.newInstance();
    pdn.setInputData(polyData);
    pdn.setComputePointNormals(true);
    return pdn.getOutputData();
  }
  return polyData;
}
function vtkDracoReader(publicAPI, model) {
  model.classHierarchy.push("vtkDracoReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      compression,
      progressCallback
    } = model;
    if (option.binary) {
      return model.dataAccessHelper.fetchBinary(url, {
        compression,
        progressCallback
      });
    }
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      binary: true
    };
    model.url = url;
    const path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    model.compression = option.compression;
    return publicAPI.loadData({
      progressCallback: option.progressCallback,
      binary: !!option.binary
    });
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const promise = fetchData(model.url, option);
    promise.then(publicAPI.parse);
    return promise;
  };
  publicAPI.parse = (content) => {
    publicAPI.parseAsArrayBuffer(content);
  };
  publicAPI.parseAsArrayBuffer = (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
    const byteArray = new Int8Array(content);
    const decoder = new decoderModule.Decoder();
    const buffer = new decoderModule.DecoderBuffer();
    buffer.Init(byteArray, byteArray.length);
    const geometryType = decoder.GetEncodedGeometryType(buffer);
    let dracoGeometry;
    if (geometryType === decoderModule.TRIANGULAR_MESH) {
      dracoGeometry = new decoderModule.Mesh();
      const status = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
      if (!status.ok()) {
        vtkErrorMacro51(`Could not decode Draco file: ${status.error_msg()}`);
        return;
      }
    } else {
      vtkErrorMacro51("Wrong geometry type, expected mesh, got point cloud.");
      return;
    }
    const polyData = getPolyDataFromDracoGeometry(decoder, dracoGeometry);
    decoderModule.destroy(dracoGeometry);
    decoderModule.destroy(buffer);
    decoderModule.destroy(decoder);
    model.output[0] = polyData;
  };
  publicAPI.requestData = () => {
    publicAPI.parse(model.parseData);
  };
}
var DEFAULT_VALUES112 = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend124(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES112, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkDracoReader(publicAPI, model);
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}
var newInstance119 = macro.newInstance(extend124, "vtkDracoReader");
var vtkDracoReader$1 = {
  extend: extend124,
  newInstance: newInstance119,
  setDracoDecoder,
  setWasmBinary,
  getDracoDecoder
};

// node_modules/@kitware/vtk.js/IO/Geometry/STLWriter/Constants.js
var FormatTypes = {
  ASCII: "ascii",
  BINARY: "binary"
};

// node_modules/@kitware/vtk.js/IO/Geometry/STLWriter.js
var {
  vtkErrorMacro: vtkErrorMacro52
} = macro;
function writeFloatBinary(dataView, offset, float) {
  dataView.setFloat32(offset, float.toPrecision(6), true);
  return offset + 4;
}
function writeVectorBinary(dataView, offset, vector) {
  let off = writeFloatBinary(dataView, offset, vector[0]);
  off = writeFloatBinary(dataView, off, vector[1]);
  return writeFloatBinary(dataView, off, vector[2]);
}
var binaryWriter = () => {
  let offset = 0;
  let dataView = null;
  return {
    init: (polyData) => {
      const polys = polyData.getPolys().getData();
      const buffer = new ArrayBuffer(80 + 4 + 50 * polys.length / 4);
      dataView = new DataView(buffer);
    },
    writeHeader: (polyData) => {
      offset += 80;
      dataView.setUint32(offset, polyData.getNumberOfCells(), true);
      offset += 4;
    },
    writeTriangle: (v1, v2, v3, dn) => {
      offset = writeVectorBinary(dataView, offset, dn);
      offset = writeVectorBinary(dataView, offset, v1);
      offset = writeVectorBinary(dataView, offset, v2);
      offset = writeVectorBinary(dataView, offset, v3);
      offset += 2;
    },
    writeFooter: (polyData) => {
    },
    getOutputData: () => dataView
  };
};
var asciiWriter = () => {
  let file = "";
  return {
    init: (polyData) => {
    },
    writeHeader: (polyData) => {
      file += "solid ascii\n";
    },
    writeTriangle: (v1, v2, v3, dn) => {
      file += ` facet normal ${dn[0].toPrecision(6)} ${dn[1].toPrecision(6)} ${dn[2].toPrecision(6)}
`;
      file += "  outer loop\n";
      file += `   vertex ${v1[0].toPrecision(6)} ${v1[1].toPrecision(6)} ${v1[2].toPrecision(6)}
`;
      file += `   vertex ${v2[0].toPrecision(6)} ${v2[1].toPrecision(6)} ${v2[2].toPrecision(6)}
`;
      file += `   vertex ${v3[0].toPrecision(6)} ${v3[1].toPrecision(6)} ${v3[2].toPrecision(6)}
`;
      file += "  endloop\n";
      file += " endfacet\n";
    },
    writeFooter: (polyData) => {
      file += "endsolid\n";
    },
    getOutputData: () => file
  };
};
function writeSTL(polyData) {
  let format2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : FormatTypes.BINARY;
  let transform = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  let writer = null;
  if (format2 === FormatTypes.BINARY) {
    writer = binaryWriter();
  } else if (format2 === FormatTypes.ASCII) {
    writer = asciiWriter();
  } else {
    vtkErrorMacro52("Invalid format type");
  }
  writer.init(polyData);
  writer.writeHeader(polyData);
  const polys = polyData.getPolys().getData();
  const points = polyData.getPoints().getData();
  const strips = polyData.getStrips() ? polyData.getStrips().getData() : null;
  const n = [];
  let v1 = [];
  let v2 = [];
  let v3 = [];
  if (strips && strips.length > 0) {
    throw new Error("Unsupported strips");
  }
  for (let i = 0; i < polys.length; ) {
    const pointNumber = polys[i++];
    if (pointNumber) {
      v1 = [points[polys[i] * 3], points[polys[i] * 3 + 1], points[polys[i++] * 3 + 2]];
      v2 = [points[polys[i] * 3], points[polys[i] * 3 + 1], points[polys[i++] * 3 + 2]];
      v3 = [points[polys[i] * 3], points[polys[i] * 3 + 1], points[polys[i++] * 3 + 2]];
      if (transform) {
        vec3_exports.transformMat4(v1, v1, transform);
        vec3_exports.transformMat4(v2, v2, transform);
        vec3_exports.transformMat4(v3, v3, transform);
      }
      vtkTriangle$1.computeNormal(v1, v2, v3, n);
      writer.writeTriangle(v1, v2, v3, n);
    }
  }
  writer.writeFooter(polyData);
  return writer.getOutputData();
}
var STATIC10 = {
  writeSTL
};
function vtkSTLWriter(publicAPI, model) {
  model.classHierarchy.push("vtkSTLWriter");
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input || input.getClassName() !== "vtkPolyData") {
      vtkErrorMacro52("Invalid or missing input");
      return;
    }
    outData[0] = writeSTL(input, model.format, model.transform);
  };
}
var DEFAULT_VALUES113 = {
  format: FormatTypes.BINARY,
  transform: null
};
function extend125(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES113, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, ["format", "transform"]);
  vtkSTLWriter(publicAPI, model);
}
var newInstance120 = macro.newInstance(extend125, "vtkSTLWriter");
var vtkSTLWriter$1 = {
  newInstance: newInstance120,
  extend: extend125,
  ...STATIC10
};

// node_modules/@kitware/vtk.js/IO/Geometry/PLYWriter/Constants.js
var FormatTypes2 = {
  ASCII: "ascii",
  BINARY: "binary"
};
var TextureCoordinatesName = {
  UV: ["u", "v"],
  TEXTURE_UV: ["texture_u", "texture_v"]
};

// node_modules/@kitware/vtk.js/IO/Geometry/PLYWriter.js
var {
  vtkErrorMacro: vtkErrorMacro53,
  vtkWarningMacro: vtkWarningMacro11
} = macro;
var writeHeader = (polyData, fileFormat, fileType, headerComments, textureFileName, textureCoordinatesName, vertexCount, faceListLength, withNormals, withUVs, withColors, withIndices) => {
  const isBinary = fileFormat !== FormatTypes2.ASCII;
  let format2;
  if (isBinary) {
    format2 = fileType ? "binary_little_endian" : "binary_big_endian";
  } else format2 = "ascii";
  headerComments.unshift("VTK.js generated PLY File");
  if (textureFileName) {
    headerComments.push(`TextureFile ${textureFileName}`);
  }
  const commentElements = headerComments.map((comment) => `comment ${comment}`).join("\n");
  const header = ["ply", `format ${format2} 1.0`, `${commentElements}`, `element vertex ${vertexCount}`, "property float x", "property float y", "property float z"];
  if (withNormals) {
    header.push("property float nx", "property float ny", "property float nz");
  }
  if (withUVs) {
    header.push(`property float ${textureCoordinatesName[0]}`, `property float ${textureCoordinatesName[1]}`);
  }
  if (withColors) {
    header.push("property uchar red", "property uchar green", "property uchar blue");
  }
  if (withIndices) {
    header.push(`element face ${faceListLength}`, "property list uchar int vertex_indices");
  }
  header.push("end_header\n");
  return header.join("\n");
};
var binaryWriter2 = () => {
  let output;
  let vOffset;
  let fOffset;
  const indexByteCount = 4;
  let ft;
  return {
    init: (polyData) => {
    },
    writeHeader: (polyData, fileFormat, fileType, headerComments, textureFileName, textureCoordinatesName, numPts, numPolys, withNormals, withUVs, withColors, withIndices) => {
      const vertexCount = polyData.getPoints().getNumberOfPoints();
      ft = fileType;
      const faceListLength = withIndices ? numPolys * (indexByteCount * 3 + 1) : 0;
      const vertexListLength = vertexCount * (4 * 3 + (withNormals ? 4 * 3 : 0) + (withUVs ? 4 * 2 : 0) + (withColors ? 3 : 0));
      const header = writeHeader(polyData, fileFormat, fileType, headerComments, textureFileName, textureCoordinatesName, numPts, numPolys, withNormals, withUVs, withColors, withIndices);
      const headerBin = new TextEncoder().encode(header);
      output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));
      new Uint8Array(output.buffer).set(headerBin, 0);
      vOffset = headerBin.length;
      fOffset = vOffset + vertexListLength;
    },
    writeVertice: (x, y, z, nx, ny, nz, u, v, r, g, b2) => {
      output.setFloat32(vOffset, x, ft);
      vOffset += 4;
      output.setFloat32(vOffset, y, ft);
      vOffset += 4;
      output.setFloat32(vOffset, z, ft);
      vOffset += 4;
      if (nx !== null && ny !== null && nz !== null) {
        output.setFloat32(vOffset, nx, ft);
        vOffset += 4;
        output.setFloat32(vOffset, ny, ft);
        vOffset += 4;
        output.setFloat32(vOffset, nz, ft);
        vOffset += 4;
      }
      if (u !== null && v !== null) {
        output.setFloat32(vOffset, u, ft);
        vOffset += 4;
        output.setFloat32(vOffset, v, ft);
        vOffset += 4;
      }
      if (r !== null && g !== null && b2 !== null) {
        output.setUint8(vOffset, r);
        vOffset += 1;
        output.setUint8(vOffset, g);
        vOffset += 1;
        output.setUint8(vOffset, b2);
        vOffset += 1;
      }
    },
    writeFace: (n, x, y, z) => {
      output.setUint8(fOffset, n);
      fOffset += 1;
      output.setUint32(fOffset, x, ft);
      fOffset += indexByteCount;
      output.setUint32(fOffset, y, ft);
      fOffset += indexByteCount;
      output.setUint32(fOffset, z, ft);
      fOffset += indexByteCount;
    },
    writeFooter: (polyData) => {
    },
    getOutputData: () => output
  };
};
var asciiWriter2 = () => {
  let fileContent = "";
  return {
    init: (polyData) => {
    },
    writeHeader: (polyData, fileFormat, fileType, headerComments, textureFileName, textureCoordinatesName, numPts, numPolys, withNormals, withUVs, withColors, withIndices) => {
      fileContent += writeHeader(polyData, fileFormat, fileType, headerComments, textureFileName, textureCoordinatesName, numPts, numPolys, withNormals, withUVs, withColors, withIndices);
    },
    writeVertice: (x, y, z, nx, ny, nz, u, v, r, g, b2) => {
      fileContent += `${x} ${y} ${z}`;
      if (nx !== null && ny !== null && nz !== null) {
        fileContent += ` ${nx} ${ny} ${nz}`;
      }
      if (u !== null && v !== null) {
        fileContent += ` ${u} ${v}`;
      }
      if (r !== null && g !== null && b2 !== null) {
        fileContent += ` ${r} ${g} ${b2}`;
      }
      fileContent += "\n";
    },
    writeFace: (n, x, y, z) => {
      fileContent += `${n} ${x} ${y} ${z}
`;
    },
    writeFooter: (polyData) => {
    },
    getOutputData: () => fileContent
  };
};
function writePLY(polyData, format2, dataByteOrder, headerComments, textureFileName, textureCoordinatesName, transform, withNormals, withUVs, withColors, withIndices) {
  const inPts = polyData.getPoints();
  const polys = polyData.getPolys();
  if (inPts === null || polys === null) {
    vtkErrorMacro53("No data to write!");
  }
  let writer = null;
  if (format2 === FormatTypes2.BINARY) {
    writer = binaryWriter2();
  } else if (format2 === FormatTypes2.ASCII) {
    writer = asciiWriter2();
  } else {
    vtkErrorMacro53("Invalid type format");
  }
  let tCoordsName = textureCoordinatesName;
  if (typeof textureCoordinatesName === "undefined") {
    vtkWarningMacro11("Invalid TextureCoordinatesName value, fallback to default uv values");
    tCoordsName = TextureCoordinatesName.UV;
  }
  writer.init(polyData);
  const numPts = inPts.getNumberOfPoints();
  const numPolys = polys.getNumberOfCells();
  const textureCoords = polyData.getPointData().getTCoords();
  withUVs = !(textureCoords === null);
  const scalars = polyData.getPointData().getScalars();
  withColors = !(scalars === null);
  const fileType = dataByteOrder ? 0 : 1;
  writer.writeHeader(polyData, format2, fileType, headerComments, textureFileName, tCoordsName, numPts, numPolys, withNormals, withUVs, withColors, withIndices);
  const normals = polyData.getPointData().getNormals();
  for (let i = 0; i < numPts; i++) {
    let p = inPts.getPoint(i);
    const x = p[0].toPrecision(6) / 1;
    const y = p[1].toPrecision(6) / 1;
    const z = p[2].toPrecision(6) / 1;
    let nx = null;
    let ny = null;
    let nz = null;
    let u = null;
    let v = null;
    let r = null;
    let g = null;
    let b2 = null;
    if (textureCoords) {
      u = textureCoords.getData()[i * 2];
      v = textureCoords.getData()[i * 2 + 1];
    }
    if (scalars) {
      r = scalars.getData()[i * 3];
      g = scalars.getData()[i * 3 + 1];
      b2 = scalars.getData()[i * 3 + 2];
    }
    if (normals) {
      nx = normals.getData()[i * 3];
      ny = normals.getData()[i * 3 + 1];
      nz = normals.getData()[i * 3 + 2];
    }
    writer.writeVertice(x, y, z, nx, ny, nz, u, v, r, g, b2);
  }
  const pd = polys.getData();
  for (let i = 0, l = pd.length; i < l; i += 4) {
    writer.writeFace(pd[i + 0], pd[i + 1], pd[i + 2], pd[i + 3]);
  }
  writer.writeFooter(polyData);
  return writer.getOutputData();
}
var STATIC11 = {
  writePLY
};
function vtkPLYWriter(publicAPI, model) {
  model.classHierarchy.push("vtkPLYWriter");
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input || input.getClassName() !== "vtkPolyData") {
      vtkErrorMacro53("Invalid or missing input");
      return;
    }
    outData[0] = writePLY(input, model.format, model.dataByteOrder, model.headerComments, model.textureFileName, model.textureCoordinatesName, model.transform, model.withNormals, model.withUVs, model.withColors, model.withIndices);
  };
}
var DEFAULT_VALUES114 = {
  format: FormatTypes2.ASCII,
  dataByteOrder: 0,
  headerComments: [],
  textureFileName: null,
  textureCoordinatesName: TextureCoordinatesName.UV,
  transform: null,
  withNormals: true,
  withUVs: true,
  withColors: true,
  withIndices: true
};
function extend126(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES114, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.setGet(publicAPI, model, [
    "format",
    "dataByteOrder",
    // binary_little_endian 0 binary_big_endian 1
    "headerComments",
    "textureFileName",
    "textureCoordinatesName",
    "transform",
    "withNormals",
    "withUVs",
    "withColors",
    "withIndices"
  ]);
  vtkPLYWriter(publicAPI, model);
}
var newInstance121 = macro.newInstance(extend126, "vtkPLYWriter");
var vtkPLYWriter$1 = {
  newInstance: newInstance121,
  extend: extend126,
  ...STATIC11
};

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter/Constants.js
var BINARY_HEADER_MAGIC = "glTF";
var BINARY_HEADER_LENGTH = 12;
var BINARY_CHUNK_TYPES = {
  JSON: 1313821514,
  BIN: 5130562
};
var BINARY_HEADER_INTS = 3;
var BINARY_CHUNK_HEADER_INTS = 2;
var MIN_LIGHT_ATTENUATION = 0.01;
var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
};
var MODES = {
  GL_POINTS: 0,
  GL_LINES: 1,
  GL_LINE_LOOP: 2,
  GL_LINE_STRIP: 3,
  GL_TRIANGLES: 4,
  GL_TRIANGLE_STRIP: 5,
  GL_TRIANGLE_FAN: 6
};
var ARRAY_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var GL_SAMPLER = {
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  REPEAT: 10497,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243
};
var DEFAULT_SAMPLER = {
  magFilter: GL_SAMPLER.NEAREST,
  minFilter: GL_SAMPLER.LINEAR_MIPMAP_LINEAR,
  wrapS: GL_SAMPLER.REPEAT,
  wrapT: GL_SAMPLER.REPEAT
};
var SEMANTIC_ATTRIBUTE_MAP = {
  NORMAL: "normal",
  POSITION: "position",
  TEXCOORD_0: "texcoord0",
  TEXCOORD_1: "texcoord1",
  WEIGHTS_0: "weight",
  JOINTS_0: "joint",
  COLOR_0: "color",
  TANGENT: "tangent"
};
var ALPHA_MODE = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter/Utils.js
var {
  vtkWarningMacro: vtkWarningMacro12,
  vtkErrorMacro: vtkErrorMacro54
} = macro;
function getGLEnumFromSamplerParameter(parameter) {
  const GL_TEXTURE_MAG_FILTER = 10240;
  const GL_TEXTURE_MIN_FILTER = 10241;
  const GL_TEXTURE_WRAP_S = 10242;
  const GL_TEXTURE_WRAP_T = 10243;
  const Mapping = {
    magFilter: GL_TEXTURE_MAG_FILTER,
    minFilter: GL_TEXTURE_MIN_FILTER,
    wrapS: GL_TEXTURE_WRAP_S,
    wrapT: GL_TEXTURE_WRAP_T
  };
  return Mapping[parameter];
}
function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ARRAY_TYPES[accessor.componentType];
  const components = COMPONENTS[accessor.type];
  const bytesPerComponent = BYTES[accessor.componentType];
  const length = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  return {
    ArrayType,
    length,
    byteLength
  };
}
function resolveUrl(url, originalPath) {
  if (typeof url !== "string" || url === "") return "";
  try {
    if (url.startsWith("data:")) return url;
    if (url.startsWith("blob:")) return url;
    const baseUrl = new URL(originalPath);
    if (!baseUrl.pathname.includes(".") && !baseUrl.pathname.endsWith("/")) {
      baseUrl.pathname += "/";
    }
    if (url.startsWith("http:") || url.startsWith("https:") || url.startsWith("//")) {
      return new URL(url, baseUrl).href;
    }
    if (url.startsWith("/")) {
      return new URL(url, baseUrl).href;
    }
    return new URL(url, baseUrl).href;
  } catch (error) {
    vtkErrorMacro54("Error resolving URL:", error);
    return "";
  }
}
async function loadImage(image) {
  if (image.bufferView) {
    const blob = new Blob([image.bufferView.data], {
      type: image.mimeType
    });
    const bitmap = await createImageBitmap(blob, {
      colorSpaceConversion: "none",
      imageOrientation: "flipY"
    });
    return bitmap;
  }
  if (image.uri) {
    vtkWarningMacro12("Falling back to image uri", image.uri);
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "Anonymous";
      img.onload = () => {
        resolve(img);
      };
      img.onerror = reject;
      img.src = image.uri;
    });
  }
  return null;
}
function createVTKTextureFromGLTFTexture(image, sampler, extensions) {
  const texture = vtkTexture$1.newInstance();
  if (sampler) {
    if ("wrapS" in sampler && "wrapT" in sampler || "minFilter" in sampler && "magFilter" in sampler) {
      if (sampler.wrapS === GL_SAMPLER.CLAMP_TO_EDGE || sampler.wrapT === GL_SAMPLER.CLAMP_TO_EDGE) {
        texture.setRepeat(false);
        texture.setEdgeClamp(true);
      } else if (sampler.wrapS === GL_SAMPLER.REPEAT || sampler.wrapT === GL_SAMPLER.REPEAT) {
        texture.setRepeat(true);
        texture.setEdgeClamp(false);
      } else {
        vtkWarningMacro12("Mirrored texture wrapping is not supported!");
      }
      const linearFilters = [GL_SAMPLER.LINEAR, GL_SAMPLER.LINEAR_MIPMAP_NEAREST, GL_SAMPLER.NEAREST_MIPMAP_LINEAR, GL_SAMPLER.LINEAR_MIPMAP_LINEAR];
      if (linearFilters.includes(sampler.minFilter) || linearFilters.includes(sampler.magFilter)) {
        texture.setInterpolate(true);
      }
    } else {
      texture.setMipLevel(8);
      texture.setInterpolate(true);
      texture.setEdgeClamp(true);
    }
  }
  texture.setImageBitmap(image);
  return texture;
}

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter/Parser.js
var {
  vtkDebugMacro: vtkDebugMacro11,
  vtkWarningMacro: vtkWarningMacro13
} = macro;
var GLTFParser = class {
  constructor(glTF) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      json,
      baseUri = ""
    } = glTF;
    this.glTF = glTF;
    this.options = options;
    this.baseUri = baseUri;
    this.json = json;
    this.extensions = json.extensions || {};
    this.extensionsUsed = json.extensionsUsed || [];
  }
  async parse() {
    const buffers = this.json.buffers || [];
    this.buffers = new Array(buffers.length).fill(null);
    const images = this.json.images || [];
    this.images = new Array(images.length).fill({});
    await this.loadBuffers();
    await this.loadImages();
    this.resolveTree();
    return this.glTF.json;
  }
  resolveTree() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    this.json.scenes = (_a = this.json.scenes) == null ? void 0 : _a.map((scene, idx) => this.resolveScene(scene, idx));
    this.json.cameras = (_b = this.json.cameras) == null ? void 0 : _b.map((camera, idx) => this.resolveCamera(camera, idx));
    this.json.bufferViews = (_c = this.json.bufferViews) == null ? void 0 : _c.map((bufView, idx) => this.resolveBufferView(bufView, idx));
    this.json.images = (_d = this.json.images) == null ? void 0 : _d.map((image, idx) => this.resolveImage(image, idx));
    this.json.samplers = (_e = this.json.samplers) == null ? void 0 : _e.map((sampler, idx) => this.resolveSampler(sampler, idx));
    this.json.textures = (_f = this.json.textures) == null ? void 0 : _f.map((texture, idx) => this.resolveTexture(texture, idx));
    this.json.accessors = (_g = this.json.accessors) == null ? void 0 : _g.map((accessor, idx) => this.resolveAccessor(accessor, idx));
    this.json.materials = (_h = this.json.materials) == null ? void 0 : _h.map((material, idx) => this.resolveMaterial(material, idx));
    this.json.meshes = (_i = this.json.meshes) == null ? void 0 : _i.map((mesh, idx) => this.resolveMesh(mesh, idx));
    this.json.nodes = (_j = this.json.nodes) == null ? void 0 : _j.map((node, idx) => this.resolveNode(node, idx));
    this.json.skins = (_k = this.json.skins) == null ? void 0 : _k.map((skin, idx) => this.resolveSkin(skin, idx));
    this.json.animations = (_l = this.json.animations) == null ? void 0 : _l.map((animation, idx) => this.resolveAnimation(animation, idx));
  }
  get(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      vtkWarningMacro13(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  resolveScene(scene, index) {
    scene.id = scene.id || `scene-${index}`;
    scene.nodes = (scene.nodes || []).map((node) => this.get("nodes", node));
    return scene;
  }
  resolveNode(node, index) {
    var _a, _b;
    node.id = node.id || `node-${index}`;
    if (node.children) {
      node.children = node.children.map((child) => this.get("nodes", child));
    }
    if (node.mesh !== void 0) {
      node.mesh = this.get("meshes", node.mesh);
    } else if (node.meshes !== void 0 && node.meshes.length) {
      node.mesh = node.meshes.reduce((accum, meshIndex) => {
        const mesh = this.get("meshes", meshIndex);
        accum.id = mesh.id;
        accum.primitives = accum.primitives.concat(mesh.primitives);
        return accum;
      }, {
        primitives: []
      });
    }
    if (node.camera !== void 0) {
      node.camera = this.get("cameras", node.camera);
    }
    if (node.skin !== void 0) {
      node.skin = this.get("skins", node.skin);
    }
    if ((_a = node.extensions) == null ? void 0 : _a.KHR_lights_punctual) {
      node.extensions.KHR_lights_punctual.light = (_b = this.extensions) == null ? void 0 : _b.KHR_lights_punctual.lights[node.extensions.KHR_lights_punctual.light];
    }
    return node;
  }
  resolveSkin(skin, index) {
    skin.id = skin.id || `skin-${index}`;
    skin.inverseBindMatrices = this.get("accessors", skin.inverseBindMatrices);
    return skin;
  }
  resolveMesh(mesh, index) {
    mesh.id = mesh.id || `mesh-${index}`;
    if (mesh.primitives) {
      mesh.primitives = mesh.primitives.map((primitive, idx) => {
        var _a;
        const attributes = primitive.attributes;
        primitive.name = `primitive-${idx}`;
        primitive.attributes = {};
        for (const attribute in attributes) {
          const attr = SEMANTIC_ATTRIBUTE_MAP[attribute];
          primitive.attributes[attr] = this.get("accessors", attributes[attribute]);
        }
        if (primitive.indices !== void 0) {
          primitive.indices = this.get("accessors", primitive.indices);
        }
        if (primitive.material !== void 0) {
          primitive.material = this.get("materials", primitive.material);
        }
        if (primitive.mode === void 0) {
          primitive.mode = MODES.GL_TRIANGLES;
        }
        if ((_a = primitive.extensions) == null ? void 0 : _a.KHR_draco_mesh_compression) {
          vtkDebugMacro11("Using Draco mesh compression");
          const bufferView = this.get("bufferViews", primitive.extensions.KHR_draco_mesh_compression.bufferView);
          primitive.extensions.KHR_draco_mesh_compression.bufferView = bufferView.data;
        }
        return primitive;
      });
    }
    return mesh;
  }
  resolveMaterial(material, index) {
    material.id = material.id || `material-${index}`;
    if (material.alphaMode === void 0) material.alphaMode = ALPHA_MODE.OPAQUE;
    if (material.doubleSided === void 0) material.doubleSided = false;
    if (material.alphaCutoff === void 0) material.alphaCutoff = 0.5;
    if (material.normalTexture) {
      material.normalTexture = {
        ...material.normalTexture
      };
      material.normalTexture.texture = this.get("textures", material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlusionTexture = {
        ...material.occlusionTexture
      };
      material.occlusionTexture.texture = this.get("textures", material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emissiveTexture = {
        ...material.emissiveTexture
      };
      material.emissiveTexture.texture = this.get("textures", material.emissiveTexture.index);
    }
    if (!material.emissiveFactor) {
      material.emissiveFactor = material.emissiveTexture ? 1 : 0;
    } else material.emissiveFactor = material.emissiveFactor[0];
    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = {
        ...material.pbrMetallicRoughness
      };
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture = {
          ...mr.baseColorTexture
        };
        mr.baseColorTexture.texture = this.get("textures", mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = {
          ...mr.metallicRoughnessTexture
        };
        mr.metallicRoughnessTexture.texture = this.get("textures", mr.metallicRoughnessTexture.index);
      }
    } else {
      material.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
    }
    return material;
  }
  /**
   * Take values of particular accessor from interleaved buffer various parts of
   * the buffer
   */
  getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
    const result = new Uint8Array(count * bytesPerElement);
    for (let i = 0; i < count; i++) {
      const elementOffset = byteOffset + i * byteStride;
      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);
    }
    return result.buffer;
  }
  resolveAccessor(accessor, index) {
    accessor.id = accessor.id || `accessor-${index}`;
    if (accessor.bufferView !== void 0) {
      accessor.bufferView = this.get("bufferViews", accessor.bufferView);
    }
    accessor.bytesPerComponent = BYTES[accessor.componentType];
    accessor.components = COMPONENTS[accessor.type];
    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
    if (accessor.bufferView) {
      const buffer = accessor.bufferView.buffer;
      const {
        ArrayType
      } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
      const baseByteOffset = (accessor.bufferView.byteOffset || 0) + buffer.byteOffset;
      const byteOffset = baseByteOffset + (accessor.byteOffset || 0);
      let arrayBufferView;
      if (accessor.bufferView.byteStride) {
        if (accessor.bufferView.byteStride === accessor.bytesPerElement) {
          arrayBufferView = new ArrayType(buffer.arrayBuffer, byteOffset, accessor.count * accessor.components);
        } else {
          const interleavedBuffer = this.getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
          arrayBufferView = new ArrayType(interleavedBuffer);
        }
      } else {
        arrayBufferView = new ArrayType(buffer.arrayBuffer, byteOffset, accessor.count * accessor.components);
      }
      accessor.value = arrayBufferView;
    }
    return accessor;
  }
  resolveTexture(texture, index) {
    texture.id = texture.id || `texture-${index}`;
    texture.sampler = "sampler" in texture ? this.get("samplers", texture.sampler) : DEFAULT_SAMPLER;
    texture.source = this.get("images", texture.source);
    if (texture.extensions !== void 0) {
      const extensionsNames = Object.keys(texture.extensions);
      extensionsNames.forEach((extensionName) => {
        const extension = texture.extensions[extensionName];
        switch (extensionName) {
          case "KHR_texture_basisu":
          case "EXT_texture_webp":
          case "EXT_texture_avif":
            texture.source = this.get("images", extension.source);
            break;
          default:
            vtkWarningMacro13(`Unhandled extension: ${extensionName}`);
        }
      });
    }
    return texture;
  }
  resolveSampler(sampler, index) {
    sampler.id = sampler.id || `sampler-${index}`;
    if (!Object.hasOwn(sampler, "wrapS")) sampler.wrapS = GL_SAMPLER.REPEAT;
    if (!Object.hasOwn(sampler, "wrapT")) sampler.wrapT = GL_SAMPLER.REPEAT;
    if (!Object.hasOwn(sampler, "minFilter")) sampler.minFilter = GL_SAMPLER.LINEAR_MIPMAP_LINEAR;
    if (!Object.hasOwn(sampler, "magFilter")) sampler.magFilter = GL_SAMPLER.NEAREST;
    sampler.parameters = {};
    for (const key in sampler) {
      const glEnum = getGLEnumFromSamplerParameter(key);
      if (glEnum !== void 0) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
    return sampler;
  }
  resolveImage(image, index) {
    image.id = image.id || `image-${index}`;
    if (image.bufferView !== void 0) {
      image.bufferView = this.get("bufferViews", image.bufferView);
    }
    return image;
  }
  resolveBufferView(bufferView, index) {
    bufferView.id = bufferView.id || `bufferView-${index}`;
    const bufferIndex = bufferView.buffer;
    bufferView.buffer = this.buffers[bufferIndex];
    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
    if ("byteOffset" in bufferView) {
      byteOffset += bufferView.byteOffset;
    }
    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    return bufferView;
  }
  resolveCamera(camera, index) {
    camera.id = camera.id || `camera-${index}`;
    return camera;
  }
  resolveAnimation(animation, index) {
    animation.id = animation.id || `animation-${index}`;
    animation.samplers.map((sampler) => {
      sampler.input = this.get("accessors", sampler.input).value;
      sampler.output = this.get("accessors", sampler.output).value;
      return sampler;
    });
    return animation;
  }
  loadBuffers() {
    const promises = this.json.buffers.map((buffer, idx) => this.loadBuffer(buffer, idx).then(() => {
      delete buffer.uri;
    }));
    return Promise.all(promises);
  }
  async loadBuffer(buffer, index) {
    let arrayBuffer = buffer;
    if (buffer.uri) {
      vtkDebugMacro11("Loading uri", buffer.uri);
      const uri = resolveUrl(buffer.uri, this.options.baseUri);
      const response = await fetch(uri);
      arrayBuffer = await response.arrayBuffer();
    } else if (this.glTF.glbBuffers) {
      arrayBuffer = this.glTF.glbBuffers[index];
    }
    this.buffers[index] = {
      arrayBuffer,
      byteOffset: 0,
      byteLength: arrayBuffer.byteLength
    };
  }
  loadImages() {
    const images = this.json.images || [];
    const promises = [];
    return new Promise((resolve, reject) => {
      for (let i = 0; i < images.length; ++i) {
        promises.push(Promise.resolve(this.loadImage(images[i], i).then(() => {
          vtkDebugMacro11("Texture loaded ", images[i]);
        })));
      }
      Promise.all(promises).then(() => resolve(this.images));
    });
  }
  async loadImage(image, index) {
    let arrayBuffer;
    let buffer;
    if (image.uri) {
      vtkDebugMacro11("Loading texture", image.uri);
      const uri = resolveUrl(image.uri, this.options.baseUri);
      const response = await fetch(uri);
      arrayBuffer = await response.arrayBuffer();
      image.uri = uri;
      image.bufferView = {
        data: arrayBuffer
      };
    } else if (image.bufferView) {
      const bufferView = this.get("bufferViews", image.bufferView);
      buffer = this.get("buffers", bufferView.buffer);
      if (this.glTF.glbBuffers) {
        buffer = this.glTF.glbBuffers[bufferView.buffer];
        arrayBuffer = buffer.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);
      }
      image.bufferView = {
        data: arrayBuffer
      };
    }
  }
};

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter/Extensions.js
var {
  vtkWarningMacro: vtkWarningMacro14
} = macro;
function handleKHRMaterialsUnlit(extension, property) {
  property.setLighting(true);
}
function handleKHRMaterialsIor(extension, property) {
  property.setBaseIOR(extension.ior);
}
function handleKHRMaterialsSpecular(extension, property) {
  property.setSpecular(extension.specularFactor);
  property.setSpecularColor(extension.specularColorFactor);
}
function handleKHRLightsPunctual(extension, transformMatrix, model) {
  const {
    light
  } = extension;
  const {
    color: color4,
    intensity,
    range,
    spot,
    type
  } = light;
  const l = vtkLight$1.newInstance({
    color: color4 || [1, 1, 1],
    intensity: intensity || 1
  });
  l.setTransformMatrix(transformMatrix);
  if (range > 0) {
    l.setAttenuationValues(1, 0, 1 / (range * range * MIN_LIGHT_ATTENUATION));
  }
  switch (type) {
    case "directional":
      l.setPositional(false);
      break;
    case "point":
      l.setPositional(true);
      l.setConeAngle(90);
      break;
    case "spot":
      l.setPositional(true);
      l.setConeAngle(radiansFromDegrees(spot.outerConeAngle));
      break;
    default:
      vtkWarningMacro14(`Unsupported light type: ${type}`);
  }
  model.lights.set(light.name, l);
}
function handleKHRDracoMeshCompression(extension) {
  const reader = vtkDracoReader$1.newInstance();
  reader.parse(extension.bufferView);
  return reader.getOutputData();
}
function handleKHRMaterialsVariants(extension, model) {
  model.variants = extension.variants.map((v) => v.name);
}

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter/Reader.js
var {
  vtkWarningMacro: vtkWarningMacro15,
  vtkDebugMacro: vtkDebugMacro12
} = macro;
async function parseGLTF(gltf, options) {
  const parser = new GLTFParser(gltf, options);
  const tree = await parser.parse();
  return tree;
}
async function createPolyDataFromGLTFMesh(primitive) {
  var _a;
  if (!primitive || !primitive.attributes) {
    vtkWarningMacro15("Primitive has no position data, skipping");
    return null;
  }
  if ((_a = primitive.extensions) == null ? void 0 : _a.KHR_draco_mesh_compression) {
    return handleKHRDracoMeshCompression(primitive.extensions.KHR_draco_mesh_compression);
  }
  const polyData = vtkPolyData$1.newInstance();
  const cells = vtkCellArray$1.newInstance();
  const pointData = polyData.getPointData();
  const attrs = Object.entries(primitive.attributes);
  attrs.forEach(async (_ref) => {
    let [attributeName, accessor] = _ref;
    switch (attributeName) {
      case SEMANTIC_ATTRIBUTE_MAP.POSITION: {
        const position = primitive.attributes.position.value;
        polyData.getPoints().setData(position, primitive.attributes.position.component);
        break;
      }
      case SEMANTIC_ATTRIBUTE_MAP.NORMAL: {
        const normals = primitive.attributes.normal.value;
        pointData.setNormals(vtkDataArray$1.newInstance({
          name: "Normals",
          values: normals,
          numberOfComponents: primitive.attributes.normal.components
        }));
        break;
      }
      case SEMANTIC_ATTRIBUTE_MAP.COLOR_0: {
        const color4 = primitive.attributes.color.value;
        pointData.setScalars(vtkDataArray$1.newInstance({
          name: "Scalars",
          values: color4,
          numberOfComponents: primitive.attributes.color.components
        }));
        break;
      }
      case SEMANTIC_ATTRIBUTE_MAP.TEXCOORD_0: {
        const tcoords0 = primitive.attributes.texcoord0.value;
        const da = vtkDataArray$1.newInstance({
          name: "TEXCOORD_0",
          values: tcoords0,
          numberOfComponents: primitive.attributes.texcoord0.components
        });
        pointData.addArray(da);
        pointData.setActiveTCoords(da.getName());
        break;
      }
      case SEMANTIC_ATTRIBUTE_MAP.TEXCOORD_1: {
        const tcoords = primitive.attributes.texcoord1.value;
        const dac = vtkDataArray$1.newInstance({
          name: "TEXCOORD_1",
          values: tcoords,
          numberOfComponents: primitive.attributes.texcoord1.components
        });
        pointData.addArray(dac);
        break;
      }
      case SEMANTIC_ATTRIBUTE_MAP.TANGENT: {
        const tangent = primitive.attributes.tangent.value;
        const dat = vtkDataArray$1.newInstance({
          name: "Tangents",
          values: tangent,
          numberOfComponents: primitive.attributes.tangent.components
        });
        pointData.addArray(dat);
        break;
      }
      default:
        vtkWarningMacro15(`Unhandled attribute: ${attributeName}`);
    }
  });
  if (primitive.indices != null) {
    const indices = primitive.indices.value;
    const nCells = indices.length - 2;
    switch (primitive.mode) {
      case MODES.GL_LINE_STRIP:
      case MODES.GL_TRIANGLE_STRIP:
      case MODES.GL_LINE_LOOP:
        vtkWarningMacro15("GL_LINE_LOOP not implemented");
        break;
      default:
        cells.allocate(4 * indices.length / 3);
        for (let cellId = 0; cellId < nCells; cellId += 3) {
          const cell = indices.slice(cellId, cellId + 3);
          cells.insertNextCell(cell);
        }
    }
  }
  switch (primitive.mode) {
    case MODES.GL_TRIANGLES:
    case MODES.GL_TRIANGLE_FAN:
      polyData.setPolys(cells);
      break;
    case MODES.GL_LINES:
    case MODES.GL_LINE_STRIP:
    case MODES.GL_LINE_LOOP:
      polyData.setLines(cells);
      break;
    case MODES.GL_POINTS:
      polyData.setVerts(cells);
      break;
    case MODES.GL_TRIANGLE_STRIP:
      polyData.setStrips(cells);
      break;
    default:
      cells.delete();
      vtkWarningMacro15("Invalid primitive draw mode. Ignoring connectivity.");
  }
  return polyData;
}
async function createPropertyFromGLTFMaterial(model, material, actor) {
  let metallicFactor = 1;
  let roughnessFactor = 1;
  const emissiveFactor = material.emissiveFactor;
  const property = actor.getProperty();
  const pbr = material.pbrMetallicRoughness;
  if (pbr != null) {
    if (!(pbr == null ? void 0 : pbr.metallicFactor) || (pbr == null ? void 0 : pbr.metallicFactor) <= 0 || (pbr == null ? void 0 : pbr.metallicFactor) >= 1) {
      vtkDebugMacro12("Invalid material.pbrMetallicRoughness.metallicFactor value. Using default value instead.");
    } else metallicFactor = pbr.metallicFactor;
    if (!(pbr == null ? void 0 : pbr.roughnessFactor) || (pbr == null ? void 0 : pbr.roughnessFactor) <= 0 || (pbr == null ? void 0 : pbr.roughnessFactor) >= 1) {
      vtkDebugMacro12("Invalid material.pbrMetallicRoughness.roughnessFactor value. Using default value instead.");
    } else roughnessFactor = pbr.roughnessFactor;
    const color4 = pbr.baseColorFactor;
    if (color4 != null) {
      property.setDiffuseColor(color4[0], color4[1], color4[2]);
      property.setOpacity(color4[3]);
    }
    property.setMetallic(metallicFactor);
    property.setRoughness(roughnessFactor);
    property.setEmission(emissiveFactor);
    if (pbr.baseColorTexture) {
      pbr.baseColorTexture.extensions;
      const tex = pbr.baseColorTexture.texture;
      if (tex.extensions != null) {
        const extensionsNames = Object.keys(tex.extensions);
        extensionsNames.forEach((extensionName) => {
          switch (extensionName) {
            default:
              vtkWarningMacro15(`Unhandled extension: ${extensionName}`);
          }
        });
      }
      const sampler = tex.sampler;
      const image = await loadImage(tex.source);
      const diffuseTex = createVTKTextureFromGLTFTexture(image, sampler);
      property.setDiffuseTexture(diffuseTex);
    }
    if (pbr.metallicRoughnessTexture) {
      pbr.metallicRoughnessTexture.extensions;
      const tex = pbr.metallicRoughnessTexture.texture;
      const sampler = tex.sampler;
      const rmImage = await loadImage(tex.source);
      const rmTex = createVTKTextureFromGLTFTexture(rmImage, sampler);
      property.setRMTexture(rmTex);
    }
    if (material.occlusionTexture) {
      material.occlusionTexture.extensions;
      const tex = material.occlusionTexture.texture;
      const sampler = tex.sampler;
      const aoImage = await loadImage(tex.source);
      const aoTex = createVTKTextureFromGLTFTexture(aoImage, sampler);
      property.setAmbientOcclusionTexture(aoTex);
    }
    if (material.emissiveTexture) {
      material.emissiveTexture.extensions;
      const tex = material.emissiveTexture.texture;
      const sampler = tex.sampler;
      const emissiveImage = await loadImage(tex.source);
      const emissiveTex = createVTKTextureFromGLTFTexture(emissiveImage, sampler);
      property.setEmissionTexture(emissiveTex);
      if (material.emissiveTexture.texCoord != null) {
        const pd = actor.getMapper().getInputData().getPointData();
        pd.setActiveTCoords(`TEXCOORD_${material.emissiveTexture.texCoord}`);
      }
    }
    if (material.normalTexture) {
      material.normalTexture.extensions;
      const tex = material.normalTexture.texture;
      const sampler = tex.sampler;
      const normalImage = await loadImage(tex.source);
      const normalTex = createVTKTextureFromGLTFTexture(normalImage, sampler);
      property.setNormalTexture(normalTex);
      if (material.normalTexture.scale != null) {
        property.setNormalStrength(material.normalTexture.scale);
      }
    }
  }
  if (material.extensions != null) {
    const extensionsNames = Object.keys(material.extensions);
    extensionsNames.forEach((extensionName) => {
      const extension = material.extensions[extensionName];
      switch (extensionName) {
        case "KHR_materials_unlit":
          handleKHRMaterialsUnlit(extension, property);
          break;
        case "KHR_materials_ior":
          handleKHRMaterialsIor(extension, property);
          break;
        case "KHR_materials_specular":
          handleKHRMaterialsSpecular(extension, property);
          break;
        default:
          vtkWarningMacro15(`Unhandled extension: ${extensionName}`);
      }
    });
  }
  if (material.alphaMode !== ALPHA_MODE.OPAQUE) {
    actor.setForceTranslucent(true);
  }
  property.setBackfaceCulling(!material.doubleSided);
}
function handlePrimitiveExtensions(nodeId, extensions, model) {
  const extensionsNames = Object.keys(extensions);
  extensionsNames.forEach((extensionName) => {
    const extension = extensions[extensionName];
    switch (extensionName) {
      case "KHR_materials_variants":
        model.variantMappings.set(nodeId, extension.mappings);
        break;
      case "KHR_draco_mesh_compression":
        break;
      default:
        vtkWarningMacro15(`Unhandled extension: ${extensionName}`);
    }
  });
}
async function createActorFromGTLFNode(worldMatrix) {
  const actor = vtkActor$1.newInstance();
  const mapper = vtkMapper$1.newInstance();
  mapper.setColorModeToDirectScalars();
  mapper.setInterpolateScalarsBeforeMapping(true);
  actor.setMapper(mapper);
  actor.setUserMatrix(worldMatrix);
  const polydata = vtkPolyData$1.newInstance();
  mapper.setInputData(polydata);
  return actor;
}
async function createActorFromGTLFPrimitive(model, primitive, worldMatrix) {
  const actor = vtkActor$1.newInstance();
  const mapper = vtkMapper$1.newInstance();
  mapper.setColorModeToDirectScalars();
  mapper.setInterpolateScalarsBeforeMapping(true);
  actor.setMapper(mapper);
  actor.setUserMatrix(worldMatrix);
  const polydata = await createPolyDataFromGLTFMesh(primitive);
  mapper.setInputData(polydata);
  if (primitive.material != null) {
    await createPropertyFromGLTFMaterial(model, primitive.material, actor);
  }
  if (primitive.extensions != null) {
    handlePrimitiveExtensions(`${primitive.name}`, primitive.extensions, model);
  }
  return actor;
}
function createGLTFAnimation(animation) {
  vtkDebugMacro12("Creating animation:", animation);
  return {
    name: animation.name,
    channels: animation.channels,
    samplers: animation.samplers,
    getChannelByTargetNode(nodeIndex) {
      return this.channels.filter((channel) => channel.target.node === nodeIndex);
    }
  };
}
function getTransformationMatrix(node) {
  const translation = node.translation ?? vec3_exports.create();
  const rotation = node.rotation ?? quat_exports.create();
  const scale = node.scale ?? vec3_exports.fromValues(1, 1, 1);
  const matrix = node.matrix != null ? mat4_exports.clone(node.matrix) : mat4_exports.fromRotationTranslationScale(mat4_exports.create(), rotation, translation, scale);
  return matrix;
}
async function processNode(node, model) {
  var _a;
  let parentActor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  let parentMatrix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : mat4_exports.create();
  node.transform = getTransformationMatrix(node);
  const worldMatrix = mat4_exports.multiply(mat4_exports.create(), parentMatrix, node.transform);
  if (node.mesh != null) {
    const nodeActor = await createActorFromGTLFNode(worldMatrix);
    if (parentActor) {
      nodeActor.setParentProp(parentActor);
    }
    model.actors.set(`${node.id}`, nodeActor);
    await Promise.all(node.mesh.primitives.map(async (primitive, i) => {
      const actor = await createActorFromGTLFPrimitive(model, primitive, worldMatrix);
      actor.setParentProp(nodeActor);
      model.actors.set(`${node.id}_${primitive.name}`, actor);
    }));
  }
  if ((_a = node.extensions) == null ? void 0 : _a.KHR_lights_punctual) {
    handleKHRLightsPunctual(node.extensions.KHR_lights_punctual, node.transform, model);
  }
  if (node.children && Array.isArray(node.children) && node.children.length > 0) {
    await Promise.all(node.children.map(async (child) => {
      const parent = model.actors.get(node.id);
      await processNode(child, model, parent, worldMatrix);
    }));
  }
}
async function createVTKObjects(model) {
  var _a, _b, _c, _d;
  model.animations = (_a = model.glTFTree.animations) == null ? void 0 : _a.map(createGLTFAnimation);
  const extensionsNames = Object.keys(((_b = model.glTFTree) == null ? void 0 : _b.extensions) || []);
  extensionsNames.forEach((extensionName) => {
    const extension = model.glTFTree.extensions[extensionName];
    switch (extensionName) {
      case "KHR_materials_variants":
        handleKHRMaterialsVariants(extension, model);
        break;
      case "KHR_draco_mesh_compression":
        break;
      default:
        vtkWarningMacro15(`Unhandled extension: ${extensionName}`);
    }
  });
  const sceneId = model.sceneId ?? model.glTFTree.scene;
  if (((_c = model.glTFTree.scenes) == null ? void 0 : _c.length) && ((_d = model.glTFTree.scenes[sceneId]) == null ? void 0 : _d.nodes)) {
    await Promise.all(model.glTFTree.scenes[sceneId].nodes.map(async (node) => {
      if (node) {
        await processNode(node, model);
      } else {
        vtkWarningMacro15(`Node not found in glTF.nodes`);
      }
    }));
  } else {
    vtkWarningMacro15("No valid scenes found in the glTF data");
  }
}
function GLTFCameraToVTKCamera(glTFCamera) {
  const camera = vtkCamera$1.newInstance();
  if (glTFCamera.type === "perspective") {
    const {
      yfov,
      znear,
      zfar
    } = glTFCamera.perspective;
    camera.setClippingRange(znear, zfar);
    camera.setParallelProjection(false);
    camera.setViewAngle(degreesFromRadians(yfov));
  } else if (glTFCamera.type === "orthographic") {
    const {
      ymag,
      znear,
      zfar
    } = glTFCamera.orthographic;
    camera.setClippingRange(znear, zfar);
    camera.setParallelProjection(true);
    camera.setParallelScale(ymag);
  } else {
    throw new Error("Unsupported camera type");
  }
  return camera;
}
function applyTransformToCamera(camera, transformMatrix) {
  if (!camera || !transformMatrix) {
    return;
  }
  const position = [0, 0, 0];
  const viewUp = [0, 1, 0];
  const focus = [0, 0, -1];
  const t = vtkTransform$1.newInstance();
  t.setMatrix(transformMatrix);
  t.transformPoint(position, position);
  t.transformPoints(viewUp, viewUp);
  t.transformPoints(focus, focus);
  focus[0] += position[0];
  focus[1] += position[1];
  focus[2] += position[2];
  camera.setPosition(position);
  camera.setFocalPoint(focus);
  camera.setViewUp(viewUp);
}

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter/Decoder.js
function getChunkInfo(headerStart, data2) {
  const header = new Uint32Array(data2, headerStart, BINARY_CHUNK_HEADER_INTS);
  const chunkStart = headerStart + BINARY_CHUNK_HEADER_INTS * 4;
  return {
    start: chunkStart,
    length: header[0],
    type: header[1]
  };
}
function getAllChunkInfos(data2) {
  const maxChunks = Math.floor((data2.byteLength - BINARY_HEADER_LENGTH) / 8);
  const infos = new Array(maxChunks);
  let chunkStart = BINARY_HEADER_INTS * 4;
  let chunkCount = 0;
  while (chunkStart < data2.byteLength) {
    const chunkInfo = getChunkInfo(chunkStart, data2);
    infos[chunkCount++] = chunkInfo;
    chunkStart += chunkInfo.length + BINARY_CHUNK_HEADER_INTS * 4;
  }
  return infos.slice(0, chunkCount);
}
function getJsonFromChunk(chunkInfo, data2) {
  const jsonStart = (BINARY_HEADER_INTS + BINARY_CHUNK_HEADER_INTS) * 4;
  const jsonView = new Uint8Array(data2, jsonStart, chunkInfo.length);
  const decoder = new TextDecoder("utf-8");
  const jsonString = decoder.decode(jsonView);
  return JSON.parse(jsonString);
}
function getBufferFromChunk(chunkInfo, data2) {
  return data2.slice(chunkInfo.start, chunkInfo.start + chunkInfo.length);
}
function parseGLB(data2) {
  if (data2.byteLength < BINARY_HEADER_LENGTH) {
    throw new Error("Invalid GLB: File too small");
  }
  const headerView = new DataView(data2, 0, BINARY_HEADER_LENGTH);
  const magic = new Uint8Array(data2, 0, 4);
  const header = {
    magic: BinaryHelper.arrayBufferToString(magic),
    version: headerView.getUint32(4, true),
    length: headerView.getUint32(8, true)
  };
  if (header.magic !== BINARY_HEADER_MAGIC) {
    throw new Error("Unsupported glTF-Binary header.");
  }
  if (header.version < 2) {
    throw new Error("Unsupported legacy binary file detected.");
  }
  if (header.length > data2.byteLength) {
    throw new Error("Invalid GLB: Declared length exceeds file size");
  }
  const chunkInfos = getAllChunkInfos(data2);
  let json = null;
  const buffers = [];
  for (let i = 0; i < chunkInfos.length; i++) {
    const chunkInfo = chunkInfos[i];
    if (chunkInfo.type === BINARY_CHUNK_TYPES.JSON && !json) {
      json = getJsonFromChunk(chunkInfo, data2);
    } else if (chunkInfo.type === BINARY_CHUNK_TYPES.BIN) {
      buffers.push(getBufferFromChunk(chunkInfo, data2));
    }
  }
  if (!json) {
    throw new Error("glTF-Binary: JSON content not found.");
  }
  return {
    json,
    buffers
  };
}

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter/Animations.js
var {
  vtkDebugMacro: vtkDebugMacro13,
  vtkWarningMacro: vtkWarningMacro16
} = macro;
function createAnimationChannel(glTFChannel, glTFSamplers) {
  const path = glTFChannel.target.path;
  const node = glTFChannel.target.node;
  function applyAnimation(value) {
    let axisAngle;
    let w;
    let nq;
    switch (path) {
      case "translation":
        node.setPosition(value[0], value[1], value[2]);
        break;
      case "rotation":
        nq = quat_exports.normalize(quat_exports.create(), value);
        axisAngle = new Float64Array(3);
        w = quat_exports.getAxisAngle(axisAngle, nq);
        node.rotateWXYZ(degreesFromRadians(w), axisAngle[0], axisAngle[1], axisAngle[2]);
        break;
      case "scale":
        node.setScale(value[0], value[1], value[2]);
        break;
      default:
        vtkWarningMacro16(`Unsupported animation path: ${path}`);
    }
  }
  function animate(currentTime) {
    const sampler = glTFSamplers[glTFChannel.sampler];
    const value = sampler.evaluate(currentTime, path);
    applyAnimation(value);
  }
  return {
    ...glTFChannel,
    animate
  };
}
function createAnimationSampler(glTFSampler) {
  let lastKeyframeIndex = 0;
  function findKeyframes(time) {
    let i1 = lastKeyframeIndex;
    while (i1 < glTFSampler.input.length - 1 && glTFSampler.input[i1] <= time) {
      i1++;
    }
    const i0 = Math.max(0, i1 - 1);
    lastKeyframeIndex = i0;
    return [glTFSampler.input[i0], glTFSampler.input[i1], i0, i1];
  }
  function stepInterpolate(path, i0) {
    const startIndex = i0 * 3;
    const v0 = new Array(3);
    for (let i = 0; i < 3; ++i) {
      v0[i] = glTFSampler.output[startIndex + i];
    }
    return v0;
  }
  function linearInterpolate(path, t0, t1, i0, i1, t) {
    const ratio = (t - t0) / (t1 - t0);
    const startIndex = i0 * 4;
    const endIndex = i1 * 4;
    const v0 = new Array(4);
    const v1 = new Array(4);
    for (let i = 0; i < 4; ++i) {
      v0[i] = glTFSampler.output[startIndex + i];
      v1[i] = glTFSampler.output[endIndex + i];
    }
    switch (path) {
      case "translation":
      case "scale":
        return vec3_exports.lerp(vec3_exports.create(), v0, v1, ratio);
      case "rotation":
        return quat_exports.slerp(quat_exports.create(), v0, v1, ratio);
      default:
        vtkWarningMacro16(`Unsupported animation path: ${path}`);
        return null;
    }
  }
  function cubicSplineInterpolate(path, t0, t1, i0, i1, time) {
    const dt = t1 - t0;
    const t = (time - t0) / dt;
    const t2 = t * t;
    const t3 = t2 * t;
    const p0 = glTFSampler.output[i0 * 3 + 1];
    const m0 = dt * glTFSampler.output[i0 * 3 + 2];
    const p1 = glTFSampler.output[i1 * 3 + 1];
    const m1 = dt * glTFSampler.output[i1 * 3];
    if (Array.isArray(p0)) {
      return p0.map((v, j) => {
        const a3 = 2 * t3 - 3 * t2 + 1;
        const b3 = t3 - 2 * t2 + t;
        const c3 = -2 * t3 + 3 * t2;
        const d3 = t3 - t2;
        return a3 * v + b3 * m0[j] + c3 * p1[j] + d3 * m1[j];
      });
    }
    const a2 = 2 * t3 - 3 * t2 + 1;
    const b2 = t3 - 2 * t2 + t;
    const c2 = -2 * t3 + 3 * t2;
    const d2 = t3 - t2;
    return a2 * p0 + b2 * m0 + c2 * p1 + d2 * m1;
  }
  function evaluate3(time, path) {
    const [t0, t1, i0, i1] = findKeyframes(time);
    let result;
    switch (glTFSampler.interpolation) {
      case "STEP":
        result = stepInterpolate(path, i0);
        break;
      case "LINEAR":
        result = linearInterpolate(path, t0, t1, i0, i1, time);
        break;
      case "CUBICSPLINE":
        result = cubicSplineInterpolate(path, t0, t1, i0, i1, time);
        break;
      default:
        vtkWarningMacro16(`Unknown interpolation method: ${glTFSampler.interpolation}`);
    }
    return result;
  }
  return {
    ...glTFSampler,
    evaluate: evaluate3
  };
}
function createAnimation(glTFAnimation, nodes) {
  glTFAnimation.samplers = glTFAnimation.samplers.map((sampler) => createAnimationSampler(sampler));
  glTFAnimation.channels = glTFAnimation.channels.map((channel) => {
    channel.target.node = nodes.get(`node-${channel.target.node}`);
    return createAnimationChannel(channel, glTFAnimation.samplers);
  });
  function update2(currentTime) {
    glTFAnimation.channels.forEach((channel) => channel.animate(currentTime));
  }
  return {
    ...glTFAnimation,
    update: update2
  };
}
function createAnimationMixer(nodes, accessors) {
  const animations = /* @__PURE__ */ new Map();
  const activeAnimations = /* @__PURE__ */ new Map();
  function addAnimation(glTFAnimation) {
    const annimation = createAnimation(glTFAnimation, nodes);
    animations.set(glTFAnimation.id, annimation);
    vtkDebugMacro13(`Animation "${glTFAnimation.id}" added to mixer`);
  }
  function play(name2) {
    let weight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    if (!animations.has(name2)) {
      vtkWarningMacro16(`Animation "${name2}" not found in mixer`);
      return;
    }
    activeAnimations.set(name2, {
      animation: animations.get(name2),
      weight,
      time: 0
    });
    vtkDebugMacro13(`Playing animation "${name2}" with weight ${weight}`);
  }
  function stop(name2) {
    if (activeAnimations.delete(name2)) {
      vtkWarningMacro16(`Stopped animation "${name2}"`);
    } else {
      vtkWarningMacro16(`Animation "${name2}" was not playing`);
    }
  }
  function stopAll() {
    activeAnimations.clear();
    vtkWarningMacro16("Stopped all animations");
  }
  function update2(deltaTime) {
    const totalWeight = Array.from(activeAnimations.values()).reduce((sum3, _ref) => {
      let {
        weight
      } = _ref;
      return sum3 + weight;
    }, 0);
    activeAnimations.forEach((_ref2, name2) => {
      let {
        animation,
        weight,
        time
      } = _ref2;
      const normalizedWeight = totalWeight > 0 ? weight / totalWeight : 0;
      const newTime = time + deltaTime;
      activeAnimations.set(name2, {
        animation,
        weight,
        time: newTime
      });
      vtkDebugMacro13(`Updating animation "${name2}" at time ${newTime.toFixed(3)} with normalized weight ${normalizedWeight.toFixed(3)}`);
      animation.update(newTime, normalizedWeight);
    });
  }
  return {
    addAnimation,
    play,
    stop,
    stopAll,
    update: update2
  };
}

// node_modules/@kitware/vtk.js/IO/Geometry/GLTFImporter.js
var {
  vtkDebugMacro: vtkDebugMacro14,
  vtkErrorMacro: vtkErrorMacro55
} = macro;
function vtkGLTFImporter(publicAPI, model) {
  model.classHierarchy.push("vtkGLTFImporter");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      compression,
      progressCallback
    } = model;
    if (option.binary) {
      return model.dataAccessHelper.fetchBinary(url, {
        compression,
        progressCallback
      });
    }
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      binary: true
    };
    model.url = url;
    const path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    model.compression = option.compression;
    model.sceneId = option.sceneId ? option.sceneId : 0;
    return publicAPI.loadData({
      progressCallback: option.progressCallback,
      binary: !!option.binary
    });
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const promise = fetchData(model.url, option);
    promise.then(publicAPI.parse);
    return promise;
  };
  publicAPI.parse = (content) => {
    if (typeof content === "string") {
      publicAPI.parseAsText(content);
    } else {
      publicAPI.parseAsBinary(content);
    }
  };
  publicAPI.parseAsBinary = async (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    const glTF = {};
    const options = {
      baseUri: model.baseURL
    };
    const magic = BinaryHelper.arrayBufferToString(new Uint8Array(content, 0, 4));
    if (magic === BINARY_HEADER_MAGIC) {
      const {
        json,
        buffers
      } = parseGLB(content);
      vtkDebugMacro14("Loaded GLB", json, buffers);
      glTF.glbBuffers = buffers;
      glTF.json = json;
    } else {
      glTF.json = JSON.parse(BinaryHelper.arrayBufferToString(content));
    }
    if (glTF.json.asset === void 0 || glTF.json.asset.version[0] < 2) {
      vtkErrorMacro55("Unsupported asset. glTF versions >=2.0 are supported.");
      return;
    }
    model.glTFTree = await parseGLTF(glTF, options);
    model.actors = /* @__PURE__ */ new Map();
    model.cameras = /* @__PURE__ */ new Map();
    model.lights = /* @__PURE__ */ new Map();
    model.animations = [];
    model.variants = [];
    model.variantMappings = /* @__PURE__ */ new Map();
    await createVTKObjects(model);
    model.scenes = model.glTFTree.scenes;
    publicAPI.invokeReady();
  };
  publicAPI.parseAsText = (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parse(model.parseData);
  };
  publicAPI.setDracoDecoder = async (dracoDecoder) => {
    await vtkDracoReader$1.setDracoDecoder(dracoDecoder);
  };
  publicAPI.importActors = () => {
    model.actors.forEach((actor) => model.renderer.addActor(actor));
  };
  publicAPI.importCameras = () => {
    var _a;
    (_a = model.glTFTree.cameras) == null ? void 0 : _a.forEach((glTFcamera) => {
      const camera = GLTFCameraToVTKCamera(glTFcamera);
      model.cameras.set(glTFcamera.id, camera);
    });
    model.scenes.forEach((scene) => {
      scene.nodes.forEach((node) => {
        var _a2;
        const camera = model.cameras.get((_a2 = node.camera) == null ? void 0 : _a2.id);
        if (camera) {
          applyTransformToCamera(camera, node.transform);
        }
      });
    });
  };
  publicAPI.importAnimations = () => {
    var _a;
    if (((_a = model.glTFTree.animations) == null ? void 0 : _a.length) > 0) {
      model.animationMixer = createAnimationMixer(model.actors, model.glTFTree.accessors);
      model.glTFTree.animations.forEach((animation) => {
        model.animationMixer.addAnimation(animation);
      });
    }
    model.animations = model.glTFTree.animations || [];
  };
  publicAPI.importLights = () => {
    var _a;
    (_a = model.lights) == null ? void 0 : _a.forEach((light) => {
      vtkDebugMacro14("Adding light", light);
      model.renderer.addLight(light);
    });
  };
  publicAPI.setCamera = (cameraId) => {
    const camera = model.cameras.get(cameraId);
    if (!camera) {
      vtkErrorMacro55(`Camera ${cameraId} not found`);
      return;
    }
    vtkDebugMacro14("Setting camera", camera);
    model.renderer.setActiveCamera(camera);
  };
  publicAPI.switchToVariant = async (variantIndex) => {
    const promises = Array.from(model.actors).map(async (_ref) => {
      let [nodeId, actor] = _ref;
      vtkDebugMacro14("Switching to variant", variantIndex, "for node", nodeId);
      const variantMappings = model.variantMappings.get(nodeId);
      if (variantMappings) {
        const mapping2 = variantMappings.find((m) => m.variants.includes(variantIndex));
        if (mapping2) {
          const variantMaterial = model.glTFTree.materials[mapping2.material];
          await createPropertyFromGLTFMaterial(model, variantMaterial, actor);
        }
      }
    });
    await Promise.all(promises);
  };
}
var DEFAULT_VALUES115 = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend127(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES115, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL", "actors", "scenes", "cameras", "animations", "animationMixer", "variants", "variantMappings"]);
  macro.set(publicAPI, model, ["renderer", "dracoDecoder"]);
  macro.event(publicAPI, model, "ready");
  vtkGLTFImporter(publicAPI, model);
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}
var newInstance122 = macro.newInstance(extend127, "vtkGLTFImporter");
var vtkGLTFImporter$1 = {
  extend: extend127,
  newInstance: newInstance122
};

// node_modules/@kitware/vtk.js/IO/Geometry/IFCImporter.js
var {
  vtkErrorMacro: vtkErrorMacro56
} = macro;
var WebIFC;
function setIFCAPI(ifcApi) {
  WebIFC = ifcApi;
}
function vtkIFCImporter(publicAPI, model) {
  model.classHierarchy.push("vtkIFCImporter");
  const meshes = [];
  function createPolyDataFromIFCMesh(mesh) {
    const {
      vertices,
      indices
    } = mesh;
    const pd = vtkPolyData$1.newInstance();
    const cells = vtkCellArray$1.newInstance();
    const pointValues = new Float32Array(vertices.length / 2);
    const normalsArray = new Float32Array(vertices.length / 2);
    for (let i = 0, p = 0; i < vertices.length; p += 3) {
      pointValues[p] = vertices[i++];
      pointValues[p + 1] = vertices[i++];
      pointValues[p + 2] = vertices[i++];
      normalsArray[p] = vertices[i++];
      normalsArray[p + 1] = vertices[i++];
      normalsArray[p + 2] = vertices[i++];
    }
    const nCells = indices.length;
    cells.resize(3 * nCells / 3);
    for (let cellId = 0; cellId < nCells; cellId += 3) {
      const cell = indices.slice(cellId, cellId + 3);
      cells.insertNextCell(cell);
    }
    pd.getPoints().setData(pointValues, 3);
    pd.setStrips(cells);
    pd.getPointData().setNormals(vtkDataArray$1.newInstance({
      name: "Normals",
      values: normalsArray,
      numberOfComponents: 3
    }));
    return pd;
  }
  function createColoredPolyDataFromIFCMesh(mesh) {
    const {
      vertices,
      indices,
      color: color4,
      userMatrix
    } = mesh;
    const pd = vtkPolyData$1.newInstance();
    const cells = vtkCellArray$1.newInstance();
    const pointValues = new Float32Array(vertices.length / 2);
    const normalsArray = new Float32Array(vertices.length / 2);
    const colorArray = new Float32Array(vertices.length / 2);
    if (userMatrix) {
      for (let i = 0, p = 0; i < vertices.length; p += 3) {
        pointValues[p] = vertices[i++];
        pointValues[p + 1] = vertices[i++];
        pointValues[p + 2] = vertices[i++];
        normalsArray[p] = vertices[i++];
        normalsArray[p + 1] = vertices[i++];
        normalsArray[p + 2] = vertices[i++];
        colorArray[p] = color4.x;
        colorArray[p + 1] = color4.y;
        colorArray[p + 2] = color4.z;
      }
      vtkMatrixBuilder.buildFromRadian().setMatrix(userMatrix).apply(pointValues);
      vtkMatrixBuilder.buildFromRadian().multiply3x3(mat3_exports.fromMat4(mat3_exports.create(), userMatrix)).apply(normalsArray);
    } else {
      for (let i = 0, p = 0; i < vertices.length; p += 3) {
        pointValues[p] = vertices[i++];
        pointValues[p + 1] = vertices[i++];
        pointValues[p + 2] = vertices[i++];
        normalsArray[p] = vertices[i++];
        normalsArray[p + 1] = vertices[i++];
        normalsArray[p + 2] = vertices[i++];
        colorArray[p] = color4.x;
        colorArray[p + 1] = color4.y;
        colorArray[p + 2] = color4.z;
      }
    }
    const nCells = indices.length;
    cells.resize(3 * nCells / 3);
    for (let cellId = 0; cellId < nCells; cellId += 3) {
      const cell = indices.slice(cellId, cellId + 3);
      cells.insertNextCell(cell);
    }
    pd.getPoints().setData(pointValues, 3);
    pd.setPolys(cells);
    pd.getPointData().setNormals(vtkDataArray$1.newInstance({
      name: "Normals",
      values: normalsArray,
      numberOfComponents: 3
    }));
    pd.getPointData().setScalars(vtkDataArray$1.newInstance({
      name: "Colors",
      values: colorArray,
      numberOfComponents: 3
    }));
    return pd;
  }
  function parseIfc(content) {
    const modelID = model._ifcApi.OpenModel(new Uint8Array(content), {
      COORDINATE_TO_ORIGIN: true,
      USE_FAST_BOOLS: true
    });
    model._ifcApi.StreamAllMeshes(modelID, (mesh) => {
      const placedGeometries = mesh.geometries;
      for (let i = 0; i < placedGeometries.size(); i++) {
        const placedGeometry = placedGeometries.get(i);
        const ifcGeometryData = model._ifcApi.GetGeometry(modelID, placedGeometry.geometryExpressID);
        const ifcVertices = model._ifcApi.GetVertexArray(ifcGeometryData.GetVertexData(), ifcGeometryData.GetVertexDataSize());
        const ifcIndices = model._ifcApi.GetIndexArray(ifcGeometryData.GetIndexData(), ifcGeometryData.GetIndexDataSize());
        meshes.push({
          vertices: ifcVertices,
          indices: ifcIndices,
          color: placedGeometry.color,
          userMatrix: placedGeometry.flatTransformation
        });
      }
    });
    model._ifcApi.CloseModel(modelID);
  }
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    const {
      compression,
      progressCallback
    } = model;
    return model.dataAccessHelper.fetchBinary(url, {
      compression,
      progressCallback
    });
  }
  publicAPI.setUrl = function(url) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      binary: true
    };
    model.url = url;
    model.baseURL = url.split("/").slice(0, -1).join("/");
    model.compression = options.compression;
    return publicAPI.loadData(options);
  };
  publicAPI.loadData = function() {
    return fetchData(model.url).then(publicAPI.parse);
  };
  publicAPI.parse = (content) => {
    publicAPI.parseAsArrayBuffer(content);
  };
  publicAPI.parseAsArrayBuffer = (content) => {
    if (!content) {
      vtkErrorMacro56("No content to parse.");
      return;
    }
    if (!WebIFC) {
      vtkErrorMacro56("vtkIFCImporter requires WebIFC API to be set.");
      return;
    }
    model._ifcApi = new WebIFC.IfcAPI();
    model._ifcApi.Init().then(() => {
      parseIfc(content);
      publicAPI.invokeReady();
    });
  };
  publicAPI.importActors = (renderer) => {
    if (model.mergeGeometries) {
      const opaqueMeshes = meshes.filter((mesh) => mesh.color.w === 1);
      const oapd = vtkAppendPolyData$1.newInstance();
      opaqueMeshes.forEach((mesh) => {
        const pd = createColoredPolyDataFromIFCMesh(mesh);
        oapd.addInputData(pd);
      });
      let mapper = vtkMapper$1.newInstance();
      mapper.setColorModeToDirectScalars();
      mapper.setInputConnection(oapd.getOutputPort());
      let actor = vtkActor$1.newInstance();
      actor.setMapper(mapper);
      renderer.addActor(actor);
      const transparentMeshes = meshes.filter((mesh) => mesh.color.w < 1);
      const tapd = vtkAppendPolyData$1.newInstance();
      transparentMeshes.forEach((mesh) => {
        const pd = createColoredPolyDataFromIFCMesh(mesh);
        tapd.addInputData(pd);
      });
      mapper = vtkMapper$1.newInstance();
      mapper.setColorModeToDirectScalars();
      mapper.setInputConnection(tapd.getOutputPort());
      actor = vtkActor$1.newInstance();
      actor.setMapper(mapper);
      actor.getProperty().setOpacity(0.5);
      renderer.addActor(actor);
    } else {
      meshes.forEach((mesh) => {
        const pd = createPolyDataFromIFCMesh(mesh);
        const mapper = vtkMapper$1.newInstance();
        mapper.setInputData(pd);
        const actor = vtkActor$1.newInstance();
        actor.setMapper(mapper);
        const {
          x,
          y,
          z,
          w
        } = mesh.color;
        actor.getProperty().setColor(x, y, z);
        actor.getProperty().setOpacity(w);
        actor.setUserMatrix(mesh.userMatrix);
        renderer.addActor(actor);
      });
    }
  };
}
var DEFAULT_VALUES116 = {
  mergeGeometries: false
};
function extend128(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES116, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper", "mergeGeometries"]);
  macro.event(publicAPI, model, "ready");
  macro.algo(publicAPI, model, 0, 1);
  vtkIFCImporter(publicAPI, model);
}
var newInstance123 = macro.newInstance(extend128, "vtkIFCImporter");
var vtkIFCImporter$1 = {
  newInstance: newInstance123,
  extend: extend128,
  setIFCAPI
};

// node_modules/@kitware/vtk.js/IO/Geometry.js
var Geometry = {
  vtkSTLReader: vtkSTLReader$1,
  vtkPLYReader: vtkPLYReader$1,
  vtkDracoReader: vtkDracoReader$1,
  vtkSTLWriter: vtkSTLWriter$1,
  vtkPLYWriter: vtkPLYWriter$1,
  vtkGLTFImporter: vtkGLTFImporter$1,
  vtkIFCImporter: vtkIFCImporter$1
};

// node_modules/@kitware/vtk.js/IO/Legacy/LegacyAsciiParser.js
var METHOD_MAPPING = {
  POINTS: "getPoints",
  VERTICES: "getVerts",
  LINES: "getLines",
  TRIANGLE_STRIPS: "getStrips",
  POLYGONS: "getPolys",
  POINT_DATA: "getPointData",
  CELL_DATA: "getCellData",
  FIELD: "getFieldData"
};
var DATATYPES = {
  bit: Uint8Array,
  unsigned_char: Uint8Array,
  char: Int8Array,
  unsigned_short: Uint16Array,
  short: Int16Array,
  unsigned_int: Uint32Array,
  int: Int32Array,
  unsigned_long: Uint32Array,
  long: Int32Array,
  float: Float32Array,
  double: Float64Array
};
var REGISTER_MAPPING = {
  SCALARS: "addArray",
  COLOR_SCALARS: "addArray",
  VECTORS: "setVectors",
  NORMALS: "setNormals",
  TEXTURE_COORDINATES: "setTCoords",
  TENSORS: "setTensors",
  FIELD: "addArray"
};
function createArrayHandler(array, setData, nbComponents) {
  let offset = 0;
  function fillWith(line) {
    line.split(" ").forEach((token) => {
      if (token.length) {
        array[offset++] = Number(token);
      }
    });
    if (offset < array.length) {
      return true;
    }
    setData(array, nbComponents);
    return false;
  }
  return fillWith;
}
var GENERIC_CELL_HANDLER = {
  init(line, dataModel) {
    const [name2, nbCells, nbValues] = line.split(" ");
    const cellArray = dataModel.dataset[METHOD_MAPPING[name2]]();
    cellArray.set({
      numberOfCells: Number(nbCells)
    }, true);
    dataModel.arrayHandler = createArrayHandler(new Uint32Array(Number(nbValues)), cellArray.setData, 1);
    return true;
  },
  parse(line, dataModel) {
    return dataModel.arrayHandler(line);
  }
};
var TYPE_PARSER = {
  DATASET: {
    init(line, datamodel) {
      const type = line.split(" ")[1];
      switch (type) {
        case "POLYDATA":
          datamodel.dataset = vtkPolyData$1.newInstance();
          break;
        default:
          console.error(`Dataset of type ${type} not supported`);
      }
      return false;
    },
    parse(line, datamodel) {
      return false;
    }
  },
  POINTS: {
    init(line, dataModel) {
      const [name2, size, type] = line.split(" ");
      const array = type === "float" ? new Float32Array(3 * Number(size)) : new Float64Array(3 * Number(size));
      const dataArray = dataModel.dataset.getPoints();
      dataArray.setName(name2);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  METADATA: {
    init(line, dataModel) {
      return true;
    },
    parse(line, dataModel) {
      return !!line.length;
    }
  },
  VERTICES: GENERIC_CELL_HANDLER,
  LINES: GENERIC_CELL_HANDLER,
  TRIANGLE_STRIPS: GENERIC_CELL_HANDLER,
  POLYGONS: GENERIC_CELL_HANDLER,
  POINT_DATA: {
    init(line, dataModel) {
      dataModel.POINT_DATA = Number(line.split(" ")[1]);
      dataModel.activeFieldLocation = "POINT_DATA";
      return false;
    },
    parse(line, dataModel) {
      return false;
    }
  },
  CELL_DATA: {
    init(line, dataModel) {
      dataModel.CELL_DATA = Number(line.split(" ")[1]);
      dataModel.activeFieldLocation = "CELL_DATA";
      return false;
    },
    parse(line, dataModel) {
      return false;
    }
  },
  SCALARS: {
    init(line, dataModel) {
      const [type, name2, dataType, numComp] = line.split(" ");
      const numOfComp = Number(numComp) > 0 ? Number(numComp) : 1;
      const size = dataModel[dataModel.activeFieldLocation] * numOfComp;
      const array = new DATATYPES[dataType](size);
      const dataArray = vtkDataArray$1.newInstance({
        name: name2,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, numOfComp);
      return true;
    },
    parse(line, dataModel) {
      if (line.split(" ")[0] === "LOOKUP_TABLE") {
        return true;
      }
      return dataModel.arrayHandler(line);
    }
  },
  COLOR_SCALARS: {
    init(line, dataModel) {
      const [type, name2, numComp] = line.split(" ");
      const numOfComp = Number(numComp) > 0 ? Number(numComp) : 1;
      const size = dataModel[dataModel.activeFieldLocation] * numOfComp;
      const array = new Uint8Array(size);
      const dataArray = vtkDataArray$1.newInstance({
        name: name2,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, numOfComp);
      return true;
    },
    parse(line, dataModel) {
      if (line.split(" ")[0] === "LOOKUP_TABLE") {
        return true;
      }
      return dataModel.arrayHandler(line);
    }
  },
  VECTORS: {
    init(line, dataModel) {
      const [type, name2, dataType] = line.split(" ");
      const size = dataModel[dataModel.activeFieldLocation] * 3;
      const array = new DATATYPES[dataType](size);
      const dataArray = vtkDataArray$1.newInstance({
        name: name2,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  NORMALS: {
    init(line, dataModel) {
      const [type, name2] = line.split(" ");
      const size = dataModel[dataModel.activeFieldLocation] * 3;
      const array = new Float32Array(size);
      const dataArray = vtkDataArray$1.newInstance({
        name: name2,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  TEXTURE_COORDINATES: {
    init(line, dataModel) {
      const [type, name2, numberOfComponents, dataType] = line.split(" ");
      const size = dataModel[dataModel.activeFieldLocation] * Number(numberOfComponents);
      const array = new DATATYPES[dataType](size);
      const dataArray = vtkDataArray$1.newInstance({
        name: name2,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  TENSORS: {
    init(line, dataModel) {
      const [type, name2, dataType] = line.split(" ");
      const size = dataModel[dataModel.activeFieldLocation] * 9;
      const array = new DATATYPES[dataType](size);
      const dataArray = vtkDataArray$1.newInstance({
        name: name2,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 9);
      return true;
    },
    parse(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  }
};
function getParser(line, dataModel) {
  const tokens = line.split(" ");
  return TYPE_PARSER[tokens[0]];
}
function parseLegacyASCII(content) {
  let dataModel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let parser = null;
  const separatorRegExp = /\r?\n/;
  const separatorRes = separatorRegExp.exec(content);
  const separator = separatorRes !== null ? separatorRes[0] : null;
  content.split(separator).forEach((line, index) => {
    if (index < 2) {
      return;
    }
    if (!parser) {
      parser = getParser(line);
      if (!parser) {
        return;
      }
      parser = parser.init(line, dataModel) ? parser : null;
      return;
    }
    if (parser && !parser.parse(line, dataModel)) {
      parser = null;
    }
  });
  return dataModel;
}
var vtkLegacyAsciiParser = {
  parseLegacyASCII
};

// node_modules/@kitware/vtk.js/IO/Legacy/PolyDataReader.js
function vtkPolyDataReader(publicAPI, model) {
  model.classHierarchy.push("vtkPolyDataReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    const {
      compression,
      progressCallback
    } = model;
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.url = url;
    const path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    model.compression = option.compression;
    return publicAPI.loadData({
      progressCallback: option.progressCallback
    });
  };
  publicAPI.loadData = function() {
    const promise = fetchData(model.url);
    promise.then(publicAPI.parseAsText);
    return promise;
  };
  publicAPI.parseAsText = (content) => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
    model.output[0] = vtkLegacyAsciiParser.parseLegacyASCII(model.parseData).dataset;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsText(model.parseData);
  };
}
var DEFAULT_VALUES117 = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend129(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES117, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkPolyDataReader(publicAPI, model);
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}
var newInstance124 = macro.newInstance(extend129, "vtkPolyDataReader");
var vtkPolyDataReader$1 = {
  newInstance: newInstance124,
  extend: extend129
};

// node_modules/@kitware/vtk.js/IO/Legacy.js
var Legacy = {
  vtkLegacyAsciiParser,
  vtkPolyDataReader: vtkPolyDataReader$1
};

// node_modules/@kitware/vtk.js/IO/Misc/ElevationReader.js
function vtkElevationReader(publicAPI, model) {
  model.classHierarchy.push("vtkElevationReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchCSV(url, options) {
    return model.dataAccessHelper.fetchText(publicAPI, url, options);
  }
  publicAPI.setUrl = (url, options) => {
    model.url = url;
    return publicAPI.loadData(options);
  };
  publicAPI.loadData = (options) => fetchCSV(model.url, options).then((csv) => {
    publicAPI.parseAsText(csv);
    return true;
  });
  publicAPI.parseAsText = (csv) => {
    model.csv = csv;
    model.elevation = [];
    const lines = model.csv.split("\n");
    lines.forEach((line, lineIdx) => {
      model.elevation.push(line.split(",").map((str) => Number(str)));
    });
    publicAPI.modified();
  };
  publicAPI.requestData = (inData, outData) => {
    const polydata = vtkPolyData$1.newInstance();
    polydata.getPoints().setData(new Float32Array(0, 0, 0, 1, 1, 1), 3);
    if (model.elevation) {
      const jSize = model.elevation.length;
      const iSize = model.elevation[0].length;
      const points = polydata.getPoints();
      points.setNumberOfPoints(iSize * jSize, 3);
      const pointValues = points.getData();
      const polys = vtkCellArray$1.newInstance({
        size: 5 * (iSize - 1) * (jSize - 1)
      });
      polydata.setPolys(polys);
      const polysValues = polys.getData();
      let cellOffset = 0;
      const tcData = new Float32Array(iSize * jSize * 2);
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcData,
        name: "TextureCoordinates"
      });
      polydata.getPointData().setTCoords(tcoords);
      for (let j = 0; j < jSize; j++) {
        for (let i = 0; i < iSize; i++) {
          const offsetIdx = j * iSize + i;
          const offsetPt = 3 * offsetIdx;
          pointValues[offsetPt + 0] = model.origin[0] + i * model.xSpacing * model.xDirection;
          pointValues[offsetPt + 1] = model.origin[1] + j * model.ySpacing * model.yDirection;
          pointValues[offsetPt + 2] = model.origin[2] + model.elevation[j][i] * model.zScaling;
          tcData[offsetIdx * 2] = i / (iSize - 1);
          tcData[offsetIdx * 2 + 1] = 1 - j / (jSize - 1);
          if (i > 0 && j > 0) {
            polysValues[cellOffset++] = 4;
            polysValues[cellOffset++] = offsetIdx;
            polysValues[cellOffset++] = offsetIdx - 1;
            polysValues[cellOffset++] = offsetIdx - 1 - iSize;
            polysValues[cellOffset++] = offsetIdx - iSize;
          }
        }
      }
    }
    model.output[0] = polydata;
  };
  publicAPI.isBusy = () => !!model.requestCount;
}
var DEFAULT_VALUES118 = {
  origin: [0, 0, 0],
  xSpacing: 1,
  ySpacing: 1,
  zScaling: 1,
  xDirection: 1,
  yDirection: -1,
  requestCount: 0
  // dataAccessHelper: null,
  // url: null,
};
function extend130(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES118, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper", "xSpacing", "ySpacing", "zScaling", "xDirection", "yDirection"]);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, "busy");
  vtkElevationReader(publicAPI, model);
}
var newInstance125 = macro.newInstance(extend130, "vtkElevationReader");
var vtkElevationReader$1 = {
  newInstance: newInstance125,
  extend: extend130
};

// node_modules/@kitware/vtk.js/IO/Misc/ITKImageReader.js
var {
  convertItkToVtkImage: convertItkToVtkImage2
} = ITKHelper;
var readImageArrayBuffer = null;
var resultPreprocessor = (result) => result;
function getArrayName(filename) {
  const idx = filename.lastIndexOf(".");
  const name2 = idx > -1 ? filename.substring(0, idx) : filename;
  return `Scalars ${name2}`;
}
function setReadImageArrayBufferFromITK(fn) {
  readImageArrayBuffer = fn;
  if (readImageArrayBuffer.length === 4) {
    readImageArrayBuffer = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn(null, ...args);
    };
    resultPreprocessor = (_ref) => {
      let {
        webWorker,
        image
      } = _ref;
      webWorker.terminate();
      return image;
    };
  }
}
function vtkITKImageReader(publicAPI, model) {
  model.classHierarchy.push("vtkITKImageReader");
  publicAPI.parseAsArrayBuffer = (arrayBuffer) => {
    if (!arrayBuffer || arrayBuffer === model.rawDataBuffer) {
      return Promise.resolve();
    }
    model.rawDataBuffer = arrayBuffer;
    return readImageArrayBuffer(arrayBuffer, model.fileName).then(resultPreprocessor).then((itkImage) => {
      const imageData = convertItkToVtkImage2(itkImage, {
        scalarArrayName: model.arrayName || getArrayName(model.fileName)
      });
      model.output[0] = imageData;
      publicAPI.modified();
    });
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsArrayBuffer(model.rawDataBuffer, model.fileName);
  };
}
var DEFAULT_VALUES119 = {
  fileName: "",
  // If null/undefined a unique array will be generated
  arrayName: null
};
function extend131(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES119, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 0, 1);
  macro.setGet(publicAPI, model, ["fileName", "arrayName"]);
  vtkITKImageReader(publicAPI, model);
  if (!readImageArrayBuffer) {
    console.error(`
      // Dependency needs to be added inside your project
      import readImageArrayBuffer from 'itk/readImageArrayBuffer';
      vtkITKImageReader.setReadImageArrayBufferFromITK(readImageArrayBuffer);
      `);
  }
}
var newInstance126 = macro.newInstance(extend131, "vtkITKImageReader");
var vtkITKImageReader$1 = {
  newInstance: newInstance126,
  extend: extend131,
  setReadImageArrayBufferFromITK
};

// node_modules/@kitware/vtk.js/IO/Misc/ITKPolyDataReader.js
var readPolyDataArrayBuffer = null;
var resultPreprocessor2 = (result) => result;
function setReadPolyDataArrayBufferFromITK(fn) {
  readPolyDataArrayBuffer = fn;
  readPolyDataArrayBuffer = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return fn(null, ...args);
  };
  resultPreprocessor2 = (_ref) => {
    let {
      webWorker,
      polyData
    } = _ref;
    webWorker.terminate();
    return polyData;
  };
}
function vtkITKPolyDataReader(publicAPI, model) {
  model.classHierarchy.push("vtkITKPolyDataReader");
  publicAPI.parseAsArrayBuffer = (arrayBuffer) => {
    if (!arrayBuffer || arrayBuffer === model.rawDataBuffer) {
      return Promise.resolve();
    }
    model.rawDataBuffer = arrayBuffer;
    return readPolyDataArrayBuffer(arrayBuffer, model.fileName).then(resultPreprocessor2).then((polyData) => {
      model.output[0] = vtk(polyData);
      publicAPI.modified();
    });
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsArrayBuffer(model.rawDataBuffer, model.fileName);
  };
}
var DEFAULT_VALUES120 = {
  fileName: "",
  // If null/undefined a unique array will be generated
  arrayName: null
};
function extend132(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES120, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 0, 1);
  macro.setGet(publicAPI, model, ["fileName", "arrayName"]);
  vtkITKPolyDataReader(publicAPI, model);
  if (!readPolyDataArrayBuffer) {
    console.error(`
      // Dependency needs to be added inside your project
      import readPolyDataArrayBuffer from 'itk/readPolyDataArrayBuffer';
      vtkITKPolyDataReader.setReadPolyDataArrayBufferFromITK(readPolyDataArrayBuffer);
      `);
  }
}
var newInstance127 = macro.newInstance(extend132, "vtkITKPolyDataReader");
var vtkITKPolyDataReader$1 = {
  newInstance: newInstance127,
  extend: extend132,
  setReadPolyDataArrayBufferFromITK
};

// node_modules/@kitware/vtk.js/IO/Misc/JSONNucleoReader.js
function vtkJSONNucleoReader(publicAPI, model) {
  model.classHierarchy.push("vtkJSONNucleoReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchText3(url, options) {
    return model.dataAccessHelper.fetchText(publicAPI, url, options);
  }
  publicAPI.setUrl = (url, options) => {
    model.url = url;
    return publicAPI.loadData(options);
  };
  publicAPI.loadData = (options) => fetchText3(model.url, options).then((csv) => {
    publicAPI.parseAsText(csv);
    return true;
  });
  publicAPI.parseAsText = (jsonAsTxt) => {
    const {
      vertices,
      indices
    } = JSON.parse(jsonAsTxt);
    const nbIndices = indices.length;
    const nbTriangles = nbIndices / 3;
    const nbCellsValues = nbTriangles + nbIndices;
    model.points = Float32Array.from(vertices);
    model.polys = nbCellsValues < 65535 ? new Uint16Array(nbCellsValues) : new Uint32Array(nbCellsValues);
    let srcOffset = 0;
    let destOffset = 0;
    while (destOffset < model.polys.length) {
      model.polys[destOffset++] = 3;
      model.polys[destOffset++] = indices[srcOffset++];
      model.polys[destOffset++] = indices[srcOffset++];
      model.polys[destOffset++] = indices[srcOffset++];
    }
    publicAPI.modified();
  };
  publicAPI.requestData = (inData, outData) => {
    const polydata = vtkPolyData$1.newInstance();
    polydata.getPoints().setData(model.points, 3);
    polydata.getPolys().setData(model.polys);
    model.output[0] = polydata;
  };
}
var DEFAULT_VALUES121 = {
  // dataAccessHelper: null,
  // url: null,
};
function extend133(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES121, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkJSONNucleoReader(publicAPI, model);
}
var newInstance128 = macro.newInstance(extend133, "vtkJSONNucleoReader");
var vtkJSONNucleoReader$1 = {
  newInstance: newInstance128,
  extend: extend133
};

// node_modules/@kitware/vtk.js/IO/Misc/JSONReader.js
function vtkJSONReader(publicAPI, model) {
  model.classHierarchy.push("vtkJSONReader");
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return model.dataAccessHelper.fetchText(publicAPI, url, option);
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.url = url;
    return publicAPI.loadData(option);
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return fetchData(model.url, option).then(publicAPI.parseAsText);
  };
  publicAPI.parseAsText = (content) => {
    if (!content) {
      return false;
    }
    model.data = JSON.parse(content);
    publicAPI.modified();
    return true;
  };
  publicAPI.requestData = (inData, outData) => {
    outData[0] = model.data;
  };
  publicAPI.isBusy = () => false;
  publicAPI.getNumberOfOutputPorts = () => model.numberOfOutputs;
}
var DEFAULT_VALUES122 = {
  // url: null,
};
function extend134(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES122, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url"]);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, "busy");
  vtkJSONReader(publicAPI, model);
}
var newInstance129 = macro.newInstance(extend134, "vtkJSONReader");
var vtkJSONReader$1 = {
  newInstance: newInstance129,
  extend: extend134
};

// node_modules/@kitware/vtk.js/IO/Misc/MTLReader.js
function vtkMTLReader(publicAPI, model) {
  model.classHierarchy.push("vtkMTLReader");
  function imageReady() {
    model.requestCount--;
    if (model.requestCount === 0) {
      publicAPI.invokeBusy(false);
    }
  }
  function parseLine2(line) {
    if (line[0] === "#" || line.length === 0) {
      return;
    }
    const tokens = line.split(/[ \t]+/).map((s) => s.trim()).filter((s) => s.length);
    if (tokens[0] === "newmtl") {
      tokens.shift();
      model.currentMaterial = tokens.join(" ").trim();
    } else if (model.currentMaterial) {
      if (tokens.length < 2) {
        return;
      }
      if (!model.materials[model.currentMaterial]) {
        model.materials[model.currentMaterial] = {};
      }
      model.materials[model.currentMaterial][tokens[0]] = tokens.slice(1);
      if (tokens[0] === "map_Kd") {
        const image = new Image();
        image.onload = () => setTimeout(imageReady, 0);
        image.src = [model.baseURL, tokens[1]].join("/");
        model.materials[model.currentMaterial].image = image;
        model.requestCount++;
      }
    }
  }
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url, options) {
    return model.dataAccessHelper.fetchText(publicAPI, url, options);
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (url.indexOf(".mtl") === -1 && !option.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.mtl`;
    } else {
      model.url = url;
      const path = url.split("/");
      path.pop();
      model.baseURL = path.join("/");
    }
    return publicAPI.loadData(option);
  };
  publicAPI.loadData = (option) => new Promise((resolve, reject) => {
    fetchData(model.url, option).then((content) => {
      publicAPI.parseAsText(content);
      resolve();
    }, (err) => {
      reject();
    });
  });
  publicAPI.parseAsText = (content) => {
    publicAPI.modified();
    model.materials = {};
    content.split("\n").forEach(parseLine2);
  };
  publicAPI.isBusy = () => !!model.requestCount;
  publicAPI.getMaterialNames = () => Object.keys(model.materials);
  publicAPI.getMaterial = (name2) => model.materials[name2];
  publicAPI.listImages = () => Object.keys(model.materials).map((name2) => model.materials[name2].map_Kd).filter((fileName) => !!fileName).map((s) => s[0].trim());
  publicAPI.setImageSrc = (imagePath, src) => new Promise((resolve, reject) => {
    const selectedName = Object.keys(model.materials).find((name2) => model.materials[name2].map_Kd && model.materials[name2].map_Kd[0].trim() === imagePath.trim());
    const material = model.materials[selectedName];
    if (material && material.image) {
      material.image.src = src;
      material.image.onload = () => setTimeout(resolve, 0);
    } else {
      resolve();
    }
  });
  publicAPI.applyMaterialToActor = (name2, actor) => {
    const material = model.materials[name2];
    if (material && actor) {
      const white = [1, 1, 1];
      const actorProp = {
        ambientColor: material.Ka ? material.Ka.map((i) => Number(i)) : white,
        specularColor: material.Ks ? material.Ks.map((i) => Number(i)) : white,
        diffuseColor: material.Kd ? material.Kd.map((i) => Number(i)) : white,
        opacity: material.d ? Number(material.d) : 1,
        specularPower: material.Ns ? Number(material.Ns) : 1
      };
      const illum = Number(material.illum || 2);
      ["ambient", "diffuse", "specular"].forEach((k, idx) => {
        actorProp[k] = idx <= illum ? 1 : 0;
      });
      if (material.image) {
        const texture = vtkTexture$1.newInstance({
          interpolate: model.interpolateTextures
        });
        texture.setImage(material.image);
        actor.addTexture(texture);
      }
      actor.getProperty().set(actorProp);
    }
  };
}
var DEFAULT_VALUES123 = {
  numberOfOutputs: 1,
  requestCount: 0,
  materials: {},
  interpolateTextures: true
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend135(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES123, initialValues);
  obj(publicAPI, model);
  get(publicAPI, model, ["url", "baseURL"]);
  setGet(publicAPI, model, ["dataAccessHelper", "interpolateTextures", "splitGroup"]);
  event(publicAPI, model, "busy");
  vtkMTLReader(publicAPI, model);
}
var newInstance130 = newInstance(extend135, "vtkMTLReader");
var vtkMTLReader$1 = {
  newInstance: newInstance130,
  extend: extend135
};

// node_modules/@kitware/vtk.js/IO/Misc/OBJWriter.js
var {
  vtkErrorMacro: vtkErrorMacro57
} = macro;
var writeFaces = (faces, withNormals, withTCoords) => {
  let outputData = "";
  const fd = faces.getData();
  let offset = 0;
  while (offset < fd.length) {
    const faceSize = fd[offset++];
    outputData += "f";
    for (let i = 0; i < faceSize; i++) {
      outputData += ` ${fd[offset + i] + 1}`;
      if (withTCoords) {
        outputData += `/${fd[offset + i] + 1}`;
        if (withNormals) {
          outputData += `//${fd[offset + i] + 1}`;
        }
      } else if (withNormals) {
        outputData += `//${fd[offset + i] + 1}`;
      }
    }
    offset += faceSize;
    outputData += "\n";
  }
  return outputData;
};
var writeLines = (lines) => {
  let outputData = "";
  const ld = lines.getData();
  let offset = 0;
  while (offset < ld.length) {
    const lineSize = ld[offset++];
    outputData += "l";
    for (let i = 0; i < lineSize; i++) {
      outputData += ` ${ld[offset + i] + 1}`;
    }
    offset += lineSize;
    outputData += "\n";
  }
  return outputData;
};
var writePoints = (pts, normals, tcoords) => {
  const outputData = [];
  const nbPts = pts.getNumberOfPoints();
  let p;
  for (let i = 0; i < nbPts; i++) {
    p = pts.getPoint(i);
    outputData.push(`v ${p[0]} ${p[1]} ${p[2]}`);
  }
  if (normals) {
    for (let i = 0; i < nbPts; i++) {
      p = normals.getTuple(i);
      outputData.push(`vn ${p[0]} ${p[1]} ${p[2]}`);
    }
  }
  if (tcoords) {
    for (let i = 0; i < nbPts; i++) {
      p = tcoords.getTuple(i);
      if (p[0] !== -1) {
        outputData.push(`vt ${p[0]} ${p[1]}`);
      }
    }
  }
  return `${outputData.join("\n")}
`;
};
var writeMTL = (materialName, textureFileName) => {
  const outputData = [];
  outputData.push(`newmtl ${materialName}`);
  outputData.push(`map_Kd ${textureFileName}`);
  return outputData.join("\n");
};
var writeOBJ = (polyData, materialFilename, materialName) => {
  let outputData = "# VTK.js generated OBJ File\n";
  const pts = polyData.getPoints();
  const polys = polyData.getPolys();
  const strips = polyData.getStrips() ? polyData.getStrips().getData() : null;
  const lines = polyData.getLines();
  const normals = polyData.getPointData().getNormals();
  const tcoords = polyData.getPointData().getTCoords();
  const hasPtNormals = normals !== null;
  const hasPtTCoords = tcoords !== null;
  if (!pts) {
    vtkErrorMacro57("No data to write!");
    return outputData;
  }
  if (materialFilename) {
    outputData += `mtllib ${materialFilename}
`;
  }
  if (materialName) {
    outputData += `usemtl ${materialName}
`;
  }
  outputData += writePoints(pts, normals, tcoords);
  const polyStrips = vtkCellArray$1.newInstance();
  if (strips && strips.length > 0) {
    vtkTriangleStrip$1.decomposeStrip(pts, polyStrips);
  }
  if (polyStrips.getNumberOfCells() > 0) {
    outputData += writeFaces(polyStrips, hasPtNormals, hasPtTCoords);
  }
  if (polys) {
    outputData += writeFaces(polys, hasPtNormals, hasPtTCoords);
  }
  if (lines) {
    outputData += writeLines(lines);
  }
  return outputData;
};
var STATIC12 = {
  writeOBJ
};
function vtkOBJWriter(publicAPI, model) {
  model.classHierarchy.push("vtkOBJWriter");
  publicAPI.exportAsZip = () => {
    var _a, _b;
    publicAPI.update();
    const modelFilename = model.modelFilename;
    const materialFilename = model.materialFilename;
    const textureFileName = model.textureFileName;
    const imageData = (_b = (_a = model.texture).getInputAsJsImageData) == null ? void 0 : _b.call(_a);
    const zipContent = {};
    zipContent[`${modelFilename}.obj`] = strToU8(model.output[0]);
    zipContent[`${materialFilename}.mtl`] = strToU8(model.mtl);
    const canvas = document.createElement("canvas");
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return new Promise((resolve) => {
      canvas.toBlob(async (blob) => {
        const arrayBuffer = await blob.arrayBuffer();
        zipContent[`${textureFileName}.png`] = new Uint8Array(arrayBuffer);
        resolve(zipSync(zipContent));
      }, "image/png");
    });
  };
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input || !input.isA("vtkPolyData")) {
      vtkErrorMacro57("Invalid or missing vtkPolyData input");
      return;
    }
    const materialFilename = `${model.materialFilename}.mtl`;
    const textureFileName = `${model.textureFileName}.png`;
    outData[0] = writeOBJ(input, materialFilename, model.materialName);
    model.mtl = writeMTL(model.materialName, textureFileName);
  };
}
var DEFAULT_VALUES124 = {
  modelFilename: "model",
  materialName: "mat_01",
  materialFilename: "material",
  texture: null,
  textureFileName: "texture"
};
function extend136(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES124, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  macro.get(publicAPI, model, ["mtl"]);
  macro.set(publicAPI, model, ["modelFilename", "materialFilename", "texture", "textureFileName"]);
  vtkOBJWriter(publicAPI, model);
}
var newInstance131 = macro.newInstance(extend136, "vtkOBJWriter");
var vtkOBJWriter$1 = {
  newInstance: newInstance131,
  extend: extend136,
  ...STATIC12
};

// node_modules/@kitware/vtk.js/Utilities/XMLConverter/chemistry-mapper/elements.json.js
var H = [
  1
];
var He = [
  2
];
var Li = [
  3
];
var Be = [
  4
];
var B = [
  5
];
var C = [
  6
];
var N = [
  7
];
var O = [
  8
];
var F = [
  9
];
var Ne = [
  10
];
var Na = [
  11
];
var Mg = [
  12
];
var Al = [
  13
];
var Si = [
  14
];
var P = [
  15
];
var S = [
  16
];
var Cl = [
  17
];
var Ar = [
  18
];
var K = [
  19
];
var Ca = [
  20
];
var Sc = [
  21
];
var Ti = [
  22
];
var V = [
  23
];
var Cr = [
  24
];
var Mn = [
  25
];
var Fe = [
  26
];
var Co = [
  27
];
var Ni = [
  28
];
var Cu = [
  29
];
var Zn = [
  30
];
var Ga = [
  31
];
var Ge = [
  32
];
var As = [
  33
];
var Se = [
  34
];
var Br = [
  35
];
var Kr = [
  36
];
var Rb = [
  37
];
var Sr = [
  38
];
var Y = [
  39
];
var Zr = [
  40
];
var Nb = [
  41
];
var Mo = [
  42
];
var Tc = [
  43
];
var Ru = [
  44
];
var Rh = [
  45
];
var Pd = [
  46
];
var Ag = [
  47
];
var Cd = [
  48
];
var In = [
  49
];
var Sn = [
  50
];
var Sb = [
  51
];
var Te = [
  52
];
var I = [
  53
];
var Xe = [
  54
];
var Cs = [
  55
];
var Ba = [
  56
];
var La = [
  57
];
var Ce = [
  58
];
var Pr = [
  59
];
var Nd = [
  60
];
var Pm = [
  61
];
var Sm = [
  62
];
var Eu = [
  63
];
var Gd = [
  64
];
var Tb = [
  65
];
var Dy = [
  66
];
var Ho = [
  67
];
var Er = [
  68
];
var Tm = [
  69
];
var Yb = [
  70
];
var Lu = [
  71
];
var Hf = [
  72
];
var Ta = [
  73
];
var W = [
  74
];
var Re = [
  75
];
var Os = [
  76
];
var Ir = [
  77
];
var Pt = [
  78
];
var Au = [
  79
];
var Hg = [
  80
];
var Tl = [
  81
];
var Pb = [
  82
];
var Bi = [
  83
];
var Po = [
  84
];
var At = [
  85
];
var Rn = [
  86
];
var Fr = [
  87
];
var Ra = [
  88
];
var Ac = [
  89
];
var Th = [
  90
];
var Pa = [
  91
];
var U = [
  92
];
var Np = [
  93
];
var Pu = [
  94
];
var Am = [
  95
];
var Cm = [
  96
];
var Bk = [
  97
];
var Cf = [
  98
];
var Es = [
  99
];
var Fm = [
  100
];
var Md = [
  101
];
var No = [
  102
];
var Lr = [
  103
];
var Rf = [
  104
];
var Db = [
  105
];
var Sg = [
  106
];
var Bh = [
  107
];
var Hs = [
  108
];
var Mt = [
  109
];
var Ds = [
  110
];
var Rg = [
  111
];
var Cn = [
  112
];
var Uut = [
  113
];
var Uuq = [
  114
];
var Uup = [
  115
];
var Uuh = [
  116
];
var Uus = [
  117
];
var Uuo = [
  118
];
var ATOMS2 = {
  H,
  He,
  Li,
  Be,
  B,
  C,
  N,
  O,
  F,
  Ne,
  Na,
  Mg,
  Al,
  Si,
  P,
  S,
  Cl,
  Ar,
  K,
  Ca,
  Sc,
  Ti,
  V,
  Cr,
  Mn,
  Fe,
  Co,
  Ni,
  Cu,
  Zn,
  Ga,
  Ge,
  As,
  Se,
  Br,
  Kr,
  Rb,
  Sr,
  Y,
  Zr,
  Nb,
  Mo,
  Tc,
  Ru,
  Rh,
  Pd,
  Ag,
  Cd,
  In,
  Sn,
  Sb,
  Te,
  I,
  Xe,
  Cs,
  Ba,
  La,
  Ce,
  Pr,
  Nd,
  Pm,
  Sm,
  Eu,
  Gd,
  Tb,
  Dy,
  Ho,
  Er,
  Tm,
  Yb,
  Lu,
  Hf,
  Ta,
  W,
  Re,
  Os,
  Ir,
  Pt,
  Au,
  Hg,
  Tl,
  Pb,
  Bi,
  Po,
  At,
  Rn,
  Fr,
  Ra,
  Ac,
  Th,
  Pa,
  U,
  Np,
  Pu,
  Am,
  Cm,
  Bk,
  Cf,
  Es,
  Fm,
  Md,
  No,
  Lr,
  Rf,
  Db,
  Sg,
  Bh,
  Hs,
  Mt,
  Ds,
  Rg,
  Cn,
  Uut,
  Uuq,
  Uup,
  Uuh,
  Uus,
  Uuo
};

// node_modules/@kitware/vtk.js/IO/Misc/PDBReader.js
function vtkPDBReader(publicAPI, model) {
  model.classHierarchy.push("vtkPDBReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchPDB(url, option) {
    return model.dataAccessHelper.fetchText(publicAPI, url, option);
  }
  publicAPI.setUrl = (url, option) => {
    if (url.indexOf(".pdb") === -1) {
      model.baseURL = url;
      model.url = `${url}`;
    } else {
      model.url = url;
      const path = url.split("/");
      path.pop();
      model.baseURL = path.join("/");
    }
    return publicAPI.loadData(option);
  };
  publicAPI.loadData = (option) => fetchPDB(model.url, option).then(publicAPI.parseAsText);
  publicAPI.parseAsText = (txt) => {
    model.pdb = txt;
    model.molecule = [];
    model.molecule = model.pdb.split("\n");
    publicAPI.modified();
    return true;
  };
  publicAPI.requestData = (inData, outData) => {
    const moleculedata = vtkMolecule$1.newInstance();
    if (model.molecule) {
      const jSize = model.molecule.length;
      const pointValues = [];
      const atomicNumber = [];
      model.numberOfAtoms = 0;
      let j = 0;
      while (j < jSize && model.molecule[j] !== "END") {
        const iSize = model.molecule[j].length;
        const linebuf = model.molecule[j];
        const command = linebuf.substr(0, 6).replace(/\s+/g, "");
        command.toUpperCase();
        if (command === "ATOM" || command === "HETATM") {
          const dum1 = linebuf.substr(12, 4).replace(/\s+/g, "");
          const x = linebuf.substr(30, 8).replace(/\s+/g, "");
          const y = linebuf.substr(38, 8).replace(/\s+/g, "");
          const z = linebuf.substr(46, 8).replace(/\s+/g, "");
          let elem = "";
          if (iSize >= 78) {
            elem = linebuf.substr(76, 2).replace(/\s+/g, "");
          }
          if (elem === "") {
            elem = dum1.substr(0, 2).replace(/\d/g, "");
          }
          pointValues.push(x);
          pointValues.push(y);
          pointValues.push(z);
          const [atomicNumberData] = ATOMS2[elem];
          atomicNumber.push(atomicNumberData);
          model.numberOfAtoms++;
        }
        j++;
      }
      moleculedata.getAtoms().elements = {};
      moleculedata.getAtoms().elements.number = Int8Array.from(atomicNumber);
      moleculedata.getAtoms().coords = {};
      moleculedata.getAtoms().coords["3d"] = Float32Array.from(pointValues);
    }
    model.output[0] = moleculedata;
  };
  publicAPI.isBusy = () => !!model.requestCount;
}
var DEFAULT_VALUES125 = {
  numberOfAtoms: 0,
  requestCount: 0
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend137(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES125, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL", "numberOfAtoms", "requestCount"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, "busy");
  vtkPDBReader(publicAPI, model);
}
var newInstance132 = macro.newInstance(extend137, "vtkPDBReader");
var vtkPDBReader$1 = {
  newInstance: newInstance132,
  extend: extend137
};

// node_modules/@kitware/vtk.js/IO/Misc/SkyboxReader.js
function vtkSkyboxReader(publicAPI, model) {
  model.classHierarchy.push("vtkSkyboxReader");
  function fetchData(url) {
    const {
      compression,
      progressCallback
    } = model;
    return model.dataAccessHelper.fetchBinary(url, {
      compression,
      progressCallback
    });
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.url = url;
    return publicAPI.loadData(option);
  };
  publicAPI.loadData = function() {
    return fetchData(model.url).then(publicAPI.parseAsArrayBuffer);
  };
  publicAPI.parseAsArrayBuffer = (content) => {
    if (!content) {
      return false;
    }
    model.textures = {};
    model.busy = true;
    publicAPI.invokeBusy(model.busy);
    model.dataMapping = {};
    const imageReady = [];
    function workDone() {
      for (let i = 0; i < model.positions.length; i++) {
        const key = model.positions[i];
        const images = model.dataMapping[key];
        if (!model.textures[key]) {
          model.textures[key] = vtkTexture$1.newInstance({
            interpolate: true
          });
        }
        if (images) {
          const texture = model.textures[key];
          for (let idx = 0; idx < 6; idx++) {
            const {
              fileName,
              transform
            } = model.faceMapping[idx];
            const readyIndex = imageReady.indexOf(`${key}/${fileName}`);
            if (readyIndex !== -1) {
              texture.setInputData(ImageHelper.imageToImageData(images[fileName], transform), idx);
              URL.revokeObjectURL(images[fileName].src);
              delete images[fileName];
              imageReady.splice(readyIndex, 1);
            }
          }
        }
      }
      model.busy = false;
      publicAPI.modified();
      publicAPI.invokeBusy(model.busy);
    }
    const decompressedFiles = unzipSync(new Uint8Array(content));
    const pending = [];
    Object.entries(decompressedFiles).forEach((_ref) => {
      let [relativePath, fileData] = _ref;
      if (relativePath.match(/index.json$/)) {
        const txt = strFromU8(fileData);
        const config = JSON.parse(txt);
        if (config.skybox && config.skybox.faceMapping) {
          model.faceMapping = config.skybox.faceMapping;
        }
        if (config.metadata && config.metadata.skybox && config.metadata.skybox.faceMapping) {
          model.faceMapping = config.metadata.skybox.faceMapping;
        }
      }
      if (relativePath.match(/\.jpg$/)) {
        const pathTokens = relativePath.split("/");
        const fileName = pathTokens.pop();
        const key = pathTokens.pop();
        if (!model.dataMapping[key]) {
          model.dataMapping[key] = {};
        }
        const blob = new Blob([fileData.buffer]);
        const img = new Image();
        const readyKey = `${key}/${fileName}`;
        model.dataMapping[key][fileName] = img;
        pending.push(new Promise((resolve) => {
          img.onload = () => {
            imageReady.push(readyKey);
            resolve();
          };
        }));
        img.src = URL.createObjectURL(blob);
      }
    });
    model.positions = Object.keys(model.dataMapping);
    model.position = model.positions[0];
    Promise.all(pending).then(() => {
      workDone();
    });
    return publicAPI.getReadyPromise();
  };
  publicAPI.requestData = (inData, outData) => {
    outData[0] = model.textures[model.position];
  };
  publicAPI.setPosition = (name2) => {
    if (model.positions.indexOf(name2) !== -1 && name2 !== model.position) {
      model.position = name2;
      publicAPI.modified();
    }
  };
  publicAPI.getReadyPromise = () => {
    if (!model.busy) {
      return Promise.resolve(publicAPI);
    }
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onBusy((isBusy) => {
        if (!isBusy) {
          subscription.unsubscribe();
          resolve(publicAPI);
        }
      });
    });
  };
  publicAPI.isBusy = () => model.busy;
}
var DEFAULT_VALUES126 = {
  // url: null,
  busy: false,
  // everything must be flipped in Y due to canvas
  // versus vtk ordering
  faceMapping: [{
    fileName: "right.jpg",
    transform: {
      flipY: true
    }
  }, {
    fileName: "left.jpg",
    transform: {
      flipY: true
    }
  }, {
    fileName: "up.jpg",
    transform: {
      flipY: true
    }
  }, {
    fileName: "down.jpg",
    transform: {
      flipY: true
    }
  }, {
    fileName: "back.jpg",
    transform: {
      flipY: true
    }
  }, {
    fileName: "front.jpg",
    transform: {
      flipY: true
    }
  }]
};
function extend138(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES126, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "positions", "position"]);
  macro.setGet(publicAPI, model, ["faceMapping"]);
  macro.event(publicAPI, model, "busy");
  macro.algo(publicAPI, model, 0, 6);
  vtkSkyboxReader(publicAPI, model);
}
var newInstance133 = macro.newInstance(extend138, "vtkSkyboxReader");
var vtkSkyboxReader$1 = {
  newInstance: newInstance133,
  extend: extend138
};

// node_modules/@kitware/vtk.js/IO/Misc/GCodeReader.js
function vtkGCodeReader(publicAPI, model) {
  const state = {
    currentPosition: {
      x: 0,
      y: 0,
      z: 0
    },
    offset: {
      x: 0,
      y: 0,
      z: 0
    },
    currentLayer: 0,
    layers: /* @__PURE__ */ new Map(),
    // Map to store layer data
    isAbsolute: true,
    // G90 is default
    isMetric: true,
    // G21 is default
    lastZ: 0
    // Track Z changes for layer detection
  };
  model.classHierarchy.push("vtkGCodeReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      compression,
      progressCallback
    } = model;
    if (option.binary) {
      return model.dataAccessHelper.fetchBinary(url, {
        compression,
        progressCallback
      });
    }
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  function detectLayerChange(newZ) {
    if (Math.abs(newZ - state.lastZ) > 1e-3) {
      state.currentLayer++;
      state.lastZ = newZ;
      return true;
    }
    return false;
  }
  function initializeLayer() {
    if (!state.layers.has(state.currentLayer)) {
      const points = vtkPoints$1.newInstance();
      const lines = vtkCellArray$1.newInstance();
      const polyData = vtkPolyData$1.newInstance();
      polyData.setPoints(points);
      polyData.setLines(lines);
      state.layers.set(state.currentLayer, {
        polyData,
        points,
        lines,
        zHeight: state.lastZ
      });
    }
  }
  function addLineToLayer(startPoint, endPoint) {
    initializeLayer();
    const layer = state.layers.get(state.currentLayer);
    const startIndex = layer.points.insertNextPoint(startPoint[0], startPoint[1], startPoint[2]);
    const endIndex = layer.points.insertNextPoint(endPoint[0], endPoint[1], endPoint[2]);
    layer.lines.insertNextCell([startIndex, endIndex]);
  }
  function processMove(params) {
    const newPosition = {
      ...state.currentPosition
    };
    let positionChanged = false;
    ["X", "Y", "Z"].forEach((axis) => {
      if (axis in params) {
        const value = state.isMetric ? params[axis] : params[axis] * 25.4;
        newPosition[axis.toLowerCase()] = state.isAbsolute ? value + state.offset[axis.toLowerCase()] : state.currentPosition[axis.toLowerCase()] + value;
        positionChanged = true;
      }
    });
    if (positionChanged) {
      if ("Z" in params) {
        detectLayerChange(newPosition.z);
      }
      const startPoint = [state.currentPosition.x, state.currentPosition.y, state.currentPosition.z];
      const endPoint = [newPosition.x, newPosition.y, newPosition.z];
      addLineToLayer(startPoint, endPoint);
      state.currentPosition = newPosition;
    }
  }
  function processG92(params) {
    ["X", "Y", "Z"].forEach((axis) => {
      if (axis in params) {
        state.offset[axis.toLowerCase()] = state.currentPosition[axis.toLowerCase()] - (state.isMetric ? params[axis] : params[axis] * 25.4);
      }
    });
  }
  function processCommand(command, params) {
    switch (command) {
      case "G0":
      case "G1":
        processMove(params);
        break;
      case "G20":
        state.isMetric = false;
        break;
      case "G21":
        state.isMetric = true;
        break;
      case "G90":
        state.isAbsolute = true;
        break;
      case "G91":
        state.isAbsolute = false;
        break;
      case "G92":
        processG92(params);
        break;
    }
  }
  function parseGCode(gcodeText) {
    const lines = gcodeText.split("\n");
    lines.forEach((line) => {
      const sline = line.split(";")[0].trim();
      if (!sline) return;
      const tokens = sline.split(" ");
      const command = tokens[0];
      const params = {};
      tokens.slice(1).forEach((token) => {
        const param = token[0];
        const value = parseFloat(token.slice(1));
        if (!Number.isNaN(value)) {
          params[param] = value;
        }
      });
      processCommand(command, params);
    });
  }
  publicAPI.setUrl = function(url) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      binary: true
    };
    model.url = url;
    const path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    model.compression = option.compression;
    return publicAPI.loadData({
      progressCallback: option.progressCallback,
      binary: !!option.binary
    });
  };
  publicAPI.loadData = function() {
    let option = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const promise = fetchData(model.url, option);
    promise.then(publicAPI.parse);
    return promise;
  };
  publicAPI.parseAsText = (content) => {
    parseGCode(content);
  };
  publicAPI.parseAsArrayBuffer = (content) => {
    const data2 = BinaryHelper.arrayBufferToString(content);
    parseGCode(data2);
  };
  publicAPI.parse = (content) => {
    if (typeof content === "string") {
      publicAPI.parseAsText(content);
    } else {
      publicAPI.parseAsArrayBuffer(content);
    }
    state.layers.forEach((layer, i) => {
      model.output[i] = layer.polyData;
    });
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parse(model.parseData);
  };
  publicAPI.getNumberOfOutputPorts = () => state.layers.size;
}
var DEFAULT_VALUES127 = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};
function extend139(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES127, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  macro.event(publicAPI, model, "ready");
  vtkGCodeReader(publicAPI, model);
}
var newInstance134 = macro.newInstance(extend139, "vtkGCodeReader");
var vtkGCodeReader$1 = {
  extend: extend139,
  newInstance: newInstance134
};

// node_modules/@kitware/vtk.js/IO/Misc.js
var Misc2 = {
  vtkElevationReader: vtkElevationReader$1,
  vtkITKImageReader: vtkITKImageReader$1,
  vtkITKPolyDataReader: vtkITKPolyDataReader$1,
  vtkJSONNucleoReader: vtkJSONNucleoReader$1,
  vtkJSONReader: vtkJSONReader$1,
  vtkMTLReader: vtkMTLReader$1,
  vtkOBJReader: vtkOBJReader$1,
  vtkOBJWriter: vtkOBJWriter$1,
  vtkPDBReader: vtkPDBReader$1,
  vtkSkyboxReader: vtkSkyboxReader$1,
  vtkGCodeReader: vtkGCodeReader$1
};

// node_modules/@kitware/vtk.js/IO/XML/XMLImageDataReader.js
function vtkXMLImageDataReader(publicAPI, model) {
  model.classHierarchy.push("vtkXMLImageDataReader");
  publicAPI.parseXML = (rootElem, type, compressor, byteOrder, headerType) => {
    var _a;
    const imageDataElem = rootElem.getElementsByTagName(model.dataType)[0];
    const origin3 = imageDataElem.getAttribute("Origin").split(" ").map((t) => Number(t));
    const spacing = imageDataElem.getAttribute("Spacing").split(" ").map((t) => Number(t));
    const direction3 = (_a = imageDataElem.getAttribute("Direction")) == null ? void 0 : _a.split(" ").map((t) => Number(t));
    const pieces = imageDataElem.getElementsByTagName("Piece");
    const nbPieces = pieces.length;
    for (let outputIndex = 0; outputIndex < nbPieces; outputIndex++) {
      const piece = pieces[outputIndex];
      const extent = piece.getAttribute("Extent").split(" ").map((t) => Number(t));
      const imageData = vtkImageData$1.newInstance({
        origin: origin3,
        spacing,
        direction: direction3,
        extent
      });
      vtkXMLReader$1.processFieldData(imageData.getNumberOfPoints(), piece.getElementsByTagName("PointData")[0], imageData.getPointData(), compressor, byteOrder, headerType, model.binaryBuffer);
      vtkXMLReader$1.processFieldData(imageData.getNumberOfCells(), piece.getElementsByTagName("CellData")[0], imageData.getCellData(), compressor, byteOrder, headerType, model.binaryBuffer);
      model.output[outputIndex] = imageData;
    }
  };
}
var DEFAULT_VALUES128 = {
  dataType: "ImageData"
};
function extend140(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES128, initialValues);
  vtkXMLReader$1.extend(publicAPI, model, initialValues);
  vtkXMLImageDataReader(publicAPI, model);
}
var newInstance135 = macro.newInstance(extend140, "vtkXMLImageDataReader");
var vtkXMLImageDataReader$1 = {
  newInstance: newInstance135,
  extend: extend140
};

// node_modules/@kitware/vtk.js/IO/XML/XMLWriter.js
var import_xmlbuilder2 = __toESM(require_xmlbuilder2_min(), 1);

// node_modules/@kitware/vtk.js/IO/XML/XMLWriter/Constants.js
var FormatTypes3 = {
  ASCII: "ascii",
  BINARY: "binary",
  APPENDED: "appended"
};
var TYPED_ARRAY = {
  Int8Array: "Int8",
  Uint8Array: "UInt8",
  Int16Array: "Int16",
  Uint16Array: "UInt16",
  Int32Array: "Int32",
  Uint32Array: "UInt32",
  Float32Array: "Float32",
  Float64Array: "Float64"
};

// node_modules/@kitware/vtk.js/IO/XML/XMLWriter.js
function compressBlock(uncompressed) {
  return zlibSync(uncompressed);
}
function processDataArray(dataArray, format2, blockSize) {
  let compressor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "vtkZLibDataCompressor";
  if (format2 === FormatTypes3.ASCII) {
    return dataArray.getData().join(" ");
  }
  if (format2 === FormatTypes3.BINARY) {
    if (compressor === "vtkZLibDataCompressor") {
      const componentUint8Size = dataArray.getElementComponentSize();
      const uncompressedUint8Size = dataArray.getNumberOfValues() * componentUint8Size;
      const blockUint8Size = blockSize;
      const nbFullBlocks = Math.trunc(uncompressedUint8Size / blockUint8Size);
      const lastBlockUint8Size = uncompressedUint8Size % blockUint8Size;
      const nbBlocks = nbFullBlocks + (lastBlockUint8Size ? 1 : 0);
      const header = new Uint32Array(3 + nbBlocks);
      header[0] = nbBlocks;
      header[1] = blockUint8Size;
      header[2] = lastBlockUint8Size;
      let totalUint8Length = 0;
      const blocks = [];
      let dataOffset = 0;
      const lastBlockId = nbBlocks - 1;
      for (let blockId = 0; blockId < nbBlocks; ++blockId) {
        const currentBlockUint8Size = lastBlockUint8Size === 0 || blockId < lastBlockId ? blockUint8Size : header[2];
        const uncompressedBlock = new Uint8Array(dataArray.getData().buffer, dataOffset, currentBlockUint8Size);
        dataOffset += blockUint8Size;
        const compressedUint8Block = compressBlock(uncompressedBlock);
        blocks.push(compressedUint8Block);
        header[3 + blockId] = compressedUint8Block.length;
        totalUint8Length += compressedUint8Block.length;
      }
      const uint8 = new Uint8Array(totalUint8Length);
      let uint8Offset = 0;
      const headerUint8 = new Uint8Array(header.buffer);
      for (let blockId = 0; blockId < nbBlocks; ++blockId) {
        uint8.set(blocks[blockId], uint8Offset);
        uint8Offset += header[3 + blockId];
      }
      return fromArrayBuffer(headerUint8.buffer) + fromArrayBuffer(uint8.buffer);
    }
    throw new Error("Only vtkZLibDataCompressor is supported");
  }
  if (format2 === FormatTypes3.APPENDED) {
    throw new Error("Appended format is not supported");
  }
  throw new Error("Format is not supported");
}
function vtkXMLWriter(publicAPI, model) {
  model.classHierarchy.push("vtkXMLWriter");
  publicAPI.create = (dataObject) => (0, import_xmlbuilder2.create)().ele("VTKFile").att("type", model.dataType).att("version", "0.1").att("byte_order", "LittleEndian").att("header_type", "UInt32").att("compressor", model.format === FormatTypes3.ASCII ? "" : "vtkZLibDataCompressor");
  publicAPI.write = (object) => publicAPI.create(object).end({
    pretty: true
  });
  publicAPI.processDataSetAttributes = (parentElement, name2, datasetAttributes) => {
    const activeAttributes = {};
    const attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
    attrTypes.forEach((attrType) => {
      const activeAttribute = datasetAttributes.getActiveAttribute(attrType);
      if (activeAttribute) {
        activeAttributes[attrType] = activeAttribute.getName();
      }
    });
    const datasetAttributesEle = parentElement.ele(name2, activeAttributes);
    for (let i = 0; i < datasetAttributes.getNumberOfArrays(); ++i) {
      publicAPI.processDataArray(datasetAttributesEle, datasetAttributes.getArrayByIndex(i));
    }
    return datasetAttributesEle;
  };
  publicAPI.processDataArray = (parentEle, scalars) => parentEle.ele("DataArray", {
    type: TYPED_ARRAY[scalars.getDataType()],
    Name: scalars.getName(),
    format: publicAPI.getFormat(),
    RangeMin: scalars.getRange()[0],
    RangeMax: scalars.getRange()[1],
    NumberOfComponents: scalars.getNumberOfComponents()
  }).txt(processDataArray(scalars, publicAPI.getFormat(), publicAPI.getBlockSize()));
  publicAPI.requestData = (inData, outData) => {
    model.file = publicAPI.write(inData);
  };
}
var DEFAULT_VALUES129 = {
  blockSize: 1024,
  // file: null,
  format: FormatTypes3.BINARY
};
function extend141(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES129, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["blockSize", "format"]);
  macro.get(publicAPI, model, ["file"]);
  macro.algo(publicAPI, model, 1, 0);
  vtkXMLWriter(publicAPI, model);
}
var vtkXMLWriter$1 = {
  extend: extend141,
  compressBlock,
  processDataArray,
  FormatTypes: FormatTypes3
};

// node_modules/@kitware/vtk.js/IO/XML/XMLImageDataWriter.js
function vtkXMLImageDataWriter(publicAPI, model) {
  model.classHierarchy.push("vtkXMLImageDataWriter");
  const superClass = {
    ...publicAPI
  };
  publicAPI.create = (dataObject) => {
    const parent = superClass.create(dataObject);
    const imageData = parent.ele("ImageData", {
      WholeExtent: dataObject.getExtent().join(" "),
      Origin: dataObject.getOrigin().join(" "),
      Spacing: dataObject.getSpacing().join(" "),
      Direction: dataObject.getDirection().join(" ")
    });
    const piece = imageData.ele("Piece", {
      Extent: dataObject.getExtent().join(" ")
    });
    publicAPI.processDataSetAttributes(piece, "PointData", dataObject.getPointData());
    publicAPI.processDataSetAttributes(piece, "CellData", dataObject.getCellData());
    return parent;
  };
}
var DEFAULT_VALUES130 = {
  dataType: "ImageData"
};
function extend142(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES130, initialValues);
  vtkXMLWriter$1.extend(publicAPI, model, initialValues);
  vtkXMLImageDataWriter(publicAPI, model);
}
var newInstance136 = macro.newInstance(extend142, "vtkXMLImageDataWriter");
var vtkXMLImageDataWriter$1 = {
  newInstance: newInstance136,
  extend: extend142
};

// node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataWriter.js
function vtkXMLPolyDataWriter(publicAPI, model) {
  model.classHierarchy.push("vtkXMLPolyDataWriter");
  const superClass = {
    ...publicAPI
  };
  function camelize2(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
  }
  publicAPI.create = (dataObject) => {
    const parent = superClass.create(dataObject);
    const polyData = parent.ele("PolyData", {});
    const piece = polyData.ele("Piece", {
      NumberOfPoints: dataObject.getPoints().getNumberOfPoints(),
      NumberOfVerts: dataObject.getNumberOfVerts(),
      NumberOfLines: dataObject.getNumberOfLines(),
      NumberOfStrips: dataObject.getNumberOfStrips(),
      NumberOfPolys: dataObject.getNumberOfPolys()
    });
    publicAPI.processDataSetAttributes(piece, "PointData", dataObject.getPointData());
    publicAPI.processDataSetAttributes(piece, "CellData", dataObject.getCellData());
    publicAPI.processDataSetAttributes(piece, "FieldData", dataObject.getFieldData());
    publicAPI.processDataArray(piece.ele("Points"), dataObject.getPoints());
    POLYDATA_FIELDS.forEach((cellType) => {
      const cellTypeName = camelize2(cellType);
      const cells = dataObject[`get${cellTypeName}`]();
      const connectivity = [];
      const offsets = [];
      const cellsData = cells.getData();
      let npts = cellsData[0];
      let offset = 0;
      for (let i = 0; i < cellsData.length; ) {
        npts = cellsData[i++];
        for (let j = 0; j < npts; ++j) {
          connectivity.push(cellsData[i++]);
        }
        offset += npts;
        offsets.push(offset);
      }
      const connectivityDataArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        name: "connectivity",
        values: Int32Array.from(connectivity)
      });
      const offsetsDataArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        name: "offsets",
        values: Int32Array.from(offsets)
      });
      const cellEle = piece.ele(cellTypeName);
      publicAPI.processDataArray(cellEle, connectivityDataArray);
      publicAPI.processDataArray(cellEle, offsetsDataArray);
    });
    return parent;
  };
}
var DEFAULT_VALUES131 = {
  dataType: "PolyData"
};
function extend143(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES131, initialValues);
  vtkXMLWriter$1.extend(publicAPI, model, initialValues);
  vtkXMLPolyDataWriter(publicAPI, model);
}
var newInstance137 = macro.newInstance(extend143, "vtkXMLPolyDataWriter");
var vtkXMLPolyDataWriter$1 = {
  newInstance: newInstance137,
  extend: extend143
};

// node_modules/@kitware/vtk.js/IO/XML.js
var XML = {
  vtkXMLImageDataReader: vtkXMLImageDataReader$1,
  vtkXMLImageDataWriter: vtkXMLImageDataWriter$1,
  vtkXMLPolyDataReader: vtkXMLPolyDataReader$1,
  vtkXMLPolyDataWriter: vtkXMLPolyDataWriter$1,
  vtkXMLReader: vtkXMLReader$1,
  vtkXMLWriter: vtkXMLWriter$1
};

// node_modules/@kitware/vtk.js/IO/index.js
var IO = {
  Core: Core4,
  Geometry,
  Legacy,
  Misc: Misc2,
  XML
};

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.json.js
var vtkColorMaps3 = [
  {
    Name: "KAAMS",
    IndexedColors: [
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      1,
      0.63,
      0.63,
      1,
      0.67,
      0.5,
      0.33,
      1,
      0.5,
      0.75,
      0.53,
      0.35,
      0.7,
      1,
      0.75,
      0.5
    ],
    Annotations: [
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Cool to Warm",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.23137254902,
      0.298039215686,
      0.752941176471,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.705882352941,
      0.0156862745098,
      0.149019607843
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Cool to Warm (Extended)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0.34902,
      0.03125,
      0.039216,
      0.062745,
      0.380392,
      0.0625,
      0.062745,
      0.117647,
      0.411765,
      0.09375,
      0.090196,
      0.184314,
      0.45098,
      0.125,
      0.12549,
      0.262745,
      0.501961,
      0.15625,
      0.160784,
      0.337255,
      0.541176,
      0.1875,
      0.2,
      0.396078,
      0.568627,
      0.21875,
      0.239216,
      0.454902,
      0.6,
      0.25,
      0.286275,
      0.521569,
      0.65098,
      0.28125,
      0.337255,
      0.592157,
      0.701961,
      0.3125,
      0.388235,
      0.654902,
      0.74902,
      0.34375,
      0.466667,
      0.737255,
      0.819608,
      0.375,
      0.572549,
      0.819608,
      0.878431,
      0.40625,
      0.654902,
      0.866667,
      0.909804,
      0.4375,
      0.752941,
      0.917647,
      0.941176,
      0.46875,
      0.823529,
      0.956863,
      0.968627,
      0.5,
      0.988235,
      0.960784,
      0.901961,
      0.5,
      0.941176,
      0.984314,
      0.988235,
      0.52,
      0.988235,
      0.945098,
      0.85098,
      0.54,
      0.980392,
      0.898039,
      0.784314,
      0.5625,
      0.968627,
      0.835294,
      0.698039,
      0.59375,
      0.94902,
      0.733333,
      0.588235,
      0.625,
      0.929412,
      0.65098,
      0.509804,
      0.65625,
      0.909804,
      0.564706,
      0.435294,
      0.6875,
      0.878431,
      0.458824,
      0.352941,
      0.71875,
      0.839216,
      0.388235,
      0.286275,
      0.75,
      0.760784,
      0.294118,
      0.211765,
      0.78125,
      0.701961,
      0.211765,
      0.168627,
      0.8125,
      0.65098,
      0.156863,
      0.129412,
      0.84375,
      0.6,
      0.094118,
      0.094118,
      0.875,
      0.54902,
      0.066667,
      0.098039,
      0.90625,
      0.501961,
      0.05098,
      0.12549,
      0.9375,
      0.45098,
      0.054902,
      0.172549,
      0.96875,
      0.4,
      0.054902,
      0.192157,
      1,
      0.34902,
      0.070588,
      0.211765
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Warm to Cool",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.705882352941,
      0.0156862745098,
      0.149019607843,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.23137254902,
      0.298039215686,
      0.752941176471
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Warm to Cool (Extended)",
    NanColor: [
      0.250004,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.34902,
      0,
      0.129412,
      0.025,
      0.4,
      392157e-8,
      0.101961,
      0.05,
      0.470588,
      0.0156863,
      0.0901961,
      0.075,
      0.54902,
      0.027451,
      0.0705882,
      0.1,
      0.619608,
      0.0627451,
      0.0431373,
      0.125,
      0.690196,
      0.12549,
      0.0627451,
      0.15,
      0.741176,
      0.184314,
      0.0745098,
      0.175,
      0.788235,
      0.266667,
      0.0941176,
      0.2,
      0.811765,
      0.345098,
      0.113725,
      0.225,
      0.831373,
      0.411765,
      0.133333,
      0.25,
      0.85098,
      0.47451,
      0.145098,
      0.275,
      0.870588,
      0.54902,
      0.156863,
      0.3,
      0.878431,
      0.619608,
      0.168627,
      0.325,
      0.890196,
      0.658824,
      0.196078,
      0.35,
      0.909804,
      0.717647,
      0.235294,
      0.375,
      0.929412,
      0.776471,
      0.278431,
      0.395522,
      0.94902,
      0.823529,
      0.321569,
      0.418905,
      0.968627,
      0.87451,
      0.407843,
      0.444278,
      0.980392,
      0.917647,
      0.509804,
      0.470149,
      0.988235,
      0.956863,
      0.643137,
      0.483582,
      0.992157,
      0.964706,
      0.713725,
      0.499,
      0.988235,
      0.980392,
      0.870588,
      0.5,
      1,
      1,
      1,
      0.501,
      0.913725,
      0.988235,
      0.937255,
      0.516418,
      0.827451,
      0.980392,
      0.886275,
      0.531343,
      0.764706,
      0.980392,
      0.866667,
      0.546766,
      0.658824,
      0.980392,
      0.843137,
      0.564179,
      0.572549,
      0.964706,
      0.835294,
      0.587562,
      0.423529,
      0.941176,
      0.87451,
      0.60597,
      0.262745,
      0.901961,
      0.862745,
      0.629851,
      0.0705882,
      0.854902,
      0.870588,
      0.651741,
      0.0509804,
      0.8,
      0.85098,
      0.681592,
      0.0235294,
      0.709804,
      0.831373,
      0.712935,
      0.0313725,
      0.615686,
      0.811765,
      0.75,
      0.0313725,
      0.537255,
      0.788235,
      0.775,
      0.0392157,
      0.466667,
      0.768627,
      0.8,
      0.0509804,
      0.396078,
      0.741176,
      0.825,
      0.054902,
      0.317647,
      0.709804,
      0.85,
      0.054902,
      0.243137,
      0.678431,
      0.875,
      0.0431373,
      0.164706,
      0.639216,
      0.9,
      0.0313725,
      0.0980392,
      0.6,
      0.925,
      0.0392157,
      0.0392157,
      0.560784,
      0.95,
      0.105882,
      0.0509804,
      0.509804,
      0.975,
      0.113725,
      0.0235294,
      0.45098,
      1,
      0.12549,
      0,
      0.380392
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Desaturated",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.278431372549,
      0.278431372549,
      0.858823529412,
      0.143,
      0,
      0,
      0.360784313725,
      0.285,
      0,
      1,
      1,
      0.429,
      0,
      0.501960784314,
      0,
      0.571,
      1,
      1,
      0,
      0.714,
      1,
      0.380392156863,
      0,
      0.857,
      0.419607843137,
      0,
      0,
      1,
      0.878431372549,
      0.301960784314,
      0.301960784314
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Cold and Hot",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      1,
      1,
      0.45,
      0,
      0,
      1,
      0.5,
      0,
      0,
      0.501960784314,
      0.55,
      1,
      0,
      0,
      1,
      1,
      1,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black-Body Radiation",
    NanColor: [
      0,
      0.498039215686,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.4,
      0.901960784314,
      0,
      0,
      0.8,
      0.901960784314,
      0.901960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "X Ray",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Grayscale",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Grayscale-DICOM-sigmoid",
    Notes: "This is a 16 point sample of a sigmoid grayscale colormap described in the DICOM standard. See equation C.11-1 in section C.11.2",
    NanColor: [
      1,
      0,
      0
    ],
    BelowRangeColor: [
      0,
      0,
      0
    ],
    AboveRangeColor: [
      1,
      1,
      1
    ],
    RGBPoints: [
      -1,
      0.01798620996209156,
      0.01798620996209156,
      0.01798620996209156,
      -0.8666666666666667,
      0.030275691986950463,
      0.030275691986950463,
      0.030275691986950463,
      -0.7333333333333334,
      0.05053016223541345,
      0.05053016223541345,
      0.05053016223541345,
      -0.6,
      0.08317269649392238,
      0.08317269649392238,
      0.08317269649392238,
      -0.4666666666666667,
      0.13392788832407365,
      0.13392788832407365,
      0.13392788832407365,
      -0.33333333333333337,
      0.2086085273260449,
      0.2086085273260449,
      0.2086085273260449,
      -0.19999999999999996,
      0.31002551887238755,
      0.31002551887238755,
      0.31002551887238755,
      -0.06666666666666665,
      0.4337256058045608,
      0.4337256058045608,
      0.4337256058045608,
      0.06666666666666665,
      0.5662743941954392,
      0.5662743941954392,
      0.5662743941954392,
      0.19999999999999996,
      0.6899744811276125,
      0.6899744811276125,
      0.6899744811276125,
      0.33333333333333326,
      0.791391472673955,
      0.791391472673955,
      0.791391472673955,
      0.46666666666666656,
      0.8660721116759263,
      0.8660721116759263,
      0.8660721116759263,
      0.6000000000000001,
      0.9168273035060777,
      0.9168273035060777,
      0.9168273035060777,
      0.7333333333333334,
      0.9494698377645865,
      0.9494698377645865,
      0.9494698377645865,
      0.8666666666666667,
      0.9697243080130495,
      0.9697243080130495,
      0.9697243080130495,
      1,
      0.9820137900379085,
      0.9820137900379085,
      0.9820137900379085
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Inverted-Grayscale",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Inverted-Grayscale-DICOM-sigmoid",
    Notes: "This is a 16 point sample of a sigmoid inverted-grayscale colormap described in the DICOM standard. See equation C.11-1 in section C.11.2",
    BelowRangeColor: [
      1,
      1,
      1
    ],
    AboveRangeColor: [
      0,
      0,
      0
    ],
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      -1,
      0.9820137900379085,
      0.9820137900379085,
      0.9820137900379085,
      -0.8666666666666667,
      0.9697243080130495,
      0.9697243080130495,
      0.9697243080130495,
      -0.7333333333333334,
      0.9494698377645866,
      0.9494698377645866,
      0.9494698377645866,
      -0.6,
      0.9168273035060777,
      0.9168273035060777,
      0.9168273035060777,
      -0.4666666666666667,
      0.8660721116759263,
      0.8660721116759263,
      0.8660721116759263,
      -0.33333333333333337,
      0.791391472673955,
      0.791391472673955,
      0.791391472673955,
      -0.19999999999999996,
      0.6899744811276125,
      0.6899744811276125,
      0.6899744811276125,
      -0.06666666666666665,
      0.5662743941954391,
      0.5662743941954391,
      0.5662743941954391,
      0.06666666666666665,
      0.43372560580456077,
      0.43372560580456077,
      0.43372560580456077,
      0.19999999999999996,
      0.3100255188723875,
      0.3100255188723875,
      0.3100255188723875,
      0.33333333333333326,
      0.20860852732604496,
      0.20860852732604496,
      0.20860852732604496,
      0.46666666666666656,
      0.13392788832407365,
      0.13392788832407365,
      0.13392788832407365,
      0.6000000000000001,
      0.08317269649392234,
      0.08317269649392234,
      0.08317269649392234,
      0.7333333333333334,
      0.05053016223541351,
      0.05053016223541351,
      0.05053016223541351,
      0.8666666666666667,
      0.03027569198695046,
      0.03027569198695046,
      0.03027569198695046,
      1,
      0.01798620996209155,
      0.01798620996209155,
      0.01798620996209155
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkRd",
    NanColor: [
      0,
      1,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkGn",
    NanColor: [
      1,
      0,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkBu",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkMa",
    NanColor: [
      0,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkCy",
    NanColor: [
      0,
      1,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Blue and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0,
      0,
      0.501960784314,
      0.666,
      0,
      0.501960784314,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Orange and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0.501960784314,
      0,
      0,
      0.666,
      1,
      0.501960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Linear YGB 1211g",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      0.988235,
      0.968627,
      0.02,
      1,
      0.952941,
      0.878431,
      0.05,
      0.968627,
      0.905882,
      0.776471,
      0.1,
      0.94902,
      0.898039,
      0.647059,
      0.15,
      0.901961,
      0.878431,
      0.556863,
      0.2,
      0.847059,
      0.858824,
      0.482353,
      0.25,
      0.690196,
      0.819608,
      0.435294,
      0.3,
      0.513725,
      0.768627,
      0.384314,
      0.35,
      0.337255,
      0.721569,
      0.337255,
      0.4,
      0.278431,
      0.658824,
      0.392157,
      0.45,
      0.231373,
      0.639216,
      0.435294,
      0.5,
      0.203922,
      0.6,
      0.486275,
      0.55,
      0.172549,
      0.568627,
      0.537255,
      0.6,
      0.141176,
      0.517647,
      0.54902,
      0.65,
      0.133333,
      0.458824,
      0.541176,
      0.7,
      0.12549,
      0.396078,
      0.529412,
      0.75,
      0.117647,
      0.321569,
      0.521569,
      0.8,
      0.121569,
      0.258824,
      0.509804,
      0.85,
      0.133333,
      0.227451,
      0.501961,
      0.9,
      0.145098,
      0.192157,
      0.490196,
      0.95,
      0.188235,
      0.164706,
      0.470588,
      1,
      0.258824,
      0.196078,
      0.439216
    ]
  },
  {
    ColorSpace: "CIELAB",
    Creator: "Francesca Samsel",
    Name: "Linear Green (Gr4L)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.054902,
      0.109804,
      0.121569,
      0.05,
      0.07451,
      0.172549,
      0.180392,
      0.1,
      0.086275,
      0.231373,
      0.219608,
      0.15,
      0.094118,
      0.278431,
      0.25098,
      0.2,
      0.109804,
      0.34902,
      0.278431,
      0.25,
      0.113725,
      0.4,
      0.278431,
      0.3,
      0.117647,
      0.45098,
      0.270588,
      0.35,
      0.117647,
      0.490196,
      0.243137,
      0.4,
      0.113725,
      0.521569,
      0.203922,
      0.45,
      0.109804,
      0.54902,
      0.152941,
      0.5,
      0.082353,
      0.588235,
      0.082353,
      0.55,
      0.109804,
      0.631373,
      0.05098,
      0.6,
      0.211765,
      0.678431,
      0.082353,
      0.65,
      0.317647,
      0.721569,
      0.113725,
      0.7,
      0.431373,
      0.760784,
      0.160784,
      0.75,
      0.556863,
      0.8,
      0.239216,
      0.8,
      0.666667,
      0.839216,
      0.294118,
      0.85,
      0.784314,
      0.878431,
      0.396078,
      0.9,
      0.886275,
      0.921569,
      0.533333,
      0.95,
      0.960784,
      0.94902,
      0.670588,
      1,
      1,
      0.984314,
      0.901961
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Linear Blue (8_31f)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.960784,
      1,
      0.980392,
      0.05,
      0.815686,
      0.960784,
      0.913725,
      0.1,
      0.670588,
      0.929412,
      0.870588,
      0.15,
      0.556863,
      0.901961,
      0.843137,
      0.2,
      0.478431,
      0.870588,
      0.823529,
      0.25,
      0.439216,
      0.831373,
      0.803922,
      0.3,
      0.4,
      0.8,
      0.788235,
      0.35,
      0.376471,
      0.768627,
      0.768627,
      0.4,
      0.34902,
      0.709804,
      0.729412,
      0.45,
      0.32549,
      0.654902,
      0.690196,
      0.5,
      0.301961,
      0.607843,
      0.658824,
      0.55,
      0.247059,
      0.545098,
      0.619608,
      0.6,
      0.239216,
      0.494118,
      0.580392,
      0.65,
      0.227451,
      0.439216,
      0.541176,
      0.7,
      0.227451,
      0.403922,
      0.521569,
      0.75,
      0.231373,
      0.368627,
      0.501961,
      0.8,
      0.227451,
      0.321569,
      0.470588,
      0.85,
      0.219608,
      0.282353,
      0.439216,
      0.9,
      0.192157,
      0.235294,
      0.4,
      0.95,
      0.160784,
      0.184314,
      0.34902,
      1,
      0.133333,
      0.12549,
      0.301961
    ]
  },
  {
    ColorSpace: "HSV",
    Name: "Blue to Red Rainbow",
    NanColor: [
      0.498039215686,
      0.498039215686,
      0.498039215686
    ],
    RGBPoints: [
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "HSV",
    Name: "Red to Blue Rainbow",
    NanColor: [
      0.498039215686,
      0.498039215686,
      0.498039215686
    ],
    RGBPoints: [
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Blended White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      1,
      0.17,
      0,
      0,
      1,
      0.34,
      0,
      1,
      1,
      0.5,
      0,
      1,
      0,
      0.67,
      1,
      1,
      0,
      0.84,
      1,
      0,
      0,
      1,
      0.878431372549,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Blended Grey",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.317647058824,
      0.341176470588,
      0.43137254902,
      0.17,
      0,
      0,
      1,
      0.34,
      0,
      1,
      1,
      0.5,
      0,
      1,
      0,
      0.67,
      1,
      1,
      0,
      0.84,
      1,
      0,
      0,
      1,
      0.878431372549,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Blended Black",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.17,
      0,
      0,
      1,
      0.34,
      0,
      1,
      1,
      0.5,
      0,
      1,
      0,
      0.67,
      1,
      1,
      0,
      0.84,
      1,
      0,
      0,
      1,
      0.878431372549,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Blue to Yellow",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.0392156862745,
      0.0392156862745,
      0.949019607843,
      1,
      0.949019607843,
      0.949019607843,
      0.0392156862745
    ]
  },
  {
    ColorSpace: "HSV",
    Name: "blot",
    RGBPoints: [
      0,
      0,
      0,
      1,
      0.166,
      0,
      0,
      1,
      0.167,
      1,
      0,
      1,
      0.332,
      1,
      0,
      1,
      0.333,
      0,
      1,
      1,
      0.5,
      0,
      1,
      1,
      0.501,
      0,
      1,
      0,
      0.666,
      0,
      1,
      0,
      0.667,
      1,
      1,
      0,
      0.832,
      1,
      1,
      0,
      0.833,
      1,
      0,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "CIELab Blue to Red",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0.6,
      0.749019607843,
      1,
      0.76862745098,
      0.466666666667,
      0.341176470588
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "jet",
    RGBPoints: [
      -1,
      0,
      0,
      0.5625,
      -0.777778,
      0,
      0,
      1,
      -0.269841,
      0,
      1,
      1,
      -0.015873,
      0.5,
      1,
      0.5,
      0.238095,
      1,
      1,
      0,
      0.746032,
      1,
      0,
      0,
      1,
      0.5,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "rainbow",
    RGBPoints: [
      -1,
      0,
      0,
      1,
      -0.5,
      0,
      1,
      1,
      0,
      0,
      1,
      0,
      0.5,
      1,
      1,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_bright",
    RGBPoints: [
      -1,
      0.32549,
      0.14902,
      0.960784,
      -0.866221,
      0.297047,
      0.375586,
      0.963836,
      -0.732441,
      0.180302,
      0.536818,
      0.964627,
      -0.598662,
      0.1302,
      0.649207,
      0.929647,
      -0.464883,
      0.0445143,
      0.749654,
      0.855998,
      -0.331104,
      0.0271325,
      0.830713,
      0.721527,
      -0.197324,
      0.259504,
      0.866145,
      0.543555,
      -0.0635452,
      0.428364,
      0.890725,
      0.329819,
      0.0702341,
      0.568503,
      0.898508,
      0.187623,
      0.204013,
      0.738259,
      0.890317,
      0.0825461,
      0.337793,
      0.84546,
      0.86136,
      0.0147555,
      0.471572,
      0.912191,
      0.808018,
      0,
      0.605351,
      0.962848,
      0.710445,
      0,
      0.73913,
      0.999469,
      0.600258,
      0.0176284,
      0.87291,
      0.994156,
      0.445975,
      0.193912,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_dark",
    RGBPoints: [
      -1,
      0,
      0,
      0.423499,
      -0.866221,
      0,
      0.119346,
      0.529237,
      -0.732441,
      0,
      0.238691,
      0.634976,
      -0.598662,
      0,
      0.346852,
      0.68788,
      -0.464883,
      0,
      0.45022,
      0.718141,
      -0.331104,
      0,
      0.553554,
      0.664839,
      -0.197324,
      0,
      0.651082,
      0.519303,
      -0.0635452,
      0.115841,
      0.72479,
      0.352857,
      0.0702341,
      0.326771,
      0.781195,
      0.140187,
      0.204013,
      0.522765,
      0.798524,
      0.0284624,
      0.337793,
      0.703162,
      0.788685,
      885756e-8,
      0.471572,
      0.845118,
      0.751133,
      0,
      0.605351,
      0.955734,
      0.690825,
      0,
      0.73913,
      0.995402,
      0.567916,
      0.0618524,
      0.87291,
      0.987712,
      0.403398,
      0.164851,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "nic_CubicL",
    RGBPoints: [
      -1,
      0.479965,
      0.0118108,
      0.5307,
      -0.87451,
      0.522213,
      0.0551282,
      0.706919,
      -0.74902,
      0.50839,
      0.237278,
      0.867764,
      -0.623529,
      0.451617,
      0.373834,
      0.987255,
      -0.498039,
      0.39365,
      0.497255,
      0.97506,
      -0.372549,
      0.328631,
      0.599639,
      0.891843,
      -0.247059,
      0.250043,
      0.690286,
      0.778553,
      -0.121569,
      0.249656,
      0.764905,
      0.645857,
      392157e-8,
      0.297954,
      0.821466,
      0.50449,
      0.129412,
      0.337509,
      0.872595,
      0.358447,
      0.254902,
      0.430011,
      0.913789,
      0.297079,
      0.380392,
      0.587191,
      0.931381,
      0.333353,
      0.505882,
      0.727937,
      0.93591,
      0.353742,
      0.631373,
      0.826403,
      0.921081,
      0.365066,
      0.756863,
      0.893201,
      0.846317,
      0.372662,
      0.882353,
      0.965347,
      0.73884,
      0.378506,
      1,
      0.983235,
      0.597451,
      0.366856
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "nic_CubicYF",
    RGBPoints: [
      -1,
      0.5151,
      0.0482,
      0.6697,
      -0.87451,
      0.520711,
      0.168955,
      0.800574,
      -0.74902,
      0.493694,
      0.278596,
      0.911824,
      -0.623529,
      0.440026,
      0.369475,
      0.984978,
      -0.498039,
      0.398932,
      0.457593,
      0.987053,
      -0.372549,
      0.350651,
      0.540644,
      0.929608,
      -0.247059,
      0.298827,
      0.615625,
      0.857729,
      -0.121569,
      0.239928,
      0.685061,
      0.769531,
      392157e-8,
      0.228832,
      0.739349,
      0.673287,
      0.129412,
      0.263297,
      0.78608,
      0.569988,
      0.254902,
      0.298107,
      0.828337,
      0.460214,
      0.380392,
      0.33092,
      0.864071,
      0.352674,
      0.505882,
      0.38306,
      0.898169,
      0.287309,
      0.631373,
      0.49023,
      0.917481,
      0.307961,
      0.756863,
      0.62372,
      0.926026,
      0.332309,
      0.882353,
      0.717458,
      0.92527,
      0.342476,
      1,
      0.8,
      0.9255,
      0.3529
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "gist_earth",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.239216,
      0.027451,
      0.415686,
      -0.74902,
      0.0901961,
      0.254902,
      0.556863,
      -0.623529,
      0.0941176,
      0.352941,
      0.54902,
      -0.498039,
      0.105882,
      0.435294,
      0.533333,
      -0.372549,
      0.12549,
      0.52549,
      0.501961,
      -0.247059,
      0.156863,
      0.596078,
      0.443137,
      -0.121569,
      0.196078,
      0.65098,
      0.380392,
      392157e-8,
      0.282353,
      0.717647,
      0.301961,
      0.129412,
      0.466667,
      0.772549,
      0.27451,
      0.254902,
      0.678431,
      0.784314,
      0.309804,
      0.380392,
      0.901961,
      0.756863,
      0.376471,
      0.505882,
      0.992157,
      0.705882,
      0.521569,
      0.631373,
      1,
      0.721569,
      0.701961,
      0.756863,
      1,
      0.784314,
      0.784314,
      0.882353,
      1,
      0.866667,
      0.866667,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "2hot",
    RGBPoints: [
      -1,
      0.0416667,
      0,
      0,
      -0.873016,
      0.208333,
      0,
      0,
      -0.746032,
      0.375,
      0,
      0,
      -0.619048,
      0.541667,
      0,
      0,
      -0.492063,
      0.708333,
      0,
      0,
      -0.365079,
      0.854137,
      0,
      0,
      -0.238095,
      0.937488,
      0.039062,
      0,
      -0.111111,
      1,
      0.208333,
      0,
      0.015873,
      1,
      0.375,
      0,
      0.142857,
      1,
      0.541667,
      0,
      0.269841,
      1,
      0.708333,
      0,
      0.396825,
      1,
      0.858805,
      0.03125,
      0.52381,
      1,
      0.947392,
      0.15625,
      0.650794,
      1,
      1,
      0.3125,
      0.777778,
      1,
      1,
      0.5625,
      0.904762,
      1,
      1,
      0.8125,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_red2yellow_BW",
    RGBPoints: [
      -1,
      754296e-12,
      0,
      109827e-10,
      -0.87451,
      0.18285,
      0.0264094,
      0,
      -0.74902,
      0.3066,
      0,
      0,
      -0.623529,
      0.422841,
      0,
      0,
      -0.498039,
      0.522945,
      0,
      0,
      -0.372549,
      0.605721,
      0,
      0,
      -0.247059,
      0.672502,
      0.14168,
      0,
      -0.121569,
      0.728167,
      0.244025,
      0,
      392157e-8,
      0.781215,
      0.333454,
      0,
      0.129412,
      0.825,
      0.423586,
      0,
      0.254902,
      0.855893,
      0.516793,
      0,
      0.380392,
      0.880491,
      0.608846,
      0,
      0.505882,
      0.910305,
      0.695505,
      0,
      0.631373,
      0.94109,
      0.779067,
      0.223528,
      0.756863,
      0.967873,
      0.858572,
      0.473521,
      0.882353,
      0.986815,
      0.933211,
      0.751583,
      1,
      1,
      1,
      0.999997
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_marine2gold_BW",
    RGBPoints: [
      -1,
      111641e-12,
      0,
      162551e-11,
      -0.87451,
      0.0413146,
      0.0619808,
      0.209857,
      -0.74902,
      0.0185557,
      0.101341,
      0.350684,
      -0.623529,
      486405e-8,
      0.149847,
      0.461054,
      -0.498039,
      0.0836345,
      0.210845,
      0.517906,
      -0.372549,
      0.173222,
      0.276134,
      0.541793,
      -0.247059,
      0.259857,
      0.343877,
      0.535869,
      -0.121569,
      0.362299,
      0.408124,
      0.504293,
      392157e-8,
      0.468266,
      0.468276,
      0.468257,
      0.129412,
      0.582781,
      0.527545,
      0.374914,
      0.254902,
      0.691591,
      0.585251,
      0.274266,
      0.380392,
      0.784454,
      0.645091,
      0.247332,
      0.505882,
      0.862299,
      0.710383,
      0.27518,
      0.631373,
      0.920863,
      0.782923,
      0.351563,
      0.756863,
      0.955792,
      0.859699,
      0.533541,
      0.882353,
      0.976162,
      0.93433,
      0.780671,
      1,
      1,
      1,
      0.999983
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2gold_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0742735,
      0.0440331,
      0.230013,
      -0.74902,
      0.125276,
      0.0258685,
      0.415826,
      -0.623529,
      0.143879,
      0.0163031,
      0.591346,
      -0.498039,
      0.212261,
      0.0627855,
      0.705239,
      -0.372549,
      0.306048,
      0.141178,
      0.763636,
      -0.247059,
      0.391537,
      0.232286,
      0.773263,
      -0.121569,
      0.461734,
      0.336633,
      0.708321,
      392157e-8,
      0.54209,
      0.427581,
      0.590007,
      0.129412,
      0.61704,
      0.508623,
      0.460978,
      0.254902,
      0.702703,
      0.579586,
      0.309117,
      0.380392,
      0.790336,
      0.644811,
      0.170397,
      0.505882,
      0.870173,
      0.710733,
      0.117134,
      0.631373,
      0.93656,
      0.781991,
      0.157144,
      0.756863,
      0.965672,
      0.862068,
      0.409836,
      0.882353,
      0.985751,
      0.936296,
      0.714162,
      1,
      1,
      1,
      0.999999
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_sapphire2gold_BW",
    RGBPoints: [
      -1,
      0.107704,
      0.107708,
      0.107694,
      -0.87451,
      0.1851,
      0.112354,
      0.308554,
      -0.74902,
      0.236782,
      0.114233,
      0.48788,
      -0.623529,
      0.28296,
      0.126187,
      0.639464,
      -0.498039,
      0.344787,
      0.171643,
      0.739713,
      -0.372549,
      0.413325,
      0.242371,
      0.76913,
      -0.247059,
      0.481863,
      0.3131,
      0.719841,
      -0.121569,
      0.550402,
      0.383829,
      0.612222,
      392157e-8,
      0.61894,
      0.454558,
      0.51126,
      0.129412,
      0.687478,
      0.525287,
      0.39993,
      0.254902,
      0.756017,
      0.596016,
      0.289923,
      0.380392,
      0.824555,
      0.666745,
      0.255498,
      0.505882,
      0.892979,
      0.736822,
      0.27696,
      0.631373,
      0.938851,
      0.804966,
      0.351734,
      0.756863,
      0.966491,
      0.874853,
      0.53572,
      0.882353,
      0.982105,
      0.94153,
      0.782579,
      1,
      1,
      1,
      0.999986
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_red2purple_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.167793,
      0.0166271,
      0.0431278,
      -0.74902,
      0.262608,
      0.0107595,
      0.0791181,
      -0.623529,
      0.351902,
      0.0101858,
      0.100926,
      -0.498039,
      0.441257,
      0.0160835,
      0.131919,
      -0.372549,
      0.5221,
      0.0555972,
      0.195625,
      -0.247059,
      0.593852,
      0.104294,
      0.310234,
      -0.121569,
      0.654628,
      0.158115,
      0.448486,
      392157e-8,
      0.707443,
      0.220914,
      0.570253,
      0.129412,
      0.749504,
      0.293268,
      0.67897,
      0.254902,
      0.781587,
      0.370517,
      0.779269,
      0.380392,
      0.809951,
      0.451099,
      0.855831,
      0.505882,
      0.84424,
      0.531462,
      0.900451,
      0.631373,
      0.865174,
      0.620901,
      0.91606,
      0.756863,
      0.875041,
      0.714054,
      0.910284,
      0.882353,
      0.880764,
      0.80554,
      0.896276,
      1,
      0.887572,
      0.887591,
      0.887556
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple2pink_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.117562,
      0.0291202,
      0.175876,
      -0.74902,
      0.178368,
      0.0458476,
      0.285454,
      -0.623529,
      0.237731,
      0.0680173,
      0.387717,
      -0.498039,
      0.300877,
      0.0956291,
      0.484802,
      -0.372549,
      0.370929,
      0.136858,
      0.554985,
      -0.247059,
      0.449033,
      0.189273,
      0.58863,
      -0.121569,
      0.529971,
      0.245796,
      0.598587,
      392157e-8,
      0.609914,
      0.300643,
      0.610244,
      0.129412,
      0.697079,
      0.351286,
      0.616371,
      0.254902,
      0.785858,
      0.401991,
      0.617376,
      0.380392,
      0.862517,
      0.45745,
      0.64463,
      0.505882,
      0.91359,
      0.525462,
      0.705336,
      0.631373,
      0.932583,
      0.61064,
      0.767412,
      0.756863,
      0.922478,
      0.706966,
      0.817522,
      0.882353,
      0.901302,
      0.803071,
      0.856311,
      1,
      0.887571,
      0.887591,
      0.887549
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_pbj_lin",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.091821,
      0.0611476,
      0.10617,
      -0.74902,
      0.160311,
      0.0900022,
      0.192713,
      -0.623529,
      0.22484,
      0.12126,
      0.272128,
      -0.498039,
      0.291263,
      0.157469,
      0.340828,
      -0.372549,
      0.360015,
      0.200388,
      0.388903,
      -0.247059,
      0.437497,
      0.250058,
      0.387201,
      -0.121569,
      0.512636,
      0.304969,
      0.355955,
      392157e-8,
      0.582603,
      0.360874,
      0.33488,
      0.129412,
      0.655126,
      0.416374,
      0.306351,
      0.254902,
      0.725889,
      0.473329,
      0.279051,
      0.380392,
      0.778125,
      0.537928,
      0.302697,
      0.505882,
      0.815894,
      0.606931,
      0.382431,
      0.631373,
      0.839159,
      0.679308,
      0.497608,
      0.756863,
      0.854748,
      0.751666,
      0.631792,
      0.882353,
      0.869483,
      0.822508,
      0.768592,
      1,
      0.887572,
      0.887589,
      0.887565
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2green_muted",
    RGBPoints: [
      -1,
      0.107704,
      0.107708,
      0.107695,
      -0.87451,
      0.141522,
      0.13066,
      0.270741,
      -0.74902,
      0.180123,
      0.146119,
      0.42308,
      -0.623529,
      0.210161,
      0.169674,
      0.551795,
      -0.498039,
      0.239701,
      0.212939,
      0.634969,
      -0.372549,
      0.253916,
      0.282947,
      0.653641,
      -0.247059,
      0.242791,
      0.366933,
      0.608521,
      -0.121569,
      0.226302,
      0.446776,
      0.52693,
      392157e-8,
      0.236237,
      0.514689,
      0.458798,
      0.129412,
      0.274641,
      0.577589,
      0.376069,
      0.254902,
      0.349625,
      0.633993,
      0.288131,
      0.380392,
      0.4437,
      0.683677,
      0.260497,
      0.505882,
      0.536247,
      0.731214,
      0.285424,
      0.631373,
      0.628472,
      0.777128,
      0.349151,
      0.756863,
      0.718259,
      0.819287,
      0.496825,
      0.882353,
      0.804768,
      0.856164,
      0.703299,
      1,
      0.887571,
      0.887591,
      0.887548
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2green_BW",
    RGBPoints: [
      -1,
      363578e-12,
      0,
      529374e-11,
      -0.87451,
      0.0539915,
      0.0577948,
      0.212806,
      -0.74902,
      0.0620393,
      0.0758942,
      0.388959,
      -0.623529,
      0.0697499,
      0.102032,
      0.54177,
      -0.498039,
      0.113295,
      0.156156,
      0.64334,
      -0.372549,
      0.152047,
      0.243196,
      0.670283,
      -0.247059,
      0.158096,
      0.344084,
      0.622864,
      -0.121569,
      0.151142,
      0.43922,
      0.532767,
      392157e-8,
      0.17155,
      0.521588,
      0.457719,
      0.129412,
      0.225861,
      0.599141,
      0.363997,
      0.254902,
      0.32328,
      0.67007,
      0.259083,
      0.380392,
      0.442344,
      0.733697,
      0.223754,
      0.505882,
      0.558409,
      0.794941,
      0.257411,
      0.631373,
      0.673875,
      0.854344,
      0.340822,
      0.756863,
      0.787244,
      0.909326,
      0.524717,
      0.882353,
      0.896483,
      0.958063,
      0.775914,
      1,
      1,
      1,
      0.999982
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GREEN-WHITE_LINEAR",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0.062745,
      0,
      -0.74902,
      0,
      0.12549,
      0,
      -0.623529,
      0,
      0.188235,
      0,
      -0.498039,
      0,
      0.25098,
      0,
      -0.372549,
      0,
      0.313725,
      0,
      -0.247059,
      0,
      0.376471,
      0,
      -0.121569,
      0.094118,
      0.439216,
      0,
      392157e-8,
      0.196078,
      0.501961,
      0,
      0.129412,
      0.294118,
      0.564706,
      0,
      0.254902,
      0.396078,
      0.627451,
      0,
      0.380392,
      0.498039,
      0.690196,
      0,
      0.505882,
      0.6,
      0.752941,
      0.145098,
      0.631373,
      0.701961,
      0.815686,
      0.364706,
      0.756863,
      0.8,
      0.878431,
      0.580392,
      0.882353,
      0.901961,
      0.941176,
      0.796078,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_green2yellow_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0.105542,
      0.0603919,
      -0.74902,
      0,
      0.159454,
      0.104148,
      -0.623529,
      0,
      0.219502,
      0.15542,
      -0.498039,
      0,
      0.282276,
      0.203811,
      -0.372549,
      0,
      0.346331,
      0.235652,
      -0.247059,
      0,
      0.411765,
      0.235428,
      -0.121569,
      0,
      0.477177,
      0.217977,
      392157e-8,
      0.0593644,
      0.541635,
      0.21361,
      0.129412,
      0.233081,
      0.604722,
      0.210591,
      0.254902,
      0.369803,
      0.664942,
      0.226536,
      0.380392,
      0.498446,
      0.722367,
      0.288237,
      0.505882,
      0.601929,
      0.782244,
      0.380815,
      0.631373,
      0.703207,
      0.840497,
      0.512134,
      0.756863,
      0.803186,
      0.896433,
      0.674462,
      0.882353,
      0.903834,
      0.950266,
      0.846715,
      1,
      1,
      1,
      0.999981
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "blue2cyan",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0.152941,
      0.364706,
      -0.74902,
      0,
      0.254902,
      0.470588,
      -0.623529,
      0,
      0.34902,
      0.572549,
      -0.498039,
      0,
      0.443137,
      0.670588,
      -0.372549,
      0,
      0.537255,
      0.772549,
      -0.247059,
      0,
      0.627451,
      0.870588,
      -0.121569,
      0,
      0.717647,
      0.964706,
      392157e-8,
      0.0784314,
      0.772549,
      1,
      0.129412,
      0.207843,
      0.858824,
      1,
      0.254902,
      0.32549,
      0.941176,
      1,
      0.380392,
      0.45098,
      1,
      1,
      0.505882,
      0.560784,
      1,
      1,
      0.631373,
      0.662745,
      1,
      1,
      0.756863,
      0.760784,
      1,
      1,
      0.882353,
      0.870588,
      1,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2cyan_BW",
    RGBPoints: [
      -1,
      405298e-12,
      0,
      59012e-10,
      -0.87451,
      0.0207526,
      0.0740933,
      0.18093,
      -0.74902,
      0,
      0.121033,
      0.30343,
      -0.623529,
      0,
      0.166892,
      0.416095,
      -0.498039,
      0,
      0.216768,
      0.524796,
      -0.372549,
      0.0164769,
      0.275471,
      0.608585,
      -0.247059,
      0.0544527,
      0.344824,
      0.659267,
      -0.121569,
      0.0880643,
      0.419118,
      0.688675,
      392157e-8,
      0.127938,
      0.492556,
      0.720256,
      0.129412,
      0.149476,
      0.566946,
      0.756918,
      0.254902,
      0.188961,
      0.641333,
      0.792122,
      0.380392,
      0.245482,
      0.715336,
      0.827609,
      0.505882,
      0.329216,
      0.786235,
      0.874761,
      0.631373,
      0.453558,
      0.852803,
      0.918466,
      0.756863,
      0.626281,
      0.910493,
      0.954,
      0.882353,
      0.82257,
      0.958709,
      0.980146,
      1,
      1,
      1,
      0.999989
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0425591,
      0.0763529,
      0.150682,
      -0.74902,
      0.0569472,
      0.119154,
      0.275403,
      -0.623529,
      0.0635978,
      0.164772,
      0.395427,
      -0.498039,
      0.0774342,
      0.213851,
      0.510014,
      -0.372549,
      0.106815,
      0.267034,
      0.615102,
      -0.247059,
      0.122093,
      0.324649,
      0.720068,
      -0.121569,
      0.160851,
      0.387068,
      0.806956,
      392157e-8,
      0.213754,
      0.453516,
      0.878012,
      0.129412,
      0.26722,
      0.524656,
      0.932436,
      0.254902,
      0.326844,
      0.599279,
      0.968038,
      0.380392,
      0.403403,
      0.674712,
      0.984784,
      0.505882,
      0.499703,
      0.745519,
      1,
      0.631373,
      0.615055,
      0.813983,
      1,
      0.756863,
      0.74405,
      0.879228,
      1,
      0.882353,
      0.877909,
      0.941913,
      1,
      1,
      1,
      1,
      0.999996
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BLUE-WHITE",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0,
      0.082353,
      -0.74902,
      0,
      0,
      0.168627,
      -0.623529,
      0,
      0,
      0.254902,
      -0.498039,
      0,
      0,
      0.337255,
      -0.372549,
      0,
      0,
      0.423529,
      -0.247059,
      0,
      0,
      0.509804,
      -0.121569,
      0,
      0.101961,
      0.592157,
      392157e-8,
      0,
      0.203922,
      0.678431,
      0.129412,
      0,
      0.301961,
      0.764706,
      0.254902,
      0,
      0.403922,
      0.85098,
      0.380392,
      0,
      0.505882,
      0.933333,
      0.505882,
      0,
      0.603922,
      1,
      0.631373,
      0.254902,
      0.705882,
      1,
      0.756863,
      0.509804,
      0.807843,
      1,
      0.882353,
      0.764706,
      0.905882,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple_BW",
    RGBPoints: [
      -1,
      4264e-11,
      0,
      620844e-12,
      -0.87451,
      0.100579,
      0.0593111,
      0.145666,
      -0.74902,
      0.167794,
      0.0889224,
      0.254953,
      -0.623529,
      0.231446,
      0.123339,
      0.360511,
      -0.498039,
      0.296699,
      0.163027,
      0.461278,
      -0.372549,
      0.363211,
      0.209286,
      0.55306,
      -0.247059,
      0.431136,
      0.260776,
      0.637195,
      -0.121569,
      0.498202,
      0.320012,
      0.705799,
      392157e-8,
      0.567456,
      0.380459,
      0.778091,
      0.129412,
      0.629381,
      0.445284,
      0.8448,
      0.254902,
      0.688373,
      0.517374,
      0.895694,
      0.380392,
      0.74891,
      0.590906,
      0.93976,
      0.505882,
      0.805017,
      0.667956,
      0.977626,
      0.631373,
      0.850914,
      0.752618,
      0.992396,
      0.756863,
      0.89724,
      0.838454,
      0.994093,
      0.882353,
      0.948461,
      0.922603,
      0.994449,
      1,
      1,
      1,
      0.999967
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_magenta_BW",
    RGBPoints: [
      -1,
      0,
      0,
      254023e-10,
      -0.87451,
      0.128696,
      0.0456782,
      0.11635,
      -0.74902,
      0.228133,
      0.0476299,
      0.201452,
      -0.623529,
      0.327273,
      0.0374065,
      0.282107,
      -0.498039,
      0.420953,
      0.0408166,
      0.35709,
      -0.372549,
      0.511562,
      0.0642203,
      0.430511,
      -0.247059,
      0.599552,
      0.102686,
      0.504257,
      -0.121569,
      0.684646,
      0.150536,
      0.579429,
      392157e-8,
      0.765817,
      0.205978,
      0.656062,
      0.129412,
      0.839176,
      0.27229,
      0.731807,
      0.254902,
      0.89536,
      0.357594,
      0.797309,
      0.380392,
      0.930238,
      0.457825,
      0.846984,
      0.505882,
      0.945921,
      0.564536,
      0.880571,
      0.631373,
      0.948995,
      0.670753,
      0.902279,
      0.756863,
      0.947124,
      0.772819,
      0.918171,
      0.882353,
      0.947265,
      0.869424,
      0.934352,
      1,
      0.954719,
      0.95475,
      0.954726
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "magenta",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.364706,
      0,
      0.152941,
      -0.74902,
      0.470588,
      0,
      0.254902,
      -0.623529,
      0.572549,
      0,
      0.34902,
      -0.498039,
      0.670588,
      0,
      0.443137,
      -0.372549,
      0.772549,
      0,
      0.537255,
      -0.247059,
      0.870588,
      0,
      0.627451,
      -0.121569,
      0.964706,
      0,
      0.717647,
      392157e-8,
      1,
      0.0784314,
      0.772549,
      0.129412,
      1,
      0.207843,
      0.858824,
      0.254902,
      1,
      0.32549,
      0.941176,
      0.380392,
      1,
      0.45098,
      1,
      0.505882,
      1,
      0.560784,
      1,
      0.631373,
      1,
      0.662745,
      1,
      0.756863,
      1,
      0.760784,
      1,
      0.882353,
      1,
      0.870588,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RED-PURPLE",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.188235,
      0,
      7843e-6,
      -0.74902,
      0.345098,
      0,
      0.035294,
      -0.623529,
      0.439216,
      0,
      0.098039,
      -0.498039,
      0.533333,
      0,
      0.152941,
      -0.372549,
      0.627451,
      0.015686,
      0.211765,
      -0.247059,
      0.721569,
      0.031373,
      0.266667,
      -0.121569,
      0.8,
      0.047059,
      0.329412,
      392157e-8,
      0.862745,
      0.047059,
      0.403922,
      0.129412,
      0.941176,
      0.062745,
      0.466667,
      0.254902,
      0.988235,
      0.078431,
      0.54902,
      0.380392,
      0.988235,
      0.141176,
      0.643137,
      0.505882,
      0.988235,
      0.25098,
      0.729412,
      0.631373,
      0.988235,
      0.376471,
      0.811765,
      0.756863,
      0.988235,
      0.54902,
      0.886275,
      0.882353,
      0.988235,
      0.752941,
      0.952941,
      1,
      0.996078,
      0.996078,
      0.996078
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_red_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.147204,
      0.0480135,
      0.0401815,
      -0.74902,
      0.253411,
      0.0617478,
      0.0301333,
      -0.623529,
      0.356059,
      0.0746331,
      0.0446897,
      -0.498039,
      0.457731,
      0.0934935,
      0.0636931,
      -0.372549,
      0.557199,
      0.122714,
      0.0860013,
      -0.247059,
      0.665179,
      0.144238,
      0.105585,
      -0.121569,
      0.763833,
      0.187056,
      0.138326,
      392157e-8,
      0.847035,
      0.254558,
      0.189407,
      0.129412,
      0.905663,
      0.345937,
      0.258215,
      0.254902,
      0.941431,
      0.447111,
      0.346277,
      0.380392,
      0.962608,
      0.546927,
      0.457571,
      0.505882,
      0.987833,
      0.637276,
      0.569944,
      0.631373,
      0.994202,
      0.732176,
      0.687958,
      0.756863,
      0.993304,
      0.826268,
      0.800567,
      0.882353,
      0.994413,
      0.917205,
      0.906393,
      1,
      1,
      1,
      0.999979
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RED_TEMPERATURE",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.090196,
      0,
      0,
      -0.74902,
      0.180392,
      0,
      0,
      -0.623529,
      0.270588,
      0,
      0,
      -0.498039,
      0.360784,
      0,
      0,
      -0.372549,
      0.45098,
      0,
      0,
      -0.247059,
      0.545098,
      0,
      0,
      -0.121569,
      0.635294,
      0,
      0,
      392157e-8,
      0.72549,
      0.058824,
      0,
      0.129412,
      0.815686,
      0.176471,
      0,
      0.254902,
      0.905882,
      0.294118,
      0,
      0.380392,
      1,
      0.411765,
      0,
      0.505882,
      1,
      0.533333,
      0.027451,
      0.631373,
      1,
      0.65098,
      0.27451,
      0.756863,
      1,
      0.768627,
      0.521569,
      0.882353,
      1,
      0.886275,
      0.768627,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_orange_BW",
    RGBPoints: [
      -1,
      0,
      0,
      253806e-10,
      -0.87451,
      0.135871,
      0.0593824,
      0,
      -0.74902,
      0.224328,
      0.0907216,
      0,
      -0.623529,
      0.318083,
      0.119647,
      0,
      -0.498039,
      0.414443,
      0.150246,
      0,
      -0.372549,
      0.511077,
      0.184884,
      0,
      -0.247059,
      0.605501,
      0.226033,
      0,
      -0.121569,
      0.695274,
      0.275491,
      0,
      392157e-8,
      0.777826,
      0.334445,
      0,
      0.129412,
      0.851498,
      0.402441,
      0,
      0.254902,
      0.915899,
      0.47759,
      602975e-9,
      0.380392,
      0.971984,
      0.557882,
      0.0361443,
      0.505882,
      1,
      0.641287,
      0.135967,
      0.631373,
      1,
      0.725198,
      0.27997,
      0.756863,
      1,
      0.808205,
      0.438135,
      0.882353,
      1,
      0.89306,
      0.587036,
      1,
      1,
      0.977928,
      0.721599
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "heated_object",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.34902,
      0.0862745,
      0,
      -0.74902,
      0.45098,
      0.172549,
      0,
      -0.623529,
      0.52549,
      0.231373,
      0,
      -0.498039,
      0.580392,
      0.278431,
      0,
      -0.372549,
      0.623529,
      0.313725,
      0,
      -0.247059,
      0.670588,
      0.352941,
      0,
      -0.121569,
      0.717647,
      0.392157,
      0,
      392157e-8,
      0.772549,
      0.439216,
      0,
      0.129412,
      0.839216,
      0.494118,
      0,
      0.254902,
      0.901961,
      0.541176,
      0,
      0.380392,
      0.968627,
      0.6,
      0,
      0.505882,
      1,
      0.658824,
      0,
      0.631373,
      1,
      0.721569,
      0,
      0.756863,
      1,
      0.827451,
      0.298039,
      0.882353,
      1,
      0.976471,
      0.72549,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_gold_BW",
    RGBPoints: [
      -1,
      0,
      0,
      190933e-10,
      -0.87451,
      0.128363,
      0.0636265,
      0,
      -0.74902,
      0.193795,
      0.111057,
      0,
      -0.623529,
      0.25976,
      0.15987,
      0,
      -0.498039,
      0.328546,
      0.210589,
      0,
      -0.372549,
      0.399726,
      0.26332,
      0,
      -0.247059,
      0.472969,
      0.318261,
      0,
      -0.121569,
      0.546245,
      0.375827,
      0,
      392157e-8,
      0.61745,
      0.436719,
      0,
      0.129412,
      0.685545,
      0.501113,
      0,
      0.254902,
      0.749578,
      0.568799,
      0,
      0.380392,
      0.80962,
      0.6394,
      0,
      0.505882,
      0.865572,
      0.712699,
      0.10257,
      0.631373,
      0.917709,
      0.787569,
      0.233665,
      0.756863,
      0.966914,
      0.863138,
      0.369608,
      0.882353,
      1,
      0.939405,
      0.496104,
      1,
      0.999225,
      1,
      0.612275
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_brown_BW",
    RGBPoints: [
      -1,
      33216e-11,
      0,
      483629e-11,
      -0.87451,
      0.14693,
      0.0518172,
      0,
      -0.74902,
      0.225806,
      0.0814996,
      0,
      -0.623529,
      0.301681,
      0.111452,
      0,
      -0.498039,
      0.370487,
      0.150664,
      0,
      -0.372549,
      0.43108,
      0.199477,
      0,
      -0.247059,
      0.4849,
      0.255107,
      0,
      -0.121569,
      0.536798,
      0.313486,
      0,
      392157e-8,
      0.59286,
      0.371167,
      0,
      0.129412,
      0.653119,
      0.428135,
      0,
      0.254902,
      0.714589,
      0.485917,
      0.0379541,
      0.380392,
      0.774667,
      0.54565,
      0.116634,
      0.505882,
      0.831222,
      0.608047,
      0.183895,
      0.631373,
      0.880305,
      0.674199,
      0.260298,
      0.756863,
      0.922314,
      0.742472,
      0.367086,
      0.882353,
      0.959408,
      0.811222,
      0.497258,
      1,
      0.993548,
      0.875183,
      0.622093
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "copper_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0784314,
      0.0501961,
      0.0313725,
      -0.74902,
      0.156863,
      0.100392,
      0.0627451,
      -0.623529,
      0.235294,
      0.150588,
      0.0941176,
      -0.498039,
      0.313725,
      0.200784,
      0.12549,
      -0.372549,
      0.392157,
      0.25098,
      0.156863,
      -0.247059,
      0.470588,
      0.301176,
      0.188235,
      -0.121569,
      0.54902,
      0.351373,
      0.219608,
      392157e-8,
      0.627451,
      0.401569,
      0.25098,
      0.129412,
      0.705882,
      0.451765,
      0.282353,
      0.254902,
      0.784314,
      0.501961,
      0.313725,
      0.380392,
      0.862745,
      0.552157,
      0.345098,
      0.505882,
      0.941176,
      0.602353,
      0.376471,
      0.631373,
      1,
      0.652549,
      0.407843,
      0.756863,
      1,
      0.702745,
      0.439216,
      0.882353,
      1,
      0.752941,
      0.470588,
      1,
      1,
      0.8,
      0.5
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "pink_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.312416,
      0.204524,
      0.204524,
      -0.74902,
      0.441822,
      0.289241,
      0.289241,
      -0.623529,
      0.54112,
      0.354246,
      0.354246,
      -0.498039,
      0.624831,
      0.409048,
      0.409048,
      -0.372549,
      0.698582,
      0.45733,
      0.45733,
      -0.247059,
      0.764404,
      0.502282,
      0.500979,
      -0.121569,
      0.791292,
      0.591516,
      0.54112,
      392157e-8,
      0.817297,
      0.66895,
      0.578481,
      0.129412,
      0.842499,
      0.738308,
      0.613572,
      0.254902,
      0.866968,
      0.801687,
      0.646762,
      0.380392,
      0.890766,
      0.86041,
      0.678329,
      0.505882,
      0.913944,
      0.913944,
      0.711254,
      0.631373,
      0.936549,
      0.936549,
      0.79459,
      0.756863,
      0.958621,
      0.958621,
      0.869979,
      0.882353,
      0.980196,
      0.980196,
      0.939336,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "bone_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.054902,
      0.054902,
      0.075817,
      -0.74902,
      0.109804,
      0.109804,
      0.151634,
      -0.623529,
      0.164706,
      0.164706,
      0.227451,
      -0.498039,
      0.219608,
      0.219608,
      0.303268,
      -0.372549,
      0.27451,
      0.27451,
      0.379085,
      -0.247059,
      0.329412,
      0.329902,
      0.454412,
      -0.121569,
      0.384314,
      0.405719,
      0.509314,
      392157e-8,
      0.439216,
      0.481536,
      0.564216,
      0.129412,
      0.494118,
      0.557353,
      0.619118,
      0.254902,
      0.54902,
      0.63317,
      0.67402,
      0.380392,
      0.603922,
      0.708987,
      0.728922,
      0.505882,
      0.660294,
      0.783824,
      0.783824,
      0.631373,
      0.746569,
      0.838725,
      0.838725,
      0.756863,
      0.832843,
      0.893627,
      0.893627,
      0.882353,
      0.919118,
      0.948529,
      0.948529,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "gray_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0627451,
      0.0627451,
      0.0627451,
      -0.74902,
      0.12549,
      0.12549,
      0.12549,
      -0.623529,
      0.188235,
      0.188235,
      0.188235,
      -0.498039,
      0.25098,
      0.25098,
      0.25098,
      -0.372549,
      0.313725,
      0.313725,
      0.313725,
      -0.247059,
      0.376471,
      0.376471,
      0.376471,
      -0.121569,
      0.439216,
      0.439216,
      0.439216,
      392157e-8,
      0.501961,
      0.501961,
      0.501961,
      0.129412,
      0.564706,
      0.564706,
      0.564706,
      0.254902,
      0.627451,
      0.627451,
      0.627451,
      0.380392,
      0.690196,
      0.690196,
      0.690196,
      0.505882,
      0.752941,
      0.752941,
      0.752941,
      0.631373,
      0.815686,
      0.815686,
      0.815686,
      0.756863,
      0.878431,
      0.878431,
      0.878431,
      0.882353,
      0.941176,
      0.941176,
      0.941176,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Purples",
    RGBPoints: [
      -1,
      0.247059,
      0,
      0.490196,
      -0.87451,
      0.288397,
      0.07677,
      0.525629,
      -0.74902,
      0.32975,
      0.153587,
      0.561092,
      -0.623529,
      0.373057,
      0.236263,
      0.600461,
      -0.498039,
      0.416363,
      0.319,
      0.639923,
      -0.372549,
      0.459669,
      0.405613,
      0.685198,
      -0.247059,
      0.503345,
      0.491534,
      0.730058,
      -0.121569,
      0.562399,
      0.54862,
      0.757616,
      392157e-8,
      0.621453,
      0.606075,
      0.785544,
      0.129412,
      0.680508,
      0.674971,
      0.824914,
      0.254902,
      0.739562,
      0.743406,
      0.863899,
      0.380392,
      0.798616,
      0.800492,
      0.893426,
      0.505882,
      0.85684,
      0.856655,
      0.922491,
      0.631373,
      0.898178,
      0.894056,
      0.942176,
      0.756863,
      0.938654,
      0.930919,
      0.961646,
      0.882353,
      0.964245,
      0.958478,
      0.977393,
      1,
      0.988235,
      0.984314,
      0.992157
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Blues",
    RGBPoints: [
      -1,
      0.031373,
      0.188235,
      0.419608,
      -0.87451,
      0.031373,
      0.253195,
      0.516063,
      -0.74902,
      0.031757,
      0.318139,
      0.612149,
      -0.623529,
      0.080969,
      0.38113,
      0.661361,
      -0.498039,
      0.130427,
      0.444152,
      0.710327,
      -0.372549,
      0.195386,
      0.509112,
      0.743791,
      -0.247059,
      0.260715,
      0.573841,
      0.777209,
      -0.121569,
      0.341423,
      0.628958,
      0.808704,
      392157e-8,
      0.422745,
      0.684075,
      0.839892,
      0.129412,
      0.523137,
      0.739193,
      0.861546,
      0.254902,
      0.622684,
      0.793464,
      0.883429,
      0.380392,
      0.701423,
      0.826928,
      0.910988,
      0.505882,
      0.778685,
      0.8603,
      0.937993,
      0.631373,
      0.825928,
      0.891795,
      0.953741,
      0.756863,
      0.87328,
      0.923291,
      0.969489,
      0.882353,
      0.922491,
      0.954787,
      0.985236,
      1,
      0.968627,
      0.984314,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Greens",
    RGBPoints: [
      -1,
      0,
      0.266667,
      0.105882,
      -0.87451,
      0,
      0.347374,
      0.139346,
      -0.74902,
      538e-6,
      0.427912,
      0.172933,
      -0.623529,
      0.069435,
      0.486967,
      0.222145,
      -0.498039,
      0.138178,
      0.546082,
      0.271326,
      -0.372549,
      0.197232,
      0.609073,
      0.31857,
      -0.247059,
      0.257255,
      0.671742,
      0.365859,
      -0.121569,
      0.357647,
      0.720953,
      0.415071,
      392157e-8,
      0.45767,
      0.769919,
      0.465021,
      0.129412,
      0.546251,
      0.811257,
      0.537855,
      0.254902,
      0.634295,
      0.852211,
      0.610688,
      0.380392,
      0.709097,
      0.883706,
      0.683522,
      0.505882,
      0.78316,
      0.914833,
      0.755894,
      0.631373,
      0.842215,
      0.938454,
      0.818885,
      0.756863,
      0.899977,
      0.961538,
      0.880692,
      0.882353,
      0.935409,
      0.975317,
      0.92203,
      1,
      0.968627,
      0.988235,
      0.960784
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PuBu",
    RGBPoints: [
      -1,
      0.301961,
      0,
      0.294118,
      -0.87451,
      0.404321,
      0.029527,
      0.390573,
      -0.74902,
      0.50599,
      0.059592,
      0.486782,
      -0.623529,
      0.519769,
      0.158016,
      0.551742,
      -0.498039,
      0.533456,
      0.256194,
      0.616301,
      -0.372549,
      0.54133,
      0.33887,
      0.655671,
      -0.247059,
      0.54902,
      0.421592,
      0.695087,
      -0.121569,
      0.54902,
      0.506236,
      0.736424,
      392157e-8,
      0.550127,
      0.590573,
      0.777701,
      0.129412,
      0.585559,
      0.665375,
      0.81707,
      0.254902,
      0.622145,
      0.739023,
      0.855825,
      0.380392,
      0.687105,
      0.784298,
      0.879446,
      0.505882,
      0.752065,
      0.829758,
      0.903253,
      0.631373,
      0.817024,
      0.87897,
      0.930811,
      0.756863,
      0.880907,
      0.927213,
      0.957832,
      0.882353,
      0.926182,
      0.958708,
      0.975548,
      1,
      0.968627,
      0.988235,
      0.992157
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuPu",
    RGBPoints: [
      -1,
      7843e-6,
      0.219608,
      0.345098,
      -0.87451,
      0.01178,
      0.286536,
      0.449427,
      -0.74902,
      0.015702,
      0.35328,
      0.553479,
      -0.623529,
      0.01767,
      0.396586,
      0.622376,
      -0.498039,
      0.021115,
      0.4402,
      0.690688,
      -0.372549,
      0.11757,
      0.503191,
      0.722184,
      -0.247059,
      0.214625,
      0.565859,
      0.753633,
      -0.121569,
      0.336671,
      0.615071,
      0.78316,
      392157e-8,
      0.457978,
      0.663975,
      0.812503,
      0.129412,
      0.556401,
      0.703345,
      0.836125,
      0.254902,
      0.65421,
      0.742714,
      0.859669,
      0.380392,
      0.736886,
      0.782084,
      0.881323,
      0.505882,
      0.81827,
      0.821638,
      0.903068,
      0.631373,
      0.873387,
      0.864944,
      0.92669,
      0.756863,
      0.927536,
      0.907605,
      0.949988,
      0.882353,
      0.964937,
      0.9391,
      0.967705,
      1,
      1,
      0.968627,
      0.984314
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuGn",
    RGBPoints: [
      -1,
      0.031373,
      0.25098,
      0.505882,
      -0.87451,
      0.031373,
      0.329719,
      0.590527,
      -0.74902,
      0.031911,
      0.408397,
      0.674787,
      -0.623529,
      0.100807,
      0.479262,
      0.710219,
      -0.498039,
      0.169704,
      0.550219,
      0.745744,
      -0.372549,
      0.238601,
      0.62699,
      0.787082,
      -0.247059,
      0.307958,
      0.703114,
      0.826759,
      -0.121569,
      0.39654,
      0.752326,
      0.797232,
      392157e-8,
      0.485121,
      0.801046,
      0.767705,
      0.129412,
      0.573702,
      0.83451,
      0.738178,
      0.254902,
      0.661592,
      0.867743,
      0.711034,
      0.380392,
      0.732457,
      0.895302,
      0.74253,
      0.505882,
      0.801845,
      0.922307,
      0.774579,
      0.631373,
      0.841215,
      0.938055,
      0.817885,
      0.756863,
      0.880907,
      0.95391,
      0.861084,
      0.882353,
      0.926182,
      0.971626,
      0.902422,
      1,
      0.968627,
      0.988235,
      0.941176
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnBu",
    RGBPoints: [
      -1,
      0,
      0.266667,
      0.105882,
      -0.87451,
      0,
      0.347374,
      0.139346,
      -0.74902,
      538e-6,
      0.427912,
      0.172933,
      -0.623529,
      0.069435,
      0.486967,
      0.222145,
      -0.498039,
      0.138178,
      0.546175,
      0.272095,
      -0.372549,
      0.197232,
      0.615071,
      0.368551,
      -0.247059,
      0.256609,
      0.683276,
      0.464867,
      -0.121569,
      0.329443,
      0.722645,
      0.555417,
      392157e-8,
      0.403137,
      0.762138,
      0.645413,
      0.129412,
      0.503529,
      0.805444,
      0.718247,
      0.254902,
      0.603922,
      0.848597,
      0.790465,
      0.380392,
      0.704314,
      0.887966,
      0.847551,
      0.505882,
      0.802307,
      0.926321,
      0.903714,
      0.631373,
      0.851519,
      0.944037,
      0.941115,
      0.756863,
      0.899977,
      0.961538,
      0.976901,
      0.882353,
      0.935409,
      0.975317,
      0.984775,
      1,
      0.968627,
      0.988235,
      0.992157
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnBuPu",
    RGBPoints: [
      -1,
      3922e-6,
      0.27451,
      0.211765,
      -0.87451,
      3922e-6,
      0.349312,
      0.280661,
      -0.74902,
      3937e-6,
      0.423852,
      0.349773,
      -0.623529,
      5905e-6,
      0.46519,
      0.446228,
      -0.498039,
      9443e-6,
      0.506344,
      0.542837,
      -0.372549,
      0.111803,
      0.535871,
      0.649135,
      -0.247059,
      0.214025,
      0.565859,
      0.753633,
      -0.121569,
      0.310481,
      0.615071,
      0.78316,
      392157e-8,
      0.407797,
      0.663975,
      0.812503,
      0.129412,
      0.531811,
      0.703345,
      0.836125,
      0.254902,
      0.65421,
      0.742714,
      0.859669,
      0.380392,
      0.736886,
      0.782084,
      0.881323,
      0.505882,
      0.81827,
      0.821176,
      0.902884,
      0.631373,
      0.873387,
      0.854641,
      0.922568,
      0.756863,
      0.927536,
      0.888535,
      0.942361,
      0.882353,
      0.964937,
      0.929873,
      0.964014,
      1,
      1,
      0.968627,
      0.984314
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuGnYl",
    RGBPoints: [
      -1,
      0.031373,
      0.113725,
      0.345098,
      -0.87451,
      0.088458,
      0.159,
      0.463206,
      -0.74902,
      0.145052,
      0.204567,
      0.5807,
      -0.623529,
      0.139146,
      0.287243,
      0.620069,
      -0.498039,
      0.13318,
      0.370196,
      0.659562,
      -0.372549,
      0.123337,
      0.470588,
      0.706805,
      -0.247059,
      0.115386,
      0.570335,
      0.753126,
      -0.121569,
      0.186251,
      0.643168,
      0.761,
      392157e-8,
      0.258716,
      0.71514,
      0.768074,
      0.129412,
      0.380761,
      0.760415,
      0.750358,
      0.254902,
      0.503576,
      0.806075,
      0.732795,
      0.380392,
      0.645306,
      0.861192,
      0.719016,
      0.505882,
      0.783899,
      0.91511,
      0.705606,
      0.631373,
      0.858701,
      0.944637,
      0.6997,
      0.756863,
      0.931349,
      0.973303,
      0.698424,
      0.882353,
      0.966782,
      0.987082,
      0.777163,
      1,
      1,
      1,
      0.85098
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PuRd",
    RGBPoints: [
      -1,
      0.286275,
      0,
      0.415686,
      -0.87451,
      0.38273,
      1968e-6,
      0.441276,
      -0.74902,
      0.479231,
      3922e-6,
      0.466774,
      -0.623529,
      0.581592,
      3922e-6,
      0.480554,
      -0.498039,
      0.683799,
      549e-5,
      0.494887,
      -0.372549,
      0.776317,
      0.105882,
      0.544098,
      -0.247059,
      0.867866,
      0.206321,
      0.592618,
      -0.121569,
      0.919047,
      0.308681,
      0.612303,
      392157e-8,
      0.968812,
      0.411226,
      0.632603,
      0.129412,
      0.974717,
      0.519493,
      0.671972,
      0.254902,
      0.980546,
      0.626451,
      0.71065,
      0.380392,
      0.984483,
      0.701253,
      0.732303,
      0.505882,
      0.988328,
      0.77504,
      0.755617,
      0.631373,
      0.990296,
      0.828189,
      0.812703,
      0.756863,
      0.992372,
      0.880907,
      0.869035,
      0.882353,
      0.996309,
      0.926182,
      0.912341,
      1,
      1,
      0.968627,
      0.952941
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RdPu",
    RGBPoints: [
      -1,
      0.403922,
      0,
      0.121569,
      -0.87451,
      0.500377,
      0,
      0.192434,
      -0.74902,
      0.596909,
      277e-6,
      0.263037,
      -0.623529,
      0.703206,
      0.035709,
      0.300438,
      -0.498039,
      0.808612,
      0.071296,
      0.338854,
      -0.372549,
      0.857824,
      0.116571,
      0.441215,
      -0.247059,
      0.905513,
      0.163552,
      0.54293,
      -0.121569,
      0.889765,
      0.281661,
      0.617732,
      392157e-8,
      0.873156,
      0.39897,
      0.691611,
      0.129412,
      0.82985,
      0.491488,
      0.736886,
      0.254902,
      0.789081,
      0.583237,
      0.781853,
      0.380392,
      0.810734,
      0.656071,
      0.819254,
      0.505882,
      0.833126,
      0.729181,
      0.85684,
      0.631373,
      0.870527,
      0.80792,
      0.898178,
      0.756863,
      0.907605,
      0.884398,
      0.938331,
      0.882353,
      0.9391,
      0.921799,
      0.958016,
      1,
      0.968627,
      0.956863,
      0.976471
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Oranges",
    RGBPoints: [
      -1,
      0.498039,
      0.152941,
      0.015686,
      -0.87451,
      0.57481,
      0.182468,
      0.013718,
      -0.74902,
      0.651765,
      0.212042,
      0.011734,
      -0.623529,
      0.752157,
      0.247474,
      7797e-6,
      -0.498039,
      0.851719,
      0.283368,
      4475e-6,
      -0.372549,
      0.898962,
      0.348328,
      0.039908,
      -0.247059,
      0.945652,
      0.413426,
      0.076401,
      -0.121569,
      0.969273,
      0.484291,
      0.157109,
      392157e-8,
      0.992157,
      0.554971,
      0.238185,
      0.129412,
      0.992157,
      0.619931,
      0.330704,
      0.254902,
      0.992157,
      0.684967,
      0.423837,
      0.380392,
      0.992157,
      0.751895,
      0.532103,
      0.505882,
      0.992249,
      0.817716,
      0.639354,
      0.631373,
      0.994218,
      0.861023,
      0.725967,
      0.756863,
      0.996186,
      0.903576,
      0.810965,
      0.882353,
      0.998155,
      0.933103,
      0.868051,
      1,
      1,
      0.960784,
      0.921569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Reds",
    RGBPoints: [
      -1,
      0.403922,
      0,
      0.05098,
      -0.87451,
      0.525967,
      0.029527,
      0.066728,
      -0.74902,
      0.647643,
      0.058962,
      0.082476,
      -0.623529,
      0.722445,
      0.076678,
      0.098224,
      -0.498039,
      0.797186,
      0.095194,
      0.114187,
      -0.372549,
      0.868051,
      0.164091,
      0.143714,
      -0.247059,
      0.937809,
      0.233541,
      0.173933,
      -0.121569,
      0.96143,
      0.326059,
      0.232987,
      392157e-8,
      0.984375,
      0.418147,
      0.292657,
      0.129412,
      0.986344,
      0.496886,
      0.371396,
      0.254902,
      0.988235,
      0.575702,
      0.450673,
      0.380392,
      0.988235,
      0.656409,
      0.543191,
      0.505882,
      0.98842,
      0.736747,
      0.635894,
      0.631373,
      0.992357,
      0.809581,
      0.732349,
      0.756863,
      0.996186,
      0.880692,
      0.826759,
      0.882353,
      0.998155,
      0.92203,
      0.885813,
      1,
      1,
      0.960784,
      0.941176
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RdOr",
    RGBPoints: [
      -1,
      0.498039,
      0,
      0,
      -0.87451,
      0.6004,
      0,
      0,
      -0.74902,
      0.702514,
      738e-6,
      477e-6,
      -0.623529,
      0.773379,
      0.095225,
      0.061499,
      -0.498039,
      0.843875,
      0.189865,
      0.12283,
      -0.372549,
      0.891119,
      0.294195,
      0.203537,
      -0.247059,
      0.937855,
      0.397924,
      0.283137,
      -0.121569,
      0.963445,
      0.476663,
      0.316601,
      392157e-8,
      0.988297,
      0.555771,
      0.351665,
      0.129412,
      0.990265,
      0.646321,
      0.436309,
      0.254902,
      0.992157,
      0.735256,
      0.519646,
      0.380392,
      0.992157,
      0.784468,
      0.570827,
      0.505882,
      0.992249,
      0.833218,
      0.623483,
      0.631373,
      0.994218,
      0.872587,
      0.706159,
      0.756863,
      0.996186,
      0.911419,
      0.788189,
      0.882353,
      0.998155,
      0.940946,
      0.859054,
      1,
      1,
      0.968627,
      0.92549
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BrOrYl",
    RGBPoints: [
      -1,
      0.4,
      0.145098,
      0.023529,
      -0.87451,
      0.500392,
      0.174625,
      0.019592,
      -0.74902,
      0.600784,
      0.204291,
      0.015656,
      -0.623529,
      0.701176,
      0.251534,
      0.011719,
      -0.498039,
      0.800984,
      0.299146,
      8397e-6,
      -0.372549,
      0.863975,
      0.370012,
      0.043829,
      -0.247059,
      0.926321,
      0.441107,
      0.0794,
      -0.121569,
      0.961753,
      0.521815,
      0.120738,
      392157e-8,
      0.996078,
      0.602645,
      0.163122,
      0.129412,
      0.996078,
      0.68729,
      0.237924,
      0.254902,
      0.996078,
      0.771011,
      0.314879,
      0.380392,
      0.996078,
      0.832034,
      0.444798,
      0.505882,
      0.996171,
      0.892042,
      0.572595,
      0.631373,
      0.998139,
      0.931411,
      0.65724,
      0.756863,
      1,
      0.969489,
      0.741669,
      0.882353,
      1,
      0.985236,
      0.822376,
      1,
      1,
      1,
      0.898039
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RdOrYl",
    RGBPoints: [
      -1,
      0.501961,
      0,
      0.14902,
      -0.87451,
      0.622038,
      0,
      0.14902,
      -0.74902,
      0.741761,
      4e-4,
      0.148866,
      -0.623529,
      0.816563,
      0.05158,
      0.129181,
      -0.498039,
      0.890965,
      0.10356,
      0.110235,
      -0.372549,
      0.940177,
      0.205921,
      0.137793,
      -0.247059,
      0.988281,
      0.308789,
      0.165536,
      -0.121569,
      0.99025,
      0.432803,
      0.200969,
      392157e-8,
      0.992218,
      0.555217,
      0.236278,
      0.129412,
      0.994187,
      0.628051,
      0.267774,
      0.254902,
      0.996078,
      0.701038,
      0.301269,
      0.380392,
      0.996078,
      0.777809,
      0.383945,
      0.505882,
      0.996171,
      0.852826,
      0.466621,
      0.631373,
      0.998139,
      0.892195,
      0.549296,
      0.756863,
      1,
      0.931349,
      0.632188,
      0.882353,
      1,
      0.966782,
      0.7188,
      1,
      1,
      1,
      0.8
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "CIELab_blue2red",
    RGBPoints: [
      -1,
      0,
      0.6,
      0.74902,
      1,
      0.76863,
      0.46667,
      0.34118
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "blue2yellow",
    RGBPoints: [
      -1,
      0,
      0,
      1,
      0,
      0.5,
      0.5,
      0.5,
      1,
      1,
      1,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2gold",
    RGBPoints: [
      -1,
      0.175119,
      0.0438468,
      1,
      -0.874016,
      0.22383,
      0.159771,
      0.94557,
      -0.748031,
      0.27254,
      0.233611,
      0.891216,
      -0.622047,
      0.321251,
      0.296526,
      0.836857,
      -0.496063,
      0.369962,
      0.354296,
      0.782359,
      -0.370079,
      0.418672,
      0.409139,
      0.72754,
      -0.244094,
      0.467383,
      0.462152,
      0.672148,
      -0.11811,
      0.51609,
      0.51396,
      0.615825,
      787402e-8,
      0.572863,
      0.55452,
      0.559172,
      0.133858,
      0.630269,
      0.593822,
      0.517729,
      0.259843,
      0.689588,
      0.624668,
      0.47446,
      0.385827,
      0.745394,
      0.656113,
      0.428638,
      0.511811,
      0.798624,
      0.688104,
      0.379105,
      0.637795,
      0.849926,
      0.720593,
      0.323834,
      0.76378,
      0.899765,
      0.753543,
      0.258657,
      0.889764,
      0.948487,
      0.78692,
      0.171778,
      1,
      0.990413,
      0.816451,
      729848e-8
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2yellow",
    RGBPoints: [
      -1,
      0.0830122,
      0,
      0.495617,
      -0.87451,
      0.141973,
      0.0551288,
      0.57363,
      -0.74902,
      0.193048,
      0.110258,
      0.604561,
      -0.623529,
      0.234231,
      0.165386,
      0.57643,
      -0.498039,
      0.275413,
      0.220515,
      0.548299,
      -0.372549,
      0.316596,
      0.275644,
      0.520169,
      -0.247059,
      0.357778,
      0.330773,
      0.492038,
      -0.121569,
      0.398961,
      0.385901,
      0.463908,
      392157e-8,
      0.449929,
      0.438487,
      0.426815,
      0.129412,
      0.511572,
      0.488299,
      0.379944,
      0.254902,
      0.581222,
      0.53603,
      0.325741,
      0.380392,
      0.650871,
      0.583761,
      0.271538,
      0.505882,
      0.720521,
      0.631493,
      0.217335,
      0.631373,
      0.79017,
      0.679224,
      0.163132,
      0.756863,
      0.85982,
      0.726955,
      0.108929,
      0.882353,
      0.910254,
      0.774159,
      0.14112,
      1,
      0.927513,
      0.81759,
      0.306289
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_cyan2orange",
    RGBPoints: [
      -1,
      0.0471513,
      0.213874,
      0.414329,
      -0.87451,
      0.0674702,
      0.256648,
      0.439027,
      -0.74902,
      0.0959957,
      0.299331,
      0.462089,
      -0.623529,
      0.132428,
      0.341872,
      0.483212,
      -0.498039,
      0.188743,
      0.38277,
      0.500597,
      -0.372549,
      0.268511,
      0.420229,
      0.512179,
      -0.247059,
      0.352945,
      0.455602,
      0.519101,
      -0.121569,
      0.43893,
      0.489368,
      0.521538,
      392157e-8,
      0.522445,
      0.522495,
      0.522436,
      0.129412,
      0.600089,
      0.555682,
      0.53205,
      0.254902,
      0.67988,
      0.587981,
      0.539163,
      0.380392,
      0.761011,
      0.619586,
      0.544439,
      0.505882,
      0.84278,
      0.650741,
      0.548567,
      0.631373,
      0.910713,
      0.687347,
      0.557822,
      0.756863,
      0.952232,
      0.734972,
      0.577775,
      0.882353,
      0.975642,
      0.789858,
      0.604868,
      1,
      0.990752,
      0.843643,
      0.632857
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple2green",
    RGBPoints: [
      -1,
      0.235006,
      0.0483128,
      0.530899,
      -0.87451,
      0.302968,
      0.108419,
      0.552391,
      -0.74902,
      0.360241,
      0.166059,
      0.569502,
      -0.623529,
      0.406746,
      0.226782,
      0.579373,
      -0.498039,
      0.444073,
      0.28964,
      0.582094,
      -0.372549,
      0.473648,
      0.353774,
      0.577947,
      -0.247059,
      0.497636,
      0.418154,
      0.567911,
      -0.121569,
      0.519086,
      0.481741,
      0.553968,
      392157e-8,
      0.542884,
      0.542914,
      0.542875,
      0.129412,
      0.566303,
      0.603989,
      0.527499,
      0.254902,
      0.595218,
      0.662965,
      0.516857,
      0.380392,
      0.628641,
      0.720701,
      0.510673,
      0.505882,
      0.665373,
      0.777849,
      0.508165,
      0.631373,
      0.704182,
      0.834921,
      0.508303,
      0.756863,
      0.743846,
      0.892328,
      0.50999,
      0.882353,
      0.783158,
      0.950422,
      0.512181,
      1,
      0.818617,
      1,
      0.513888
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple2green_dark",
    RGBPoints: [
      -1,
      0.107656,
      0,
      0.428682,
      -0.87451,
      0.1924,
      0,
      0.449799,
      -0.74902,
      0.255118,
      0.0648939,
      0.466726,
      -0.623529,
      0.304256,
      0.133066,
      0.476703,
      -0.498039,
      0.343202,
      0.19716,
      0.479793,
      -0.372549,
      0.373876,
      0.260353,
      0.476241,
      -0.247059,
      0.398497,
      0.322872,
      0.466953,
      -0.121569,
      0.420016,
      0.384252,
      0.453785,
      392157e-8,
      0.44319,
      0.443216,
      0.443186,
      0.129412,
      0.465553,
      0.502139,
      0.428233,
      0.254902,
      0.492959,
      0.559151,
      0.417591,
      0.380392,
      0.524654,
      0.615092,
      0.411016,
      0.505882,
      0.55959,
      0.670583,
      0.40779,
      0.631373,
      0.596614,
      0.726102,
      0.406948,
      0.756863,
      0.634544,
      0.782032,
      0.407439,
      0.882353,
      0.672183,
      0.838703,
      0.408237,
      1,
      0.706131,
      0.892759,
      0.408452
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "coolwarm",
    RGBPoints: [
      -1,
      0.229806,
      0.298718,
      0.753683,
      -0.875,
      0.303869,
      0.406535,
      0.844959,
      -0.75,
      0.383013,
      0.509419,
      0.917388,
      -0.625,
      0.466667,
      0.604563,
      0.968155,
      -0.5,
      0.552953,
      0.688929,
      0.995376,
      -0.375,
      0.639176,
      0.7596,
      0.998151,
      -0.25,
      0.722193,
      0.813953,
      0.976575,
      -0.125,
      0.798692,
      0.849786,
      0.931689,
      0,
      0.865395,
      0.86541,
      0.865396,
      0.125,
      0.924128,
      0.827385,
      0.774508,
      0.25,
      0.958853,
      0.769768,
      0.678008,
      0.375,
      0.969954,
      0.694267,
      0.579375,
      0.5,
      0.958003,
      0.602842,
      0.481776,
      0.625,
      0.923945,
      0.497309,
      0.38797,
      0.75,
      0.869187,
      0.378313,
      0.300267,
      0.875,
      0.795632,
      0.241284,
      0.220526,
      1,
      0.705673,
      0.0155562,
      0.150233
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuRd",
    RGBPoints: [
      -1,
      0.019608,
      0.188235,
      0.380392,
      -0.87451,
      0.088504,
      0.321107,
      0.564937,
      -0.74902,
      0.163399,
      0.444983,
      0.697501,
      -0.623529,
      0.247059,
      0.555709,
      0.754095,
      -0.498039,
      0.420684,
      0.676432,
      0.818685,
      -0.372549,
      0.606459,
      0.789773,
      0.880277,
      -0.247059,
      0.761476,
      0.868512,
      0.924567,
      -0.121569,
      0.878047,
      0.925721,
      0.951942,
      392157e-8,
      0.969089,
      0.966474,
      0.964937,
      0.129412,
      0.983852,
      0.897578,
      0.846828,
      0.254902,
      0.982468,
      0.800692,
      0.706113,
      0.380392,
      0.960323,
      0.66782,
      0.536332,
      0.505882,
      0.894579,
      0.503806,
      0.399769,
      0.631373,
      0.81707,
      0.33218,
      0.281046,
      0.756863,
      0.728489,
      0.155017,
      0.197386,
      0.882353,
      0.576932,
      0.055363,
      0.14925,
      1,
      0.403922,
      0,
      0.121569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Spectral_lowBlue",
    RGBPoints: [
      -1,
      0.368627,
      0.309804,
      0.635294,
      -0.87451,
      0.260361,
      0.450058,
      0.70173,
      -0.74902,
      0.248058,
      0.591311,
      0.717186,
      -0.623529,
      0.376009,
      0.734025,
      0.658132,
      -0.498039,
      0.537947,
      0.814764,
      0.64506,
      -0.372549,
      0.702345,
      0.879585,
      0.636678,
      -0.247059,
      0.84752,
      0.938639,
      0.607151,
      -0.121569,
      0.940408,
      0.976163,
      0.656055,
      392157e-8,
      0.999923,
      0.997616,
      0.745021,
      0.129412,
      0.997463,
      0.921338,
      0.61707,
      0.254902,
      0.995002,
      0.824606,
      0.499885,
      0.380392,
      0.992541,
      0.701576,
      0.39654,
      0.505882,
      0.973472,
      0.547405,
      0.318108,
      0.631373,
      0.937793,
      0.398539,
      0.270127,
      0.756863,
      0.861515,
      0.282891,
      0.299654,
      0.882353,
      0.746482,
      0.144637,
      0.288812,
      1,
      0.619608,
      3922e-6,
      0.258824
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnRP",
    RGBPoints: [
      -1,
      0,
      0.266667,
      0.105882,
      -0.87451,
      0.066436,
      0.394617,
      0.174779,
      -0.74902,
      0.168858,
      0.524567,
      0.25767,
      -0.623529,
      0.323875,
      0.657439,
      0.361015,
      -0.498039,
      0.504883,
      0.772318,
      0.506344,
      -0.372549,
      0.678431,
      0.870127,
      0.654902,
      -0.247059,
      0.803922,
      0.921799,
      0.780392,
      -0.121569,
      0.897116,
      0.951942,
      0.882814,
      392157e-8,
      0.967397,
      0.965936,
      0.967474,
      0.129412,
      0.928028,
      0.879815,
      0.930565,
      0.254902,
      0.866052,
      0.780777,
      0.882891,
      0.380392,
      0.77501,
      0.665129,
      0.821376,
      0.505882,
      0.675663,
      0.537024,
      0.737024,
      0.631373,
      0.57847,
      0.396155,
      0.645982,
      0.756863,
      0.492349,
      0.223914,
      0.547559,
      0.882353,
      0.375548,
      0.096886,
      0.423299,
      1,
      0.25098,
      0,
      0.294118
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GYPi",
    RGBPoints: [
      -1,
      0.152941,
      0.392157,
      0.098039,
      -0.87451,
      0.246444,
      0.505344,
      0.117724,
      -0.74902,
      0.351942,
      0.614533,
      0.161399,
      -0.623529,
      0.474971,
      0.717878,
      0.240138,
      -0.498039,
      0.611995,
      0.811226,
      0.392849,
      -0.372549,
      0.746328,
      0.893118,
      0.565321,
      -0.247059,
      0.859516,
      0.94233,
      0.747405,
      -0.121569,
      0.928105,
      0.96386,
      0.875663,
      392157e-8,
      0.969089,
      0.966859,
      0.968012,
      0.129412,
      0.983852,
      0.910265,
      0.948328,
      0.254902,
      0.979239,
      0.833218,
      0.914648,
      0.380392,
      0.949712,
      0.729873,
      0.862976,
      0.505882,
      0.905652,
      0.58293,
      0.763552,
      0.631373,
      0.85521,
      0.410073,
      0.652211,
      0.756863,
      0.793695,
      0.183699,
      0.531642,
      0.882353,
      0.683737,
      0.063899,
      0.420761,
      1,
      0.556863,
      3922e-6,
      0.321569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnYlRd",
    RGBPoints: [
      -1,
      0,
      0.407843,
      0.215686,
      -0.87451,
      0.063975,
      0.525952,
      0.277201,
      -0.74902,
      0.177932,
      0.633064,
      0.332718,
      -0.623529,
      0.364937,
      0.724106,
      0.379469,
      -0.498039,
      0.527951,
      0.797155,
      0.40223,
      -0.372549,
      0.678431,
      0.862822,
      0.433449,
      -0.247059,
      0.803922,
      0.916955,
      0.514648,
      -0.121569,
      0.909419,
      0.961861,
      0.625067,
      392157e-8,
      0.999923,
      0.997616,
      0.745021,
      0.129412,
      0.997463,
      0.921338,
      0.61707,
      0.254902,
      0.995002,
      0.824606,
      0.499885,
      0.380392,
      0.992541,
      0.701576,
      0.39654,
      0.505882,
      0.973472,
      0.547405,
      0.318108,
      0.631373,
      0.939023,
      0.389927,
      0.245521,
      0.756863,
      0.867666,
      0.239831,
      0.176624,
      0.882353,
      0.762399,
      0.110727,
      0.151326,
      1,
      0.647059,
      0,
      0.14902
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GBBr",
    RGBPoints: [
      -1,
      0,
      0.235294,
      0.188235,
      -0.87451,
      2461e-6,
      0.338639,
      0.301423,
      -0.74902,
      0.055902,
      0.448981,
      0.417609,
      -0.623529,
      0.183852,
      0.56955,
      0.538178,
      -0.498039,
      0.357785,
      0.700115,
      0.660746,
      -0.372549,
      0.540177,
      0.819531,
      0.77624,
      -0.247059,
      0.714879,
      0.890888,
      0.864821,
      -0.121569,
      0.851134,
      0.934564,
      0.922645,
      392157e-8,
      0.960861,
      0.959785,
      0.95694,
      0.129412,
      0.963322,
      0.927797,
      0.83391,
      0.254902,
      0.939946,
      0.868897,
      0.68935,
      0.380392,
      0.883353,
      0.775394,
      0.517109,
      0.505882,
      0.808074,
      0.625836,
      0.324106,
      0.631373,
      0.717647,
      0.476355,
      0.15494,
      0.756863,
      0.592157,
      0.358247,
      0.06882,
      0.882353,
      0.458593,
      0.26436,
      0.031142,
      1,
      0.329412,
      0.188235,
      0.019608
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PuOr",
    RGBPoints: [
      -1,
      0.498039,
      0.231373,
      0.031373,
      -0.87451,
      0.62599,
      0.30273,
      0.026451,
      -0.74902,
      0.746943,
      0.387082,
      0.037524,
      -0.623529,
      0.85767,
      0.490427,
      0.071972,
      -0.498039,
      0.936409,
      0.617762,
      0.236371,
      -0.372549,
      0.992695,
      0.743099,
      0.43291,
      -0.247059,
      0.995156,
      0.841523,
      0.63714,
      -0.121569,
      0.985313,
      0.913802,
      0.813687,
      392157e-8,
      0.966244,
      0.966398,
      0.967705,
      0.129412,
      0.889965,
      0.89504,
      0.938178,
      0.254902,
      0.806151,
      0.804306,
      0.894656,
      0.380392,
      0.712649,
      0.688658,
      0.833141,
      0.505882,
      0.594233,
      0.554325,
      0.744637,
      0.631373,
      0.474894,
      0.404229,
      0.652364,
      0.756863,
      0.366628,
      0.217224,
      0.563783,
      0.882353,
      0.266436,
      0.089965,
      0.434833,
      1,
      0.176471,
      0,
      0.294118
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PRGn",
    RGBPoints: [
      -1,
      0.25098,
      0,
      0.294118,
      -0.87451,
      0.383852,
      0.103345,
      0.431911,
      -0.74902,
      0.497732,
      0.234679,
      0.55371,
      -0.623529,
      0.583852,
      0.40692,
      0.652134,
      -0.498039,
      0.681968,
      0.545175,
      0.742561,
      -0.372549,
      0.7807,
      0.672357,
      0.825221,
      -0.247059,
      0.871742,
      0.788005,
      0.886736,
      -0.121569,
      0.930488,
      0.885198,
      0.932872,
      392157e-8,
      0.966321,
      0.968089,
      0.965859,
      0.129412,
      0.892503,
      0.950865,
      0.877278,
      0.254902,
      0.796078,
      0.91857,
      0.772549,
      0.380392,
      0.670588,
      0.866897,
      0.647059,
      0.505882,
      0.493195,
      0.765398,
      0.496655,
      0.631373,
      0.314187,
      0.649135,
      0.354556,
      0.756863,
      0.15917,
      0.516263,
      0.251211,
      0.882353,
      0.062284,
      0.386621,
      0.170473,
      1,
      0,
      0.266667,
      0.105882
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PiYG",
    RGBPoints: [
      -1,
      0.556863,
      3922e-6,
      0.321569,
      -0.87451,
      0.692195,
      0.067897,
      0.427374,
      -0.74902,
      0.797539,
      0.197847,
      0.539177,
      -0.623529,
      0.859054,
      0.424221,
      0.659746,
      -0.498039,
      0.908574,
      0.592618,
      0.770319,
      -0.372549,
      0.951557,
      0.736332,
      0.866205,
      -0.247059,
      0.981084,
      0.839677,
      0.917878,
      -0.121569,
      0.98293,
      0.913802,
      0.949558,
      392157e-8,
      0.96732,
      0.968474,
      0.965629,
      0.129412,
      0.92549,
      0.963552,
      0.869666,
      0.254902,
      0.852441,
      0.939254,
      0.736025,
      0.380392,
      0.739254,
      0.890042,
      0.553941,
      0.505882,
      0.60323,
      0.805536,
      0.382238,
      0.631373,
      0.467282,
      0.711419,
      0.235217,
      0.756863,
      0.344252,
      0.608074,
      0.156478,
      0.882353,
      0.2406,
      0.49827,
      0.116494,
      1,
      0.152941,
      0.392157,
      0.098039
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "OrPu",
    RGBPoints: [
      -1,
      0.176471,
      0,
      0.294118,
      -0.87451,
      0.272434,
      0.095963,
      0.444214,
      -0.74902,
      0.373395,
      0.228912,
      0.56932,
      -0.623529,
      0.481661,
      0.415917,
      0.657901,
      -0.498039,
      0.601922,
      0.562937,
      0.750481,
      -0.372549,
      0.718493,
      0.695886,
      0.836986,
      -0.247059,
      0.811995,
      0.811534,
      0.898501,
      -0.121569,
      0.894733,
      0.8995,
      0.940023,
      392157e-8,
      0.969166,
      0.966859,
      0.963629,
      0.129412,
      0.98639,
      0.910265,
      0.803691,
      0.254902,
      0.995002,
      0.835371,
      0.624375,
      0.380392,
      0.992541,
      0.736947,
      0.420146,
      0.505882,
      0.931949,
      0.609458,
      0.224221,
      0.631373,
      0.85075,
      0.483968,
      0.069819,
      0.756863,
      0.740023,
      0.380623,
      0.035371,
      0.882353,
      0.617993,
      0.29827,
      0.026759,
      1,
      0.498039,
      0.231373,
      0.031373
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BrBG",
    RGBPoints: [
      -1,
      0.329412,
      0.188235,
      0.019608,
      -0.87451,
      0.467205,
      0.269435,
      0.031911,
      -0.74902,
      0.6,
      0.365629,
      0.074202,
      -0.623529,
      0.72549,
      0.483737,
      0.160323,
      -0.498039,
      0.812995,
      0.635832,
      0.336409,
      -0.372549,
      0.88689,
      0.781238,
      0.527874,
      -0.247059,
      0.943483,
      0.87474,
      0.700115,
      -0.121569,
      0.963168,
      0.929796,
      0.841599,
      392157e-8,
      0.957247,
      0.959938,
      0.959554,
      0.129412,
      0.84406,
      0.932872,
      0.920185,
      0.254902,
      0.70396,
      0.886428,
      0.859285,
      0.380392,
      0.529258,
      0.815071,
      0.770704,
      0.505882,
      0.346251,
      0.691811,
      0.653057,
      0.631373,
      0.175855,
      0.562015,
      0.530642,
      0.756863,
      0.047905,
      0.441446,
      0.410073,
      0.882353,
      2307e-6,
      0.33218,
      0.294348,
      1,
      0,
      0.235294,
      0.188235
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GyRd",
    RGBPoints: [
      -1,
      0.101961,
      0.101961,
      0.101961,
      -0.87451,
      0.227451,
      0.227451,
      0.227451,
      -0.74902,
      0.359939,
      0.359939,
      0.359939,
      -0.623529,
      0.502653,
      0.502653,
      0.502653,
      -0.498039,
      0.631373,
      0.631373,
      0.631373,
      -0.372549,
      0.749865,
      0.749865,
      0.749865,
      -0.247059,
      0.843368,
      0.843368,
      0.843368,
      -0.121569,
      0.926105,
      0.926105,
      0.926105,
      392157e-8,
      0.999846,
      0.997232,
      0.995694,
      0.129412,
      0.994925,
      0.908651,
      0.857901,
      0.254902,
      0.982468,
      0.800692,
      0.706113,
      0.380392,
      0.960323,
      0.66782,
      0.536332,
      0.505882,
      0.894579,
      0.503806,
      0.399769,
      0.631373,
      0.81707,
      0.33218,
      0.281046,
      0.756863,
      0.728489,
      0.155017,
      0.197386,
      0.882353,
      0.576932,
      0.055363,
      0.14925,
      1,
      0.403922,
      0,
      0.121569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divHi_purpleGreen",
    RGBPoints: [
      -1,
      0.297553,
      0,
      0.489074,
      -0.87451,
      0.40259,
      0.151146,
      0.567754,
      -0.74902,
      0.516038,
      0.284843,
      0.658231,
      -0.623529,
      0.629783,
      0.423646,
      0.750938,
      -0.498039,
      0.735198,
      0.563697,
      0.835956,
      -0.372549,
      0.82408,
      0.695541,
      0.903582,
      -0.247059,
      0.889091,
      0.807454,
      0.944862,
      -0.121569,
      0.92334,
      0.886917,
      0.951839,
      392157e-8,
      0.921045,
      0.921084,
      0.921003,
      0.129412,
      0.877324,
      0.907455,
      0.845381,
      0.254902,
      0.797649,
      0.849713,
      0.734695,
      0.380392,
      0.691646,
      0.75964,
      0.600532,
      0.505882,
      0.568981,
      0.649159,
      0.453807,
      0.631373,
      0.438945,
      0.529756,
      0.304259,
      0.756863,
      0.30973,
      0.412001,
      0.158303,
      0.882353,
      0.187078,
      0.305111,
      251458e-8,
      1,
      0.101655,
      0.220836,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divHi_purpleGreen_dim",
    RGBPoints: [
      -1,
      0.404088,
      0.131038,
      0.592767,
      -0.87451,
      0.486469,
      0.230957,
      0.651243,
      -0.74902,
      0.575165,
      0.339335,
      0.717723,
      -0.623529,
      0.662741,
      0.454332,
      0.784263,
      -0.498039,
      0.742071,
      0.570213,
      0.842918,
      -0.372549,
      0.806935,
      0.678992,
      0.886227,
      -0.247059,
      0.852219,
      0.771315,
      0.90763,
      -0.121569,
      0.873345,
      0.837327,
      0.901572,
      392157e-8,
      0.866783,
      0.86682,
      0.866745,
      0.129412,
      0.82839,
      0.858225,
      0.796812,
      0.254902,
      0.762578,
      0.814287,
      0.700202,
      0.380392,
      0.676429,
      0.744229,
      0.585735,
      0.505882,
      0.577033,
      0.65732,
      0.461526,
      0.631373,
      0.47128,
      0.562476,
      0.33476,
      0.756863,
      0.365461,
      0.467957,
      0.21076,
      0.882353,
      0.264758,
      0.381138,
      0.0878313,
      1,
      0.182591,
      0.312249,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divLow_icePeach",
    RGBPoints: [
      -1,
      0.480048,
      0.817441,
      0.998056,
      -0.87451,
      0.425898,
      0.726921,
      0.883187,
      -0.74902,
      0.366682,
      0.629445,
      0.761936,
      -0.623529,
      0.308756,
      0.531002,
      0.640217,
      -0.498039,
      0.258021,
      0.43705,
      0.523433,
      -0.372549,
      0.219244,
      0.352381,
      0.416348,
      -0.247059,
      0.195127,
      0.281032,
      0.322979,
      -0.121569,
      0.186286,
      0.22627,
      0.246525,
      392157e-8,
      0.192352,
      0.19236,
      0.192364,
      0.129412,
      0.255927,
      0.214469,
      0.191756,
      0.254902,
      0.340459,
      0.254426,
      0.206666,
      0.380392,
      0.444655,
      0.309315,
      0.234029,
      0.505882,
      0.565353,
      0.376004,
      0.270969,
      0.631373,
      0.697917,
      0.450748,
      0.314293,
      0.756863,
      0.836657,
      0.529064,
      0.360227,
      0.882353,
      0.972695,
      0.614884,
      0.413123,
      1,
      1,
      0.705904,
      0.472699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divLow_purpleGreen",
    RGBPoints: [
      -1,
      0.956034,
      0.666487,
      0.952663,
      -0.87451,
      0.874457,
      0.572698,
      0.936352,
      -0.74902,
      0.753465,
      0.488253,
      0.909063,
      -0.623529,
      0.63309,
      0.413507,
      0.763833,
      -0.498039,
      0.514491,
      0.345878,
      0.620015,
      -0.372549,
      0.405008,
      0.288141,
      0.484376,
      -0.247059,
      0.311388,
      0.241986,
      0.363556,
      -0.121569,
      0.238722,
      0.209044,
      0.263449,
      392157e-8,
      0.192352,
      0.192366,
      0.192362,
      0.129412,
      0.200379,
      0.233201,
      0.168618,
      0.254902,
      0.230151,
      0.291737,
      0.165227,
      0.380392,
      0.279481,
      0.366076,
      0.178607,
      0.505882,
      0.344927,
      0.453267,
      0.205703,
      0.631373,
      0.421554,
      0.549449,
      0.242643,
      0.756863,
      0.503334,
      0.649999,
      0.284377,
      0.882353,
      0.583497,
      0.749672,
      0.324969,
      1,
      0.650705,
      0.837228,
      0.356264
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Haze_green",
    RGBPoints: [
      -1,
      1,
      0.835294,
      0.886275,
      -0.87451,
      0.937255,
      0.756863,
      0.870443,
      -0.74902,
      0.875817,
      0.666376,
      0.857807,
      -0.623529,
      0.778359,
      0.583007,
      0.808134,
      -0.498039,
      0.676253,
      0.494118,
      0.745098,
      -0.372549,
      0.561365,
      0.390123,
      0.682353,
      -0.247059,
      0.438344,
      0.262745,
      0.621496,
      -0.121569,
      0.321133,
      0.141031,
      0.558751,
      392157e-8,
      0.203922,
      0.0217865,
      0.495861,
      0.129412,
      0.265505,
      0.129412,
      0.433261,
      0.254902,
      0.311692,
      0.255338,
      0.37008,
      0.380392,
      0.356282,
      0.377342,
      0.310821,
      0.505882,
      0.39971,
      0.488889,
      0.258243,
      0.631373,
      0.442556,
      0.604357,
      0.205519,
      0.756863,
      0.48671,
      0.71968,
      0.152941,
      0.882353,
      0.529847,
      0.830356,
      0.100944,
      1,
      0.572549,
      0.933333,
      0.054902
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Haze_lime",
    RGBPoints: [
      -1,
      0.704034,
      0.784196,
      1,
      -0.87451,
      0.633111,
      0.691418,
      0.956078,
      -0.74902,
      0.564021,
      0.600606,
      0.912157,
      -0.623529,
      0.496827,
      0.51189,
      0.868235,
      -0.498039,
      0.43157,
      0.425416,
      0.824314,
      -0.372549,
      0.368248,
      0.341347,
      0.780392,
      -0.247059,
      0.306767,
      0.259855,
      0.736471,
      -0.121569,
      0.246862,
      0.181069,
      0.692549,
      392157e-8,
      0.191619,
      0.109542,
      0.648627,
      0.129412,
      0.257404,
      0.194031,
      0.604706,
      0.254902,
      0.321794,
      0.278775,
      0.560784,
      0.380392,
      0.387909,
      0.364617,
      0.516863,
      0.505882,
      0.456569,
      0.451881,
      0.472941,
      0.631373,
      0.527424,
      0.540773,
      0.42902,
      0.756863,
      0.599759,
      0.631427,
      0.385098,
      0.882353,
      0.673065,
      0.723898,
      0.341176,
      1,
      0.742751,
      0.812252,
      0.3
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Haze",
    RGBPoints: [
      -1,
      1,
      0.835294,
      0.996078,
      -392157e-8,
      0.023529,
      0.141176,
      0.498039,
      392157e-8,
      0.015686,
      0.137255,
      0.494118,
      1,
      0.984314,
      0.764706,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Haze_cyan",
    RGBPoints: [
      -1,
      0.956863,
      1,
      0.835294,
      -0.87451,
      0.933188,
      0.921714,
      0.760784,
      -0.74902,
      0.870588,
      0.803486,
      0.671605,
      -0.623529,
      0.807843,
      0.684096,
      0.583297,
      -0.498039,
      0.745098,
      0.569208,
      0.494118,
      -0.372549,
      0.682353,
      0.437763,
      0.390123,
      -0.247059,
      0.621496,
      0.288163,
      0.262745,
      -0.121569,
      0.558751,
      0.144517,
      0.141031,
      392157e-8,
      0.495861,
      0.0217865,
      0.0413943,
      0.129412,
      0.433261,
      0.137255,
      0.129412,
      0.254902,
      0.37008,
      0.263181,
      0.255338,
      0.380392,
      0.306318,
      0.381845,
      0.372694,
      0.505882,
      0.243137,
      0.503994,
      0.494263,
      0.631373,
      0.180392,
      0.629484,
      0.619753,
      0.756863,
      0.117647,
      0.754975,
      0.747131,
      0.882353,
      0.054902,
      0.876398,
      0.866812,
      1,
      0,
      0.988235,
      0.976471
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "nic_Edge",
    RGBPoints: [
      -1,
      0.191208,
      0.191208,
      0.191208,
      -0.87451,
      0.239484,
      545035e-8,
      0.614821,
      -0.74902,
      0.220593,
      0.0617459,
      0.863547,
      -0.623529,
      0.17509,
      0.278988,
      0.97794,
      -0.498039,
      0.143526,
      0.576069,
      0.998553,
      -0.372549,
      0.166456,
      0.871883,
      0.96594,
      -0.247059,
      0.376202,
      0.993555,
      0.981833,
      -0.121569,
      0.681996,
      0.991297,
      0.999239,
      392157e-8,
      0.954172,
      0.952734,
      0.94374,
      0.129412,
      0.999735,
      0.99301,
      0.662896,
      0.254902,
      0.979399,
      0.991466,
      0.357973,
      0.380392,
      0.968771,
      0.854967,
      0.162659,
      0.505882,
      0.999245,
      0.556697,
      0.144323,
      0.631373,
      0.973959,
      0.26223,
      0.177946,
      0.756863,
      0.852358,
      0.0526707,
      0.222974,
      0.882353,
      0.593889,
      912724e-8,
      0.238855,
      1,
      0.191208,
      0.191208,
      0.191208
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_iceFire_H",
    RGBPoints: [
      -1,
      405432e-12,
      0,
      590122e-11,
      -0.87451,
      0,
      0.120401,
      0.302675,
      -0.74902,
      0,
      0.216583,
      0.524574,
      -0.623529,
      0.0552475,
      0.345025,
      0.6595,
      -0.498039,
      0.128047,
      0.492588,
      0.720288,
      -0.372549,
      0.188955,
      0.641309,
      0.792092,
      -0.247059,
      0.327673,
      0.784935,
      0.873434,
      -0.121569,
      0.60824,
      0.892164,
      0.935547,
      392157e-8,
      0.881371,
      0.912178,
      0.818099,
      0.129412,
      0.951407,
      0.835621,
      0.449279,
      0.254902,
      0.904481,
      0.690489,
      0,
      0.380392,
      0.85407,
      0.510864,
      0,
      0.505882,
      0.777093,
      0.33018,
      88199e-8,
      0.631373,
      0.672862,
      0.139087,
      269398e-8,
      0.756863,
      0.508815,
      0,
      0,
      0.882353,
      0.299417,
      366289e-9,
      547829e-9,
      1,
      0.0157519,
      332021e-8,
      455569e-13
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_iceFire_L",
    RGBPoints: [
      -1,
      0.870485,
      0.913768,
      0.832905,
      -0.87451,
      0.586919,
      0.887865,
      0.934003,
      -0.74902,
      0.31583,
      0.776442,
      0.867858,
      -0.623529,
      0.18302,
      0.632034,
      0.787722,
      -0.498039,
      0.117909,
      0.484134,
      0.713825,
      -0.372549,
      0.0507239,
      0.335979,
      0.654741,
      -0.247059,
      0,
      0.209874,
      0.511832,
      -0.121569,
      0,
      0.114689,
      0.28935,
      392157e-8,
      0.0157519,
      332021e-8,
      455569e-13,
      0.129412,
      0.312914,
      0,
      0,
      0.254902,
      0.520865,
      0,
      0,
      0.380392,
      0.680105,
      0.15255,
      25996e-7,
      0.505882,
      0.785109,
      0.339479,
      797922e-9,
      0.631373,
      0.857354,
      0.522494,
      0,
      0.756863,
      0.910974,
      0.699774,
      0,
      0.882353,
      0.951921,
      0.842817,
      0.478545,
      1,
      0.881371,
      0.912178,
      0.818099
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "hsv",
    RGBPoints: [
      -1,
      1,
      0,
      0,
      -0.666666,
      1,
      0,
      1,
      -0.333333,
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      0.33333,
      0,
      1,
      0,
      0.66666,
      1,
      1,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "hue_L60",
    RGBPoints: [
      -1,
      0.964784,
      0.400592,
      0.349549,
      -0.87451,
      0.964915,
      0.372498,
      0.53785,
      -0.74902,
      0.892353,
      0.401039,
      0.759569,
      -0.623529,
      0.79263,
      0.446956,
      0.903017,
      -0.498039,
      0.682208,
      0.49954,
      0.966673,
      -0.372549,
      0.56392,
      0.553082,
      0.968836,
      -0.247059,
      0.442031,
      0.606396,
      0.901601,
      -0.121569,
      0.305499,
      0.65701,
      0.765784,
      392157e-8,
      0.197251,
      0.687914,
      0.620914,
      0.129412,
      0.193882,
      0.701887,
      0.472654,
      0.254902,
      0.249866,
      0.706123,
      0.320005,
      0.380392,
      0.35132,
      0.697417,
      0.202919,
      0.505882,
      0.498097,
      0.669467,
      0.125232,
      0.631373,
      0.637477,
      0.626239,
      0.107431,
      0.756863,
      0.762115,
      0.56872,
      0.155812,
      0.882353,
      0.889434,
      0.481116,
      0.240445,
      1,
      0.964784,
      0.400592,
      0.349549
    ]
  },
  {
    IndexedColors: [
      0,
      0,
      0,
      0.8941176470588236,
      0.1019607843137255,
      0.1098039215686274,
      0.2156862745098039,
      0.4941176470588236,
      0.7215686274509804,
      0.3019607843137255,
      0.6862745098039216,
      0.2901960784313726,
      0.596078431372549,
      0.3058823529411765,
      0.6392156862745098,
      1,
      0.4980392156862745,
      0,
      0.6509803921568628,
      0.3372549019607843,
      0.1568627450980392
    ],
    Name: "Spectrum",
    NanColor: [
      0.6509803921568628,
      0.3372549019607843,
      0.1568627450980392
    ]
  },
  {
    IndexedColors: [
      0.4745098039215686,
      0.09019607843137255,
      0.09019607843137255,
      0.7098039215686275,
      0.00392156862745098,
      0.00392156862745098,
      0.9372549019607843,
      0.2784313725490196,
      0.09803921568627451,
      0.9764705882352941,
      0.5137254901960784,
      0.1411764705882353,
      1,
      0.7058823529411765,
      0,
      1,
      0.8980392156862745,
      0.02352941176470588
    ],
    Name: "Warm",
    NanColor: [
      1,
      0.8980392156862745,
      0.02352941176470588
    ]
  },
  {
    IndexedColors: [
      0.4588235294117647,
      0.6941176470588235,
      0.00392156862745098,
      0.3450980392156863,
      0.5019607843137255,
      0.1607843137254902,
      0.3137254901960784,
      0.8431372549019608,
      0.7490196078431373,
      0.1098039215686274,
      0.5843137254901961,
      0.803921568627451,
      0.2313725490196079,
      0.407843137254902,
      0.6705882352941176,
      0.6039215686274509,
      0.407843137254902,
      1,
      0.3725490196078431,
      0.2,
      0.5019607843137255
    ],
    Name: "Cool",
    NanColor: [
      0.3725490196078431,
      0.2,
      0.5019607843137255
    ]
  },
  {
    IndexedColors: [
      0.2313725490196079,
      0.407843137254902,
      0.6705882352941176,
      0.1098039215686274,
      0.5843137254901961,
      0.803921568627451,
      0.3058823529411765,
      0.8509803921568627,
      0.9176470588235294,
      0.4509803921568628,
      0.6039215686274509,
      0.8352941176470589,
      0.2588235294117647,
      0.2392156862745098,
      0.6627450980392157,
      0.3137254901960784,
      0.3294117647058823,
      0.5294117647058824,
      0.06274509803921569,
      0.1647058823529412,
      0.3215686274509804
    ],
    Name: "Blues",
    NanColor: [
      0.06274509803921569,
      0.1647058823529412,
      0.3215686274509804
    ]
  },
  {
    IndexedColors: [
      0.1098039215686274,
      0.5843137254901961,
      0.803921568627451,
      0.2313725490196079,
      0.407843137254902,
      0.6705882352941176,
      0.4,
      0.2431372549019608,
      0.7176470588235294,
      0.6352941176470588,
      0.3294117647058823,
      0.8117647058823529,
      0.8705882352941177,
      0.3803921568627451,
      0.807843137254902,
      0.8627450980392157,
      0.3803921568627451,
      0.5843137254901961,
      0.2392156862745098,
      0.06274509803921569,
      0.3215686274509804
    ],
    Name: "Wild Flower",
    NanColor: [
      0.2392156862745098,
      0.06274509803921569,
      0.3215686274509804
    ]
  },
  {
    IndexedColors: [
      0.396078431372549,
      0.4862745098039216,
      0.2156862745098039,
      0.4588235294117647,
      0.6941176470588235,
      0.00392156862745098,
      0.6980392156862745,
      0.7294117647058823,
      0.1882352941176471,
      1,
      0.8980392156862745,
      0.02352941176470588,
      1,
      0.7058823529411765,
      0,
      0.9764705882352941,
      0.5137254901960784,
      0.1411764705882353
    ],
    Name: "Citrus",
    NanColor: [
      0.9764705882352941,
      0.5137254901960784,
      0.1411764705882353
    ]
  },
  {
    IndexedColors: [
      0.4980392156862745,
      0.2313725490196079,
      0.03137254901960784,
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333,
      0.1764705882352941,
      0,
      0.2941176470588235
    ],
    Name: "Brewer Diverging Purple-Orange (11)",
    NanColor: [
      0.1764705882352941,
      0,
      0.2941176470588235
    ]
  },
  {
    IndexedColors: [
      0.4980392156862745,
      0.2313725490196079,
      0.03137254901960784,
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333,
      0.1764705882352941,
      0,
      0.2941176470588235
    ],
    Name: "Brewer Diverging Purple-Orange (10)",
    NanColor: [
      0.1764705882352941,
      0,
      0.2941176470588235
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (9)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (8)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.9450980392156862,
      0.6392156862745098,
      0.2509803921568627,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6,
      0.5568627450980392,
      0.7647058823529411,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (7)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.9450980392156862,
      0.6392156862745098,
      0.2509803921568627,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6,
      0.5568627450980392,
      0.7647058823529411,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (6)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.9019607843137255,
      0.3803921568627451,
      0.00392156862745098,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ],
    Name: "Brewer Diverging Purple-Orange (5)",
    NanColor: [
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.9019607843137255,
      0.3803921568627451,
      0.00392156862745098,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ],
    Name: "Brewer Diverging Purple-Orange (4)",
    NanColor: [
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.9450980392156862,
      0.6392156862745098,
      0.2509803921568627,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.6,
      0.5568627450980392,
      0.7647058823529411
    ],
    Name: "Brewer Diverging Purple-Orange (3)",
    NanColor: [
      0.6,
      0.5568627450980392,
      0.7647058823529411
    ]
  },
  {
    IndexedColors: [
      0.6196078431372549,
      0.00392156862745098,
      0.2588235294117647,
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      1,
      1,
      0.7490196078431373,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353,
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ],
    Name: "Brewer Diverging Spectral (11)",
    NanColor: [
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ]
  },
  {
    IndexedColors: [
      0.6196078431372549,
      0.00392156862745098,
      0.2588235294117647,
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353,
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ],
    Name: "Brewer Diverging Spectral (10)",
    NanColor: [
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      1,
      1,
      0.7490196078431373,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (9)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (8)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9882352941176471,
      0.5529411764705883,
      0.3490196078431372,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      1,
      1,
      0.7490196078431373,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6,
      0.8352941176470589,
      0.5803921568627451,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (7)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9882352941176471,
      0.5529411764705883,
      0.3490196078431372,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6,
      0.8352941176470589,
      0.5803921568627451,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (6)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8431372549019608,
      0.09803921568627451,
      0.1098039215686274,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      1,
      1,
      0.7490196078431373,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ],
    Name: "Brewer Diverging Spectral (5)",
    NanColor: [
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ]
  },
  {
    IndexedColors: [
      0.8431372549019608,
      0.09803921568627451,
      0.1098039215686274,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ],
    Name: "Brewer Diverging Spectral (4)",
    NanColor: [
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ]
  },
  {
    IndexedColors: [
      0.9882352941176471,
      0.5529411764705883,
      0.3490196078431372,
      1,
      1,
      0.7490196078431373,
      0.6,
      0.8352941176470589,
      0.5803921568627451
    ],
    Name: "Brewer Diverging Spectral (3)",
    NanColor: [
      0.6,
      0.8352941176470589,
      0.5803921568627451
    ]
  },
  {
    IndexedColors: [
      0.3294117647058823,
      0.1882352941176471,
      0.0196078431372549,
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922,
      0,
      0.2352941176470588,
      0.1882352941176471
    ],
    Name: "Brewer Diverging Brown-Blue-Green (11)",
    NanColor: [
      0,
      0.2352941176470588,
      0.1882352941176471
    ]
  },
  {
    IndexedColors: [
      0.3294117647058823,
      0.1882352941176471,
      0.0196078431372549,
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922,
      0,
      0.2352941176470588,
      0.1882352941176471
    ],
    Name: "Brewer Diverging Brown-Blue-Green (10)",
    NanColor: [
      0,
      0.2352941176470588,
      0.1882352941176471
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (9)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (8)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.8470588235294118,
      0.7019607843137254,
      0.396078431372549,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (7)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.8470588235294118,
      0.7019607843137254,
      0.396078431372549,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (6)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.6509803921568628,
      0.3803921568627451,
      0.1019607843137255,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ],
    Name: "Brewer Diverging Brown-Blue-Green (5)",
    NanColor: [
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ]
  },
  {
    IndexedColors: [
      0.6509803921568628,
      0.3803921568627451,
      0.1019607843137255,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ],
    Name: "Brewer Diverging Brown-Blue-Green (4)",
    NanColor: [
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ]
  },
  {
    IndexedColors: [
      0.8470588235294118,
      0.7019607843137254,
      0.396078431372549,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687
    ],
    Name: "Brewer Diverging Brown-Blue-Green (3)",
    NanColor: [
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8980392156862745,
      0.9607843137254902,
      0.9764705882352941,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.2549019607843137,
      0.6823529411764706,
      0.4627450980392157,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176,
      0,
      0.4274509803921568,
      0.1725490196078431,
      0,
      0.2666666666666667,
      0.1058823529411765
    ],
    Name: "Brewer Sequential Blue-Green (9)",
    NanColor: [
      0,
      0.2666666666666667,
      0.1058823529411765
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8980392156862745,
      0.9607843137254902,
      0.9764705882352941,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.2549019607843137,
      0.6823529411764706,
      0.4627450980392157,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176,
      0,
      0.3450980392156863,
      0.1411764705882353
    ],
    Name: "Brewer Sequential Blue-Green (8)",
    NanColor: [
      0,
      0.3450980392156863,
      0.1411764705882353
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.2549019607843137,
      0.6823529411764706,
      0.4627450980392157,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176,
      0,
      0.3450980392156863,
      0.1411764705882353
    ],
    Name: "Brewer Sequential Blue-Green (7)",
    NanColor: [
      0,
      0.3450980392156863,
      0.1411764705882353
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431,
      0,
      0.4274509803921568,
      0.1725490196078431
    ],
    Name: "Brewer Sequential Blue-Green (6)",
    NanColor: [
      0,
      0.4274509803921568,
      0.1725490196078431
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.6980392156862745,
      0.8862745098039215,
      0.8862745098039215,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431,
      0,
      0.4274509803921568,
      0.1725490196078431
    ],
    Name: "Brewer Sequential Blue-Green (5)",
    NanColor: [
      0,
      0.4274509803921568,
      0.1725490196078431
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.6980392156862745,
      0.8862745098039215,
      0.8862745098039215,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176
    ],
    Name: "Brewer Sequential Blue-Green (4)",
    NanColor: [
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176
    ]
  },
  {
    IndexedColors: [
      0.8980392156862745,
      0.9607843137254902,
      0.9764705882352941,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431
    ],
    Name: "Brewer Sequential Blue-Green (3)",
    NanColor: [
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8980392156862745,
      1,
      0.9686274509803922,
      0.7372549019607844,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.9254901960784314,
      0.4392156862745098,
      0.0784313725490196,
      0.8,
      0.2980392156862745,
      0.00784313725490196,
      0.6,
      0.203921568627451,
      0.01568627450980392,
      0.4,
      0.1450980392156863,
      0.02352941176470588
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (9)",
    NanColor: [
      0.4,
      0.1450980392156863,
      0.02352941176470588
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8980392156862745,
      1,
      0.9686274509803922,
      0.7372549019607844,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.9254901960784314,
      0.4392156862745098,
      0.0784313725490196,
      0.8,
      0.2980392156862745,
      0.00784313725490196,
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (8)",
    NanColor: [
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.9254901960784314,
      0.4392156862745098,
      0.0784313725490196,
      0.8,
      0.2980392156862745,
      0.00784313725490196,
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (7)",
    NanColor: [
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372,
      0.6,
      0.203921568627451,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (6)",
    NanColor: [
      0.6,
      0.203921568627451,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8509803921568627,
      0.5568627450980392,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372,
      0.6,
      0.203921568627451,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (5)",
    NanColor: [
      0.6,
      0.203921568627451,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8509803921568627,
      0.5568627450980392,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.8,
      0.2980392156862745,
      0.00784313725490196
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (4)",
    NanColor: [
      0.8,
      0.2980392156862745,
      0.00784313725490196
    ]
  },
  {
    IndexedColors: [
      1,
      0.9686274509803922,
      0.7372549019607844,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (3)",
    NanColor: [
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8784313725490196,
      0.9254901960784314,
      0.9568627450980393,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5490196078431373,
      0.4196078431372549,
      0.6941176470588235,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804,
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216,
      0.3019607843137255,
      0,
      0.2941176470588235
    ],
    Name: "Brewer Sequential Blue-Purple (9)",
    NanColor: [
      0.3019607843137255,
      0,
      0.2941176470588235
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8784313725490196,
      0.9254901960784314,
      0.9568627450980393,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5490196078431373,
      0.4196078431372549,
      0.6941176470588235,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804,
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ],
    Name: "Brewer Sequential Blue-Purple (8)",
    NanColor: [
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5490196078431373,
      0.4196078431372549,
      0.6941176470588235,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804,
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ],
    Name: "Brewer Sequential Blue-Purple (7)",
    NanColor: [
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137,
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ],
    Name: "Brewer Sequential Blue-Purple (6)",
    NanColor: [
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7019607843137254,
      0.803921568627451,
      0.8901960784313725,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137,
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ],
    Name: "Brewer Sequential Blue-Purple (5)",
    NanColor: [
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7019607843137254,
      0.803921568627451,
      0.8901960784313725,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804
    ],
    Name: "Brewer Sequential Blue-Purple (4)",
    NanColor: [
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804
    ]
  },
  {
    IndexedColors: [
      0.8784313725490196,
      0.9254901960784314,
      0.9568627450980393,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137
    ],
    Name: "Brewer Sequential Blue-Purple (3)",
    NanColor: [
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137
    ]
  },
  {
    IndexedColors: [
      0.4980392156862745,
      0.788235294117647,
      0.4980392156862745,
      0.7450980392156863,
      0.6823529411764706,
      0.8313725490196079,
      0.9921568627450981,
      0.7529411764705882,
      0.5254901960784314,
      1,
      1,
      0.6,
      0.2196078431372549,
      0.4235294117647059,
      0.6901960784313725,
      0.9411764705882353,
      0.00784313725490196,
      0.4980392156862745,
      0.7490196078431373,
      0.3568627450980392,
      0.09019607843137255,
      0.4,
      0.4,
      0.4
    ],
    Name: "Brewer Qualitative Accent",
    NanColor: [
      0.4,
      0.4,
      0.4
    ]
  },
  {
    IndexedColors: [
      0.1058823529411765,
      0.6196078431372549,
      0.4666666666666667,
      0.8509803921568627,
      0.3725490196078431,
      0.00784313725490196,
      0.4588235294117647,
      0.4392156862745098,
      0.7019607843137254,
      0.9058823529411765,
      0.1607843137254902,
      0.5411764705882353,
      0.4,
      0.6509803921568628,
      0.1176470588235294,
      0.9019607843137255,
      0.6705882352941176,
      0.00784313725490196,
      0.6509803921568628,
      0.4627450980392157,
      0.1137254901960784,
      0.4,
      0.4,
      0.4
    ],
    Name: "Brewer Qualitative Dark2",
    NanColor: [
      0.4,
      0.4,
      0.4
    ]
  },
  {
    IndexedColors: [
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.9882352941176471,
      0.5529411764705883,
      0.3843137254901961,
      0.5529411764705883,
      0.6274509803921569,
      0.796078431372549,
      0.9058823529411765,
      0.5411764705882353,
      0.7647058823529411,
      0.6509803921568628,
      0.8470588235294118,
      0.3294117647058823,
      1,
      0.8509803921568627,
      0.1843137254901961,
      0.8980392156862745,
      0.7686274509803922,
      0.5803921568627451,
      0.7019607843137254,
      0.7019607843137254,
      0.7019607843137254
    ],
    Name: "Brewer Qualitative Set2",
    NanColor: [
      0.7019607843137254,
      0.7019607843137254,
      0.7019607843137254
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.8862745098039215,
      0.803921568627451,
      0.9921568627450981,
      0.803921568627451,
      0.6745098039215687,
      0.796078431372549,
      0.8352941176470589,
      0.9098039215686274,
      0.9568627450980393,
      0.792156862745098,
      0.8941176470588236,
      0.9019607843137255,
      0.9607843137254902,
      0.788235294117647,
      1,
      0.9490196078431372,
      0.6823529411764706,
      0.9450980392156862,
      0.8862745098039215,
      0.8,
      0.8,
      0.8,
      0.8
    ],
    Name: "Brewer Qualitative Pastel2",
    NanColor: [
      0.8,
      0.8,
      0.8
    ]
  },
  {
    IndexedColors: [
      0.984313725490196,
      0.7058823529411765,
      0.6823529411764706,
      0.7019607843137254,
      0.803921568627451,
      0.8901960784313725,
      0.8,
      0.9215686274509803,
      0.7725490196078432,
      0.8705882352941177,
      0.796078431372549,
      0.8941176470588236,
      0.996078431372549,
      0.8509803921568627,
      0.6509803921568628,
      1,
      1,
      0.8,
      0.8980392156862745,
      0.8470588235294118,
      0.7411764705882353,
      0.9921568627450981,
      0.8549019607843137,
      0.9254901960784314,
      0.9490196078431372,
      0.9490196078431372,
      0.9490196078431372
    ],
    Name: "Brewer Qualitative Pastel1",
    NanColor: [
      0.9490196078431372,
      0.9490196078431372,
      0.9490196078431372
    ]
  },
  {
    IndexedColors: [
      0.8941176470588236,
      0.1019607843137255,
      0.1098039215686274,
      0.2156862745098039,
      0.4941176470588236,
      0.7215686274509804,
      0.3019607843137255,
      0.6862745098039216,
      0.2901960784313726,
      0.596078431372549,
      0.3058823529411765,
      0.6392156862745098,
      1,
      0.4980392156862745,
      0,
      1,
      1,
      0.2,
      0.6509803921568628,
      0.3372549019607843,
      0.1568627450980392,
      0.9686274509803922,
      0.5058823529411764,
      0.7490196078431373,
      0.6,
      0.6,
      0.6
    ],
    Name: "Brewer Qualitative Set1",
    NanColor: [
      0.6,
      0.6,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.6509803921568628,
      0.807843137254902,
      0.8901960784313725,
      0.1215686274509804,
      0.4705882352941176,
      0.7058823529411765,
      0.6980392156862745,
      0.8745098039215686,
      0.5411764705882353,
      0.2,
      0.6274509803921569,
      0.1725490196078431,
      0.984313725490196,
      0.6039215686274509,
      0.6,
      0.8901960784313725,
      0.1019607843137255,
      0.1098039215686274,
      0.9921568627450981,
      0.7490196078431373,
      0.4352941176470588,
      1,
      0.4980392156862745,
      0,
      0.792156862745098,
      0.6980392156862745,
      0.8392156862745098,
      0.4156862745098039,
      0.2392156862745098,
      0.6039215686274509,
      1,
      1,
      0.6
    ],
    Name: "Brewer Qualitative Paired",
    NanColor: [
      1,
      1,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.5529411764705883,
      0.8274509803921568,
      0.7803921568627451,
      1,
      1,
      0.7019607843137254,
      0.7450980392156863,
      0.7294117647058823,
      0.8549019607843137,
      0.984313725490196,
      0.5019607843137255,
      0.4470588235294118,
      0.5019607843137255,
      0.6941176470588235,
      0.8274509803921568,
      0.9921568627450981,
      0.7058823529411765,
      0.3843137254901961,
      0.7019607843137254,
      0.8705882352941177,
      0.4117647058823529,
      0.9882352941176471,
      0.803921568627451,
      0.8980392156862745,
      0.8509803921568627,
      0.8509803921568627,
      0.8509803921568627,
      0.7372549019607844,
      0.5019607843137255,
      0.7411764705882353,
      0.8,
      0.9215686274509803,
      0.7725490196078432,
      1,
      0.9294117647058824,
      0.4352941176470588
    ],
    Name: "Brewer Qualitative Set3",
    NanColor: [
      1,
      0.9294117647058824,
      0.4352941176470588
    ]
  },
  {
    IndexedColors: [
      1,
      0,
      0,
      1,
      0.862745,
      0,
      0,
      0.695201,
      0
    ],
    Name: "Traffic Lights",
    NanColor: [
      0.803922,
      0,
      0.803922
    ]
  },
  {
    IndexedColors: [
      0.908659,
      0.604013,
      0.581857,
      1,
      0.862745,
      0,
      0,
      0.695201,
      0
    ],
    Name: "Traffic Lights For Deuteranopes",
    NanColor: [
      0.803922,
      0,
      0.803922
    ]
  },
  {
    IndexedColors: [
      0.4196078431372549,
      0,
      0.07058823529411765,
      0.9019607843137255,
      0.9411764705882353,
      0.0196078431372549,
      0.01568627450980392,
      0.6196078431372549,
      0.00784313725490196
    ],
    Name: "Traffic Lights For Deuteranopes 2",
    NanColor: [
      0.803922,
      0,
      0.803922
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Muted Blue-Green",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.109804,
      0.27451,
      0.301961,
      0.02,
      0.129412,
      0.309804,
      0.341176,
      0.05,
      0.14902,
      0.341176,
      0.380392,
      0.1,
      0.188235,
      0.403922,
      0.458824,
      0.15,
      0.227451,
      0.447059,
      0.521569,
      0.2,
      0.290196,
      0.494118,
      0.588235,
      0.25,
      0.368627,
      0.552941,
      0.670588,
      0.3,
      0.458824,
      0.619608,
      0.74902,
      0.35,
      0.588235,
      0.713725,
      0.85098,
      0.4,
      0.72549,
      0.815686,
      0.941176,
      0.45,
      0.831373,
      0.882353,
      0.980392,
      0.475,
      0.909804,
      0.933333,
      1,
      0.5,
      0.980392,
      0.984314,
      1,
      0.5,
      0.996078,
      1,
      0.94902,
      0.5,
      1,
      1,
      0.980392,
      0.5,
      0.980392,
      0.984314,
      1,
      0.525,
      0.972549,
      0.988235,
      0.890196,
      0.55,
      0.917647,
      0.960784,
      0.835294,
      0.6,
      0.835294,
      0.921569,
      0.772549,
      0.65,
      0.768627,
      0.901961,
      0.737255,
      0.7,
      0.670588,
      0.831373,
      0.654902,
      0.75,
      0.576471,
      0.760784,
      0.584314,
      0.8,
      0.498039,
      0.678431,
      0.521569,
      0.85,
      0.392157,
      0.560784,
      0.427451,
      0.9,
      0.294118,
      0.45098,
      0.333333,
      0.95,
      0.211765,
      0.34902,
      0.254902,
      1,
      0.152941,
      0.278431,
      0.196078
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Green-Blue Asymmetric Divergent (62Blbc)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.121569,
      0.2,
      0.145098,
      0.05,
      0.196078,
      0.301961,
      0.223529,
      0.1,
      0.258824,
      0.4,
      0.278431,
      0.2,
      0.341176,
      0.54902,
      0.341176,
      0.25,
      0.419608,
      0.619608,
      0.376471,
      0.3,
      0.545098,
      0.701961,
      0.392157,
      0.35,
      0.643137,
      0.780392,
      0.403922,
      0.4,
      0.729412,
      0.819608,
      0.45098,
      0.45,
      0.811765,
      0.870588,
      0.521569,
      0.5,
      0.898039,
      0.909804,
      0.564706,
      0.55,
      0.941176,
      0.92549,
      0.686275,
      0.6,
      0.960784,
      0.94902,
      0.776471,
      0.64,
      1,
      1,
      1,
      0.65,
      0.890196,
      0.988235,
      0.972549,
      0.7,
      0.721569,
      0.894118,
      0.901961,
      0.75,
      0.631373,
      0.823529,
      0.839216,
      0.8,
      0.517647,
      0.662745,
      0.701961,
      0.85,
      0.384314,
      0.494118,
      0.54902,
      0.9,
      0.298039,
      0.360784,
      0.45098,
      0.95,
      0.223529,
      0.25098,
      0.34902,
      0.99,
      0.156863,
      0.172549,
      0.25098,
      1,
      0.137255,
      0.137255,
      0.188235
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Asymmtrical Earth Tones (6_21b)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.141176,
      0.14902,
      0.2,
      0.05,
      0.215686,
      0.258824,
      0.321569,
      0.1,
      0.243137,
      0.368627,
      0.380392,
      0.15,
      0.27451,
      0.439216,
      0.4,
      0.2,
      0.32549,
      0.501961,
      0.384314,
      0.25,
      0.403922,
      0.6,
      0.419608,
      0.3,
      0.486275,
      0.701961,
      0.454902,
      0.35,
      0.556863,
      0.74902,
      0.494118,
      0.4,
      0.670588,
      0.8,
      0.545098,
      0.5,
      0.854902,
      0.901961,
      0.631373,
      0.55,
      0.92549,
      0.941176,
      0.694118,
      0.6,
      0.960784,
      0.94902,
      0.776471,
      0.65,
      0.988235,
      0.968627,
      0.909804,
      0.7,
      0.839216,
      0.815686,
      0.772549,
      0.75,
      0.701961,
      0.662745,
      0.615686,
      0.8,
      0.6,
      0.529412,
      0.478431,
      0.85,
      0.501961,
      0.403922,
      0.360784,
      0.9,
      0.439216,
      0.313725,
      0.290196,
      1,
      0.301961,
      0.164706,
      0.176471
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Yellow 15",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      0.988235,
      2e-3,
      1,
      1,
      0.988235,
      0.05,
      0.984314,
      0.988235,
      0.843137,
      0.1,
      0.988235,
      0.988235,
      0.741176,
      0.15,
      0.980392,
      0.968627,
      0.654902,
      0.2,
      0.980392,
      0.945098,
      0.576471,
      0.25,
      0.968627,
      0.905882,
      0.486275,
      0.3,
      0.968627,
      0.862745,
      0.388235,
      0.35,
      0.960784,
      0.803922,
      0.286275,
      0.4,
      0.94902,
      0.741176,
      0.219608,
      0.45,
      0.941176,
      0.678431,
      0.14902,
      0.5,
      0.929412,
      0.607843,
      0.094118,
      0.55,
      0.921569,
      0.545098,
      0.054902,
      0.6,
      0.909804,
      0.486275,
      0.035294,
      0.65,
      0.890196,
      0.411765,
      0.019608,
      0.7,
      0.8,
      0.305882,
      0,
      0.75,
      0.760784,
      0.239216,
      0,
      0.8,
      0.678431,
      0.180392,
      0.011765,
      0.85,
      0.6,
      0.121569,
      0.023529,
      0.9,
      0.501961,
      0.054902,
      0.031373,
      0.95,
      0.4,
      0.039216,
      0.058824,
      1,
      0.301961,
      0.047059,
      0.090196
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Magma (matplotlib)",
    NanColor: [
      0,
      1,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Nathaniel J. Smith & Stefan van der Walt",
    RGBPoints: [
      0,
      1462e-6,
      466e-6,
      0.013866,
      3922e-6,
      2258e-6,
      1295e-6,
      0.018331,
      7843e-6,
      3279e-6,
      2305e-6,
      0.023708,
      0.011765,
      4512e-6,
      349e-5,
      0.029965,
      0.015686,
      595e-5,
      4843e-6,
      0.03713,
      0.019608,
      7588e-6,
      6356e-6,
      0.044973,
      0.023529,
      9426e-6,
      8022e-6,
      0.052844,
      0.027451,
      0.011465,
      9828e-6,
      0.06075,
      0.031373,
      0.013708,
      0.011771,
      0.068667,
      0.035294,
      0.016156,
      0.01384,
      0.076603,
      0.039216,
      0.018815,
      0.016026,
      0.084584,
      0.043137,
      0.021692,
      0.01832,
      0.09261,
      0.047059,
      0.024792,
      0.020715,
      0.100676,
      0.05098,
      0.028123,
      0.023201,
      0.108787,
      0.054902,
      0.031696,
      0.025765,
      0.116965,
      0.058824,
      0.03552,
      0.028397,
      0.125209,
      0.062745,
      0.039608,
      0.03109,
      0.133515,
      0.066667,
      0.04383,
      0.03383,
      0.141886,
      0.070588,
      0.048062,
      0.036607,
      0.150327,
      0.07451,
      0.05232,
      0.039407,
      0.158841,
      0.078431,
      0.056615,
      0.04216,
      0.167446,
      0.082353,
      0.060949,
      0.044794,
      0.176129,
      0.086275,
      0.06533,
      0.047318,
      0.184892,
      0.090196,
      0.069764,
      0.049726,
      0.193735,
      0.094118,
      0.074257,
      0.052017,
      0.20266,
      0.098039,
      0.078815,
      0.054184,
      0.211667,
      0.101961,
      0.083446,
      0.056225,
      0.220755,
      0.105882,
      0.088155,
      0.058133,
      0.229922,
      0.109804,
      0.092949,
      0.059904,
      0.239164,
      0.113725,
      0.097833,
      0.061531,
      0.248477,
      0.117647,
      0.102815,
      0.06301,
      0.257854,
      0.121569,
      0.107899,
      0.064335,
      0.267289,
      0.12549,
      0.113094,
      0.065492,
      0.276784,
      0.129412,
      0.118405,
      0.066479,
      0.286321,
      0.133333,
      0.123833,
      0.067295,
      0.295879,
      0.137255,
      0.12938,
      0.067935,
      0.305443,
      0.141176,
      0.135053,
      0.068391,
      0.315,
      0.145098,
      0.140858,
      0.068654,
      0.324538,
      0.14902,
      0.146785,
      0.068738,
      0.334011,
      0.152941,
      0.152839,
      0.068637,
      0.343404,
      0.156863,
      0.159018,
      0.068354,
      0.352688,
      0.160784,
      0.165308,
      0.067911,
      0.361816,
      0.164706,
      0.171713,
      0.067305,
      0.370771,
      0.168627,
      0.178212,
      0.066576,
      0.379497,
      0.172549,
      0.184801,
      0.065732,
      0.387973,
      0.176471,
      0.19146,
      0.064818,
      0.396152,
      0.180392,
      0.198177,
      0.063862,
      0.404009,
      0.184314,
      0.204935,
      0.062907,
      0.411514,
      0.188235,
      0.211718,
      0.061992,
      0.418647,
      0.192157,
      0.218512,
      0.061158,
      0.425392,
      0.196078,
      0.225302,
      0.060445,
      0.431742,
      0.2,
      0.232077,
      0.059889,
      0.437695,
      0.203922,
      0.238826,
      0.059517,
      0.443256,
      0.207843,
      0.245543,
      0.059352,
      0.448436,
      0.211765,
      0.25222,
      0.059415,
      0.453248,
      0.215686,
      0.258857,
      0.059706,
      0.45771,
      0.219608,
      0.265447,
      0.060237,
      0.46184,
      0.223529,
      0.271994,
      0.060994,
      0.46566,
      0.227451,
      0.278493,
      0.061978,
      0.46919,
      0.231373,
      0.284951,
      0.063168,
      0.472451,
      0.235294,
      0.291366,
      0.064553,
      0.475462,
      0.239216,
      0.29774,
      0.066117,
      0.478243,
      0.243137,
      0.304081,
      0.067835,
      0.480812,
      0.247059,
      0.310382,
      0.069702,
      0.483186,
      0.25098,
      0.316654,
      0.07169,
      0.48538,
      0.254902,
      0.322899,
      0.073782,
      0.487408,
      0.258824,
      0.329114,
      0.075972,
      0.489287,
      0.262745,
      0.335308,
      0.078236,
      0.491024,
      0.266667,
      0.341482,
      0.080564,
      0.492631,
      0.270588,
      0.347636,
      0.082946,
      0.494121,
      0.27451,
      0.353773,
      0.085373,
      0.495501,
      0.278431,
      0.359898,
      0.087831,
      0.496778,
      0.282353,
      0.366012,
      0.090314,
      0.49796,
      0.286275,
      0.372116,
      0.092816,
      0.499053,
      0.290196,
      0.378211,
      0.095332,
      0.500067,
      0.294118,
      0.384299,
      0.097855,
      0.501002,
      0.298039,
      0.390384,
      0.100379,
      0.501864,
      0.301961,
      0.396467,
      0.102902,
      0.502658,
      0.305882,
      0.402548,
      0.10542,
      0.503386,
      0.309804,
      0.408629,
      0.10793,
      0.504052,
      0.313725,
      0.414709,
      0.110431,
      0.504662,
      0.317647,
      0.420791,
      0.11292,
      0.505215,
      0.321569,
      0.426877,
      0.115395,
      0.505714,
      0.32549,
      0.432967,
      0.117855,
      0.50616,
      0.329412,
      0.439062,
      0.120298,
      0.506555,
      0.333333,
      0.445163,
      0.122724,
      0.506901,
      0.337255,
      0.451271,
      0.125132,
      0.507198,
      0.341176,
      0.457386,
      0.127522,
      0.507448,
      0.345098,
      0.463508,
      0.129893,
      0.507652,
      0.34902,
      0.46964,
      0.132245,
      0.507809,
      0.352941,
      0.47578,
      0.134577,
      0.507921,
      0.356863,
      0.481929,
      0.136891,
      0.507989,
      0.360784,
      0.488088,
      0.139186,
      0.508011,
      0.364706,
      0.494258,
      0.141462,
      0.507988,
      0.368627,
      0.500438,
      0.143719,
      0.50792,
      0.372549,
      0.506629,
      0.145958,
      0.507806,
      0.376471,
      0.512831,
      0.148179,
      0.507648,
      0.380392,
      0.519045,
      0.150383,
      0.507443,
      0.384314,
      0.52527,
      0.152569,
      0.507192,
      0.388235,
      0.531507,
      0.154739,
      0.506895,
      0.392157,
      0.537755,
      0.156894,
      0.506551,
      0.396078,
      0.544015,
      0.159033,
      0.506159,
      0.4,
      0.550287,
      0.161158,
      0.505719,
      0.403922,
      0.556571,
      0.163269,
      0.50523,
      0.407843,
      0.562866,
      0.165368,
      0.504692,
      0.411765,
      0.569172,
      0.167454,
      0.504105,
      0.415686,
      0.57549,
      0.16953,
      0.503466,
      0.419608,
      0.581819,
      0.171596,
      0.502777,
      0.423529,
      0.588158,
      0.173652,
      0.502035,
      0.427451,
      0.594508,
      0.175701,
      0.501241,
      0.431373,
      0.600868,
      0.177743,
      0.500394,
      0.435294,
      0.607238,
      0.179779,
      0.499492,
      0.439216,
      0.613617,
      0.181811,
      0.498536,
      0.443137,
      0.620005,
      0.18384,
      0.497524,
      0.447059,
      0.626401,
      0.185867,
      0.496456,
      0.45098,
      0.632805,
      0.187893,
      0.495332,
      0.454902,
      0.639216,
      0.189921,
      0.49415,
      0.458824,
      0.645633,
      0.191952,
      0.49291,
      0.462745,
      0.652056,
      0.193986,
      0.491611,
      0.466667,
      0.658483,
      0.196027,
      0.490253,
      0.470588,
      0.664915,
      0.198075,
      0.488836,
      0.47451,
      0.671349,
      0.200133,
      0.487358,
      0.478431,
      0.677786,
      0.202203,
      0.485819,
      0.482353,
      0.684224,
      0.204286,
      0.484219,
      0.486275,
      0.690661,
      0.206384,
      0.482558,
      0.490196,
      0.697098,
      0.208501,
      0.480835,
      0.494118,
      0.703532,
      0.210638,
      0.479049,
      0.498039,
      0.709962,
      0.212797,
      0.477201,
      0.501961,
      0.716387,
      0.214982,
      0.47529,
      0.505882,
      0.722805,
      0.217194,
      0.473316,
      0.509804,
      0.729216,
      0.219437,
      0.471279,
      0.513725,
      0.735616,
      0.221713,
      0.46918,
      0.517647,
      0.742004,
      0.224025,
      0.467018,
      0.521569,
      0.748378,
      0.226377,
      0.464794,
      0.52549,
      0.754737,
      0.228772,
      0.462509,
      0.529412,
      0.761077,
      0.231214,
      0.460162,
      0.533333,
      0.767398,
      0.233705,
      0.457755,
      0.537255,
      0.773695,
      0.236249,
      0.455289,
      0.541176,
      0.779968,
      0.238851,
      0.452765,
      0.545098,
      0.786212,
      0.241514,
      0.450184,
      0.54902,
      0.792427,
      0.244242,
      0.447543,
      0.552941,
      0.798608,
      0.24704,
      0.444848,
      0.556863,
      0.804752,
      0.249911,
      0.442102,
      0.560784,
      0.810855,
      0.252861,
      0.439305,
      0.564706,
      0.816914,
      0.255895,
      0.436461,
      0.568627,
      0.822926,
      0.259016,
      0.433573,
      0.572549,
      0.828886,
      0.262229,
      0.430644,
      0.576471,
      0.834791,
      0.26554,
      0.427671,
      0.580392,
      0.840636,
      0.268953,
      0.424666,
      0.584314,
      0.846416,
      0.272473,
      0.421631,
      0.588235,
      0.852126,
      0.276106,
      0.418573,
      0.592157,
      0.857763,
      0.279857,
      0.415496,
      0.596078,
      0.86332,
      0.283729,
      0.412403,
      0.6,
      0.868793,
      0.287728,
      0.409303,
      0.603922,
      0.874176,
      0.291859,
      0.406205,
      0.607843,
      0.879464,
      0.296125,
      0.403118,
      0.611765,
      0.884651,
      0.30053,
      0.400047,
      0.615686,
      0.889731,
      0.305079,
      0.397002,
      0.619608,
      0.8947,
      0.309773,
      0.393995,
      0.623529,
      0.899552,
      0.314616,
      0.391037,
      0.627451,
      0.904281,
      0.31961,
      0.388137,
      0.631373,
      0.908884,
      0.324755,
      0.385308,
      0.635294,
      0.913354,
      0.330052,
      0.382563,
      0.639216,
      0.917689,
      0.3355,
      0.379915,
      0.643137,
      0.921884,
      0.341098,
      0.377376,
      0.647059,
      0.925937,
      0.346844,
      0.374959,
      0.65098,
      0.929845,
      0.352734,
      0.372677,
      0.654902,
      0.933606,
      0.358764,
      0.370541,
      0.658824,
      0.937221,
      0.364929,
      0.368567,
      0.662745,
      0.940687,
      0.371224,
      0.366762,
      0.666667,
      0.944006,
      0.377643,
      0.365136,
      0.670588,
      0.94718,
      0.384178,
      0.363701,
      0.67451,
      0.95021,
      0.39082,
      0.362468,
      0.678431,
      0.953099,
      0.397563,
      0.361438,
      0.682353,
      0.955849,
      0.4044,
      0.360619,
      0.686275,
      0.958464,
      0.411324,
      0.360014,
      0.690196,
      0.960949,
      0.418323,
      0.35963,
      0.694118,
      0.96331,
      0.42539,
      0.359469,
      0.698039,
      0.965549,
      0.432519,
      0.359529,
      0.701961,
      0.967671,
      0.439703,
      0.35981,
      0.705882,
      0.96968,
      0.446936,
      0.360311,
      0.709804,
      0.971582,
      0.45421,
      0.36103,
      0.713725,
      0.973381,
      0.46152,
      0.361965,
      0.717647,
      0.975082,
      0.468861,
      0.363111,
      0.721569,
      0.97669,
      0.476226,
      0.364466,
      0.72549,
      0.97821,
      0.483612,
      0.366025,
      0.729412,
      0.979645,
      0.491014,
      0.367783,
      0.733333,
      0.981,
      0.498428,
      0.369734,
      0.737255,
      0.982279,
      0.505851,
      0.371874,
      0.741176,
      0.983485,
      0.51328,
      0.374198,
      0.745098,
      0.984622,
      0.520713,
      0.376698,
      0.74902,
      0.985693,
      0.528148,
      0.379371,
      0.752941,
      0.9867,
      0.535582,
      0.38221,
      0.756863,
      0.987646,
      0.543015,
      0.38521,
      0.760784,
      0.988533,
      0.550446,
      0.388365,
      0.764706,
      0.989363,
      0.557873,
      0.391671,
      0.768627,
      0.990138,
      0.565296,
      0.395122,
      0.772549,
      0.990871,
      0.572706,
      0.398714,
      0.776471,
      0.991558,
      0.580107,
      0.402441,
      0.780392,
      0.992196,
      0.587502,
      0.406299,
      0.784314,
      0.992785,
      0.594891,
      0.410283,
      0.788235,
      0.993326,
      0.602275,
      0.41439,
      0.792157,
      0.993834,
      0.609644,
      0.418613,
      0.796078,
      0.994309,
      0.616999,
      0.42295,
      0.8,
      0.994738,
      0.62435,
      0.427397,
      0.803922,
      0.995122,
      0.631696,
      0.431951,
      0.807843,
      0.99548,
      0.639027,
      0.436607,
      0.811765,
      0.99581,
      0.646344,
      0.441361,
      0.815686,
      0.996096,
      0.653659,
      0.446213,
      0.819608,
      0.996341,
      0.660969,
      0.45116,
      0.823529,
      0.99658,
      0.668256,
      0.456192,
      0.827451,
      0.996775,
      0.675541,
      0.461314,
      0.831373,
      0.996925,
      0.682828,
      0.466526,
      0.835294,
      0.997077,
      0.690088,
      0.471811,
      0.839216,
      0.997186,
      0.697349,
      0.477182,
      0.843137,
      0.997254,
      0.704611,
      0.482635,
      0.847059,
      0.997325,
      0.711848,
      0.488154,
      0.85098,
      0.997351,
      0.719089,
      0.493755,
      0.854902,
      0.997351,
      0.726324,
      0.499428,
      0.858824,
      0.997341,
      0.733545,
      0.505167,
      0.862745,
      0.997285,
      0.740772,
      0.510983,
      0.866667,
      0.997228,
      0.747981,
      0.516859,
      0.870588,
      0.997138,
      0.75519,
      0.522806,
      0.87451,
      0.997019,
      0.762398,
      0.528821,
      0.878431,
      0.996898,
      0.769591,
      0.534892,
      0.882353,
      0.996727,
      0.776795,
      0.541039,
      0.886275,
      0.996571,
      0.783977,
      0.547233,
      0.890196,
      0.996369,
      0.791167,
      0.553499,
      0.894118,
      0.996162,
      0.798348,
      0.55982,
      0.898039,
      0.995932,
      0.805527,
      0.566202,
      0.901961,
      0.99568,
      0.812706,
      0.572645,
      0.905882,
      0.995424,
      0.819875,
      0.57914,
      0.909804,
      0.995131,
      0.827052,
      0.585701,
      0.913725,
      0.994851,
      0.834213,
      0.592307,
      0.917647,
      0.994524,
      0.841387,
      0.598983,
      0.921569,
      0.994222,
      0.84854,
      0.605696,
      0.92549,
      0.993866,
      0.855711,
      0.612482,
      0.929412,
      0.993545,
      0.862859,
      0.619299,
      0.933333,
      0.99317,
      0.870024,
      0.626189,
      0.937255,
      0.992831,
      0.877168,
      0.633109,
      0.941176,
      0.99244,
      0.88433,
      0.640099,
      0.945098,
      0.992089,
      0.89147,
      0.647116,
      0.94902,
      0.991688,
      0.898627,
      0.654202,
      0.952941,
      0.991332,
      0.905763,
      0.661309,
      0.956863,
      0.99093,
      0.912915,
      0.668481,
      0.960784,
      0.99057,
      0.920049,
      0.675675,
      0.964706,
      0.990175,
      0.927196,
      0.682926,
      0.968627,
      0.989815,
      0.934329,
      0.690198,
      0.972549,
      0.989434,
      0.94147,
      0.697519,
      0.976471,
      0.989077,
      0.948604,
      0.704863,
      0.980392,
      0.988717,
      0.955742,
      0.712242,
      0.984314,
      0.988367,
      0.962878,
      0.719649,
      0.988235,
      0.988033,
      0.970012,
      0.727077,
      0.992157,
      0.987691,
      0.977154,
      0.734536,
      0.996078,
      0.987387,
      0.984288,
      0.742002,
      1,
      0.987053,
      0.991438,
      0.749504
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Inferno (matplotlib)",
    NanColor: [
      0,
      1,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Nathaniel J. Smith & Stefan van der Walt",
    RGBPoints: [
      0,
      1462e-6,
      466e-6,
      0.013866,
      3922e-6,
      2267e-6,
      127e-5,
      0.01857,
      7843e-6,
      3299e-6,
      2249e-6,
      0.024239,
      0.011765,
      4547e-6,
      3392e-6,
      0.030909,
      0.015686,
      6006e-6,
      4692e-6,
      0.038558,
      0.019608,
      7676e-6,
      6136e-6,
      0.046836,
      0.023529,
      9561e-6,
      7713e-6,
      0.055143,
      0.027451,
      0.011663,
      9417e-6,
      0.06346,
      0.031373,
      0.013995,
      0.011225,
      0.071862,
      0.035294,
      0.016561,
      0.013136,
      0.080282,
      0.039216,
      0.019373,
      0.015133,
      0.088767,
      0.043137,
      0.022447,
      0.017199,
      0.097327,
      0.047059,
      0.025793,
      0.019331,
      0.10593,
      0.05098,
      0.029432,
      0.021503,
      0.114621,
      0.054902,
      0.033385,
      0.023702,
      0.123397,
      0.058824,
      0.037668,
      0.025921,
      0.132232,
      0.062745,
      0.042253,
      0.028139,
      0.141141,
      0.066667,
      0.046915,
      0.030324,
      0.150164,
      0.070588,
      0.051644,
      0.032474,
      0.159254,
      0.07451,
      0.056449,
      0.034569,
      0.168414,
      0.078431,
      0.06134,
      0.03659,
      0.177642,
      0.082353,
      0.066331,
      0.038504,
      0.186962,
      0.086275,
      0.071429,
      0.040294,
      0.196354,
      0.090196,
      0.076637,
      0.041905,
      0.205799,
      0.094118,
      0.081962,
      0.043328,
      0.215289,
      0.098039,
      0.087411,
      0.044556,
      0.224813,
      0.101961,
      0.09299,
      0.045583,
      0.234358,
      0.105882,
      0.098702,
      0.046402,
      0.243904,
      0.109804,
      0.104551,
      0.047008,
      0.25343,
      0.113725,
      0.110536,
      0.047399,
      0.262912,
      0.117647,
      0.116656,
      0.047574,
      0.272321,
      0.121569,
      0.122908,
      0.047536,
      0.281624,
      0.12549,
      0.129285,
      0.047293,
      0.290788,
      0.129412,
      0.135778,
      0.046856,
      0.299776,
      0.133333,
      0.142378,
      0.046242,
      0.308553,
      0.137255,
      0.149073,
      0.045468,
      0.317085,
      0.141176,
      0.15585,
      0.044559,
      0.325338,
      0.145098,
      0.162689,
      0.043554,
      0.333277,
      0.14902,
      0.169575,
      0.042489,
      0.340874,
      0.152941,
      0.176493,
      0.041402,
      0.348111,
      0.156863,
      0.183429,
      0.040329,
      0.354971,
      0.160784,
      0.190367,
      0.039309,
      0.361447,
      0.164706,
      0.197297,
      0.0384,
      0.367535,
      0.168627,
      0.204209,
      0.037632,
      0.373238,
      0.172549,
      0.211095,
      0.03703,
      0.378563,
      0.176471,
      0.217949,
      0.036615,
      0.383522,
      0.180392,
      0.224763,
      0.036405,
      0.388129,
      0.184314,
      0.231538,
      0.036405,
      0.3924,
      0.188235,
      0.238273,
      0.036621,
      0.396353,
      0.192157,
      0.244967,
      0.037055,
      0.400007,
      0.196078,
      0.25162,
      0.037705,
      0.403378,
      0.2,
      0.258234,
      0.038571,
      0.406485,
      0.203922,
      0.26481,
      0.039647,
      0.409345,
      0.207843,
      0.271347,
      0.040922,
      0.411976,
      0.211765,
      0.27785,
      0.042353,
      0.414392,
      0.215686,
      0.284321,
      0.043933,
      0.416608,
      0.219608,
      0.290763,
      0.045644,
      0.418637,
      0.223529,
      0.297178,
      0.04747,
      0.420491,
      0.227451,
      0.303568,
      0.049396,
      0.422182,
      0.231373,
      0.309935,
      0.051407,
      0.423721,
      0.235294,
      0.316282,
      0.05349,
      0.425116,
      0.239216,
      0.32261,
      0.055634,
      0.426377,
      0.243137,
      0.328921,
      0.057827,
      0.427511,
      0.247059,
      0.335217,
      0.06006,
      0.428524,
      0.25098,
      0.3415,
      0.062325,
      0.429425,
      0.254902,
      0.347771,
      0.064616,
      0.430217,
      0.258824,
      0.354032,
      0.066925,
      0.430906,
      0.262745,
      0.360284,
      0.069247,
      0.431497,
      0.266667,
      0.366529,
      0.071579,
      0.431994,
      0.270588,
      0.372768,
      0.073915,
      0.4324,
      0.27451,
      0.379001,
      0.076253,
      0.432719,
      0.278431,
      0.385228,
      0.078591,
      0.432955,
      0.282353,
      0.391453,
      0.080927,
      0.433109,
      0.286275,
      0.397674,
      0.083257,
      0.433183,
      0.290196,
      0.403894,
      0.08558,
      0.433179,
      0.294118,
      0.410113,
      0.087896,
      0.433098,
      0.298039,
      0.416331,
      0.090203,
      0.432943,
      0.301961,
      0.422549,
      0.092501,
      0.432714,
      0.305882,
      0.428768,
      0.09479,
      0.432412,
      0.309804,
      0.434987,
      0.097069,
      0.432039,
      0.313725,
      0.441207,
      0.099338,
      0.431594,
      0.317647,
      0.447428,
      0.101597,
      0.43108,
      0.321569,
      0.453651,
      0.103848,
      0.430498,
      0.32549,
      0.459875,
      0.106089,
      0.429846,
      0.329412,
      0.4661,
      0.108322,
      0.429125,
      0.333333,
      0.472328,
      0.110547,
      0.428334,
      0.337255,
      0.478558,
      0.112764,
      0.427475,
      0.341176,
      0.484789,
      0.114974,
      0.426548,
      0.345098,
      0.491022,
      0.117179,
      0.425552,
      0.34902,
      0.497257,
      0.119379,
      0.424488,
      0.352941,
      0.503493,
      0.121575,
      0.423356,
      0.356863,
      0.50973,
      0.123769,
      0.422156,
      0.360784,
      0.515967,
      0.12596,
      0.420887,
      0.364706,
      0.522206,
      0.12815,
      0.419549,
      0.368627,
      0.528444,
      0.130341,
      0.418142,
      0.372549,
      0.534683,
      0.132534,
      0.416667,
      0.376471,
      0.54092,
      0.134729,
      0.415123,
      0.380392,
      0.547157,
      0.136929,
      0.413511,
      0.384314,
      0.553392,
      0.139134,
      0.411829,
      0.388235,
      0.559624,
      0.141346,
      0.410078,
      0.392157,
      0.565854,
      0.143567,
      0.408258,
      0.396078,
      0.572081,
      0.145797,
      0.406369,
      0.4,
      0.578304,
      0.148039,
      0.404411,
      0.403922,
      0.584521,
      0.150294,
      0.402385,
      0.407843,
      0.590734,
      0.152563,
      0.40029,
      0.411765,
      0.59694,
      0.154848,
      0.398125,
      0.415686,
      0.603139,
      0.157151,
      0.395891,
      0.419608,
      0.60933,
      0.159474,
      0.393589,
      0.423529,
      0.615513,
      0.161817,
      0.391219,
      0.427451,
      0.621685,
      0.164184,
      0.388781,
      0.431373,
      0.627847,
      0.166575,
      0.386276,
      0.435294,
      0.633998,
      0.168992,
      0.383704,
      0.439216,
      0.640135,
      0.171438,
      0.381065,
      0.443137,
      0.64626,
      0.173914,
      0.378359,
      0.447059,
      0.652369,
      0.176421,
      0.375586,
      0.45098,
      0.658463,
      0.178962,
      0.372748,
      0.454902,
      0.66454,
      0.181539,
      0.369846,
      0.458824,
      0.670599,
      0.184153,
      0.366879,
      0.462745,
      0.676638,
      0.186807,
      0.363849,
      0.466667,
      0.682656,
      0.189501,
      0.360757,
      0.470588,
      0.688653,
      0.192239,
      0.357603,
      0.47451,
      0.694627,
      0.195021,
      0.354388,
      0.478431,
      0.700576,
      0.197851,
      0.351113,
      0.482353,
      0.7065,
      0.200728,
      0.347777,
      0.486275,
      0.712396,
      0.203656,
      0.344383,
      0.490196,
      0.718264,
      0.206636,
      0.340931,
      0.494118,
      0.724103,
      0.20967,
      0.337424,
      0.498039,
      0.729909,
      0.212759,
      0.333861,
      0.501961,
      0.735683,
      0.215906,
      0.330245,
      0.505882,
      0.741423,
      0.219112,
      0.326576,
      0.509804,
      0.747127,
      0.222378,
      0.322856,
      0.513725,
      0.752794,
      0.225706,
      0.319085,
      0.517647,
      0.758422,
      0.229097,
      0.315266,
      0.521569,
      0.76401,
      0.232554,
      0.311399,
      0.52549,
      0.769556,
      0.236077,
      0.307485,
      0.529412,
      0.775059,
      0.239667,
      0.303526,
      0.533333,
      0.780517,
      0.243327,
      0.299523,
      0.537255,
      0.785929,
      0.247056,
      0.295477,
      0.541176,
      0.791293,
      0.250856,
      0.29139,
      0.545098,
      0.796607,
      0.254728,
      0.287264,
      0.54902,
      0.801871,
      0.258674,
      0.283099,
      0.552941,
      0.807082,
      0.262692,
      0.278898,
      0.556863,
      0.812239,
      0.266786,
      0.274661,
      0.560784,
      0.817341,
      0.270954,
      0.27039,
      0.564706,
      0.822386,
      0.275197,
      0.266085,
      0.568627,
      0.827372,
      0.279517,
      0.26175,
      0.572549,
      0.832299,
      0.283913,
      0.257383,
      0.576471,
      0.837165,
      0.288385,
      0.252988,
      0.580392,
      0.841969,
      0.292933,
      0.248564,
      0.584314,
      0.846709,
      0.297559,
      0.244113,
      0.588235,
      0.851384,
      0.30226,
      0.239636,
      0.592157,
      0.855992,
      0.307038,
      0.235133,
      0.596078,
      0.860533,
      0.311892,
      0.230606,
      0.6,
      0.865006,
      0.316822,
      0.226055,
      0.603922,
      0.869409,
      0.321827,
      0.221482,
      0.607843,
      0.873741,
      0.326906,
      0.216886,
      0.611765,
      0.878001,
      0.33206,
      0.212268,
      0.615686,
      0.882188,
      0.337287,
      0.207628,
      0.619608,
      0.886302,
      0.342586,
      0.202968,
      0.623529,
      0.890341,
      0.347957,
      0.198286,
      0.627451,
      0.894305,
      0.353399,
      0.193584,
      0.631373,
      0.898192,
      0.358911,
      0.18886,
      0.635294,
      0.902003,
      0.364492,
      0.184116,
      0.639216,
      0.905735,
      0.37014,
      0.17935,
      0.643137,
      0.90939,
      0.375856,
      0.174563,
      0.647059,
      0.912966,
      0.381636,
      0.169755,
      0.65098,
      0.916462,
      0.387481,
      0.164924,
      0.654902,
      0.919879,
      0.393389,
      0.16007,
      0.658824,
      0.923215,
      0.399359,
      0.155193,
      0.662745,
      0.92647,
      0.405389,
      0.150292,
      0.666667,
      0.929644,
      0.411479,
      0.145367,
      0.670588,
      0.932737,
      0.417627,
      0.140417,
      0.67451,
      0.935747,
      0.423831,
      0.13544,
      0.678431,
      0.938675,
      0.430091,
      0.130438,
      0.682353,
      0.941521,
      0.436405,
      0.125409,
      0.686275,
      0.944285,
      0.442772,
      0.120354,
      0.690196,
      0.946965,
      0.449191,
      0.115272,
      0.694118,
      0.949562,
      0.45566,
      0.110164,
      0.698039,
      0.952075,
      0.462178,
      0.105031,
      0.701961,
      0.954506,
      0.468744,
      0.099874,
      0.705882,
      0.956852,
      0.475356,
      0.094695,
      0.709804,
      0.959114,
      0.482014,
      0.089499,
      0.713725,
      0.961293,
      0.488716,
      0.084289,
      0.717647,
      0.963387,
      0.495462,
      0.079073,
      0.721569,
      0.965397,
      0.502249,
      0.073859,
      0.72549,
      0.967322,
      0.509078,
      0.068659,
      0.729412,
      0.969163,
      0.515946,
      0.063488,
      0.733333,
      0.970919,
      0.522853,
      0.058367,
      0.737255,
      0.97259,
      0.529798,
      0.053324,
      0.741176,
      0.974176,
      0.53678,
      0.048392,
      0.745098,
      0.975677,
      0.543798,
      0.043618,
      0.74902,
      0.977092,
      0.55085,
      0.03905,
      0.752941,
      0.978422,
      0.557937,
      0.034931,
      0.756863,
      0.979666,
      0.565057,
      0.031409,
      0.760784,
      0.980824,
      0.572209,
      0.028508,
      0.764706,
      0.981895,
      0.579392,
      0.02625,
      0.768627,
      0.982881,
      0.586606,
      0.024661,
      0.772549,
      0.983779,
      0.593849,
      0.02377,
      0.776471,
      0.984591,
      0.601122,
      0.023606,
      0.780392,
      0.985315,
      0.608422,
      0.024202,
      0.784314,
      0.985952,
      0.61575,
      0.025592,
      0.788235,
      0.986502,
      0.623105,
      0.027814,
      0.792157,
      0.986964,
      0.630485,
      0.030908,
      0.796078,
      0.987337,
      0.63789,
      0.034916,
      0.8,
      0.987622,
      0.64532,
      0.039886,
      0.803922,
      0.987819,
      0.652773,
      0.045581,
      0.807843,
      0.987926,
      0.66025,
      0.05175,
      0.811765,
      0.987945,
      0.667748,
      0.058329,
      0.815686,
      0.987874,
      0.675267,
      0.065257,
      0.819608,
      0.987714,
      0.682807,
      0.072489,
      0.823529,
      0.987464,
      0.690366,
      0.07999,
      0.827451,
      0.987124,
      0.697944,
      0.087731,
      0.831373,
      0.986694,
      0.70554,
      0.095694,
      0.835294,
      0.986175,
      0.713153,
      0.103863,
      0.839216,
      0.985566,
      0.720782,
      0.112229,
      0.843137,
      0.984865,
      0.728427,
      0.120785,
      0.847059,
      0.984075,
      0.736087,
      0.129527,
      0.85098,
      0.983196,
      0.743758,
      0.138453,
      0.854902,
      0.982228,
      0.751442,
      0.147565,
      0.858824,
      0.981173,
      0.759135,
      0.156863,
      0.862745,
      0.980032,
      0.766837,
      0.166353,
      0.866667,
      0.978806,
      0.774545,
      0.176037,
      0.870588,
      0.977497,
      0.782258,
      0.185923,
      0.87451,
      0.976108,
      0.789974,
      0.196018,
      0.878431,
      0.974638,
      0.797692,
      0.206332,
      0.882353,
      0.973088,
      0.805409,
      0.216877,
      0.886275,
      0.971468,
      0.813122,
      0.227658,
      0.890196,
      0.969783,
      0.820825,
      0.238686,
      0.894118,
      0.968041,
      0.828515,
      0.249972,
      0.898039,
      0.966243,
      0.836191,
      0.261534,
      0.901961,
      0.964394,
      0.843848,
      0.273391,
      0.905882,
      0.962517,
      0.851476,
      0.285546,
      0.909804,
      0.960626,
      0.859069,
      0.29801,
      0.913725,
      0.95872,
      0.866624,
      0.31082,
      0.917647,
      0.956834,
      0.874129,
      0.323974,
      0.921569,
      0.954997,
      0.881569,
      0.337475,
      0.92549,
      0.953215,
      0.888942,
      0.351369,
      0.929412,
      0.951546,
      0.896226,
      0.365627,
      0.933333,
      0.950018,
      0.903409,
      0.380271,
      0.937255,
      0.948683,
      0.910473,
      0.395289,
      0.941176,
      0.947594,
      0.917399,
      0.410665,
      0.945098,
      0.946809,
      0.924168,
      0.426373,
      0.94902,
      0.946392,
      0.930761,
      0.442367,
      0.952941,
      0.946403,
      0.937159,
      0.458592,
      0.956863,
      0.946903,
      0.943348,
      0.47497,
      0.960784,
      0.947937,
      0.949318,
      0.491426,
      0.964706,
      0.949545,
      0.955063,
      0.50786,
      0.968627,
      0.95174,
      0.960587,
      0.524203,
      0.972549,
      0.954529,
      0.965896,
      0.540361,
      0.976471,
      0.957896,
      0.971003,
      0.556275,
      0.980392,
      0.961812,
      0.975924,
      0.571925,
      0.984314,
      0.966249,
      0.980678,
      0.587206,
      0.988235,
      0.971162,
      0.985282,
      0.602154,
      0.992157,
      0.976511,
      0.989753,
      0.61676,
      0.996078,
      0.982257,
      0.994109,
      0.631017,
      1,
      0.988362,
      0.998364,
      0.644924
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Plasma (matplotlib)",
    NanColor: [
      0,
      1,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Nathaniel J. Smith & Stefan van der Walt",
    RGBPoints: [
      0,
      0.050383,
      0.029803,
      0.527975,
      3922e-6,
      0.063536,
      0.028426,
      0.533124,
      7843e-6,
      0.075353,
      0.027206,
      0.538007,
      0.011765,
      0.086222,
      0.026125,
      0.542658,
      0.015686,
      0.096379,
      0.025165,
      0.547103,
      0.019608,
      0.10598,
      0.024309,
      0.551368,
      0.023529,
      0.115124,
      0.023556,
      0.555468,
      0.027451,
      0.123903,
      0.022878,
      0.559423,
      0.031373,
      0.132381,
      0.022258,
      0.56325,
      0.035294,
      0.140603,
      0.021687,
      0.566959,
      0.039216,
      0.148607,
      0.021154,
      0.570562,
      0.043137,
      0.156421,
      0.020651,
      0.574065,
      0.047059,
      0.16407,
      0.020171,
      0.577478,
      0.05098,
      0.171574,
      0.019706,
      0.580806,
      0.054902,
      0.17895,
      0.019252,
      0.584054,
      0.058824,
      0.186213,
      0.018803,
      0.587228,
      0.062745,
      0.193374,
      0.018354,
      0.59033,
      0.066667,
      0.200445,
      0.017902,
      0.593364,
      0.070588,
      0.207435,
      0.017442,
      0.596333,
      0.07451,
      0.21435,
      0.016973,
      0.599239,
      0.078431,
      0.221197,
      0.016497,
      0.602083,
      0.082353,
      0.227983,
      0.016007,
      0.604867,
      0.086275,
      0.234715,
      0.015502,
      0.607592,
      0.090196,
      0.241396,
      0.014979,
      0.610259,
      0.094118,
      0.248032,
      0.014439,
      0.612868,
      0.098039,
      0.254627,
      0.013882,
      0.615419,
      0.101961,
      0.261183,
      0.013308,
      0.617911,
      0.105882,
      0.267703,
      0.012716,
      0.620346,
      0.109804,
      0.274191,
      0.012109,
      0.622722,
      0.113725,
      0.280648,
      0.011488,
      0.625038,
      0.117647,
      0.287076,
      0.010855,
      0.627295,
      0.121569,
      0.293478,
      0.010213,
      0.62949,
      0.12549,
      0.299855,
      9561e-6,
      0.631624,
      0.129412,
      0.30621,
      8902e-6,
      0.633694,
      0.133333,
      0.312543,
      8239e-6,
      0.6357,
      0.137255,
      0.318856,
      7576e-6,
      0.63764,
      0.141176,
      0.32515,
      6915e-6,
      0.639512,
      0.145098,
      0.331426,
      6261e-6,
      0.641316,
      0.14902,
      0.337683,
      5618e-6,
      0.643049,
      0.152941,
      0.343925,
      4991e-6,
      0.64471,
      0.156863,
      0.35015,
      4382e-6,
      0.646298,
      0.160784,
      0.356359,
      3798e-6,
      0.64781,
      0.164706,
      0.362553,
      3243e-6,
      0.649245,
      0.168627,
      0.368733,
      2724e-6,
      0.650601,
      0.172549,
      0.374897,
      2245e-6,
      0.651876,
      0.176471,
      0.381047,
      1814e-6,
      0.653068,
      0.180392,
      0.387183,
      1434e-6,
      0.654177,
      0.184314,
      0.393304,
      1114e-6,
      0.655199,
      0.188235,
      0.399411,
      859e-6,
      0.656133,
      0.192157,
      0.405503,
      678e-6,
      0.656977,
      0.196078,
      0.41158,
      577e-6,
      0.65773,
      0.2,
      0.417642,
      564e-6,
      0.65839,
      0.203922,
      0.423689,
      646e-6,
      0.658956,
      0.207843,
      0.429719,
      831e-6,
      0.659425,
      0.211765,
      0.435734,
      1127e-6,
      0.659797,
      0.215686,
      0.441732,
      154e-5,
      0.660069,
      0.219608,
      0.447714,
      208e-5,
      0.66024,
      0.223529,
      0.453677,
      2755e-6,
      0.66031,
      0.227451,
      0.459623,
      3574e-6,
      0.660277,
      0.231373,
      0.46555,
      4545e-6,
      0.660139,
      0.235294,
      0.471457,
      5678e-6,
      0.659897,
      0.239216,
      0.477344,
      698e-5,
      0.659549,
      0.243137,
      0.48321,
      846e-5,
      0.659095,
      0.247059,
      0.489055,
      0.010127,
      0.658534,
      0.25098,
      0.494877,
      0.01199,
      0.657865,
      0.254902,
      0.500678,
      0.014055,
      0.657088,
      0.258824,
      0.506454,
      0.016333,
      0.656202,
      0.262745,
      0.512206,
      0.018833,
      0.655209,
      0.266667,
      0.517933,
      0.021563,
      0.654109,
      0.270588,
      0.523633,
      0.024532,
      0.652901,
      0.27451,
      0.529306,
      0.027747,
      0.651586,
      0.278431,
      0.534952,
      0.031217,
      0.650165,
      0.282353,
      0.54057,
      0.03495,
      0.64864,
      0.286275,
      0.546157,
      0.038954,
      0.64701,
      0.290196,
      0.551715,
      0.043136,
      0.645277,
      0.294118,
      0.557243,
      0.047331,
      0.643443,
      0.298039,
      0.562738,
      0.051545,
      0.641509,
      0.301961,
      0.568201,
      0.055778,
      0.639477,
      0.305882,
      0.573632,
      0.060028,
      0.637349,
      0.309804,
      0.579029,
      0.064296,
      0.635126,
      0.313725,
      0.584391,
      0.068579,
      0.632812,
      0.317647,
      0.589719,
      0.072878,
      0.630408,
      0.321569,
      0.595011,
      0.07719,
      0.627917,
      0.32549,
      0.600266,
      0.081516,
      0.625342,
      0.329412,
      0.605485,
      0.085854,
      0.622686,
      0.333333,
      0.610667,
      0.090204,
      0.619951,
      0.337255,
      0.615812,
      0.094564,
      0.61714,
      0.341176,
      0.620919,
      0.098934,
      0.614257,
      0.345098,
      0.625987,
      0.103312,
      0.611305,
      0.34902,
      0.631017,
      0.107699,
      0.608287,
      0.352941,
      0.636008,
      0.112092,
      0.605205,
      0.356863,
      0.640959,
      0.116492,
      0.602065,
      0.360784,
      0.645872,
      0.120898,
      0.598867,
      0.364706,
      0.650746,
      0.125309,
      0.595617,
      0.368627,
      0.65558,
      0.129725,
      0.592317,
      0.372549,
      0.660374,
      0.134144,
      0.588971,
      0.376471,
      0.665129,
      0.138566,
      0.585582,
      0.380392,
      0.669845,
      0.142992,
      0.582154,
      0.384314,
      0.674522,
      0.147419,
      0.578688,
      0.388235,
      0.67916,
      0.151848,
      0.575189,
      0.392157,
      0.683758,
      0.156278,
      0.57166,
      0.396078,
      0.688318,
      0.160709,
      0.568103,
      0.4,
      0.69284,
      0.165141,
      0.564522,
      0.403922,
      0.697324,
      0.169573,
      0.560919,
      0.407843,
      0.701769,
      0.174005,
      0.557296,
      0.411765,
      0.706178,
      0.178437,
      0.553657,
      0.415686,
      0.710549,
      0.182868,
      0.550004,
      0.419608,
      0.714883,
      0.187299,
      0.546338,
      0.423529,
      0.719181,
      0.191729,
      0.542663,
      0.427451,
      0.723444,
      0.196158,
      0.538981,
      0.431373,
      0.72767,
      0.200586,
      0.535293,
      0.435294,
      0.731862,
      0.205013,
      0.531601,
      0.439216,
      0.736019,
      0.209439,
      0.527908,
      0.443137,
      0.740143,
      0.213864,
      0.524216,
      0.447059,
      0.744232,
      0.218288,
      0.520524,
      0.45098,
      0.748289,
      0.222711,
      0.516834,
      0.454902,
      0.752312,
      0.227133,
      0.513149,
      0.458824,
      0.756304,
      0.231555,
      0.509468,
      0.462745,
      0.760264,
      0.235976,
      0.505794,
      0.466667,
      0.764193,
      0.240396,
      0.502126,
      0.470588,
      0.76809,
      0.244817,
      0.498465,
      0.47451,
      0.771958,
      0.249237,
      0.494813,
      0.478431,
      0.775796,
      0.253658,
      0.491171,
      0.482353,
      0.779604,
      0.258078,
      0.487539,
      0.486275,
      0.783383,
      0.2625,
      0.483918,
      0.490196,
      0.787133,
      0.266922,
      0.480307,
      0.494118,
      0.790855,
      0.271345,
      0.476706,
      0.498039,
      0.794549,
      0.27577,
      0.473117,
      0.501961,
      0.798216,
      0.280197,
      0.469538,
      0.505882,
      0.801855,
      0.284626,
      0.465971,
      0.509804,
      0.805467,
      0.289057,
      0.462415,
      0.513725,
      0.809052,
      0.293491,
      0.45887,
      0.517647,
      0.812612,
      0.297928,
      0.455338,
      0.521569,
      0.816144,
      0.302368,
      0.451816,
      0.52549,
      0.819651,
      0.306812,
      0.448306,
      0.529412,
      0.823132,
      0.311261,
      0.444806,
      0.533333,
      0.826588,
      0.315714,
      0.441316,
      0.537255,
      0.830018,
      0.320172,
      0.437836,
      0.541176,
      0.833422,
      0.324635,
      0.434366,
      0.545098,
      0.836801,
      0.329105,
      0.430905,
      0.54902,
      0.840155,
      0.33358,
      0.427455,
      0.552941,
      0.843484,
      0.338062,
      0.424013,
      0.556863,
      0.846788,
      0.342551,
      0.420579,
      0.560784,
      0.850066,
      0.347048,
      0.417153,
      0.564706,
      0.853319,
      0.351553,
      0.413734,
      0.568627,
      0.856547,
      0.356066,
      0.410322,
      0.572549,
      0.85975,
      0.360588,
      0.406917,
      0.576471,
      0.862927,
      0.365119,
      0.403519,
      0.580392,
      0.866078,
      0.36966,
      0.400126,
      0.584314,
      0.869203,
      0.374212,
      0.396738,
      0.588235,
      0.872303,
      0.378774,
      0.393355,
      0.592157,
      0.875376,
      0.383347,
      0.389976,
      0.596078,
      0.878423,
      0.387932,
      0.3866,
      0.6,
      0.881443,
      0.392529,
      0.383229,
      0.603922,
      0.884436,
      0.397139,
      0.37986,
      0.607843,
      0.887402,
      0.401762,
      0.376494,
      0.611765,
      0.89034,
      0.406398,
      0.37313,
      0.615686,
      0.89325,
      0.411048,
      0.369768,
      0.619608,
      0.896131,
      0.415712,
      0.366407,
      0.623529,
      0.898984,
      0.420392,
      0.363047,
      0.627451,
      0.901807,
      0.425087,
      0.359688,
      0.631373,
      0.904601,
      0.429797,
      0.356329,
      0.635294,
      0.907365,
      0.434524,
      0.35297,
      0.639216,
      0.910098,
      0.439268,
      0.34961,
      0.643137,
      0.9128,
      0.444029,
      0.346251,
      0.647059,
      0.915471,
      0.448807,
      0.34289,
      0.65098,
      0.918109,
      0.453603,
      0.339529,
      0.654902,
      0.920714,
      0.458417,
      0.336166,
      0.658824,
      0.923287,
      0.463251,
      0.332801,
      0.662745,
      0.925825,
      0.468103,
      0.329435,
      0.666667,
      0.928329,
      0.472975,
      0.326067,
      0.670588,
      0.930798,
      0.477867,
      0.322697,
      0.67451,
      0.933232,
      0.48278,
      0.319325,
      0.678431,
      0.93563,
      0.487712,
      0.315952,
      0.682353,
      0.93799,
      0.492667,
      0.312575,
      0.686275,
      0.940313,
      0.497642,
      0.309197,
      0.690196,
      0.942598,
      0.502639,
      0.305816,
      0.694118,
      0.944844,
      0.507658,
      0.302433,
      0.698039,
      0.947051,
      0.512699,
      0.299049,
      0.701961,
      0.949217,
      0.517763,
      0.295662,
      0.705882,
      0.951344,
      0.52285,
      0.292275,
      0.709804,
      0.953428,
      0.52796,
      0.288883,
      0.713725,
      0.95547,
      0.533093,
      0.28549,
      0.717647,
      0.957469,
      0.53825,
      0.282096,
      0.721569,
      0.959424,
      0.543431,
      0.278701,
      0.72549,
      0.961336,
      0.548636,
      0.275305,
      0.729412,
      0.963203,
      0.553865,
      0.271909,
      0.733333,
      0.965024,
      0.559118,
      0.268513,
      0.737255,
      0.966798,
      0.564396,
      0.265118,
      0.741176,
      0.968526,
      0.5697,
      0.261721,
      0.745098,
      0.970205,
      0.575028,
      0.258325,
      0.74902,
      0.971835,
      0.580382,
      0.254931,
      0.752941,
      0.973416,
      0.585761,
      0.25154,
      0.756863,
      0.974947,
      0.591165,
      0.248151,
      0.760784,
      0.976428,
      0.596595,
      0.244767,
      0.764706,
      0.977856,
      0.602051,
      0.241387,
      0.768627,
      0.979233,
      0.607532,
      0.238013,
      0.772549,
      0.980556,
      0.613039,
      0.234646,
      0.776471,
      0.981826,
      0.618572,
      0.231287,
      0.780392,
      0.983041,
      0.624131,
      0.227937,
      0.784314,
      0.984199,
      0.629718,
      0.224595,
      0.788235,
      0.985301,
      0.63533,
      0.221265,
      0.792157,
      0.986345,
      0.640969,
      0.217948,
      0.796078,
      0.987332,
      0.646633,
      0.214648,
      0.8,
      0.98826,
      0.652325,
      0.211364,
      0.803922,
      0.989128,
      0.658043,
      0.2081,
      0.807843,
      0.989935,
      0.663787,
      0.204859,
      0.811765,
      0.990681,
      0.669558,
      0.201642,
      0.815686,
      0.991365,
      0.675355,
      0.198453,
      0.819608,
      0.991985,
      0.681179,
      0.195295,
      0.823529,
      0.992541,
      0.68703,
      0.19217,
      0.827451,
      0.993032,
      0.692907,
      0.189084,
      0.831373,
      0.993456,
      0.69881,
      0.186041,
      0.835294,
      0.993814,
      0.704741,
      0.183043,
      0.839216,
      0.994103,
      0.710698,
      0.180097,
      0.843137,
      0.994324,
      0.716681,
      0.177208,
      0.847059,
      0.994474,
      0.722691,
      0.174381,
      0.85098,
      0.994553,
      0.728728,
      0.171622,
      0.854902,
      0.994561,
      0.734791,
      0.168938,
      0.858824,
      0.994495,
      0.74088,
      0.166335,
      0.862745,
      0.994355,
      0.746995,
      0.163821,
      0.866667,
      0.994141,
      0.753137,
      0.161404,
      0.870588,
      0.993851,
      0.759304,
      0.159092,
      0.87451,
      0.993482,
      0.765499,
      0.156891,
      0.878431,
      0.993033,
      0.77172,
      0.154808,
      0.882353,
      0.992505,
      0.777967,
      0.152855,
      0.886275,
      0.991897,
      0.784239,
      0.151042,
      0.890196,
      0.991209,
      0.790537,
      0.149377,
      0.894118,
      0.990439,
      0.796859,
      0.14787,
      0.898039,
      0.989587,
      0.803205,
      0.146529,
      0.901961,
      0.988648,
      0.809579,
      0.145357,
      0.905882,
      0.987621,
      0.815978,
      0.144363,
      0.909804,
      0.986509,
      0.822401,
      0.143557,
      0.913725,
      0.985314,
      0.828846,
      0.142945,
      0.917647,
      0.984031,
      0.835315,
      0.142528,
      0.921569,
      0.982653,
      0.841812,
      0.142303,
      0.92549,
      0.98119,
      0.848329,
      0.142279,
      0.929412,
      0.979644,
      0.854866,
      0.142453,
      0.933333,
      0.977995,
      0.861432,
      0.142808,
      0.937255,
      0.976265,
      0.868016,
      0.143351,
      0.941176,
      0.974443,
      0.874622,
      0.144061,
      0.945098,
      0.97253,
      0.88125,
      0.144923,
      0.94902,
      0.970533,
      0.887896,
      0.145919,
      0.952941,
      0.968443,
      0.894564,
      0.147014,
      0.956863,
      0.966271,
      0.901249,
      0.14818,
      0.960784,
      0.964021,
      0.90795,
      0.14937,
      0.964706,
      0.961681,
      0.914672,
      0.15052,
      0.968627,
      0.959276,
      0.921407,
      0.151566,
      0.972549,
      0.956808,
      0.928152,
      0.152409,
      0.976471,
      0.954287,
      0.934908,
      0.152921,
      0.980392,
      0.951726,
      0.941671,
      0.152925,
      0.984314,
      0.949151,
      0.948435,
      0.152178,
      0.988235,
      0.946602,
      0.95519,
      0.150328,
      0.992157,
      0.944152,
      0.961916,
      0.146861,
      0.996078,
      0.941896,
      0.96859,
      0.140956,
      1,
      0.940015,
      0.975158,
      0.131326
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Viridis (matplotlib)",
    NanColor: [
      1,
      0,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Eric Firing",
    RGBPoints: [
      0,
      0.267004,
      4874e-6,
      0.329415,
      3922e-6,
      0.26851,
      9605e-6,
      0.335427,
      7843e-6,
      0.269944,
      0.014625,
      0.341379,
      0.011765,
      0.271305,
      0.019942,
      0.347269,
      0.015686,
      0.272594,
      0.025563,
      0.353093,
      0.019608,
      0.273809,
      0.031497,
      0.358853,
      0.023529,
      0.274952,
      0.037752,
      0.364543,
      0.027451,
      0.276022,
      0.044167,
      0.370164,
      0.031373,
      0.277018,
      0.050344,
      0.375715,
      0.035294,
      0.277941,
      0.056324,
      0.381191,
      0.039216,
      0.278791,
      0.062145,
      0.386592,
      0.043137,
      0.279566,
      0.067836,
      0.391917,
      0.047059,
      0.280267,
      0.073417,
      0.397163,
      0.05098,
      0.280894,
      0.078907,
      0.402329,
      0.054902,
      0.281446,
      0.08432,
      0.407414,
      0.058824,
      0.281924,
      0.089666,
      0.412415,
      0.062745,
      0.282327,
      0.094955,
      0.417331,
      0.066667,
      0.282656,
      0.100196,
      0.42216,
      0.070588,
      0.28291,
      0.105393,
      0.426902,
      0.07451,
      0.283091,
      0.110553,
      0.431554,
      0.078431,
      0.283197,
      0.11568,
      0.436115,
      0.082353,
      0.283229,
      0.120777,
      0.440584,
      0.086275,
      0.283187,
      0.125848,
      0.44496,
      0.090196,
      0.283072,
      0.130895,
      0.449241,
      0.094118,
      0.282884,
      0.13592,
      0.453427,
      0.098039,
      0.282623,
      0.140926,
      0.457517,
      0.101961,
      0.28229,
      0.145912,
      0.46151,
      0.105882,
      0.281887,
      0.150881,
      0.465405,
      0.109804,
      0.281412,
      0.155834,
      0.469201,
      0.113725,
      0.280868,
      0.160771,
      0.472899,
      0.117647,
      0.280255,
      0.165693,
      0.476498,
      0.121569,
      0.279574,
      0.170599,
      0.479997,
      0.12549,
      0.278826,
      0.17549,
      0.483397,
      0.129412,
      0.278012,
      0.180367,
      0.486697,
      0.133333,
      0.277134,
      0.185228,
      0.489898,
      0.137255,
      0.276194,
      0.190074,
      0.493001,
      0.141176,
      0.275191,
      0.194905,
      0.496005,
      0.145098,
      0.274128,
      0.199721,
      0.498911,
      0.14902,
      0.273006,
      0.20452,
      0.501721,
      0.152941,
      0.271828,
      0.209303,
      0.504434,
      0.156863,
      0.270595,
      0.214069,
      0.507052,
      0.160784,
      0.269308,
      0.218818,
      0.509577,
      0.164706,
      0.267968,
      0.223549,
      0.512008,
      0.168627,
      0.26658,
      0.228262,
      0.514349,
      0.172549,
      0.265145,
      0.232956,
      0.516599,
      0.176471,
      0.263663,
      0.237631,
      0.518762,
      0.180392,
      0.262138,
      0.242286,
      0.520837,
      0.184314,
      0.260571,
      0.246922,
      0.522828,
      0.188235,
      0.258965,
      0.251537,
      0.524736,
      0.192157,
      0.257322,
      0.25613,
      0.526563,
      0.196078,
      0.255645,
      0.260703,
      0.528312,
      0.2,
      0.253935,
      0.265254,
      0.529983,
      0.203922,
      0.252194,
      0.269783,
      0.531579,
      0.207843,
      0.250425,
      0.27429,
      0.533103,
      0.211765,
      0.248629,
      0.278775,
      0.534556,
      0.215686,
      0.246811,
      0.283237,
      0.535941,
      0.219608,
      0.244972,
      0.287675,
      0.53726,
      0.223529,
      0.243113,
      0.292092,
      0.538516,
      0.227451,
      0.241237,
      0.296485,
      0.539709,
      0.231373,
      0.239346,
      0.300855,
      0.540844,
      0.235294,
      0.237441,
      0.305202,
      0.541921,
      0.239216,
      0.235526,
      0.309527,
      0.542944,
      0.243137,
      0.233603,
      0.313828,
      0.543914,
      0.247059,
      0.231674,
      0.318106,
      0.544834,
      0.25098,
      0.229739,
      0.322361,
      0.545706,
      0.254902,
      0.227802,
      0.326594,
      0.546532,
      0.258824,
      0.225863,
      0.330805,
      0.547314,
      0.262745,
      0.223925,
      0.334994,
      0.548053,
      0.266667,
      0.221989,
      0.339161,
      0.548752,
      0.270588,
      0.220057,
      0.343307,
      0.549413,
      0.27451,
      0.21813,
      0.347432,
      0.550038,
      0.278431,
      0.21621,
      0.351535,
      0.550627,
      0.282353,
      0.214298,
      0.355619,
      0.551184,
      0.286275,
      0.212395,
      0.359683,
      0.55171,
      0.290196,
      0.210503,
      0.363727,
      0.552206,
      0.294118,
      0.208623,
      0.367752,
      0.552675,
      0.298039,
      0.206756,
      0.371758,
      0.553117,
      0.301961,
      0.204903,
      0.375746,
      0.553533,
      0.305882,
      0.203063,
      0.379716,
      0.553925,
      0.309804,
      0.201239,
      0.38367,
      0.554294,
      0.313725,
      0.19943,
      0.387607,
      0.554642,
      0.317647,
      0.197636,
      0.391528,
      0.554969,
      0.321569,
      0.19586,
      0.395433,
      0.555276,
      0.32549,
      0.1941,
      0.399323,
      0.555565,
      0.329412,
      0.192357,
      0.403199,
      0.555836,
      0.333333,
      0.190631,
      0.407061,
      0.556089,
      0.337255,
      0.188923,
      0.41091,
      0.556326,
      0.341176,
      0.187231,
      0.414746,
      0.556547,
      0.345098,
      0.185556,
      0.41857,
      0.556753,
      0.34902,
      0.183898,
      0.422383,
      0.556944,
      0.352941,
      0.182256,
      0.426184,
      0.55712,
      0.356863,
      0.180629,
      0.429975,
      0.557282,
      0.360784,
      0.179019,
      0.433756,
      0.55743,
      0.364706,
      0.177423,
      0.437527,
      0.557565,
      0.368627,
      0.175841,
      0.44129,
      0.557685,
      0.372549,
      0.174274,
      0.445044,
      0.557792,
      0.376471,
      0.172719,
      0.448791,
      0.557885,
      0.380392,
      0.171176,
      0.45253,
      0.557965,
      0.384314,
      0.169646,
      0.456262,
      0.55803,
      0.388235,
      0.168126,
      0.459988,
      0.558082,
      0.392157,
      0.166617,
      0.463708,
      0.558119,
      0.396078,
      0.165117,
      0.467423,
      0.558141,
      0.4,
      0.163625,
      0.471133,
      0.558148,
      0.403922,
      0.162142,
      0.474838,
      0.55814,
      0.407843,
      0.160665,
      0.47854,
      0.558115,
      0.411765,
      0.159194,
      0.482237,
      0.558073,
      0.415686,
      0.157729,
      0.485932,
      0.558013,
      0.419608,
      0.15627,
      0.489624,
      0.557936,
      0.423529,
      0.154815,
      0.493313,
      0.55784,
      0.427451,
      0.153364,
      0.497,
      0.557724,
      0.431373,
      0.151918,
      0.500685,
      0.557587,
      0.435294,
      0.150476,
      0.504369,
      0.55743,
      0.439216,
      0.149039,
      0.508051,
      0.55725,
      0.443137,
      0.147607,
      0.511733,
      0.557049,
      0.447059,
      0.14618,
      0.515413,
      0.556823,
      0.45098,
      0.144759,
      0.519093,
      0.556572,
      0.454902,
      0.143343,
      0.522773,
      0.556295,
      0.458824,
      0.141935,
      0.526453,
      0.555991,
      0.462745,
      0.140536,
      0.530132,
      0.555659,
      0.466667,
      0.139147,
      0.533812,
      0.555298,
      0.470588,
      0.13777,
      0.537492,
      0.554906,
      0.47451,
      0.136408,
      0.541173,
      0.554483,
      0.478431,
      0.135066,
      0.544853,
      0.554029,
      0.482353,
      0.133743,
      0.548535,
      0.553541,
      0.486275,
      0.132444,
      0.552216,
      0.553018,
      0.490196,
      0.131172,
      0.555899,
      0.552459,
      0.494118,
      0.129933,
      0.559582,
      0.551864,
      0.498039,
      0.128729,
      0.563265,
      0.551229,
      0.501961,
      0.127568,
      0.566949,
      0.550556,
      0.505882,
      0.126453,
      0.570633,
      0.549841,
      0.509804,
      0.125394,
      0.574318,
      0.549086,
      0.513725,
      0.124395,
      0.578002,
      0.548287,
      0.517647,
      0.123463,
      0.581687,
      0.547445,
      0.521569,
      0.122606,
      0.585371,
      0.546557,
      0.52549,
      0.121831,
      0.589055,
      0.545623,
      0.529412,
      0.121148,
      0.592739,
      0.544641,
      0.533333,
      0.120565,
      0.596422,
      0.543611,
      0.537255,
      0.120092,
      0.600104,
      0.54253,
      0.541176,
      0.119738,
      0.603785,
      0.5414,
      0.545098,
      0.119512,
      0.607464,
      0.540218,
      0.54902,
      0.119423,
      0.611141,
      0.538982,
      0.552941,
      0.119483,
      0.614817,
      0.537692,
      0.556863,
      0.119699,
      0.61849,
      0.536347,
      0.560784,
      0.120081,
      0.622161,
      0.534946,
      0.564706,
      0.120638,
      0.625828,
      0.533488,
      0.568627,
      0.12138,
      0.629492,
      0.531973,
      0.572549,
      0.122312,
      0.633153,
      0.530398,
      0.576471,
      0.123444,
      0.636809,
      0.528763,
      0.580392,
      0.12478,
      0.640461,
      0.527068,
      0.584314,
      0.126326,
      0.644107,
      0.525311,
      0.588235,
      0.128087,
      0.647749,
      0.523491,
      0.592157,
      0.130067,
      0.651384,
      0.521608,
      0.596078,
      0.132268,
      0.655014,
      0.519661,
      0.6,
      0.134692,
      0.658636,
      0.517649,
      0.603922,
      0.137339,
      0.662252,
      0.515571,
      0.607843,
      0.14021,
      0.665859,
      0.513427,
      0.611765,
      0.143303,
      0.669459,
      0.511215,
      0.615686,
      0.146616,
      0.67305,
      0.508936,
      0.619608,
      0.150148,
      0.676631,
      0.506589,
      0.623529,
      0.153894,
      0.680203,
      0.504172,
      0.627451,
      0.157851,
      0.683765,
      0.501686,
      0.631373,
      0.162016,
      0.687316,
      0.499129,
      0.635294,
      0.166383,
      0.690856,
      0.496502,
      0.639216,
      0.170948,
      0.694384,
      0.493803,
      0.643137,
      0.175707,
      0.6979,
      0.491033,
      0.647059,
      0.180653,
      0.701402,
      0.488189,
      0.65098,
      0.185783,
      0.704891,
      0.485273,
      0.654902,
      0.19109,
      0.708366,
      0.482284,
      0.658824,
      0.196571,
      0.711827,
      0.479221,
      0.662745,
      0.202219,
      0.715272,
      0.476084,
      0.666667,
      0.20803,
      0.718701,
      0.472873,
      0.670588,
      0.214,
      0.722114,
      0.469588,
      0.67451,
      0.220124,
      0.725509,
      0.466226,
      0.678431,
      0.226397,
      0.728888,
      0.462789,
      0.682353,
      0.232815,
      0.732247,
      0.459277,
      0.686275,
      0.239374,
      0.735588,
      0.455688,
      0.690196,
      0.24607,
      0.73891,
      0.452024,
      0.694118,
      0.252899,
      0.742211,
      0.448284,
      0.698039,
      0.259857,
      0.745492,
      0.444467,
      0.701961,
      0.266941,
      0.748751,
      0.440573,
      0.705882,
      0.274149,
      0.751988,
      0.436601,
      0.709804,
      0.281477,
      0.755203,
      0.432552,
      0.713725,
      0.288921,
      0.758394,
      0.428426,
      0.717647,
      0.296479,
      0.761561,
      0.424223,
      0.721569,
      0.304148,
      0.764704,
      0.419943,
      0.72549,
      0.311925,
      0.767822,
      0.415586,
      0.729412,
      0.319809,
      0.770914,
      0.411152,
      0.733333,
      0.327796,
      0.77398,
      0.40664,
      0.737255,
      0.335885,
      0.777018,
      0.402049,
      0.741176,
      0.344074,
      0.780029,
      0.397381,
      0.745098,
      0.35236,
      0.783011,
      0.392636,
      0.74902,
      0.360741,
      0.785964,
      0.387814,
      0.752941,
      0.369214,
      0.788888,
      0.382914,
      0.756863,
      0.377779,
      0.791781,
      0.377939,
      0.760784,
      0.386433,
      0.794644,
      0.372886,
      0.764706,
      0.395174,
      0.797475,
      0.367757,
      0.768627,
      0.404001,
      0.800275,
      0.362552,
      0.772549,
      0.412913,
      0.803041,
      0.357269,
      0.776471,
      0.421908,
      0.805774,
      0.35191,
      0.780392,
      0.430983,
      0.808473,
      0.346476,
      0.784314,
      0.440137,
      0.811138,
      0.340967,
      0.788235,
      0.449368,
      0.813768,
      0.335384,
      0.792157,
      0.458674,
      0.816363,
      0.329727,
      0.796078,
      0.468053,
      0.818921,
      0.323998,
      0.8,
      0.477504,
      0.821444,
      0.318195,
      0.803922,
      0.487026,
      0.823929,
      0.312321,
      0.807843,
      0.496615,
      0.826376,
      0.306377,
      0.811765,
      0.506271,
      0.828786,
      0.300362,
      0.815686,
      0.515992,
      0.831158,
      0.294279,
      0.819608,
      0.525776,
      0.833491,
      0.288127,
      0.823529,
      0.535621,
      0.835785,
      0.281908,
      0.827451,
      0.545524,
      0.838039,
      0.275626,
      0.831373,
      0.555484,
      0.840254,
      0.269281,
      0.835294,
      0.565498,
      0.84243,
      0.262877,
      0.839216,
      0.575563,
      0.844566,
      0.256415,
      0.843137,
      0.585678,
      0.846661,
      0.249897,
      0.847059,
      0.595839,
      0.848717,
      0.243329,
      0.85098,
      0.606045,
      0.850733,
      0.236712,
      0.854902,
      0.616293,
      0.852709,
      0.230052,
      0.858824,
      0.626579,
      0.854645,
      0.223353,
      0.862745,
      0.636902,
      0.856542,
      0.21662,
      0.866667,
      0.647257,
      0.8584,
      0.209861,
      0.870588,
      0.657642,
      0.860219,
      0.203082,
      0.87451,
      0.668054,
      0.861999,
      0.196293,
      0.878431,
      0.678489,
      0.863742,
      0.189503,
      0.882353,
      0.688944,
      0.865448,
      0.182725,
      0.886275,
      0.699415,
      0.867117,
      0.175971,
      0.890196,
      0.709898,
      0.868751,
      0.169257,
      0.894118,
      0.720391,
      0.87035,
      0.162603,
      0.898039,
      0.730889,
      0.871916,
      0.156029,
      0.901961,
      0.741388,
      0.873449,
      0.149561,
      0.905882,
      0.751884,
      0.874951,
      0.143228,
      0.909804,
      0.762373,
      0.876424,
      0.137064,
      0.913725,
      0.772852,
      0.877868,
      0.131109,
      0.917647,
      0.783315,
      0.879285,
      0.125405,
      0.921569,
      0.79376,
      0.880678,
      0.120005,
      0.92549,
      0.804182,
      0.882046,
      0.114965,
      0.929412,
      0.814576,
      0.883393,
      0.110347,
      0.933333,
      0.82494,
      0.88472,
      0.106217,
      0.937255,
      0.83527,
      0.886029,
      0.102646,
      0.941176,
      0.845561,
      0.887322,
      0.099702,
      0.945098,
      0.85581,
      0.888601,
      0.097452,
      0.94902,
      0.866013,
      0.889868,
      0.095953,
      0.952941,
      0.876168,
      0.891125,
      0.09525,
      0.956863,
      0.886271,
      0.892374,
      0.095374,
      0.960784,
      0.89632,
      0.893616,
      0.096335,
      0.964706,
      0.906311,
      0.894855,
      0.098125,
      0.968627,
      0.916242,
      0.896091,
      0.100717,
      0.972549,
      0.926106,
      0.89733,
      0.104071,
      0.976471,
      0.935904,
      0.89857,
      0.108131,
      0.980392,
      0.945636,
      0.899815,
      0.112838,
      0.984314,
      0.9553,
      0.901065,
      0.118128,
      0.988235,
      0.964894,
      0.902323,
      0.123941,
      0.992157,
      0.974417,
      0.90359,
      0.130215,
      0.996078,
      0.983868,
      0.904867,
      0.136897,
      1,
      0.993248,
      0.906157,
      0.143936
    ]
  },
  {
    ShowIndexedColorActiveValues: 1,
    IndexedColors: [
      0.07,
      0.5,
      0.7,
      1,
      1,
      1,
      0.85,
      1,
      1,
      0.8,
      0.5,
      1,
      0.76,
      1,
      0,
      1,
      0.71,
      0.71,
      0.5,
      0.5,
      0.5,
      0.05,
      0.05,
      1,
      1,
      0.05,
      0.05,
      0.7,
      1,
      1,
      0.7,
      0.89,
      0.96,
      0.67,
      0.36,
      0.95,
      0.54,
      1,
      0,
      0.75,
      0.65,
      0.65,
      0.5,
      0.6,
      0.6,
      1,
      0.5,
      0,
      1,
      1,
      0.19,
      0.12,
      0.94,
      0.12,
      0.5,
      0.82,
      0.89,
      0.56,
      0.25,
      0.83,
      0.24,
      1,
      0,
      0.9,
      0.9,
      0.9,
      0.75,
      0.76,
      0.78,
      0.65,
      0.65,
      0.67,
      0.54,
      0.6,
      0.78,
      0.61,
      0.48,
      0.78,
      0.5,
      0.48,
      0.78,
      0.44,
      0.48,
      0.78,
      0.36,
      0.48,
      0.76,
      1,
      0.48,
      0.38,
      0.49,
      0.5,
      0.69,
      0.76,
      0.56,
      0.56,
      0.4,
      0.56,
      0.56,
      0.74,
      0.5,
      0.89,
      1,
      0.63,
      0,
      0.65,
      0.16,
      0.16,
      0.36,
      0.72,
      0.82,
      0.44,
      0.18,
      0.69,
      0,
      1,
      0,
      0.58,
      1,
      1,
      0.58,
      0.88,
      0.88,
      0.45,
      0.76,
      0.79,
      0.33,
      0.71,
      0.71,
      0.23,
      0.62,
      0.62,
      0.14,
      0.56,
      0.56,
      0.04,
      0.49,
      0.55,
      0,
      0.41,
      0.52,
      0.88,
      0.88,
      1,
      1,
      0.85,
      0.56,
      0.65,
      0.46,
      0.45,
      0.4,
      0.5,
      0.5,
      0.62,
      0.39,
      0.71,
      0.83,
      0.48,
      0,
      0.58,
      0,
      0.58,
      0.26,
      0.62,
      0.69,
      0.34,
      0.09,
      0.56,
      0,
      0.79,
      0,
      0.44,
      0.83,
      1,
      1,
      1,
      0.78,
      0.85,
      1,
      0.78,
      0.78,
      1,
      0.78,
      0.64,
      1,
      0.78,
      0.56,
      1,
      0.78,
      0.38,
      1,
      0.78,
      0.27,
      1,
      0.78,
      0.19,
      1,
      0.78,
      0.12,
      1,
      0.78,
      0,
      1,
      0.61,
      0,
      0.9,
      0.46,
      0,
      0.83,
      0.32,
      0,
      0.75,
      0.22,
      0,
      0.67,
      0.14,
      0.3,
      0.76,
      1,
      0.3,
      0.65,
      1,
      0.13,
      0.58,
      0.84,
      0.15,
      0.49,
      0.67,
      0.15,
      0.4,
      0.59,
      0.09,
      0.33,
      0.53,
      0.96,
      0.93,
      0.82,
      0.8,
      0.82,
      0.12,
      0.71,
      0.71,
      0.76,
      0.65,
      0.33,
      0.3,
      0.34,
      0.35,
      0.38,
      0.62,
      0.31,
      0.71,
      0.67,
      0.36,
      0,
      0.46,
      0.31,
      0.27,
      0.26,
      0.51,
      0.59,
      0.26,
      0,
      0.4,
      0,
      0.49,
      0,
      0.44,
      0.67,
      0.98,
      0,
      0.73,
      1,
      0,
      0.63,
      1,
      0,
      0.56,
      1,
      0,
      0.5,
      1,
      0,
      0.42,
      1,
      0.33,
      0.36,
      0.95,
      0.47,
      0.36,
      0.89,
      0.54,
      0.31,
      0.89,
      0.63,
      0.21,
      0.83,
      0.7,
      0.12,
      0.83,
      0.7,
      0.12,
      0.73,
      0.7,
      0.05,
      0.65,
      0.74,
      0.05,
      0.53,
      0.78,
      0,
      0.4,
      0.8,
      0,
      0.35,
      0.82,
      0,
      0.31,
      0.85,
      0,
      0.27,
      0.88,
      0,
      0.22,
      0.9,
      0,
      0.18,
      0.91,
      0,
      0.15,
      0.92,
      0,
      0.14,
      0.93,
      0,
      0.13,
      0.94,
      0,
      0.12,
      0.95,
      0,
      0.11,
      0.96,
      0,
      0.1,
      0.97,
      0,
      0.09,
      0.98,
      0,
      0.08,
      0.99,
      0,
      0.07,
      1,
      0,
      0.06
    ],
    Annotations: [
      0,
      "Xx",
      1,
      "H",
      2,
      "He",
      3,
      "Li",
      4,
      "Be",
      5,
      "B",
      6,
      "C",
      7,
      "N",
      8,
      "O",
      9,
      "F",
      10,
      "Ne",
      11,
      "Na",
      12,
      "Mg",
      13,
      "Al",
      14,
      "Si",
      15,
      "P",
      16,
      "S",
      17,
      "Cl",
      18,
      "Ar",
      19,
      "K",
      20,
      "Ca",
      21,
      "Sc",
      22,
      "Ti",
      23,
      "V",
      24,
      "Cr",
      25,
      "Mn",
      26,
      "Fe",
      27,
      "Co",
      28,
      "Ni",
      29,
      "Cu",
      30,
      "Zn",
      31,
      "Ga",
      32,
      "Ge",
      33,
      "As",
      34,
      "Se",
      35,
      "Br",
      36,
      "Kr",
      37,
      "Rb",
      38,
      "Sr",
      39,
      "Y",
      40,
      "Zr",
      41,
      "Nb",
      42,
      "Mo",
      43,
      "Tc",
      44,
      "Ru",
      45,
      "Rh",
      46,
      "Pd",
      47,
      "Ag",
      48,
      "Cd",
      49,
      "In",
      50,
      "Sn",
      51,
      "Sb",
      52,
      "Te",
      53,
      "I",
      54,
      "Xe",
      55,
      "Cs",
      56,
      "Ba",
      57,
      "La",
      58,
      "Ce",
      59,
      "Pr",
      60,
      "Nd",
      61,
      "Pm",
      62,
      "Sm",
      63,
      "Eu",
      64,
      "Gd",
      65,
      "Tb",
      66,
      "Dy",
      67,
      "Ho",
      68,
      "Er",
      69,
      "Tm",
      70,
      "Yb",
      71,
      "Lu",
      72,
      "Hf",
      73,
      "Ta",
      74,
      "W",
      75,
      "Re",
      76,
      "Os",
      77,
      "Ir",
      78,
      "Pt",
      79,
      "Au",
      80,
      "Hg",
      81,
      "Tl",
      82,
      "Pb",
      83,
      "Bi",
      84,
      "Po",
      85,
      "At",
      86,
      "Rn",
      87,
      "Fr",
      88,
      "Ra",
      89,
      "Ac",
      90,
      "Th",
      91,
      "Pa",
      92,
      "U",
      93,
      "Np",
      94,
      "Pu",
      95,
      "Am",
      96,
      "Cm",
      97,
      "Bk",
      98,
      "Cf",
      99,
      "Es",
      100,
      "Fm",
      101,
      "Md",
      102,
      "No",
      103,
      "Lr",
      104,
      "Rf",
      105,
      "Db",
      106,
      "Sg",
      107,
      "Bh",
      108,
      "Hs",
      109,
      "Mt",
      110,
      "Ds",
      111,
      "Rg",
      112,
      "Cn",
      113,
      "Uut",
      114,
      "Uuq",
      115,
      "Uup",
      116,
      "Uuh",
      117,
      "Uus",
      118,
      "Uuo"
    ],
    Name: "BlueObeliskElements"
  }
];

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js
var presetMap2 = /* @__PURE__ */ Object.create(null);
vtkColorMaps3.filter((p) => p.RGBPoints).filter((p) => p.ColorSpace !== "CIELAB").forEach((p) => {
  presetMap2[p.Name] = p;
});
var rgbPresetNames2 = Object.keys(presetMap2);
rgbPresetNames2.sort();
function getPresetByName2(name2) {
  return presetMap2[name2];
}
function addPreset2(preset) {
  if (!preset.RGBPoints || preset.ColorSpace === "CIELAB") {
    return;
  }
  if (!presetMap2[preset.Name]) {
    rgbPresetNames2.push(preset.Name);
    rgbPresetNames2.sort();
  }
  presetMap2[preset.Name] = preset;
}
function removePresetByName2(name2) {
  const index = rgbPresetNames2.indexOf(name2);
  if (index > -1) {
    rgbPresetNames2.splice(index, 1);
  }
  delete presetMap2[name2];
}
var vtkColorMaps4 = {
  addPreset: addPreset2,
  removePresetByName: removePresetByName2,
  getPresetByName: getPresetByName2,
  rgbPresetNames: rgbPresetNames2
};

// node_modules/@kitware/vtk.js/Rendering/Core/Coordinate/Constants.js
var Coordinate = {
  DISPLAY: 0,
  NORMALIZED_DISPLAY: 1,
  VIEWPORT: 2,
  NORMALIZED_VIEWPORT: 3,
  PROJECTION: 4,
  VIEW: 5,
  WORLD: 6
};
var Constants13 = {
  Coordinate
};

// node_modules/@kitware/vtk.js/Rendering/Core/Coordinate.js
var {
  Coordinate: Coordinate2
} = Constants13;
var {
  vtkErrorMacro: vtkErrorMacro58
} = macro;
function vtkCoordinate(publicAPI, model) {
  model.classHierarchy.push("vtkCoordinate");
  publicAPI.setValue = function() {
    if (model.deleted) {
      vtkErrorMacro58("instance deleted - cannot call any method");
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    let array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length === 2) {
      publicAPI.setValue(array[0], array[1], 0);
      return true;
    }
    if (array.length !== 3) {
      throw new RangeError("Invalid number of values for array setter");
    }
    let changeDetected = false;
    model.value.forEach((item, index) => {
      if (item !== array[index]) {
        if (changeDetected) {
          return;
        }
        changeDetected = true;
      }
    });
    if (changeDetected) {
      model.value = [].concat(array);
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.setCoordinateSystemToDisplay = () => {
    publicAPI.setCoordinateSystem(Coordinate2.DISPLAY);
  };
  publicAPI.setCoordinateSystemToNormalizedDisplay = () => {
    publicAPI.setCoordinateSystem(Coordinate2.NORMALIZED_DISPLAY);
  };
  publicAPI.setCoordinateSystemToViewport = () => {
    publicAPI.setCoordinateSystem(Coordinate2.VIEWPORT);
  };
  publicAPI.setCoordinateSystemToNormalizedViewport = () => {
    publicAPI.setCoordinateSystem(Coordinate2.NORMALIZED_VIEWPORT);
  };
  publicAPI.setCoordinateSystemToProjection = () => {
    publicAPI.setCoordinateSystem(Coordinate2.PROJECTION);
  };
  publicAPI.setCoordinateSystemToView = () => {
    publicAPI.setCoordinateSystem(Coordinate2.VIEW);
  };
  publicAPI.setCoordinateSystemToWorld = () => {
    publicAPI.setCoordinateSystem(Coordinate2.WORLD);
  };
  publicAPI.getCoordinateSystemAsString = () => macro.enumToString(Coordinate2, model.coordinateSystem);
  publicAPI.getComputedWorldValue = (ren) => {
    let val = model.computedWorldValue;
    if (model.computing) {
      return val;
    }
    model.computing = 1;
    val[0] = model.value[0];
    val[1] = model.value[1];
    val[2] = model.value[2];
    let renderer = ren;
    if (model.renderer) {
      renderer = model.renderer;
    }
    if (!renderer) {
      if (model.coordinateSystem === Coordinate2.WORLD) {
        if (model.referenceCoordinate) {
          const refValue = model.referenceCoordinate.getComputedWorldValue(renderer);
          val[0] += refValue[0];
          val[1] += refValue[1];
          val[2] += refValue[2];
        }
        model.computing = 0;
      } else {
        vtkErrorMacro58("Attempt to compute world coordinates from another coordinate system without a renderer");
      }
      return val;
    }
    let view = null;
    if (renderer && renderer.getRenderWindow().getViews()) {
      view = renderer.getRenderWindow().getViews()[0];
    } else {
      return model.computedWorldValue;
    }
    const dims = view.getViewportSize(renderer);
    const aspect = dims[0] / dims[1];
    if (model.referenceCoordinate && model.coordinateSystem !== Coordinate2.WORLD) {
      const fval = model.referenceCoordinate.getComputedDoubleDisplayValue(renderer);
      let refValue = [fval[0], fval[1], 0];
      switch (model.coordinateSystem) {
        case Coordinate2.NORMALIZED_DISPLAY:
          refValue = view.displayToNormalizedDisplay(refValue[0], refValue[1], refValue[2]);
          break;
        case Coordinate2.VIEWPORT:
          refValue = view.displayToNormalizedDisplay(refValue[0], refValue[1], refValue[2]);
          refValue = view.normalizedDisplayToViewport(refValue[0], refValue[1], refValue[2], renderer);
          break;
        case Coordinate2.NORMALIZED_VIEWPORT:
          refValue = view.displayToNormalizedDisplay(refValue[0], refValue[1], refValue[2]);
          refValue = view.normalizedDisplayToViewport(refValue[0], refValue[1], refValue[2], renderer);
          refValue = view.viewportToNormalizedViewport(refValue[0], refValue[1], refValue[2], renderer);
          break;
        case Coordinate2.PROJECTION:
          refValue = view.displayToNormalizedDisplay(refValue[0], refValue[1], refValue[2]);
          refValue = view.normalizedDisplayToViewport(refValue[0], refValue[1], refValue[2], renderer);
          refValue = view.viewportToNormalizedViewport(refValue[0], refValue[1], refValue[2], renderer);
          refValue = renderer.normalizedViewportToProjection(refValue[0], refValue[1], refValue[2]);
          break;
        case Coordinate2.VIEW:
          refValue = view.displayToNormalizedDisplay(refValue[0], refValue[1], refValue[2]);
          refValue = view.normalizedDisplayToViewport(refValue[0], refValue[1], refValue[2], renderer);
          refValue = view.viewportToNormalizedViewport(refValue[0], refValue[1], refValue[2], renderer);
          refValue = renderer.normalizedViewportToProjection(refValue[0], refValue[1], refValue[2]);
          refValue = renderer.projectionToView(refValue[0], refValue[1], refValue[2], aspect);
          break;
      }
      val[0] += refValue[0];
      val[1] += refValue[1];
      val[2] += refValue[2];
    }
    switch (model.coordinateSystem) {
      case Coordinate2.DISPLAY:
        val = view.displayToNormalizedDisplay(val[0], val[1], val[2]);
        val = view.normalizedDisplayToViewport(val[0], val[1], val[2], renderer);
        val = view.viewportToNormalizedViewport(val[0], val[1], val[2], renderer);
        val = renderer.normalizedViewportToProjection(val[0], val[1], val[2]);
        val = renderer.projectionToView(val[0], val[1], val[2], aspect);
        val = renderer.viewToWorld(val[0], val[1], val[2]);
        break;
      case Coordinate2.NORMALIZED_DISPLAY:
        val = view.normalizedDisplayToViewport(val[0], val[1], val[2], renderer);
        val = view.viewportToNormalizedViewport(val[0], val[1], val[2], renderer);
        val = renderer.normalizedViewportToProjection(val[0], val[1], val[2]);
        val = renderer.projectionToView(val[0], val[1], val[2], aspect);
        val = renderer.viewToWorld(val[0], val[1], val[2]);
        break;
      case Coordinate2.VIEWPORT:
        val = view.viewportToNormalizedViewport(val[0], val[1], val[2], renderer);
        val = renderer.normalizedViewportToProjection(val[0], val[1], val[2]);
        val = renderer.projectionToView(val[0], val[1], val[2], aspect);
        val = renderer.viewToWorld(val[0], val[1], val[2]);
        break;
      case Coordinate2.NORMALIZED_VIEWPORT:
        val = renderer.normalizedViewportToProjection(val[0], val[1], val[2]);
        val = renderer.projectionToView(val[0], val[1], val[2], aspect);
        val = renderer.viewToWorld(val[0], val[1], val[2]);
        break;
      case Coordinate2.PROJECTION:
        val = renderer.projectionToView(val[0], val[1], val[2], aspect);
        val = renderer.viewToWorld(val[0], val[1], val[2]);
        break;
      case Coordinate2.VIEW:
        val = renderer.viewToWorld(val[0], val[1], val[2]);
        break;
    }
    if (model.referenceCoordinate && model.coordinateSystem === Coordinate2.WORLD) {
      const refValue = publicAPI.getComputedWorldValue(renderer);
      val[0] += refValue[0];
      val[1] += refValue[1];
      val[2] += refValue[2];
    }
    model.computing = 0;
    model.computedWorldValue = val.slice(0);
    return val;
  };
  publicAPI.getComputedViewportValue = (ren) => {
    const f2 = publicAPI.getComputedDoubleViewportValue(ren);
    return [round(f2[0]), round(f2[1])];
  };
  publicAPI.getComputedDisplayValue = (ren) => {
    const val = publicAPI.getComputedDoubleDisplayValue(ren);
    return [floor(val[0]), floor(val[1])];
  };
  publicAPI.getComputedLocalDisplayValue = (ren) => {
    let renderer = ren;
    if (model.renderer) {
      renderer = model.renderer;
    }
    let val = publicAPI.getComputedDisplayValue(renderer);
    if (!renderer) {
      vtkErrorMacro58("Attempt to convert to local display coordinates without a renderer");
      return val;
    }
    let view = null;
    if (renderer && renderer.getRenderWindow().getViews()) {
      view = renderer.getRenderWindow().getViews()[0];
    } else {
      return val;
    }
    val = view.displayToLocalDisplay(val[0], val[1], val[2]);
    return [round(val[0]), round(val[1])];
  };
  publicAPI.getComputedDoubleViewportValue = (ren) => {
    let renderer = ren;
    if (model.renderer) {
      renderer = model.renderer;
    }
    let val = publicAPI.getComputedDoubleDisplayValue(renderer);
    if (!renderer) {
      return val;
    }
    let view = null;
    if (renderer && renderer.getRenderWindow().getViews()) {
      view = renderer.getRenderWindow().getViews()[0];
    } else {
      return val;
    }
    val = view.displayToNormalizedDisplay(val[0], val[1], val[2]);
    val = view.normalizedDisplayToViewport(val[0], val[1], val[2], renderer);
    return [val[0], val[1]];
  };
  publicAPI.getComputedDoubleDisplayValue = (ren) => {
    if (model.computing) {
      return model.computedDoubleDisplayValue;
    }
    model.computing = 1;
    let val = model.value.slice(0);
    let renderer = ren;
    if (model.renderer) {
      renderer = model.renderer;
    }
    if (!renderer) {
      if (model.coordinateSystem === Coordinate2.DISPLAY) {
        model.computedDoubleDisplayValue[0] = val[0];
        model.computedDoubleDisplayValue[1] = val[1];
        if (model.referenceCoordinate) {
          const refValue = model.referenceCoordinate.getComputedDoubleDisplayValue();
          model.computedDoubleDisplayValue[0] += refValue[0];
          model.computedDoubleDisplayValue[1] += refValue[1];
        }
      } else {
        model.computedDoubleDisplayValue[0] = Number.MAX_VALUE;
        model.computedDoubleDisplayValue[1] = Number.MAX_VALUE;
        vtkErrorMacro58("Request for coordinate transformation without required viewport");
      }
      return model.computedDoubleDisplayValue;
    }
    let view = null;
    if (renderer && renderer.getRenderWindow().getViews()) {
      view = renderer.getRenderWindow().getViews()[0];
    } else {
      return val;
    }
    const dims = view.getViewportSize(renderer);
    const aspect = dims[0] / dims[1];
    switch (model.coordinateSystem) {
      case Coordinate2.WORLD: {
        if (model.referenceCoordinate) {
          const refValue = model.referenceCoordinate.getComputedWorldValue(renderer);
          val[0] += refValue[0];
          val[1] += refValue[1];
          val[2] += refValue[2];
        }
        val = renderer.worldToView(val[0], val[1], val[2]);
        val = renderer.viewToProjection(val[0], val[1], val[2], aspect);
        val = renderer.projectionToNormalizedViewport(val[0], val[1], val[2]);
        val = view.normalizedViewportToViewport(val[0], val[1], val[2], renderer);
        val = view.viewportToNormalizedDisplay(val[0], val[1], val[2], renderer);
        val = view.normalizedDisplayToDisplay(val[0], val[1], val[2]);
        break;
      }
      case Coordinate2.VIEW: {
        val = renderer.viewToProjection(val[0], val[1], val[2], aspect);
        val = renderer.projectionToNormalizedViewport(val[0], val[1], val[2]);
        val = view.normalizedViewportToViewport(val[0], val[1], val[2], renderer);
        val = view.viewportToNormalizedDisplay(val[0], val[1], val[2], renderer);
        val = view.normalizedDisplayToDisplay(val[0], val[1], val[2]);
        break;
      }
      case Coordinate2.PROJECTION: {
        val = renderer.projectionToNormalizedViewport(val[0], val[1], val[2]);
        val = view.normalizedViewportToViewport(val[0], val[1], val[2], renderer);
        val = view.viewportToNormalizedDisplay(val[0], val[1], val[2], renderer);
        val = view.normalizedDisplayToDisplay(val[0], val[1], val[2]);
        break;
      }
      case Coordinate2.NORMALIZED_VIEWPORT: {
        val = view.normalizedViewportToViewport(val[0], val[1], val[2], renderer);
        if (model.referenceCoordinate) {
          const refValue = model.referenceCoordinate.getComputedDoubleViewportValue(renderer);
          val[0] += refValue[0];
          val[1] += refValue[1];
        }
        val = view.viewportToNormalizedDisplay(val[0], val[1], val[2], renderer);
        val = view.normalizedDisplayToDisplay(val[0], val[1], val[2]);
        break;
      }
      case Coordinate2.VIEWPORT: {
        if (model.referenceCoordinate) {
          const refValue = model.referenceCoordinate.getComputedDoubleViewportValue(renderer);
          val[0] += refValue[0];
          val[1] += refValue[1];
        }
        val = view.viewportToNormalizedDisplay(val[0], val[1], val[2], renderer);
        val = view.normalizedDisplayToDisplay(val[0], val[1], val[2]);
        break;
      }
      case Coordinate2.NORMALIZED_DISPLAY:
        val = view.normalizedDisplayToDisplay(val[0], val[1], val[2]);
        break;
      case Coordinate2.USERDEFINED:
        val = model.value.slice(0);
        break;
    }
    if (model.referenceCoordinate && (model.coordinateSystem === Coordinate2.DISPLAY || model.coordinateSystem === Coordinate2.NORMALIZED_DISPLAY)) {
      const refValue = model.referenceCoordinate.getComputedDoubleDisplayValue(renderer);
      val[0] += refValue[0];
      val[1] += refValue[1];
    }
    model.computedDoubleDisplayValue[0] = val[0];
    model.computedDoubleDisplayValue[1] = val[1];
    model.computing = 0;
    return model.computedDoubleDisplayValue;
  };
  publicAPI.getComputedValue = (ren) => {
    let renderer = ren;
    if (model.renderer) {
      renderer = model.renderer;
    }
    switch (model.coordinateSystem) {
      case Coordinate2.WORLD:
        return publicAPI.getComputedWorldValue(renderer);
      case Coordinate2.VIEW:
      case Coordinate2.NORMALIZED_VIEWPORT:
      case Coordinate2.VIEWPORT: {
        const val = publicAPI.getComputedViewportValue(renderer);
        model.computedWorldValue[0] = val[0];
        model.computedWorldValue[1] = val[1];
        break;
      }
      case Coordinate2.NORMALIZED_DISPLAY:
      case Coordinate2.DISPLAY: {
        const val = model.getComputedDisplayValue(renderer);
        model.computedWorldValue[0] = val[0];
        model.computedWorldValue[1] = val[1];
        break;
      }
    }
    return model.computedWorldValue;
  };
}
var DEFAULT_VALUES132 = {
  coordinateSystem: Coordinate2.WORLD,
  value: [0, 0, 0],
  renderer: null,
  referenceCoordinate: null,
  computing: 0,
  computedWorldValue: [0, 0, 0],
  computedDoubleDisplayValue: [0, 0]
};
function extend144(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES132, initialValues);
  macro.obj(publicAPI, model);
  macro.set(publicAPI, model, ["property"]);
  macro.get(publicAPI, model, ["value"]);
  macro.setGet(publicAPI, model, ["coordinateSystem", "referenceCoordinate", "renderer"]);
  macro.getArray(publicAPI, model, ["value"], 3);
  vtkCoordinate(publicAPI, model);
}
var newInstance138 = macro.newInstance(extend144, "vtkCoordinate");
var vtkCoordinate$1 = {
  newInstance: newInstance138,
  extend: extend144,
  ...Constants13
};

// node_modules/@kitware/vtk.js/Rendering/Core/Actor2D.js
function vtkActor2D2(publicAPI, model) {
  model.classHierarchy.push("vtkActor2D");
  publicAPI.getActors2D = () => publicAPI;
  publicAPI.getIsOpaque = () => {
    if (!model.property) {
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    if (model.property === null) {
      publicAPI.setProperty(publicAPI.makeProperty());
    }
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = vtkProperty2D$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.setDisplayPosition = (XPos, YPos) => {
    model.positionCoordinate.setCoordinateSystem(Coordinate.DISPLAY);
    model.positionCoordinate.setValue(XPos, YPos, 0);
  };
  publicAPI.setWidth = (w) => {
    const pos = model.position2Coordinate.getValue();
    model.position2Coordinate.setCoordinateSystemToNormalizedViewport();
    model.position2Coordinate.setValue(w, pos[1]);
  };
  publicAPI.setHeight = (w) => {
    const pos = model.position2Coordinate.getValue();
    model.position2Coordinate.setCoordinateSystemToNormalizedViewport();
    model.position2Coordinate.setValue(pos[0], w);
  };
  publicAPI.getWidth = () => model.position2Coordinate.getValue()[0];
  publicAPI.getHeight = () => model.position2Coordinate.getValue()[1];
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    mt = model.positionCoordinate.getMTime() > mt ? model.positionCoordinate.getMTime() : mt;
    mt = model.positionCoordinate2.getMTime() > mt ? model.positionCoordinate2.getMTime() : mt;
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getBounds = () => {
    if (typeof publicAPI.getMapper().getBounds === "function") {
      model.useBounds = true;
      return publicAPI.getMapper().getBounds();
    }
    model.useBounds = false;
    return [];
  };
  publicAPI.getActualPositionCoordinate = () => model.positionCoordinate;
  publicAPI.getActualPositionCoordinate2 = () => model.positionCoordinate2;
}
var DEFAULT_VALUES133 = {
  mapper: null,
  property: null,
  layerNumber: 0,
  positionCoordinate: null,
  positionCoordinate2: null
};
function extend145(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES133, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.positionCoordinate = vtkCoordinate$1.newInstance();
  model.positionCoordinate.setCoordinateSystemToViewport();
  model.positionCoordinate2 = vtkCoordinate$1.newInstance();
  model.positionCoordinate2.setCoordinateSystemToNormalizedViewport();
  model.positionCoordinate2.setValue(0.5, 0.5);
  model.positionCoordinate2.setReferenceCoordinate(model.positionCoordinate);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["mapper", "layerNumber"]);
  vtkActor2D2(publicAPI, model);
}
var newInstance139 = macro.newInstance(extend145, "vtkActor2D");
var vtkActor2D$1 = {
  newInstance: newInstance139,
  extend: extend145
};

// node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor/Presets.js
var STYLES = {
  default: {
    defaultStyle: {
      fontStyle: "bold",
      fontFamily: "Arial",
      fontColor: "black",
      fontSizeScale: (res) => res / 2,
      faceColor: "white",
      edgeThickness: 0.1,
      edgeColor: "black",
      resolution: 400
    },
    xMinusFaceProperty: {
      text: "X-",
      faceColor: "yellow"
    },
    xPlusFaceProperty: {
      text: "X+",
      faceColor: "yellow"
    },
    yMinusFaceProperty: {
      text: "Y-",
      faceColor: "red"
    },
    yPlusFaceProperty: {
      text: "Y+",
      faceColor: "red"
    },
    zMinusFaceProperty: {
      text: "Z-",
      faceColor: "#008000"
    },
    zPlusFaceProperty: {
      text: "Z+",
      faceColor: "#008000"
    }
  },
  lps: {
    xMinusFaceProperty: {
      text: "R",
      faceRotation: -90
    },
    xPlusFaceProperty: {
      text: "L",
      faceRotation: 90
    },
    yMinusFaceProperty: {
      text: "A",
      faceRotation: 0
    },
    yPlusFaceProperty: {
      text: "P",
      faceRotation: 180
    },
    zMinusFaceProperty: {
      text: "I",
      faceRotation: 180
    },
    zPlusFaceProperty: {
      text: "S",
      faceRotation: 0
    }
  }
};
function applyDefinitions(definitions, cubeActor) {
  cubeActor.set(definitions);
}
function applyPreset(name2, cubeActor) {
  return applyDefinitions(STYLES[name2], cubeActor);
}
function registerStylePreset(name2, definitions) {
  STYLES[name2] = definitions;
}
var AnnotatedCubePresets = {
  applyDefinitions,
  applyPreset,
  registerStylePreset
};

// node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js
var FACE_TO_INDEX = {
  xPlus: 0,
  xMinus: 1,
  yPlus: 2,
  yMinus: 3,
  zPlus: 4,
  zMinus: 5
};
function vtkAnnotatedCubeActor(publicAPI, model) {
  model.classHierarchy.push("vtkAnnotatedCubeActor");
  model.xPlusFaceProperty = {
    ...model.xPlusFaceProperty
  };
  model.xMinusFaceProperty = {
    ...model.xMinusFaceProperty
  };
  model.yPlusFaceProperty = {
    ...model.yPlusFaceProperty
  };
  model.yMinusFaceProperty = {
    ...model.yMinusFaceProperty
  };
  model.zPlusFaceProperty = {
    ...model.zPlusFaceProperty
  };
  model.zMinusFaceProperty = {
    ...model.zMinusFaceProperty
  };
  let cubeSource = null;
  const canvas = document.createElement("canvas");
  const mapper = vtkMapper$1.newInstance();
  const texture = vtkTexture$1.newInstance();
  texture.setInterpolate(true);
  function updateFaceTexture(faceName) {
    let newProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (newProp) {
      Object.assign(model[`${faceName}FaceProperty`], newProp);
    }
    const prop = {
      ...model.defaultStyle,
      ...model[`${faceName}FaceProperty`]
    };
    canvas.width = prop.resolution;
    canvas.height = prop.resolution;
    const ctxt = canvas.getContext("2d");
    ctxt.fillStyle = prop.faceColor;
    ctxt.fillRect(0, 0, canvas.width, canvas.height);
    if (prop.edgeThickness > 0) {
      ctxt.strokeStyle = prop.edgeColor;
      ctxt.lineWidth = prop.edgeThickness * canvas.width;
      ctxt.strokeRect(0, 0, canvas.width, canvas.height);
    }
    ctxt.save();
    ctxt.translate(0, canvas.height);
    ctxt.scale(1, -1);
    ctxt.translate(canvas.width / 2, canvas.height / 2);
    ctxt.rotate(-Math.PI * (prop.faceRotation / 180));
    const textSize = prop.fontSizeScale(prop.resolution);
    ctxt.fillStyle = prop.fontColor;
    ctxt.textAlign = "center";
    ctxt.textBaseline = "middle";
    ctxt.font = `${prop.fontStyle} ${textSize}px "${prop.fontFamily}"`;
    ctxt.fillText(prop.text, 0, 0);
    ctxt.restore();
    const vtkImage = ImageHelper.canvasToImageData(canvas);
    texture.setInputData(vtkImage, FACE_TO_INDEX[faceName]);
    publicAPI.modified();
  }
  function updateAllFaceTextures() {
    cubeSource = vtkCubeSource$1.newInstance({
      generate3DTextureCoordinates: true
    });
    mapper.setInputConnection(cubeSource.getOutputPort());
    updateFaceTexture("xPlus");
    updateFaceTexture("xMinus");
    updateFaceTexture("yPlus");
    updateFaceTexture("yMinus");
    updateFaceTexture("zPlus");
    updateFaceTexture("zMinus");
  }
  publicAPI.setDefaultStyle = (style6) => {
    model.defaultStyle = {
      ...model.defaultStyle,
      ...style6
    };
    updateAllFaceTextures();
  };
  publicAPI.setXPlusFaceProperty = (prop) => updateFaceTexture("xPlus", prop);
  publicAPI.setXMinusFaceProperty = (prop) => updateFaceTexture("xMinus", prop);
  publicAPI.setYPlusFaceProperty = (prop) => updateFaceTexture("yPlus", prop);
  publicAPI.setYMinusFaceProperty = (prop) => updateFaceTexture("yMinus", prop);
  publicAPI.setZPlusFaceProperty = (prop) => updateFaceTexture("zPlus", prop);
  publicAPI.setZMinusFaceProperty = (prop) => updateFaceTexture("zMinus", prop);
  updateAllFaceTextures();
  mapper.setInputConnection(cubeSource.getOutputPort());
  publicAPI.setMapper(mapper);
  publicAPI.addTexture(texture);
}
var DEFAULT_VALUES134 = {
  defaultStyle: {
    text: "",
    faceColor: "white",
    faceRotation: 0,
    fontFamily: "Arial",
    fontColor: "black",
    fontStyle: "normal",
    fontSizeScale: (resolution) => resolution / 1.8,
    edgeThickness: 0.1,
    edgeColor: "black",
    resolution: 200
  }
  // xPlusFaceProperty: null,
  // xMinusFaceProperty: null,
  // yPlusFaceProperty: null,
  // yMinusFaceProperty: null,
  // zPlusFaceProperty: null,
  // zMinusFaceProperty: null,
};
function extend146(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES134, initialValues);
  vtkActor$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["defaultStyle", "xPlusFaceProperty", "xMinusFaceProperty", "yPlusFaceProperty", "yMinusFaceProperty", "zPlusFaceProperty", "zMinusFaceProperty"]);
  vtkAnnotatedCubeActor(publicAPI, model);
}
var newInstance140 = macro.newInstance(extend146, "vtkAnnotatedCubeActor");
var vtkAnnotatedCubeActor$1 = {
  newInstance: newInstance140,
  extend: extend146,
  Presets: AnnotatedCubePresets
};

// node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js
function centerDataSet(ds) {
  const bounds2 = ds.getPoints().getBounds();
  const center = [-(bounds2[0] + bounds2[1]) * 0.5, -(bounds2[2] + bounds2[3]) * 0.5, -(bounds2[4] + bounds2[5]) * 0.5];
  vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());
}
function shiftDataset(ds, axis) {
  let invert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const bounds2 = ds.getPoints().getBounds();
  const center = [0, 0, 0];
  if (invert) {
    center[axis] = -bounds2[axis * 2 + 1];
  } else {
    center[axis] = -bounds2[axis * 2];
  }
  vtkMatrixBuilder.buildFromDegree().translate(...center).apply(ds.getPoints().getData());
}
function addColor(ds, r, g, b2) {
  const size = ds.getPoints().getData().length;
  const rgbArray = new Uint8ClampedArray(size);
  let offset = 0;
  while (offset < size) {
    rgbArray[offset++] = r;
    rgbArray[offset++] = g;
    rgbArray[offset++] = b2;
  }
  ds.getPointData().setScalars(vtkDataArray$1.newInstance({
    name: "color",
    numberOfComponents: 3,
    values: rgbArray
  }));
}
function vtkAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkAxesActor");
  const _mapper = vtkMapper$1.newInstance();
  publicAPI.setMapper(_mapper);
  publicAPI.update = () => {
    let currentConfig = {
      ...model.config,
      ...model.xConfig
    };
    const xAxis = vtkArrowSource$1.newInstance({
      direction: [1, 0, 0],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(xAxis);
    } else {
      shiftDataset(xAxis, 0, currentConfig.invert);
    }
    addColor(xAxis, ...currentConfig.color);
    currentConfig = {
      ...model.config,
      ...model.yConfig
    };
    const yAxis = vtkArrowSource$1.newInstance({
      direction: [0, 1, 0],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(yAxis);
    } else {
      shiftDataset(yAxis, 1, currentConfig.invert);
    }
    addColor(yAxis, ...currentConfig.color);
    currentConfig = {
      ...model.config,
      ...model.zConfig
    };
    const zAxis = vtkArrowSource$1.newInstance({
      direction: [0, 0, 1],
      ...currentConfig
    }).getOutputData();
    if (model.config.recenter) {
      centerDataSet(zAxis);
    } else {
      shiftDataset(zAxis, 2, currentConfig.invert);
    }
    addColor(zAxis, ...currentConfig.color);
    const source = vtkAppendPolyData$1.newInstance();
    source.setInputData(xAxis);
    source.addInputData(yAxis);
    source.addInputData(zAxis);
    _mapper.setInputConnection(source.getOutputPort());
  };
  publicAPI.update();
  const _debouncedUpdate = macro.debounce(publicAPI.update, 0);
  publicAPI.setXAxisColor = (color4) => publicAPI.setXConfig({
    ...publicAPI.getXConfig(),
    color: color4
  });
  publicAPI.setYAxisColor = (color4) => publicAPI.setYConfig({
    ...publicAPI.getYConfig(),
    color: color4
  });
  publicAPI.setZAxisColor = (color4) => publicAPI.setZConfig({
    ...publicAPI.getZConfig(),
    color: color4
  });
  publicAPI.getXAxisColor = () => model.getXConfig().color;
  publicAPI.getYAxisColor = () => model.getYConfig().color;
  publicAPI.getZAxisColor = () => model.getZConfig().color;
  model._onConfigChanged = _debouncedUpdate;
  model._onXConfigChanged = _debouncedUpdate;
  model._onYConfigChanged = _debouncedUpdate;
  model._onZConfigChanged = _debouncedUpdate;
}
function defaultValues13(initialValues) {
  return {
    config: {
      recenter: true,
      tipResolution: 60,
      tipRadius: 0.1,
      tipLength: 0.2,
      shaftResolution: 60,
      shaftRadius: 0.03,
      invert: false,
      ...initialValues == null ? void 0 : initialValues.config
    },
    xConfig: {
      color: [255, 0, 0],
      invert: false,
      ...initialValues == null ? void 0 : initialValues.xConfig
    },
    yConfig: {
      color: [255, 255, 0],
      invert: false,
      ...initialValues == null ? void 0 : initialValues.yConfig
    },
    zConfig: {
      color: [0, 128, 0],
      invert: false,
      ...initialValues == null ? void 0 : initialValues.zConfig
    }
  };
}
function extend147(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkActor$1.extend(publicAPI, model, defaultValues13(initialValues));
  macro.setGet(publicAPI, model, ["config", "xConfig", "yConfig", "zConfig"]);
  vtkAxesActor(publicAPI, model);
}
var newInstance141 = macro.newInstance(extend147, "vtkAxesActor");
var vtkAxesActor$1 = {
  newInstance: newInstance141,
  extend: extend147
};

// node_modules/@kitware/vtk.js/Rendering/Core/CellPicker.js
function createCellMap() {
  return {
    [CellType.VTK_LINE]: vtkLine$1.newInstance(),
    [CellType.VTK_POLY_LINE]: vtkPolyLine$1.newInstance(),
    [CellType.VTK_TRIANGLE]: vtkTriangle$1.newInstance(),
    [CellType.VTK_QUAD]: vtkQuad$1.newInstance()
  };
}
function clipLineWithPlane(mapper, matrix, p1, p2) {
  const outObj = {
    planeId: -1,
    t1: 0,
    t2: 1,
    intersect: 0
  };
  const nbClippingPlanes = mapper.getNumberOfClippingPlanes();
  const plane = [];
  for (let i = 0; i < nbClippingPlanes; i++) {
    mapper.getClippingPlaneInDataCoords(matrix, i, plane);
    const d1 = plane[0] * p1[0] + plane[1] * p1[1] + plane[2] * p1[2] + plane[3];
    const d2 = plane[0] * p2[0] + plane[1] * p2[1] + plane[2] * p2[2] + plane[3];
    if (d1 < 0 && d2 < 0) {
      return 0;
    }
    if (d1 < 0 || d2 < 0) {
      let t = 0;
      if (d1 !== 0) {
        t = d1 / (d1 - d2);
      }
      if (d1 < 0) {
        if (t >= outObj.t1) {
          outObj.t1 = t;
          outObj.planeId = i;
        }
      } else if (t <= outObj.t2) {
        outObj.t2 = t;
      }
      if (outObj.t1 > outObj.t2) {
        outObj.intersect = 0;
        return outObj;
      }
    }
  }
  outObj.intersect = 1;
  return outObj;
}
var STATIC13 = {
  clipLineWithPlane
};
function vtkCellPicker(publicAPI, model) {
  model.classHierarchy.push("vtkCellPicker");
  const superClass = {
    ...publicAPI
  };
  function resetCellPickerInfo() {
    model.cellId = -1;
    model.pCoords[0] = 0;
    model.pCoords[1] = 0;
    model.pCoords[2] = 0;
    model.cellIJK[0] = 0;
    model.cellIJK[1] = 0;
    model.cellIJK[2] = 0;
    model.mapperNormal[0] = 0;
    model.mapperNormal[1] = 0;
    model.mapperNormal[2] = 1;
    model.pickNormal[0] = 0;
    model.pickNormal[1] = 0;
    model.pickNormal[2] = 1;
  }
  function resetPickInfo() {
    model.dataSet = null;
    model.mapper = null;
    resetCellPickerInfo();
  }
  publicAPI.initialize = () => {
    resetPickInfo();
    superClass.initialize();
  };
  publicAPI.computeSurfaceNormal = (data2, cell, weights, normal) => {
    const normals = data2.getPointData().getNormals();
    if (normals) {
      normal[0] = 0;
      normal[1] = 0;
      normal[2] = 0;
      const pointNormal = [];
      for (let i = 0; i < 3; i++) {
        normals.getTuple(cell.getPointsIds()[i], pointNormal);
        normal[0] += pointNormal[0] * weights[i];
        normal[1] += pointNormal[1] * weights[i];
        normal[2] += pointNormal[2] * weights[i];
      }
      normalize(normal);
    } else {
      return 0;
    }
    return 1;
  };
  publicAPI.pick = (selection, renderer) => {
    publicAPI.initialize();
    const pickResult = superClass.pick(selection, renderer);
    if (pickResult) {
      const camera = renderer.getActiveCamera();
      const cameraPos = [];
      camera.getPosition(cameraPos);
      if (camera.getParallelProjection()) {
        const cameraFocus = [];
        camera.getFocalPoint(cameraFocus);
        model.pickNormal[0] = cameraPos[0] - cameraFocus[0];
        model.pickNormal[1] = cameraPos[1] - cameraFocus[1];
        model.pickNormal[2] = cameraPos[2] - cameraFocus[2];
      } else {
        model.pickNormal[0] = cameraPos[0] - model.pickPosition[0];
        model.pickNormal[1] = cameraPos[1] - model.pickPosition[1];
        model.pickNormal[2] = cameraPos[2] - model.pickPosition[2];
      }
      normalize(model.pickNormal);
    }
    return pickResult;
  };
  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {
    let tMin = Number.MAX_VALUE;
    let t1 = 0;
    let t2 = 1;
    const vtkCellPickerPlaneTol = 1e-14;
    const clipLine = clipLineWithPlane(mapper, model.transformMatrix, p1, p2);
    if (mapper && !clipLine.intersect) {
      return Number.MAX_VALUE;
    }
    if (mapper.isA("vtkImageMapper") || mapper.isA("vtkImageArrayMapper")) {
      const pickData = mapper.intersectWithLineForCellPicking(p1, p2);
      if (pickData) {
        tMin = pickData.t;
        model.cellIJK = pickData.ijk;
        model.pCoords = pickData.pCoords;
      }
    } else if (mapper.isA("vtkVolumeMapper")) {
      const interceptionObject = vtkBox$1.intersectWithLine(mapper.getBounds(), p1, p2);
      t1 = (interceptionObject == null ? void 0 : interceptionObject.t1) > clipLine.t1 ? interceptionObject.t1 : clipLine.t1;
      t2 = (interceptionObject == null ? void 0 : interceptionObject.t2) < clipLine.t2 ? interceptionObject.t2 : clipLine.t2;
      tMin = model.intersectVolumeWithLine(p1, p2, t1, t2, tolerance, prop);
    } else if (mapper.isA("vtkMapper")) {
      tMin = model.intersectActorWithLine(p1, p2, t1, t2, tolerance, mapper);
    }
    if (tMin < model.globalTMin) {
      model.globalTMin = tMin;
      if (Math.abs(tMin - t1) < vtkCellPickerPlaneTol && clipLine.clippingPlaneId >= 0) {
        model.mapperPosition[0] = p1[0] * (1 - t1) + p2[0] * t1;
        model.mapperPosition[1] = p1[1] * (1 - t1) + p2[1] * t1;
        model.mapperPosition[2] = p1[2] * (1 - t1) + p2[2] * t1;
        const plane = [];
        mapper.getClippingPlaneInDataCoords(model.transformMatrix, clipLine.clippingPlaneId, plane);
        normalize(plane);
        model.mapperNormal[0] = -plane[0];
        model.mapperNormal[1] = -plane[1];
        model.mapperNormal[2] = -plane[2];
      }
      vec3_exports.transformMat4(model.pickPosition, model.mapperPosition, model.transformMatrix);
      const mat = model.transformMatrix;
      model.mapperNormal[0] = mat[0] * model.pickNormal[0] + mat[4] * model.pickNormal[1] + mat[8] * model.pickNormal[2];
      model.mapperNormal[1] = mat[1] * model.pickNormal[0] + mat[5] * model.pickNormal[1] + mat[9] * model.pickNormal[2];
      model.mapperNormal[2] = mat[2] * model.pickNormal[0] + mat[6] * model.pickNormal[1] + mat[10] * model.pickNormal[2];
    }
    return tMin;
  };
  model.intersectVolumeWithLine = (p1, p2, t1, t2, tolerance, volume) => {
    let tMin = Number.MAX_VALUE;
    const mapper = volume.getMapper();
    const imageData = mapper.getInputData();
    const dims = imageData.getDimensions();
    const scalars = imageData.getPointData().getScalars().getData();
    const extent = imageData.getExtent();
    const imageTransform = imageData.getWorldToIndex();
    const numIComps = 1;
    let oWidth = mapper.getOpacityTextureWidth();
    if (oWidth <= 0) {
      oWidth = 1024;
    }
    const tmpTable = new Float32Array(oWidth);
    const opacityArray = new Float32Array(oWidth);
    let ofun;
    let oRange;
    const sampleDist = volume.getMapper().getSampleDistance();
    for (let c2 = 0; c2 < numIComps; ++c2) {
      ofun = volume.getProperty().getScalarOpacity(c2);
      oRange = ofun.getRange();
      ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
      const opacityFactor = sampleDist / volume.getProperty().getScalarOpacityUnitDistance(c2);
      for (let i = 0; i < oWidth; ++i) {
        opacityArray[i] = 1 - (1 - tmpTable[i]) ** opacityFactor;
      }
    }
    const scale = oWidth / (oRange[1] - oRange[0] + 1);
    const q1 = [0, 0, 0, 1];
    const q2 = [0, 0, 0, 1];
    q1[0] = p1[0];
    q1[1] = p1[1];
    q1[2] = p1[2];
    q2[0] = p2[0];
    q2[1] = p2[1];
    q2[2] = p2[2];
    if (t1 !== 0 || t2 !== 1) {
      for (let j = 0; j < 3; j++) {
        q1[j] = p1[j] * (1 - t1) + p2[j] * t1;
        q2[j] = p1[j] * (1 - t2) + p2[j] * t2;
      }
    }
    const x1 = [0, 0, 0, 0];
    const x2 = [0, 0, 0, 0];
    vec4_exports.transformMat4(x1, q1, imageTransform);
    vec4_exports.transformMat4(x2, q2, imageTransform);
    const x = [0, 0, 0];
    const xi = [0, 0, 0];
    const sliceSize = dims[1] * dims[0];
    const rowSize = dims[0];
    const step = 1 / Math.sqrt(distance2BetweenPoints(x1, x2));
    let insideVolume;
    for (let t = 0; t < 1; t += step) {
      insideVolume = true;
      for (let j = 0; j < 3; j++) {
        x[j] = x1[j] * (1 - t) + x2[j] * t;
      }
      for (let j = 0; j < 3; j++) {
        if (x[j] < extent[2 * j]) {
          x[j] = extent[2 * j];
          insideVolume = false;
        } else if (x[j] > extent[2 * j + 1]) {
          x[j] = extent[2 * j + 1];
          insideVolume = false;
        }
        xi[j] = Math.round(x[j]);
      }
      if (insideVolume) {
        const index = xi[2] * sliceSize + xi[1] * rowSize + xi[0];
        let value = scalars[index];
        if (value < oRange[0]) {
          value = oRange[0];
        } else if (value > oRange[1]) {
          value = oRange[1];
        }
        value = Math.floor((value - oRange[0]) * scale);
        const opacity = tmpTable[value];
        if (opacity > model.opacityThreshold) {
          tMin = t1 * (1 - t) + t2 * t;
          break;
        }
      }
    }
    return tMin;
  };
  model.intersectActorWithLine = (p1, p2, t1, t2, tolerance, mapper) => {
    let tMin = Number.MAX_VALUE;
    const minXYZ = [0, 0, 0];
    let pDistMin = Number.MAX_VALUE;
    const minPCoords = [0, 0, 0];
    let minCellId = null;
    let minCell = null;
    let minCellType = null;
    let subId = null;
    const x = [];
    const data2 = mapper.getInputData();
    const q1 = [0, 0, 0];
    const q2 = [0, 0, 0];
    q1[0] = p1[0];
    q1[1] = p1[1];
    q1[2] = p1[2];
    q2[0] = p2[0];
    q2[1] = p2[1];
    q2[2] = p2[2];
    if (t1 !== 0 || t2 !== 1) {
      for (let j = 0; j < 3; j++) {
        q1[j] = p1[j] * (1 - t1) + p2[j] * t1;
        q2[j] = p1[j] * (1 - t2) + p2[j] * t2;
      }
    }
    if (data2.getCells) {
      if (!data2.getCells()) {
        data2.buildLinks();
      }
      const tempCellMap = createCellMap();
      const minCellMap = createCellMap();
      const numberOfCells = data2.getNumberOfCells();
      for (let cellId = 0; cellId < numberOfCells; cellId++) {
        const pCoords = [0, 0, 0];
        minCellType = data2.getCellType(cellId);
        if (minCellType === CellType.VTK_EMPTY_CELL) {
          continue;
        }
        const cell = tempCellMap[minCellType];
        if (cell == null) {
          continue;
        }
        minCell = minCellMap[minCellType];
        data2.getCell(cellId, cell);
        let cellPicked;
        {
          if (vtkCellTypes$1.hasSubCells(minCellType)) {
            cellPicked = cell.intersectWithLine(t1, t2, p1, p2, tolerance, x, pCoords);
          } else {
            cellPicked = cell.intersectWithLine(p1, p2, tolerance, x, pCoords);
          }
        }
        if (cellPicked.intersect === 1 && cellPicked.t <= tMin + model.tolerance && cellPicked.t >= t1 && cellPicked.t <= t2) {
          const pDist = cell.getParametricDistance(pCoords);
          if (pDist < pDistMin || pDist === pDistMin && cellPicked.t < tMin) {
            tMin = cellPicked.t;
            pDistMin = pDist;
            subId = cellPicked.subId;
            minCellId = cellId;
            cell.deepCopy(minCell);
            for (let k = 0; k < 3; k++) {
              minXYZ[k] = x[k];
              minPCoords[k] = pCoords[k];
            }
          }
        }
      }
    }
    if (minCellId >= 0 && tMin < model.globalTMin) {
      resetPickInfo();
      const nbPointsInCell = minCell.getNumberOfPoints();
      const weights = new Array(nbPointsInCell);
      for (let i = 0; i < nbPointsInCell; i++) {
        weights[i] = 0;
      }
      const point = [];
      if (vtkCellTypes$1.hasSubCells(minCellType)) {
        minCell.evaluateLocation(subId, minPCoords, point, weights);
      } else {
        minCell.evaluateLocation(minPCoords, point, weights);
      }
      model.dataSet = data2;
      model.cellId = minCellId;
      model.pCoords[0] = minPCoords[0];
      model.pCoords[1] = minPCoords[1];
      model.pCoords[2] = minPCoords[2];
      let maxWeight = 0;
      let iMaxWeight = -1;
      for (let i = 0; i < nbPointsInCell; i++) {
        if (weights[i] > maxWeight) {
          iMaxWeight = i;
          maxWeight = weights[i];
        }
      }
      if (iMaxWeight !== -1) {
        model.pointId = minCell.getPointsIds()[iMaxWeight];
      }
      model.mapperPosition[0] = minXYZ[0];
      model.mapperPosition[1] = minXYZ[1];
      model.mapperPosition[2] = minXYZ[2];
      if (!publicAPI.computeSurfaceNormal(data2, minCell, weights, model.mapperNormal)) {
        model.mapperNormal[0] = p1[0] - p2[0];
        model.mapperNormal[1] = p1[1] - p2[1];
        model.mapperNormal[2] = p1[2] - p2[2];
        normalize(model.mapperNormal);
      }
    }
    return tMin;
  };
}
var DEFAULT_VALUES135 = {
  cellId: -1,
  pCoords: [],
  cellIJK: [],
  pickNormal: [],
  mapperNormal: [],
  opacityThreshold: 0.2
};
function extend148(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES135, initialValues);
  vtkPicker$1.extend(publicAPI, model, initialValues);
  macro.getArray(publicAPI, model, ["pickNormal", "mapperNormal", "pCoords", "cellIJK"]);
  macro.setGet(publicAPI, model, ["opacityThreshold"]);
  macro.get(publicAPI, model, ["cellId"]);
  vtkCellPicker(publicAPI, model);
}
var newInstance142 = macro.newInstance(extend148, "vtkCellPicker");
var vtkCellPicker$1 = {
  newInstance: newInstance142,
  extend: extend148,
  ...STATIC13
};

// node_modules/@kitware/vtk.js/Rendering/Core/Follower.js
function vtkFollower(publicAPI, model) {
  model.classHierarchy.push("vtkFollower");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.camera !== null) {
      const time = model.camera.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.computeMatrix = () => {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      mat4_exports.identity(model.matrix);
      if (model.userMatrix) {
        mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, model.origin);
      mat4_exports.translate(model.matrix, model.matrix, model.position);
      mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
      mat4_exports.scale(model.matrix, model.matrix, model.scale);
      if (model.camera) {
        const vup = new Float64Array(model.viewUp);
        if (!model.useViewUp) {
          vec3_exports.set(vup, ...model.camera.getViewUp());
        }
        const vpn = new Float64Array(3);
        if (model.camera.getParallelProjection()) {
          vec3_exports.set(vpn, ...model.camera.getViewPlaneNormal());
        } else {
          vec3_exports.set(vpn, ...model.position);
          vec3_exports.subtract(vpn, model.camera.getPosition(), vpn);
          vec3_exports.normalize(vpn, vpn);
        }
        const vright = new Float64Array(3);
        vec3_exports.cross(vright, vup, vpn);
        vec3_exports.normalize(vright, vright);
        vec3_exports.cross(vpn, vright, vup);
        vec3_exports.normalize(vpn, vpn);
        model.followerMatrix[0] = vright[0];
        model.followerMatrix[1] = vright[1];
        model.followerMatrix[2] = vright[2];
        model.followerMatrix[4] = vup[0];
        model.followerMatrix[5] = vup[1];
        model.followerMatrix[6] = vup[2];
        model.followerMatrix[8] = vpn[0];
        model.followerMatrix[9] = vpn[1];
        model.followerMatrix[10] = vpn[2];
        mat4_exports.multiply(model.matrix, model.matrix, model.followerMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      mat4_exports.transpose(model.matrix, model.matrix);
      model.isIdentity = false;
      model.matrixMTime.modified();
    }
  };
}
var DEFAULT_VALUES136 = {
  viewUp: [0, 1, 0],
  useViewUp: false,
  camera: null
};
function extend149(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES136, initialValues);
  vtkActor$1.extend(publicAPI, model, initialValues);
  model.followerMatrix = mat4_exports.identity(new Float64Array(16));
  macro.setGet(publicAPI, model, ["useViewUp", "camera"]);
  macro.setGetArray(publicAPI, model, ["viewUp"], 3);
  vtkFollower(publicAPI, model);
}
var newInstance143 = macro.newInstance(extend149, "vtkFollower");
var vtkFollower$1 = {
  newInstance: newInstance143,
  extend: extend149
};

// node_modules/@kitware/vtk.js/Rendering/Core/Glyph3DMapper/Constants.js
var OrientationModes = {
  DIRECTION: 0,
  ROTATION: 1,
  MATRIX: 2
};
var ScaleModes = {
  SCALE_BY_CONSTANT: 0,
  SCALE_BY_MAGNITUDE: 1,
  SCALE_BY_COMPONENTS: 2
};
var Constants14 = {
  OrientationModes,
  ScaleModes
};

// node_modules/@kitware/vtk.js/Rendering/Core/Glyph3DMapper.js
var {
  OrientationModes: OrientationModes2,
  ScaleModes: ScaleModes2
} = Constants14;
var {
  vtkErrorMacro: vtkErrorMacro59
} = macro;
function vtkGlyph3DMapper(publicAPI, model) {
  model.classHierarchy.push("vtkGlyph3DMapper");
  publicAPI.getOrientationModeAsString = () => macro.enumToString(OrientationModes2, model.orientationMode);
  publicAPI.setOrientationModeToDirection = () => publicAPI.setOrientationMode(OrientationModes2.DIRECTION);
  publicAPI.setOrientationModeToRotation = () => publicAPI.setOrientationMode(OrientationModes2.ROTATION);
  publicAPI.setOrientationModeToMatrix = () => publicAPI.setOrientationMode(OrientationModes2.MATRIX);
  publicAPI.getOrientationArrayData = () => {
    const idata = publicAPI.getInputData(0);
    if (!idata || !idata.getPointData()) {
      return null;
    }
    if (!model.orientationArray) {
      return idata.getPointData().getVectors();
    }
    return idata.getPointData().getArray(model.orientationArray);
  };
  publicAPI.getScaleModeAsString = () => macro.enumToString(ScaleModes2, model.scaleMode);
  publicAPI.setScaleModeToScaleByMagnitude = () => publicAPI.setScaleMode(ScaleModes2.SCALE_BY_MAGNITUDE);
  publicAPI.setScaleModeToScaleByComponents = () => publicAPI.setScaleMode(ScaleModes2.SCALE_BY_COMPONENTS);
  publicAPI.setScaleModeToScaleByConstant = () => publicAPI.setScaleMode(ScaleModes2.SCALE_BY_CONSTANT);
  publicAPI.getScaleArrayData = () => {
    const idata = publicAPI.getInputData(0);
    if (!idata || !idata.getPointData()) {
      return null;
    }
    if (!model.scaleArray) {
      return idata.getPointData().getScalars();
    }
    return idata.getPointData().getArray(model.scaleArray);
  };
  publicAPI.getBounds = () => {
    const idata = publicAPI.getInputData(0);
    const gdata = publicAPI.getInputData(1);
    if (!idata || !gdata) {
      return createUninitializedBounds();
    }
    publicAPI.buildArrays();
    return model.bounds;
  };
  publicAPI.buildArrays = () => {
    const idata = publicAPI.getInputData(0);
    const gdata = publicAPI.getInputData(1);
    if (model.buildTime.getMTime() < gdata.getMTime() || model.buildTime.getMTime() < idata.getMTime() || model.buildTime.getMTime() < publicAPI.getMTime()) {
      const pts = idata.getPoints().getData();
      let sArray = publicAPI.getScaleArrayData();
      let sData = null;
      let numSComp = 0;
      if (sArray) {
        sData = sArray.getData();
        numSComp = sArray.getNumberOfComponents();
      }
      if (model.scaling && sArray && model.scaleMode === ScaleModes2.SCALE_BY_COMPONENTS && sArray.getNumberOfComponents() !== 3) {
        vtkErrorMacro59("Cannot scale by components since scale array does not have 3 components.");
        sArray = null;
      }
      const gbounds = gdata.getBounds();
      const corners = [];
      vtkBoundingBox.getCorners(gbounds, corners);
      model.bounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
      model.bounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
      model.bounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
      model.bounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
      model.bounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
      model.bounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
      const tcorner = new Float64Array(3);
      const oArray = publicAPI.getOrientationArrayData();
      const identity = mat4_exports.identity(new Float64Array(16));
      const trans = [];
      const scale = [];
      const numPts = pts.length / 3;
      model.matrixArray = new Float32Array(16 * numPts);
      const mbuff = model.matrixArray.buffer;
      model.normalArray = new Float32Array(9 * numPts);
      const nbuff = model.normalArray.buffer;
      const tuple = [];
      const orientation3 = [];
      for (let i = 0; i < numPts; ++i) {
        const z = new Float32Array(mbuff, i * 64, 16);
        trans[0] = pts[i * 3];
        trans[1] = pts[i * 3 + 1];
        trans[2] = pts[i * 3 + 2];
        mat4_exports.translate(z, identity, trans);
        if (oArray) {
          oArray.getTuple(i, orientation3);
          switch (model.orientationMode) {
            case OrientationModes2.MATRIX: {
              const rotMat4 = [...orientation3.slice(0, 3), 0, ...orientation3.slice(3, 6), 0, ...orientation3.slice(6, 9), 0, 0, 0, 0, 1];
              mat4_exports.multiply(z, z, rotMat4);
              break;
            }
            case OrientationModes2.ROTATION:
              mat4_exports.rotateZ(z, z, orientation3[2]);
              mat4_exports.rotateX(z, z, orientation3[0]);
              mat4_exports.rotateY(z, z, orientation3[1]);
              break;
            case OrientationModes2.DIRECTION:
              if (orientation3[1] === 0 && orientation3[2] === 0) {
                if (orientation3[0] < 0) {
                  mat4_exports.rotateY(z, z, 3.1415926);
                }
              } else {
                const vMag = norm(orientation3);
                const vNew = [];
                vNew[0] = (orientation3[0] + vMag) / 2;
                vNew[1] = orientation3[1] / 2;
                vNew[2] = orientation3[2] / 2;
                mat4_exports.rotate(z, z, 3.1415926, vNew);
              }
              break;
          }
        }
        if (model.scaling) {
          scale[0] = model.scaleFactor;
          scale[1] = model.scaleFactor;
          scale[2] = model.scaleFactor;
          if (sArray) {
            switch (model.scaleMode) {
              case ScaleModes2.SCALE_BY_MAGNITUDE:
                for (let t = 0; t < numSComp; ++t) {
                  tuple[t] = sData[i * numSComp + t];
                }
                scale[0] *= norm(tuple, numSComp);
                scale[1] = scale[0];
                scale[2] = scale[0];
                break;
              case ScaleModes2.SCALE_BY_COMPONENTS:
                for (let t = 0; t < numSComp; ++t) {
                  tuple[t] = sData[i * numSComp + t];
                }
                scale[0] *= tuple[0];
                scale[1] *= tuple[1];
                scale[2] *= tuple[2];
                break;
              case ScaleModes2.SCALE_BY_CONSTANT:
            }
          }
          if (scale[0] === 0) {
            scale[0] = 1e-10;
          }
          if (scale[1] === 0) {
            scale[1] = 1e-10;
          }
          if (scale[2] === 0) {
            scale[2] = 1e-10;
          }
          mat4_exports.scale(z, z, scale);
        }
        for (let p = 0; p < 8; ++p) {
          vec3_exports.transformMat4(tcorner, corners[p], z);
          if (tcorner[0] < model.bounds[0]) {
            model.bounds[0] = tcorner[0];
          }
          if (tcorner[1] < model.bounds[2]) {
            model.bounds[2] = tcorner[1];
          }
          if (tcorner[2] < model.bounds[4]) {
            model.bounds[4] = tcorner[2];
          }
          if (tcorner[0] > model.bounds[1]) {
            model.bounds[1] = tcorner[0];
          }
          if (tcorner[1] > model.bounds[3]) {
            model.bounds[3] = tcorner[1];
          }
          if (tcorner[2] > model.bounds[5]) {
            model.bounds[5] = tcorner[2];
          }
        }
        const n = new Float32Array(nbuff, i * 36, 9);
        mat3_exports.fromMat4(n, z);
        mat3_exports.invert(n, n);
        mat3_exports.transpose(n, n);
      }
      const scalars = publicAPI.getAbstractScalars(idata, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
      if (!model.useLookupTableScalarRange) {
        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
      }
      model.colorArray = null;
      const lut = publicAPI.getLookupTable();
      if (lut && scalars) {
        lut.build();
        model.colorArray = lut.mapScalars(scalars, model.colorMode, 0);
      }
      model.buildTime.modified();
    }
  };
  publicAPI.getPrimitiveCount = () => {
    const glyph = publicAPI.getInputData(1);
    const mult = publicAPI.getInputData().getPoints().getNumberOfValues() / 3;
    const pcount = {
      points: mult * glyph.getPoints().getNumberOfValues() / 3,
      verts: mult * (glyph.getVerts().getNumberOfValues() - glyph.getVerts().getNumberOfCells()),
      lines: mult * (glyph.getLines().getNumberOfValues() - 2 * glyph.getLines().getNumberOfCells()),
      triangles: mult * (glyph.getPolys().getNumberOfValues() - 3 * glyph.getLines().getNumberOfCells())
    };
    return pcount;
  };
  publicAPI.setSourceConnection = (outputPort) => publicAPI.setInputConnection(outputPort, 1);
}
var DEFAULT_VALUES137 = {
  orient: true,
  orientationMode: OrientationModes2.DIRECTION,
  orientationArray: null,
  scaling: true,
  scaleFactor: 1,
  scaleMode: ScaleModes2.SCALE_BY_MAGNITUDE,
  scaleArray: null,
  matrixArray: null,
  normalArray: null,
  colorArray: null
};
function extend150(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES137, initialValues);
  vtkMapper$1.extend(publicAPI, model, initialValues);
  macro.algo(publicAPI, model, 2, 0);
  model.buildTime = {};
  macro.obj(model.buildTime, {
    mtime: 0
  });
  model.boundsTime = {};
  macro.obj(model.boundsTime, {
    mtime: 0
  });
  macro.setGet(publicAPI, model, ["orient", "orientationMode", "orientationArray", "scaleArray", "scaleFactor", "scaleMode", "scaling"]);
  macro.get(publicAPI, model, ["colorArray", "matrixArray", "normalArray", "buildTime"]);
  vtkGlyph3DMapper(publicAPI, model);
}
var newInstance144 = macro.newInstance(extend150, "vtkGlyph3DMapper");
var vtkGlyph3DMapper$1 = {
  newInstance: newInstance144,
  extend: extend150,
  ...Constants14
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var SlicingMode = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5
};
var Constants15 = {
  SlicingMode
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper.js
function vtkAbstractImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractImageMapper");
  publicAPI.getIsOpaque = () => true;
  publicAPI.getCurrentImage = () => null;
  publicAPI.getBoundsForSlice = () => {
    macro.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED");
    return createUninitializedBounds();
  };
}
var DEFAULT_VALUES138 = {
  slice: 0,
  customDisplayExtent: [0, 0, 0, 0, 0, 0],
  useCustomExtents: false,
  backgroundColor: [0, 0, 0, 1],
  colorTextureWidth: 1024,
  opacityTextureWidth: 1024,
  labelOutlineTextureWidth: 1024
};
function extend151(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES138, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["slice", "useCustomExtents", "colorTextureWidth", "opacityTextureWidth", "labelOutlineTextureWidth"]);
  macro.setGetArray(publicAPI, model, ["customDisplayExtent"], 6);
  macro.setGetArray(publicAPI, model, ["backgroundColor"], 4);
  vtkAbstractImageMapper(publicAPI, model);
}
var vtkAbstractImageMapper$1 = {
  extend: extend151
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper/helper.js
function doPicking(p1, p2, mapper) {
  const imageData = mapper.getCurrentImage();
  const extent = imageData.getExtent();
  const ijk = [extent[0], extent[2], extent[4]];
  const {
    ijkMode
  } = mapper.getClosestIJKAxis();
  let nSlice = mapper.isA("vtkImageArrayMapper") ? mapper.getSubSlice() : mapper.getSlice();
  if (ijkMode !== mapper.getSlicingMode()) {
    nSlice = mapper.getSliceAtPosition(nSlice);
  }
  ijk[ijkMode] += nSlice;
  const worldOrigin = [0, 0, 0];
  imageData.indexToWorld(ijk, worldOrigin);
  ijk[ijkMode] += 1;
  const worldNormal = [0, 0, 0];
  imageData.indexToWorld(ijk, worldNormal);
  worldNormal[0] -= worldOrigin[0];
  worldNormal[1] -= worldOrigin[1];
  worldNormal[2] -= worldOrigin[2];
  vec3_exports.normalize(worldNormal, worldNormal);
  const intersect = vtkPlane$1.intersectWithLine(p1, p2, worldOrigin, worldNormal);
  if (intersect.intersection) {
    const point = intersect.x;
    const absoluteIJK = [0, 0, 0];
    imageData.worldToIndex(point, absoluteIJK);
    return {
      t: intersect.t,
      absoluteIJK
    };
  }
  return null;
}
function intersectWithLineForPointPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];
    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {
      return null;
    }
    return {
      t: pickingData.t,
      ijk
    };
  }
  return null;
}
function intersectWithLineForCellPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const absIJK = pickingData.absoluteIJK;
    const ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];
    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] || // handle single-slice images
    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {
      return null;
    }
    const pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];
    return {
      t: pickingData.t,
      ijk,
      pCoords
    };
  }
  return null;
}

// node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js
var {
  staticOffsetAPI,
  otherStaticMethods
} = CoincidentTopologyHelper;
var {
  SlicingMode: SlicingMode2
} = Constants15;
function vtkImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkImageMapper");
  publicAPI.getSliceAtPosition = (pos) => {
    const image = publicAPI.getCurrentImage();
    let pos3;
    if (pos.length === 3) {
      pos3 = pos;
    } else if (Number.isFinite(pos)) {
      const bds = image.getBounds();
      switch (model.slicingMode) {
        case SlicingMode2.X:
          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode2.Y:
          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode2.Z:
          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];
          break;
      }
    }
    const ijk = [0, 0, 0];
    image.worldToIndex(pos3, ijk);
    const ex = image.getExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let slice = 0;
    switch (ijkMode) {
      case SlicingMode2.I:
        slice = clampValue(ijk[0], ex[0], ex[1]);
        break;
      case SlicingMode2.J:
        slice = clampValue(ijk[1], ex[2], ex[3]);
        break;
      case SlicingMode2.K:
        slice = clampValue(ijk[2], ex[4], ex[5]);
        break;
      default:
        return 0;
    }
    return slice;
  };
  publicAPI.setSliceFromCamera = (cam) => {
    const fp = cam.getFocalPoint();
    switch (model.slicingMode) {
      case SlicingMode2.I:
      case SlicingMode2.J:
      case SlicingMode2.K:
        {
          const slice = publicAPI.getSliceAtPosition(fp);
          publicAPI.setSlice(slice);
        }
        break;
      case SlicingMode2.X:
        publicAPI.setSlice(fp[0]);
        break;
      case SlicingMode2.Y:
        publicAPI.setSlice(fp[1]);
        break;
      case SlicingMode2.Z:
        publicAPI.setSlice(fp[2]);
        break;
    }
  };
  publicAPI.setXSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode2.X);
    publicAPI.setSlice(id);
  };
  publicAPI.setYSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode2.Y);
    publicAPI.setSlice(id);
  };
  publicAPI.setZSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode2.Z);
    publicAPI.setSlice(id);
  };
  publicAPI.setISlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode2.I);
    publicAPI.setSlice(id);
  };
  publicAPI.setJSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode2.J);
    publicAPI.setSlice(id);
  };
  publicAPI.setKSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode2.K);
    publicAPI.setSlice(id);
  };
  publicAPI.getSlicingModeNormal = () => {
    const out = [0, 0, 0];
    const mat3 = publicAPI.getCurrentImage().getDirection();
    switch (model.slicingMode) {
      case SlicingMode2.X:
        out[0] = 1;
        break;
      case SlicingMode2.Y:
        out[1] = 1;
        break;
      case SlicingMode2.Z:
        out[2] = 1;
        break;
      case SlicingMode2.I:
        multiply3x3_vect3(mat3, [1, 0, 0], out);
        break;
      case SlicingMode2.J:
        multiply3x3_vect3(mat3, [0, 1, 0], out);
        break;
      case SlicingMode2.K:
        multiply3x3_vect3(mat3, [0, 0, 1], out);
        break;
    }
    return out;
  };
  function computeClosestIJKAxis() {
    let xyzMode;
    switch (model.slicingMode) {
      case SlicingMode2.X:
        xyzMode = 0;
        break;
      case SlicingMode2.Y:
        xyzMode = 1;
        break;
      case SlicingMode2.Z:
        xyzMode = 2;
        break;
      default:
        model.closestIJKAxis = {
          ijkMode: model.slicingMode,
          flip: false
        };
        return;
    }
    const direction3 = publicAPI.getCurrentImage().getDirection();
    const newMatrix = getSparseOrthogonalMatrix(direction3);
    let ijkMode = 0;
    for (; ijkMode < 3; ++ijkMode) {
      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {
        break;
      }
    }
    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;
    model.closestIJKAxis = {
      ijkMode,
      flip
    };
  }
  publicAPI.setSlicingMode = (mode) => {
    if (model.slicingMode === mode) {
      return;
    }
    model.slicingMode = mode;
    if (publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    publicAPI.modified();
  };
  publicAPI.getClosestIJKAxis = () => {
    if ((model.closestIJKAxis === void 0 || model.closestIJKAxis.ijkMode === SlicingMode2.NONE) && publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    return model.closestIJKAxis;
  };
  publicAPI.getBounds = () => {
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return createUninitializedBounds();
    }
    if (!model.useCustomExtents) {
      return image.getBounds();
    }
    const ex = model.customDisplayExtent.slice();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = model.slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(model.slice);
    }
    switch (ijkMode) {
      case SlicingMode2.I:
        ex[0] = nSlice;
        ex[1] = nSlice;
        break;
      case SlicingMode2.J:
        ex[2] = nSlice;
        ex[3] = nSlice;
        break;
      case SlicingMode2.K:
        ex[4] = nSlice;
        ex[5] = nSlice;
        break;
    }
    return image.extentToBounds(ex);
  };
  publicAPI.getBoundsForSlice = function() {
    let slice = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.slice;
    let halfThickness = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return createUninitializedBounds();
    }
    const extent = image.getSpatialExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(slice);
    }
    switch (ijkMode) {
      case SlicingMode2.I:
        extent[0] = nSlice - halfThickness;
        extent[1] = nSlice + halfThickness;
        break;
      case SlicingMode2.J:
        extent[2] = nSlice - halfThickness;
        extent[3] = nSlice + halfThickness;
        break;
      case SlicingMode2.K:
        extent[4] = nSlice - halfThickness;
        extent[5] = nSlice + halfThickness;
        break;
    }
    return image.extentToBounds(extent);
  };
  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);
  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);
  publicAPI.getCurrentImage = () => publicAPI.getInputData();
}
var DEFAULT_VALUES139 = {
  slicingMode: SlicingMode2.NONE,
  closestIJKAxis: {
    ijkMode: SlicingMode2.NONE,
    flip: false
  },
  renderToRectangle: false,
  sliceAtFocalPoint: false,
  preferSizeOverAccuracy: false
  // Whether to use halfFloat representation of float, when it is inaccurate
};
function extend152(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES139, initialValues);
  vtkAbstractImageMapper$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["slicingMode"]);
  macro.setGet(publicAPI, model, ["closestIJKAxis", "renderToRectangle", "sliceAtFocalPoint", "preferSizeOverAccuracy"]);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkImageMapper(publicAPI, model);
}
var newInstance145 = macro.newInstance(extend152, "vtkImageMapper");
var vtkImageMapper$1 = {
  newInstance: newInstance145,
  extend: extend152,
  ...staticOffsetAPI,
  ...otherStaticMethods,
  ...Constants15
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var InterpolationType3 = {
  NEAREST: 0,
  LINEAR: 1
};
var Constants16 = {
  InterpolationType: InterpolationType3
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty.js
var {
  InterpolationType: InterpolationType4
} = Constants16;
var {
  vtkErrorMacro: vtkErrorMacro60
} = macro;
var VTK_MAX_VRCOMP2 = 4;
function vtkImageProperty(publicAPI, model) {
  model.classHierarchy.push("vtkImageProperty");
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index = 0; index < VTK_MAX_VRCOMP2; index++) {
      if (model.componentData[index].rGBTransferFunction) {
        time = model.componentData[index].rGBTransferFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index].piecewiseFunction) {
        time = model.componentData[index].piecewiseFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
    }
    return mTime;
  };
  publicAPI.setRGBTransferFunction = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    if (model.componentData[idx].rGBTransferFunction !== transferFunc) {
      model.componentData[idx].rGBTransferFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getRGBTransferFunction = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.componentData[idx].rGBTransferFunction;
  };
  publicAPI.setPiecewiseFunction = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    if (model.componentData[idx].piecewiseFunction !== transferFunc) {
      model.componentData[idx].piecewiseFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getPiecewiseFunction = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.componentData[idx].piecewiseFunction;
  };
  publicAPI.setScalarOpacity = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    return publicAPI.setPiecewiseFunction(idx, transferFunc);
  };
  publicAPI.getScalarOpacity = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return publicAPI.getPiecewiseFunction(idx);
  };
  publicAPI.setComponentWeight = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    if (index < 0 || index >= VTK_MAX_VRCOMP2) {
      vtkErrorMacro60("Invalid index");
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index].componentWeight !== val) {
      model.componentData[index].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (index < 0 || index >= VTK_MAX_VRCOMP2) {
      vtkErrorMacro60("Invalid index");
      return 0;
    }
    return model.componentData[index].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType4.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType4.LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macro.enumToString(InterpolationType4, model.interpolationType);
}
var defaultValues14 = (initialValues) => ({
  independentComponents: false,
  interpolationType: InterpolationType4.LINEAR,
  colorWindow: 255,
  colorLevel: 127.5,
  ambient: 1,
  diffuse: 0,
  opacity: 1,
  useLookupTableScalarRange: false,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1,
  updatedExtents: [],
  ...initialValues
});
function extend153(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues14(initialValues));
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0; i < VTK_MAX_VRCOMP2; i++) {
      model.componentData.push({
        rGBTransferFunction: null,
        piecewiseFunction: null,
        componentWeight: 1
      });
    }
  }
  macro.setGet(publicAPI, model, ["independentComponents", "interpolationType", "colorWindow", "colorLevel", "ambient", "diffuse", "opacity", "useLookupTableScalarRange", "useLabelOutline", "labelOutlineOpacity", "updatedExtents"]);
  macro.setGetArray(publicAPI, model, ["labelOutlineThickness"]);
  vtkImageProperty(publicAPI, model);
}
var newInstance146 = macro.newInstance(extend153, "vtkImageProperty");
var vtkImageProperty$1 = {
  newInstance: newInstance146,
  extend: extend153
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageResliceMapper/Constants.js
var SlabTypes = {
  MIN: 0,
  MAX: 1,
  MEAN: 2,
  SUM: 3
};
var Constants17 = {
  SlabTypes
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageResliceMapper.js
var {
  SlabTypes: SlabTypes2
} = Constants17;
var {
  staticOffsetAPI: staticOffsetAPI2,
  otherStaticMethods: otherStaticMethods2
} = CoincidentTopologyHelper;
function vtkImageResliceMapper(publicAPI, model) {
  model.classHierarchy.push("vtkImageResliceMapper");
  publicAPI.getBounds = () => {
    let bds = [...vtkBoundingBox.INIT_BOUNDS];
    const image = publicAPI.getInputData();
    if (publicAPI.getSlicePolyData()) {
      bds = publicAPI.getSlicePolyData().getBounds();
    } else if (image) {
      bds = image.getBounds();
      if (publicAPI.getSlicePlane()) {
        vtkBoundingBox.cutWithPlane(bds, publicAPI.getSlicePlane().getOrigin(), publicAPI.getSlicePlane().getNormal());
      }
    }
    return bds;
  };
}
var defaultValues15 = (initialValues) => ({
  slabThickness: 0,
  slabTrapezoidIntegration: 0,
  slabType: SlabTypes2.MEAN,
  slicePlane: null,
  slicePolyData: null,
  ...initialValues
});
function extend154(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues15(initialValues));
  vtkAbstractImageMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["slabThickness", "slabTrapezoidIntegration", "slabType", "slicePlane", "slicePolyData"]);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkImageResliceMapper(publicAPI, model);
}
var newInstance147 = macro.newInstance(extend154, "vtkImageResliceMapper");
var vtkImageResliceMapper$1 = {
  newInstance: newInstance147,
  extend: extend154,
  ...staticOffsetAPI2,
  ...otherStaticMethods2
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js
function vtkImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkImageSlice");
  publicAPI.getActors = () => publicAPI;
  publicAPI.getImages = () => publicAPI;
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.properties[0]) {
      publicAPI.getProperty();
    }
    let isOpaque = model.properties[0].getOpacity() >= 1;
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => false;
  publicAPI.makeProperty = vtkImageProperty$1.newInstance;
  publicAPI.getBoundsForSlice = (slice, thickness) => {
    const bds = model.mapper.getBoundsForSlice(slice, thickness);
    if (!vtkBoundingBox.isValid(bds)) {
      return bds;
    }
    publicAPI.computeMatrix();
    const tmp4 = new Float64Array(16);
    mat4_exports.transpose(tmp4, model.matrix);
    const newBounds = vtkBoundingBox.transformBounds(bds, tmp4);
    return newBounds;
  };
  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];
  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];
  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];
  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];
  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];
  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    model.properties.forEach((property) => {
      mt = Math.max(mt, property.getMTime());
      const rgbFunc = property.getRGBTransferFunction();
      if (rgbFunc !== null) {
        mt = Math.max(mt, rgbFunc.getMTime());
      }
    });
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
}
var DEFAULT_VALUES140 = {
  mapper: null,
  forceOpaque: false,
  forceTranslucent: false
};
function extend155(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES140, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.setGet(publicAPI, model, ["mapper", "forceOpaque", "forceTranslucent"]);
  vtkImageSlice(publicAPI, model);
}
var newInstance148 = macro.newInstance(extend155, "vtkImageSlice");
var vtkImageSlice$1 = {
  newInstance: newInstance148,
  extend: extend155
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper2D.js
var {
  ColorMode,
  ScalarMode: ScalarMode4,
  GetArray
} = Constants;
var {
  VectorMode
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes4
} = vtkDataArray$1;
function updateZigzaggingCoordinates(coordinates, dimensions) {
  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;
  coordinates[0] += directionX;
  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {
    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;
    coordinates[0] -= directionX;
    coordinates[1] += directionY;
    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {
      coordinates[1] -= directionY;
      coordinates[2]++;
    }
  }
}
function getIndexFromCoordinates(coordinates, dimensions) {
  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);
}
function getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {
  const intTexelIndex = Math.floor(texelIndexPosition);
  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);
  let xDirection;
  let xEndFlag;
  if (xCoordBeforeWrap < dimensions[0]) {
    textureCoordinate[0] = xCoordBeforeWrap;
    xDirection = 1;
    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;
  } else {
    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;
    xDirection = -1;
    xEndFlag = textureCoordinate[0] === 0;
  }
  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);
  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);
  let yDirection;
  let yEndFlag;
  if (yCoordBeforeWrap < dimensions[1]) {
    textureCoordinate[1] = yCoordBeforeWrap;
    yDirection = 1;
    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;
  } else {
    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;
    yDirection = -1;
    yEndFlag = textureCoordinate[1] === 0;
  }
  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);
  const remainder = texelIndexPosition - intTexelIndex;
  if (xEndFlag) {
    if (yEndFlag) {
      textureCoordinate[2] += remainder;
    } else {
      textureCoordinate[1] += yDirection * remainder;
    }
  } else {
    textureCoordinate[0] += xDirection * remainder;
  }
  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];
  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];
  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];
}
var colorTextureCoordinatesCache = /* @__PURE__ */ new WeakMap();
function getOrCreateColorTextureCoordinates(input, component, range, useLogScale, numberOfColorsInRange, dimensions, useZigzagPattern) {
  var _a;
  const argStrings = new Array(arguments.length);
  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {
    const arg = arguments[argIndex];
    argStrings[argIndex] = ((_a = arg.getMTime) == null ? void 0 : _a.call(arg)) ?? arg;
  }
  const stringHash = argStrings.join("/");
  const cachedResult = colorTextureCoordinatesCache.get(input);
  if (cachedResult && cachedResult.stringHash === stringHash) {
    return cachedResult.textureCoordinates;
  }
  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);
  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];
  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;
  const textureSCoeff = 1 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);
  const texelIndexOrigin = paddedRangeMin;
  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);
  const inputV = input.getData();
  const numScalars = input.getNumberOfTuples();
  const numComps = input.getNumberOfComponents();
  const useMagnitude = component < 0 || component >= numComps;
  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;
  const output = vtkDataArray$1.newInstance({
    numberOfComponents: numberOfOutputComponents,
    values: new Float32Array(numScalars * numberOfOutputComponents)
  });
  const outputV = output.getData();
  const nanTextureCoordinate = [0, 0, 0];
  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);
  let inputIdx = 0;
  let outputIdx = 0;
  const textureCoordinate = [0.5, 0.5, 0.5];
  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
    let scalarValue;
    if (useMagnitude) {
      let sum3 = 0;
      for (let compIdx = 0; compIdx < numComps; ++compIdx) {
        const compValue = Number(inputV[inputIdx + compIdx]);
        sum3 += compValue * compValue;
      }
      scalarValue = Math.sqrt(sum3);
    } else {
      scalarValue = Number(inputV[inputIdx + component]);
    }
    if (useLogScale) {
      scalarValue = Math.log10(scalarValue);
    }
    inputIdx += numComps;
    if (isNan(scalarValue)) {
      textureCoordinate[0] = nanTextureCoordinate[0];
      textureCoordinate[1] = nanTextureCoordinate[1];
      textureCoordinate[2] = nanTextureCoordinate[2];
    } else if (useZigzagPattern) {
      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;
      if (texelIndexPosition < 1) {
        texelIndexPosition = 0;
      } else if (texelIndexPosition > numberOfColorsInRange) {
        texelIndexPosition = numberOfColorsInRange + 1;
      }
      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);
    } else {
      textureCoordinate[1] = 0.49;
      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;
      if (textureS > 1e3) {
        textureCoordinate[0] = 1e3;
      } else if (textureS < -1e3) {
        textureCoordinate[0] = -1e3;
      } else {
        textureCoordinate[0] = textureS;
      }
    }
    for (let i = 0; i < numberOfOutputComponents; ++i) {
      outputV[outputIdx++] = textureCoordinate[i];
    }
  }
  colorTextureCoordinatesCache.set(input, {
    stringHash,
    textureCoordinates: output
  });
  return output;
}
function vtkMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkMapper2D");
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode4, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFlag: false
      };
    }
    let scalars = null;
    let cellFlag = false;
    if (scalarMode === ScalarMode4.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode4.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode4.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode4.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode4.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode4.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.mapScalars = (input, alpha) => {
    const {
      scalars,
      cellFlag
    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    model.areScalarsMappedFromCells = cellFlag;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString) return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {
      model.mapScalarsToTexture(scalars, cellFlag, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      const lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {
    if (cellFlag && !(model.colorMode === ColorMode.DIRECT_SCALARS)) {
      return true;
    }
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    if (!scalars) {
      return false;
    }
    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes4.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {
      return false;
    }
    return true;
  };
  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {
    const range = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    const origAlpha = model.lookupTable.getAlpha();
    const scaledRange = useLogScale ? [Math.log10(range[0]), Math.log10(range[1])] : range;
    model.colorMapColors = null;
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;
      model.lookupTable.build();
      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();
      const maxTextureWidthForCells = 2048;
      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3;
      const maxTextureWidthForPoints = 4096;
      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2;
      const minColorsInRange = 2;
      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;
      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);
      const numberOfColorsForCells = model.numberOfColorsInRange + 3;
      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2;
      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];
      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];
      const scalarsArray = new Float64Array(textureSize);
      scalarsArray.fill(NaN);
      const numberOfNonSpecialColors = model.numberOfColorsInRange;
      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;
      const textureCoordinates = [0, 0, 0];
      const rangeMin = scaledRange[0];
      const rangeDifference = scaledRange[1] - scaledRange[0];
      for (let i = 0; i < numberOfNonNaNColors; ++i) {
        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);
        const intermediateValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);
        const scalarValue = useLogScale ? 10 ** intermediateValue : intermediateValue;
        scalarsArray[scalarsArrayIndex] = scalarValue;
        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);
      }
      const scalarsDataArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: scalarsArray
      });
      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);
      model.colorTextureMap = vtkImageData$1.newInstance();
      model.colorTextureMap.setDimensions(textureDimensions);
      model.colorTextureMap.getPointData().setScalars(colorsDataArray);
      model.lookupTable.setAlpha(origAlpha);
    }
    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();
    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, scaledRange, useLogScale, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), cellFlag);
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
}
var DEFAULT_VALUES141 = {
  static: false,
  lookupTable: null,
  scalarVisibility: false,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME
  colorMapColors: null,
  // Same as this->Colors
  areScalarsMappedFromCells: false,
  renderTime: 0,
  colorByArrayName: null,
  transformCoordinate: null,
  viewSpecificProperties: null,
  customShaderAttributes: []
};
function extend156(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES141, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["areScalarsMappedFromCells", "colorCoordinates", "colorTextureMap", "colorMapColors"]);
  macro.setGet(publicAPI, model, [
    "arrayAccessMode",
    "colorByArrayName",
    "colorMode",
    "lookupTable",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "static",
    "transformCoordinate",
    "useLookupTableScalarRange",
    "viewSpecificProperties",
    "customShaderAttributes"
    // point data array names that will be transferred to the VBO
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  if (!model.viewSpecificProperties) {
    model.viewSpecificProperties = {};
  }
  vtkMapper2D(publicAPI, model);
}
var newInstance149 = macro.newInstance(extend156, "vtkMapper2D");
var vtkMapper2D$1 = {
  newInstance: newInstance149,
  extend: extend156
};

// node_modules/@kitware/vtk.js/Rendering/Core/PixelSpaceCallbackMapper.js
function vtkPixelSpaceCallbackMapper2(publicAPI, model) {
  model.classHierarchy.push("vtkPixelSpaceCallbackMapper");
  if (!model.callback) {
    model.callback = () => {
    };
  }
  publicAPI.invokeCallback = (dataset, camera, aspect, windowSize, depthValues) => {
    if (!model.callback) {
      return;
    }
    const matrix = camera.getCompositeProjectionMatrix(aspect, -1, 1);
    mat4_exports.transpose(matrix, matrix);
    const dataPoints = dataset.getPoints();
    const result = new Float64Array(3);
    const width2 = windowSize.usize;
    const height2 = windowSize.vsize;
    const hw = width2 / 2;
    const hh = height2 / 2;
    const coords = [];
    for (let pidx = 0; pidx < dataPoints.getNumberOfPoints(); pidx += 1) {
      const point = dataPoints.getPoint(pidx);
      vec3_exports.transformMat4(result, point, matrix);
      const coord = [result[0] * hw + hw, result[1] * hh + hh, result[2], 0];
      if (depthValues) {
        const linIdx = Math.floor(coord[1]) * width2 + Math.floor(coord[0]);
        const idx = linIdx * 4;
        const r = depthValues[idx] / 255;
        const g = depthValues[idx + 1] / 255;
        const z = (r * 256 + g) / 257;
        coord[3] = z * 2 - 1;
      }
      coords.push(coord);
    }
    model.callback(coords, camera, aspect, depthValues, [width2, height2]);
  };
}
var DEFAULT_VALUES142 = {
  callback: null,
  useZValues: false
};
function extend157(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES142, initialValues);
  vtkMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["callback", "useZValues"]);
  vtkPixelSpaceCallbackMapper2(publicAPI, model);
}
var newInstance150 = macro.newInstance(extend157, "vtkPixelSpaceCallbackMapper");
var vtkPixelSpaceCallbackMapper$1 = {
  newInstance: newInstance150,
  extend: extend157
};

// node_modules/@kitware/vtk.js/Rendering/Core/Skybox.js
function vtkSkybox2(publicAPI, model) {
  model.classHierarchy.push("vtkSkybox");
  publicAPI.getIsOpaque = () => true;
  publicAPI.hasTranslucentPolygonalGeometry = () => false;
  publicAPI.getSupportsSelection = () => false;
}
var DEFAULT_VALUES143 = {
  format: "box"
};
function extend158(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES143, initialValues);
  vtkActor$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, [
    "format"
    // can be box or background, in the future sphere, floor as well
  ]);
  vtkSkybox2(publicAPI, model);
}
var newInstance151 = macro.newInstance(extend158, "vtkSkybox");
var vtkSkybox$1 = {
  newInstance: newInstance151,
  extend: extend158
};

// node_modules/@kitware/vtk.js/Rendering/Core/SphereMapper.js
function vtkSphereMapper(publicAPI, model) {
  model.classHierarchy.push("vtkSphereMapper");
}
var DEFAULT_VALUES144 = {
  scaleArray: null,
  radius: 0.05,
  scaleFactor: 1
};
function extend159(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES144, initialValues);
  vtkMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["radius", "scaleArray", "scaleFactor"]);
  vtkSphereMapper(publicAPI, model);
}
var newInstance152 = macro.newInstance(extend159, "vtkSphereMapper");
var vtkSphereMapper$1 = {
  newInstance: newInstance152,
  extend: extend159
};

// node_modules/@kitware/vtk.js/Rendering/Core/StickMapper.js
function vtkStickMapper(publicAPI, model) {
  model.classHierarchy.push("vtkStickMapper");
}
var DEFAULT_VALUES145 = {
  scaleArray: null,
  orientationArray: null,
  radius: 0.025,
  length: 0.1
};
function extend160(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES145, initialValues);
  vtkMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["scaleArray", "orientationArray", "radius", "length"]);
  vtkStickMapper(publicAPI, model);
}
var newInstance153 = macro.newInstance(extend160, "vtkStickMapper");
var vtkStickMapper$1 = {
  newInstance: newInstance153,
  extend: extend160
};

// node_modules/@kitware/vtk.js/Rendering/Core/TextProperty.js
function vtkTextProperty(publicAPI, model) {
  model.classHierarchy.push("vtkTextProperty");
}
var DEFAULT_VALUES146 = {
  fontFamily: "Arial",
  fontColor: [0, 0, 0],
  fontStyle: "normal",
  // backgroundColor: [1, 1, 1],
  // Scales the font size based on the given resolution.
  // Dividing by 1.8 ensures the font size is proportionate and not too large.
  // The value 1.8 is a chosen scaling factor for visual balance.
  fontSizeScale: (resolution) => resolution / 1.8,
  resolution: 200
  // shadowColor: [1, 1, 0],
  // shadowOffset: [1, -1],
  // shadowBlur: 0,
};
function extend161(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES146, initialValues);
  vtkProperty2D$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["fontFamily", "fontStyle", "fillStyle", "fontSizeScale", "resolution", "shadowBlur"]);
  macro.setGetArray(publicAPI, model, ["shadowOffset"], 2);
  macro.setGetArray(publicAPI, model, ["backgroundColor", "fontColor", "shadowColor"], 3);
  vtkTextProperty(publicAPI, model);
}
var newInstance154 = macro.newInstance(extend161, "vtkTextProperty");
var vtkTextProperty$1 = {
  newInstance: newInstance154,
  extend: extend161
};

// node_modules/@kitware/vtk.js/Rendering/Core/TextActor.js
function vtkTextActor(publicAPI, model) {
  model.classHierarchy.push("vtkTextActor");
  publicAPI.makeProperty = vtkTextProperty$1.newInstance;
  const texture = vtkTexture$1.newInstance({
    resizable: true
  });
  const canvas = new OffscreenCanvas(1, 1);
  const mapper = vtkMapper2D$1.newInstance();
  const plane = vtkPlaneSource$1.newInstance({
    xResolution: 1,
    yResolution: 1
  });
  function createImageData(text2) {
    const fontSizeScale = publicAPI.getProperty().getFontSizeScale();
    const fontStyle = publicAPI.getProperty().getFontStyle();
    const fontFamily = publicAPI.getProperty().getFontFamily();
    const fontColor = publicAPI.getProperty().getFontColor();
    const shadowColor = publicAPI.getProperty().getShadowColor();
    const shadowOffset = publicAPI.getProperty().getShadowOffset();
    const shadowBlur = publicAPI.getProperty().getShadowBlur();
    const resolution = publicAPI.getProperty().getResolution();
    const backgroundColor = publicAPI.getProperty().getBackgroundColor();
    const dpr = Math.max(window.devicePixelRatio || 1, 1);
    const ctx = canvas.getContext("2d");
    const textSize = fontSizeScale(resolution) * dpr;
    ctx.font = `${fontStyle} ${textSize}px "${fontFamily}"`;
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    const metrics = ctx.measureText(text2);
    const textWidth = metrics.width / dpr;
    const {
      actualBoundingBoxLeft,
      actualBoundingBoxRight,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent
    } = metrics;
    const hAdjustment = (actualBoundingBoxLeft - actualBoundingBoxRight) / 2;
    const vAdjustment = (actualBoundingBoxAscent - actualBoundingBoxDescent) / 2;
    const textHeight = textSize / dpr - vAdjustment;
    const width2 = Math.max(Math.round(textWidth * dpr), 1);
    const height2 = Math.max(Math.round(textHeight * dpr), 1);
    canvas.width = width2;
    canvas.height = height2;
    ctx.translate(0, height2);
    ctx.scale(1, -1);
    ctx.clearRect(0, 0, width2, height2);
    if (backgroundColor) {
      ctx.fillStyle = floatRGB2HexCode(backgroundColor);
      ctx.fillRect(0, 0, width2, height2);
    }
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.font = `${fontStyle} ${textSize}px "${fontFamily}"`;
    ctx.fillStyle = floatRGB2HexCode(fontColor);
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    if (shadowColor) {
      ctx.shadowColor = floatRGB2HexCode(shadowColor);
      ctx.shadowOffsetX = shadowOffset[0];
      ctx.shadowOffsetY = shadowOffset[1];
      ctx.shadowBlur = shadowBlur;
    }
    ctx.fillText(text2, width2 / 2 + hAdjustment, height2 / 2 + vAdjustment);
    plane.set({
      point1: [width2, 0, 0],
      point2: [0, height2, 0]
    });
    return ImageHelper.canvasToImageData(canvas);
  }
  mapper.setInputConnection(plane.getOutputPort());
  publicAPI.setMapper(mapper);
  publicAPI.addTexture(texture);
  model._onInputChanged = (_publicAPI, _model, value) => {
    const image = createImageData(value);
    texture.setInputData(image, 0);
  };
}
var DEFAULT_VALUES147 = {
  mapper: null,
  property: null
};
function extend162(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES147, initialValues);
  vtkActor2D$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["input"]);
  vtkTextActor(publicAPI, model);
}
var newInstance155 = macro.newInstance(extend162, "vtkTextActor");
var vtkTextActor$1 = {
  newInstance: newInstance155,
  extend: extend162
};

// node_modules/@kitware/vtk.js/Rendering/Core/VectorText/Utils.js
function computeFacesUV(vertices, iA, iB, iC) {
  const ax = vertices[iA * 3];
  const ay = vertices[iA * 3 + 1];
  const bx = vertices[iB * 3];
  const by = vertices[iB * 3 + 1];
  const cx = vertices[iC * 3];
  const cy = vertices[iC * 3 + 1];
  return [[ax, ay], [bx, by], [cx, cy]];
}
function computeSidesUV(vertices, iA, iB, iC, iD) {
  const ax = vertices[iA * 3];
  const ay = vertices[iA * 3 + 1];
  const az = vertices[iA * 3 + 2];
  const bx = vertices[iB * 3];
  const by = vertices[iB * 3 + 1];
  const bz = vertices[iB * 3 + 2];
  const cx = vertices[iC * 3];
  const cy = vertices[iC * 3 + 1];
  const cz = vertices[iC * 3 + 2];
  const dx = vertices[iD * 3];
  const dy = vertices[iD * 3 + 1];
  const dz = vertices[iD * 3 + 2];
  if (Math.abs(ay - by) < Math.abs(ax - bx)) {
    return [[ax, 1 - az], [bx, 1 - bz], [cx, 1 - cz], [dx, 1 - dz]];
  }
  return [[ay, 1 - az], [by, 1 - bz], [cy, 1 - cz], [dy, 1 - dz]];
}
function createShapePath() {
  const curves = [];
  const currentPoint = [0, 0];
  const holes = [];
  return {
    curves,
    currentPoint,
    holes,
    moveTo(x, y) {
      currentPoint[0] = x;
      currentPoint[1] = y;
    },
    lineTo(x, y) {
      const start = [...currentPoint];
      const end2 = [x, y];
      curves.push({
        curveType: "LineCurve",
        start,
        end: end2,
        getPointAt(t) {
          return [start[0] + t * (end2[0] - start[0]), start[1] + t * (end2[1] - start[1])];
        },
        getPoints(resolution) {
          const points = [];
          for (let i = 0; i <= resolution; i++) {
            points.push(this.getPointAt(i / resolution));
          }
          return points;
        }
      });
      currentPoint[0] = x;
      currentPoint[1] = y;
    },
    quadraticCurveTo(cpX, cpY, x, y) {
      const start = [...currentPoint];
      const end2 = [x, y];
      const cp = [cpX, cpY];
      curves.push({
        curveType: "QuadraticBezierCurve",
        cp,
        start,
        end: end2,
        getPointAt(t) {
          const oneMinusT = 1 - t;
          return [oneMinusT * oneMinusT * start[0] + 2 * oneMinusT * t * cp[0] + t * t * end2[0], oneMinusT * oneMinusT * start[1] + 2 * oneMinusT * t * cp[1] + t * t * end2[1]];
        },
        getPoints(resolution) {
          const points = [];
          for (let i = 0; i <= resolution; i++) {
            points.push(this.getPointAt(i / resolution));
          }
          return points;
        }
      });
      currentPoint[0] = x;
      currentPoint[1] = y;
    },
    bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, x, y) {
      const start = [...currentPoint];
      const end2 = [x, y];
      const cp1 = [cp1X, cp1Y];
      const cp2 = [cp2X, cp2Y];
      curves.push({
        curveType: "BezierCurve",
        cp1,
        cp2,
        start,
        end: end2,
        getPointAt(t) {
          const oneMinusT = 1 - t;
          return [oneMinusT * oneMinusT * oneMinusT * start[0] + 3 * oneMinusT * oneMinusT * t * cp1[0] + 3 * oneMinusT * t * t * cp2[0] + t * t * t * end2[0], oneMinusT * oneMinusT * oneMinusT * start[1] + 3 * oneMinusT * oneMinusT * t * cp1[1] + 3 * oneMinusT * t * t * cp2[1] + t * t * t * end2[1]];
        },
        getPoints(resolution) {
          const points = [];
          for (let i = 0; i <= resolution; i++) {
            points.push(this.getPointAt(i / resolution));
          }
          return points;
        }
      });
      currentPoint[0] = x;
      currentPoint[1] = y;
    },
    /**
     * Get points from the shape
     * @param {*} divisions
     * @returns
     */
    getPoints(divisions) {
      let last;
      const points = [];
      for (let i = 0; i < curves.length; i++) {
        const curve = curves[i];
        let resolution = divisions;
        if (curve.curveType === "EllipseCurve") {
          resolution = divisions * 2;
        } else if (curve.curveType === "LineCurve") {
          resolution = 1;
        }
        const pts = curve.getPoints(resolution);
        for (let j = 0; j < pts.length; j++) {
          const point = pts[j];
          if (last && areEquals(last, point)) continue;
          points.push(point);
          last = point;
        }
      }
      return points;
    },
    /**
     * Extract points from the shape
     * @param {*} divisions
     * @returns
     */
    extractPoints(divisions) {
      const points = this.getPoints(divisions);
      const holesPoints = this.holes.map((hole) => hole.getPoints(divisions));
      return {
        shape: points,
        holes: holesPoints
      };
    },
    /**
     * Defines if a given point is inside the polygon defines by the path
     * @param {*} point
     * @param {*} polygon
     * @returns {boolean}
     */
    isPointInside(point, polygon) {
      const x = point[0];
      const y = point[1];
      let isInside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i][0];
        const yi = polygon[i][1];
        const xj = polygon[j][0];
        const yj = polygon[j][1];
        const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) isInside = !isInside;
      }
      return isInside;
    },
    isIntersect(path) {
      const pathA = this.getPoints(1, curves, false);
      const pathB = path.getPoints(1);
      return this.isPointInside(pathB[0], pathA);
    }
  };
}
function getBoundingSize(shapes, depth, curveSegments) {
  const minPoint = [Infinity, Infinity, depth > 0 ? 0 : depth];
  const maxPoint = [-Infinity, -Infinity, depth < 0 ? 0 : depth];
  for (let i = 0; i < shapes.length; i++) {
    const shape2 = shapes[i];
    const shapePoints = shape2.extractPoints(curveSegments);
    for (let j = 0; j < shapePoints.shape.length; j++) {
      const p = shapePoints.shape[j];
      if (p[0] < minPoint[0]) minPoint[0] = p[0];
      if (p[1] < minPoint[1]) minPoint[1] = p[1];
      if (p[0] > maxPoint[0]) maxPoint[0] = p[0];
      if (p[1] > maxPoint[1]) maxPoint[1] = p[1];
    }
  }
  return {
    min: minPoint,
    max: maxPoint
  };
}
function removeDupEndPoints(points) {
  const l = points.length;
  const isEqual = areEquals(points[l - 1], points[0]);
  if (l > 2 && isEqual) {
    points.pop();
  }
}
function isClockWise(points) {
  let sum3 = 0;
  const n = points.length;
  for (let p = n - 1, q = 0; q < n; p = q++) {
    sum3 += points[p][0] * points[q][1] - points[q][0] * points[p][1];
  }
  return sum3 * 0.5 < 0;
}
function computeBevelVector(pt, prev, next) {
  const vPrevX = pt[0] - prev[0];
  const vPrevY = pt[1] - prev[1];
  const vNextX = next[0] - pt[0];
  const vNextY = next[1] - pt[1];
  const cross2 = vPrevX * vNextY - vPrevY * vNextX;
  let tx;
  let ty;
  let shrinkBy;
  if (Math.abs(cross2) > Number.EPSILON) {
    const lenPrev = Math.hypot(vPrevX, vPrevY);
    const lenNext = Math.hypot(vNextX, vNextY);
    const prevShiftX = prev[0] - vPrevY / lenPrev;
    const prevShiftY = prev[1] + vPrevX / lenPrev;
    const nextShiftX = next[0] - vNextY / lenNext;
    const nextShiftY = next[1] + vNextX / lenNext;
    const sf = ((nextShiftX - prevShiftX) * vNextY - (nextShiftY - prevShiftY) * vNextX) / (vPrevX * vNextY - vPrevY * vNextX);
    tx = prevShiftX + vPrevX * sf - pt[0];
    ty = prevShiftY + vPrevY * sf - pt[1];
    const lensq = tx * tx + ty * ty;
    if (lensq <= 2) {
      return [tx, ty];
    }
    shrinkBy = Math.sqrt(lensq / 2);
  } else {
    const sameDir = vPrevX > 0 && vNextX > 0 || vPrevX < 0 && vNextX < 0 || Math.sign(vPrevY) === Math.sign(vNextY);
    if (sameDir) {
      tx = -vPrevY;
      ty = vPrevX;
      shrinkBy = Math.hypot(vPrevX, vPrevY);
    } else {
      tx = vPrevX;
      ty = vPrevY;
      shrinkBy = Math.sqrt((vPrevX * vPrevX + vPrevY * vPrevY) / 2);
    }
  }
  return [tx / shrinkBy, ty / shrinkBy];
}
function triangulateShape(earcut, contour, holes) {
  const faces = [];
  const vertices = [];
  const holeIndices = [];
  removeDupEndPoints(contour);
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i][0], contour[i][1]);
  }
  let holeIndex = contour.length;
  holes.forEach(removeDupEndPoints);
  for (let i = 0; i < holes.length; i++) {
    holeIndices.push(holeIndex);
    const hole = holes[i];
    holeIndex += hole.length;
    for (let j = 0; j < hole.length; j++) {
      vertices.push(hole[j][0], hole[j][1]);
    }
  }
  const triangles = earcut(vertices, holeIndices);
  for (let i = 0; i < triangles.length; i += 3) {
    faces.push(triangles.slice(i, i + 3));
  }
  return faces;
}
function scalePoint(pt, vec, size) {
  const rt = [pt[0], pt[1]];
  rt[0] += vec[0] * size;
  rt[1] += vec[1] * size;
  return rt;
}
function addTriangle(layers, a2, b2, c2, verticesArray, uvArray, colorArray, color4) {
  const tri = [a2, c2, b2];
  tri.forEach((i) => {
    verticesArray.push(layers[i * 3], layers[i * 3 + 1], layers[i * 3 + 2]);
  });
  const nextIndex = verticesArray.length / 3;
  const uvs = computeFacesUV(verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
  uvs.forEach((uv) => {
    uvArray.push(uv[0], uv[1]);
  });
  if (colorArray && color4) {
    for (let i = 0; i < 3; ++i) colorArray.push(color4[0] * 255, color4[1] * 255, color4[2] * 255);
  }
}
function addQuad(layers, a2, b2, c2, d2, verticesArray, uvArray, colorArray, color4) {
  const quad = [a2, d2, b2, b2, d2, c2];
  quad.forEach((i) => verticesArray.push(layers[i * 3], layers[i * 3 + 1], layers[i * 3 + 2]));
  const nextIndex = verticesArray.length / 3;
  const uvs = computeSidesUV(verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
  uvArray.push(uvs[0][0], uvs[0][1]);
  uvArray.push(uvs[1][0], uvs[1][1]);
  uvArray.push(uvs[3][0], uvs[3][1]);
  uvArray.push(uvs[1][0], uvs[1][1]);
  uvArray.push(uvs[2][0], uvs[2][1]);
  uvArray.push(uvs[3][0], uvs[3][1]);
  if (colorArray && color4) {
    for (let i = 0; i < 6; ++i) colorArray.push(color4[0] * 255, color4[1] * 255, color4[2] * 255);
  }
}
function buildLidFaces(layers, faces, vlen, steps, bevelEnabled, bevelSegments, verticesArray, uvArray, colorArray, color4) {
  if (bevelEnabled) {
    let layer = 0;
    let offset = vlen * layer;
    faces.forEach((_ref) => {
      let [a2, b2, c2] = _ref;
      addTriangle(layers, c2 + offset, b2 + offset, a2 + offset, verticesArray, uvArray, colorArray, color4);
    });
    layer = steps + bevelSegments * 2;
    offset = vlen * layer;
    faces.forEach((_ref2) => {
      let [a2, b2, c2] = _ref2;
      addTriangle(layers, a2 + offset, b2 + offset, c2 + offset, verticesArray, uvArray, colorArray, color4);
    });
  } else {
    faces.forEach((_ref3) => {
      let [a2, b2, c2] = _ref3;
      addTriangle(layers, c2, b2, a2, verticesArray, uvArray, colorArray, color4);
    });
    const offset = vlen * steps;
    faces.forEach((_ref4) => {
      let [a2, b2, c2] = _ref4;
      addTriangle(layers, a2 + offset, b2 + offset, c2 + offset, verticesArray, uvArray, colorArray, color4);
    });
  }
}
function buildWalls(layers, contour, layerOffset, vlen, steps, bevelSegments, verticesArray, uvArray, colorArray, color4) {
  const totalLayers = steps + bevelSegments * 2;
  for (let i = 0; i < contour.length; i++) {
    const j = i;
    const k = i === 0 ? contour.length - 1 : i - 1;
    for (let s = 0; s < totalLayers; s++) {
      const slen1 = vlen * s;
      const slen2 = vlen * (s + 1);
      const a2 = layerOffset + j + slen1;
      const b2 = layerOffset + k + slen1;
      const c2 = layerOffset + k + slen2;
      const d2 = layerOffset + j + slen2;
      addQuad(layers, a2, b2, c2, d2, verticesArray, uvArray, colorArray, color4);
    }
  }
}
function buildSideFaces(layers, contour, holes, vlen, steps, bevelSegments, verticesArray, uvArray, colorArray, color4) {
  let layerOffset = 0;
  buildWalls(layers, contour, layerOffset, vlen, steps, bevelSegments, verticesArray, uvArray, colorArray, color4);
  layerOffset += contour.length;
  for (let i = 0; i < holes.length; i++) {
    const ahole = holes[i];
    buildWalls(layers, ahole, layerOffset, vlen, steps, bevelSegments, verticesArray, uvArray, colorArray, color4);
    layerOffset += ahole.length;
  }
}

// node_modules/@kitware/vtk.js/Rendering/Core/VectorText.js
var {
  vtkErrorMacro: vtkErrorMacro61,
  vtkWarningMacro: vtkWarningMacro17
} = macro;
function vtkVectorText(publicAPI, model) {
  model.classHierarchy.push("vtkVectorText");
  function addShape(shape2, offsetSize, letterColor) {
    const curveSegments = model.curveSegments;
    const steps = model.steps;
    const depth = model.depth;
    const bevelEnabled = model.bevelEnabled;
    let bevelThickness = model.bevelThickness;
    let bevelSize = bevelThickness - 0.1;
    let bevelOffset = model.bevelOffset;
    let bevelSegments = model.bevelSegments;
    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
      bevelOffset = 0;
    }
    const shapePoints = shape2.extractPoints(curveSegments);
    let vertices = shapePoints.shape;
    const holes = shapePoints.holes;
    vertices.forEach((p) => {
      p[0] += offsetSize[0];
      p[1] += offsetSize[1];
    });
    holes.forEach((hole) => {
      hole.forEach((p) => {
        p[0] += offsetSize[0];
        p[1] += offsetSize[1];
      });
    });
    if (vertices.length < 3) {
      vtkWarningMacro17("Not enough points to create a shape");
      return;
    }
    const faces = triangulateShape(model.earcut, vertices, holes);
    const contour = vertices;
    vertices = [...vertices, ...holes.flat()];
    const vlen = vertices.length;
    const contourMovements = [];
    for (let i = 0, j = contour.length - 1, k = i + 1; i < contour.length; i++, j++, k++) {
      if (j === contour.length) j = 0;
      if (k === contour.length) k = 0;
      contourMovements[i] = computeBevelVector(contour[i], contour[j], contour[k]);
    }
    const holesMovements = [];
    let oneHoleMovements;
    let verticesMovements = [...contourMovements];
    for (let h = 0, hl = holes.length; h < hl; h++) {
      const ahole = holes[h];
      oneHoleMovements = [];
      for (let i = 0, j = ahole.length - 1, k = i + 1; i < ahole.length; i++, j++, k++) {
        if (j === ahole.length) j = 0;
        if (k === ahole.length) k = 0;
        oneHoleMovements[i] = computeBevelVector(ahole[i], ahole[j], ahole[k]);
      }
      holesMovements.push(oneHoleMovements);
      verticesMovements = [...verticesMovements, ...oneHoleMovements];
    }
    const layers = [];
    for (let b2 = 0; b2 < bevelSegments; b2++) {
      const t = b2 / bevelSegments;
      const z = bevelThickness * Math.cos(t * Math.PI / 2);
      const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
      for (let i = 0; i < contour.length; i++) {
        const vert = scalePoint(contour[i], contourMovements[i], bs2);
        layers.push(vert[0], vert[1], -z + offsetSize[2]);
      }
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (let i = 0; i < ahole.length; i++) {
          const vert = scalePoint(ahole[i], oneHoleMovements[i], bs2);
          layers.push(vert[0], vert[1], -z + offsetSize[2]);
        }
      }
    }
    const bs = bevelSize + bevelOffset;
    for (let i = 0; i < vlen; i++) {
      const vert = bevelEnabled ? scalePoint(vertices[i], verticesMovements[i], bs) : vertices[i];
      layers.push(vert[0], vert[1], 0 + offsetSize[2]);
    }
    for (let s = 1; s <= steps; s++) {
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePoint(vertices[i], verticesMovements[i], bs) : vertices[i];
        layers.push(vert[0], vert[1], depth / steps * s + offsetSize[2]);
      }
    }
    for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
      const t = b2 / bevelSegments;
      const z = bevelThickness * Math.cos(t * Math.PI / 2);
      const topBevelSize = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
      for (let i = 0, il = contour.length; i < il; i++) {
        const vert = scalePoint(contour[i], contourMovements[i], topBevelSize);
        layers.push(vert[0], vert[1], depth + z + offsetSize[2]);
      }
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (let i = 0, il = ahole.length; i < il; i++) {
          const vert = scalePoint(ahole[i], oneHoleMovements[i], topBevelSize);
          layers.push(vert[0], vert[1], depth + z + offsetSize[2]);
        }
      }
    }
    buildLidFaces(layers, faces, vlen, steps, bevelEnabled, bevelSegments, model.verticesArray, model.uvArray, model.colorArray, letterColor);
    buildSideFaces(layers, contour, holes, vlen, steps, bevelSegments, model.verticesArray, model.uvArray, model.colorArray, letterColor);
  }
  function buildShape() {
    model.shapes = [];
    if (!model.font || !model.text) {
      return;
    }
    const path = model.font.getPath(model.text, 0, 0, model.fontSize);
    if (!path || !path.commands || !path.commands.length) {
      return;
    }
    let first;
    let shapePath = createShapePath();
    const commands = path.commands;
    for (let i = 0; i < commands.length; i++) {
      const command = commands[i];
      shapePath = shapePath || createShapePath();
      switch (command.type) {
        case "M":
          shapePath.moveTo(command.x, -command.y);
          first = command;
          break;
        case "L":
          shapePath.lineTo(command.x, -command.y);
          break;
        case "C":
          shapePath.bezierCurveTo(command.x1, -command.y1, command.x2, -command.y2, command.x, -command.y);
          break;
        case "Q":
          shapePath.quadraticCurveTo(command.x1, -command.y1, command.x, -command.y);
          break;
        case "Z":
          shapePath.lineTo(first.x, -first.y);
          if (isClockWise(shapePath.getPoints(1))) {
            model.shapes.push(shapePath);
          } else {
            for (let j = 0; j < model.shapes.length; j++) {
              const shape2 = model.shapes[j];
              if (shape2.isIntersect(shapePath)) {
                shape2.holes.push(shapePath);
                break;
              }
            }
          }
          shapePath = null;
          break;
        default:
          console.warn(`Unknown path command: ${command.type}`);
          break;
      }
    }
    if (shapePath) {
      model.shapes.push(shapePath);
    }
  }
  function buildPolyData(polyData) {
    model.verticesArray = [];
    model.uvArray = [];
    model.colorArray = [];
    const cells = vtkCellArray$1.newInstance();
    const pointData = polyData.getPointData();
    const boundingSize = getBoundingSize(model.shapes, model.depth, model.curveSegments);
    const offsetSize = [0, 0, 0];
    subtract(boundingSize.min, boundingSize.max, offsetSize);
    let letterIndex = 0;
    model.shapes.forEach((shape2) => {
      let color4 = null;
      if (model.perLetterFaceColors) {
        color4 = model.perLetterFaceColors(letterIndex) || [1, 1, 1];
      }
      addShape(shape2, offsetSize, color4);
      letterIndex++;
    });
    const vertexCount = model.verticesArray.length / 3;
    const indices = [];
    for (let i = 0; i < vertexCount; i += 3) {
      indices.push(i, i + 2, i + 1);
    }
    const cellSize = indices.length;
    cells.resize(cellSize + cellSize / 3);
    for (let i = 0; i < indices.length; i += 3) {
      cells.insertNextCell([indices[i], indices[i + 1], indices[i + 2]]);
    }
    polyData.setPolys(cells);
    polyData.getPoints().setData(Float32Array.from(model.verticesArray), 3);
    const da = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: Float32Array.from(model.uvArray),
      name: "TEXCOORD_0"
    });
    pointData.addArray(da);
    pointData.setActiveTCoords(da.getName());
    if (model.colorArray && model.colorArray.length) {
      const ca = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: Uint8Array.from(model.colorArray),
        name: "Colors"
      });
      pointData.addArray(ca);
      pointData.setActiveScalars(ca.getName());
    }
    return polyData;
  }
  publicAPI.requestData = (inData, outData) => {
    var _a;
    if (!model.font) {
      vtkErrorMacro61("Font object not set, make sure the TTF file is parsed using opentype.js.");
      return;
    }
    if (!model.text) {
      vtkErrorMacro61("Text not set. Cannot generate vector text.");
      return;
    }
    buildShape();
    const polyData = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    buildPolyData(polyData);
    outData[0] = polyData;
  };
}
var DEFAULT_VALUES148 = {
  shapes: [],
  verticesArray: [],
  uvArray: [],
  font: null,
  earcut: null,
  // Earcut module for triangulation
  fontSize: 10,
  depth: 1,
  steps: 1,
  bevelEnabled: false,
  curveSegments: 12,
  bevelThickness: 0.2,
  bevelSize: 0.1,
  bevelOffset: 0,
  bevelSegments: 1,
  text: null,
  perLetterFaceColors: null
  // (letterIndex: number) => [r,g,b]
};
function extend163(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES148, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 0, 1);
  macro.setGet(publicAPI, model, ["fontSize", "text", "depth", "steps", "bevelEnabled", "curveSegments", "bevelThickness", "bevelSize", "bevelOffset", "bevelSegments", "perLetterFaceColors"]);
  macro.set(publicAPI, model, ["font"]);
  vtkVectorText(publicAPI, model);
}
var newInstance156 = macro.newInstance(extend163, "vtkVectorText");
var vtkVector = {
  newInstance: newInstance156,
  extend: extend163
};

// node_modules/@kitware/vtk.js/Rendering/Core.js
var Core5 = {
  vtkAbstractMapper: vtkAbstractMapper$1,
  vtkAbstractMapper3D: vtkAbstractMapper3D$1,
  vtkAbstractPicker: vtkAbstractPicker$1,
  vtkActor: vtkActor$1,
  vtkActor2D: vtkActor2D$1,
  vtkAnnotatedCubeActor: vtkAnnotatedCubeActor$1,
  vtkAxesActor: vtkAxesActor$1,
  vtkCamera: vtkCamera$1,
  vtkCellPicker: vtkCellPicker$1,
  vtkColorTransferFunction: {
    vtkColorMaps: vtkColorMaps4,
    ...vtkColorTransferFunction$1
  },
  vtkCoordinate: vtkCoordinate$1,
  vtkCubeAxesActor: vtkCubeAxesActor$1,
  vtkFollower: vtkFollower$1,
  vtkGlyph3DMapper: vtkGlyph3DMapper$1,
  vtkHardwareSelector: vtkHardwareSelector$1,
  vtkImageMapper: vtkImageMapper$1,
  vtkImageProperty: vtkImageProperty$1,
  vtkImageResliceMapper: vtkImageResliceMapper$1,
  vtkImageSlice: vtkImageSlice$1,
  vtkInteractorObserver: vtkInteractorObserver$1,
  vtkInteractorStyle: vtkInteractorStyle$1,
  vtkLight: vtkLight$1,
  vtkMapper: vtkMapper$1,
  vtkMapper2D: vtkMapper2D$1,
  vtkPicker: vtkPicker$1,
  vtkPixelSpaceCallbackMapper: vtkPixelSpaceCallbackMapper$1,
  vtkPointPicker: vtkPointPicker$1,
  vtkProp: vtkProp$1,
  vtkProp3D: vtkProp3D$1,
  vtkProperty: vtkProperty$1,
  vtkProperty2D: vtkProperty2D$1,
  vtkRenderer: vtkRenderer$1,
  vtkRenderWindow: vtkRenderWindow$1,
  vtkRenderWindowInteractor: vtkRenderWindowInteractor$1,
  vtkScalarBarActor: vtkScalarBarActor$1,
  vtkSkybox: vtkSkybox$1,
  vtkSphereMapper: vtkSphereMapper$1,
  vtkStickMapper: vtkStickMapper$1,
  vtkTexture: vtkTexture$1,
  vtkTextActor: vtkTextActor$1,
  vtkTextProperty: vtkTextProperty$1,
  vtkVector,
  vtkViewport: vtkViewport$1,
  vtkVolume: vtkVolume$1,
  vtkVolumeMapper: vtkVolumeMapper$1,
  vtkVolumeProperty: vtkVolumeProperty$1
};

// node_modules/@kitware/vtk.js/Rendering/Misc/CanvasView.js
var {
  vtkErrorMacro: vtkErrorMacro62
} = macro;
function vtkCanvasView(publicAPI, model) {
  model.classHierarchy.push("vtkCanvasView");
  function updateWindow() {
    if (model._renderable) {
      model.canvas.setAttribute("width", model.size[0]);
      model.canvas.setAttribute("height", model.size[1]);
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
  }
  publicAPI.onModified(updateWindow);
  publicAPI.setContainer = (el) => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro62("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
      }
      if (model.useBackgroundImage) {
        model.el.appendChild(model.bgImage);
      }
      publicAPI.modified();
    }
  };
  publicAPI.setBackgroundImage = (img) => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = (value) => {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && model.el && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  publicAPI.setViewStream = (stream) => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady((e2) => publicAPI.setBackgroundImage(e2.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.delete = macro.chain(publicAPI.setViewStream, publicAPI.delete);
  model._renderable = publicAPI;
  model._renderers = [publicAPI];
  publicAPI.traverseAllPasses = () => {
  };
  publicAPI.isInViewport = () => true;
  publicAPI.getInteractive = () => true;
}
var DEFAULT_VALUES149 = {
  canvas: null,
  size: [300, 300],
  cursorVisibility: true,
  cursor: "pointer",
  useOffScreen: false,
  useBackgroundImage: false
};
function extend164(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES149, initialValues);
  if (!model.canvas) {
    model.canvas = document.createElement("canvas");
    model.canvas.style.width = "100%";
  }
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  macro.obj(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["useBackgroundImage", "_renderable"]);
  macro.setGet(publicAPI, model, ["canvas", "cursor", "useOffScreen", "interactor"]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  macro.getArray(publicAPI, model, ["_renderers"]);
  macro.moveToProtected(publicAPI, model, ["renderable", "renderers"]);
  vtkCanvasView(publicAPI, model);
}
var newInstance157 = macro.newInstance(extend164, "vtkCanvasView");
var vtkCanvasView$1 = {
  newInstance: newInstance157,
  extend: extend164
};

// node_modules/@kitware/vtk.js/Rendering/Misc/FullScreenRenderWindow.js
var userParams = vtkURLExtract.extractURLParameters();
var STYLE_CONTAINER = {
  margin: "0",
  padding: "0",
  position: "absolute",
  top: "0",
  left: "0",
  width: "100%",
  height: "100%",
  overflow: "hidden"
};
var STYLE_CONTROL_PANEL = {
  position: "absolute",
  left: "25px",
  top: "25px",
  backgroundColor: "white",
  borderRadius: "5px",
  listStyle: "none",
  padding: "5px 10px",
  margin: "0",
  display: "block",
  border: "solid 1px black",
  maxWidth: "calc(100% - 70px)",
  maxHeight: "calc(100% - 60px)",
  overflow: "auto"
};
function applyStyle2(el, style6) {
  Object.keys(style6).forEach((key) => {
    el.style[key] = style6[key];
  });
}
function vtkFullScreenRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkFullScreenRenderWindow");
  const body = document.querySelector("body");
  if (!model.rootContainer) {
    model.rootContainer = body;
  }
  if (!model.container) {
    model.container = document.createElement("div");
    applyStyle2(model.container, model.containerStyle || STYLE_CONTAINER);
    model.rootContainer.appendChild(model.container);
  }
  if (model.rootContainer === body) {
    document.documentElement.style.height = "100%";
    body.style.height = "100%";
    body.style.padding = "0";
    body.style.margin = "0";
  }
  model.renderWindow = vtkRenderWindow$1.newInstance();
  model.renderer = vtkRenderer$1.newInstance();
  model.renderWindow.addRenderer(model.renderer);
  model.apiSpecificRenderWindow = model.renderWindow.newAPISpecificView(userParams.viewAPI ?? model.defaultViewAPI);
  model.apiSpecificRenderWindow.setContainer(model.container);
  model.renderWindow.addView(model.apiSpecificRenderWindow);
  model.interactor = vtkRenderWindowInteractor$1.newInstance();
  model.interactor.setInteractorStyle(vtkInteractorStyleTrackballCamera$1.newInstance());
  model.interactor.setView(model.apiSpecificRenderWindow);
  model.interactor.initialize();
  model.interactor.bindEvents(model.container);
  publicAPI.setBackground = model.renderer.setBackground;
  publicAPI.removeController = () => {
    const el = model.controlContainer;
    if (el) {
      el.parentNode.removeChild(el);
    }
  };
  publicAPI.setControllerVisibility = (visible2) => {
    model.controllerVisibility = visible2;
    if (model.controlContainer) {
      if (visible2) {
        model.controlContainer.style.display = "block";
      } else {
        model.controlContainer.style.display = "none";
      }
    }
  };
  publicAPI.toggleControllerVisibility = () => {
    publicAPI.setControllerVisibility(!model.controllerVisibility);
  };
  function handleKeypress(e2) {
    if (String.fromCharCode(e2.charCode) === "c") {
      publicAPI.toggleControllerVisibility();
    }
  }
  publicAPI.addController = (html) => {
    model.controlContainer = document.createElement("div");
    applyStyle2(model.controlContainer, model.controlPanelStyle || STYLE_CONTROL_PANEL);
    model.rootContainer.appendChild(model.controlContainer);
    model.controlContainer.innerHTML = html;
    publicAPI.setControllerVisibility(model.controllerVisibility);
    model.rootContainer.addEventListener("keypress", handleKeypress);
  };
  publicAPI.setBackground(...model.background);
  publicAPI.addRepresentation = (representation) => {
    representation.getActors().forEach((actor) => {
      model.renderer.addActor(actor);
    });
  };
  publicAPI.removeRepresentation = (representation) => {
    representation.getActors().forEach((actor) => model.renderer.removeActor(actor));
  };
  publicAPI.delete = macro.chain(publicAPI.setContainer, model.apiSpecificRenderWindow.delete, () => {
    var _a;
    (_a = model.rootContainer) == null ? void 0 : _a.removeEventListener("keypress", handleKeypress);
    window.removeEventListener("resize", publicAPI.resize);
  }, publicAPI.delete);
  publicAPI.resize = () => {
    const dims = model.container.getBoundingClientRect();
    const devicePixelRatio = window.devicePixelRatio || 1;
    model.apiSpecificRenderWindow.setSize(Math.floor(dims.width * devicePixelRatio), Math.floor(dims.height * devicePixelRatio));
    if (model.resizeCallback) {
      model.resizeCallback(dims);
    }
    model.renderWindow.render();
  };
  publicAPI.setResizeCallback = (cb) => {
    model.resizeCallback = cb;
    publicAPI.resize();
  };
  if (model.listenWindowResize) {
    window.addEventListener("resize", publicAPI.resize);
  }
  publicAPI.resize();
}
var DEFAULT_VALUES150 = {
  background: [0.32, 0.34, 0.43],
  containerStyle: null,
  controlPanelStyle: null,
  // defaultViewAPI: undefined,
  listenWindowResize: true,
  resizeCallback: null,
  controllerVisibility: true
};
function extend165(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES150, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["renderWindow", "renderer", "apiSpecificRenderWindow", "interactor", "rootContainer", "container", "controlContainer"]);
  vtkFullScreenRenderWindow(publicAPI, model);
}
var newInstance158 = macro.newInstance(extend165);
var vtkFullScreenRenderWindow$1 = {
  newInstance: newInstance158,
  extend: extend165
};

// node_modules/@kitware/vtk.js/Rendering/Misc/RemoteView.js
var SHARED_IMAGE_STREAM = vtkImageStream$1.newInstance();
var connectImageStream = SHARED_IMAGE_STREAM.connect;
var disconnectImageStream = SHARED_IMAGE_STREAM.disconnect;
function vtkRemoteView(publicAPI, model) {
  model.classHierarchy.push("vtkRemoteView");
  model.canvasView = vtkCanvasView$1.newInstance({
    canvas: model.canvasElement
  });
  model.interactorStyle = vtkInteractorStyleRemoteMouse$1.newInstance();
  model.interactor = vtkRenderWindowInteractor$1.newInstance();
  model.interactor.setView(model.canvasView);
  model.interactor.initialize();
  model.interactor.setInteractorStyle(model.interactorStyle);
  model.interactorStyle.onRemoteMouseEvent((e2) => {
    if (model.session && model.rpcMouseEvent) {
      model.session.call(model.rpcMouseEvent, [e2]);
    }
  });
  model.interactorStyle.onRemoteWheelEvent((e2) => {
    if (model.session && model.rpcWheelEvent) {
      model.session.call(model.rpcWheelEvent, [e2]);
    }
  });
  model.interactorStyle.onRemoteGestureEvent((e2) => {
    if (model.session && model.rpcGestureEvent) {
      model.session.call(model.rpcGestureEvent, [e2]);
    }
  });
  publicAPI.delete = macro.chain(() => {
    model.session = null;
    if (model.canvasView) {
      model.canvasView.setViewStream(null);
      model.canvasView.delete();
    }
    if (model.interactor) {
      model.interactor.delete();
    }
    if (model.viewStream) {
      model.viewStream.delete();
    }
  }, publicAPI.delete);
  publicAPI.getCanvasElement = () => model.canvasView.getCanvas();
  publicAPI.setViewStream = (viewStream) => {
    model.viewStream = viewStream;
    model.canvasView.setViewStream(model.viewStream);
    model.viewStream.setStillQuality(model.stillQuality);
    model.viewStream.setStillRatio(model.stillRatio);
    model.viewStream.setInteractiveQuality(model.interactiveQuality);
    model.viewStream.setInteractiveRatio(model.interactiveRatio);
    model.interactor.onStartAnimation(model.viewStream.startInteraction);
    model.interactor.onEndAnimation(model.viewStream.endInteraction);
    publicAPI.setViewId(viewStream.getViewId());
  };
  publicAPI.setViewId = (id) => {
    if (!model.viewStream) {
      publicAPI.setViewStream(SHARED_IMAGE_STREAM.createViewStream(id));
    }
    model.viewStream.setViewId(id);
    model.interactorStyle.setRemoteEventAddOn({
      view: id
    });
    publicAPI.modified();
  };
  publicAPI.setContainer = (container) => {
    if (model.container) {
      model.interactor.unbindEvents(container);
    }
    model.container = container;
    model.canvasView.setContainer(model.container);
    if (container) {
      model.interactor.bindEvents(container);
      publicAPI.resize();
    }
  };
  publicAPI.resize = () => {
    if (model.container && model.canvasView) {
      const {
        width: width2,
        height: height2
      } = model.container.getBoundingClientRect();
      model.canvasView.setSize(width2, height2);
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    if (model.viewStream) {
      model.viewStream.render();
    }
  };
  publicAPI.resetCamera = () => {
    if (model.viewStream) {
      model.viewStream.resetCamera();
    }
  };
  const internal = {
    modified: publicAPI.modified
  };
  macro.set(internal, model, ["interactiveQuality", "interactiveRatio", "stillQuality", "stillRatio"]);
  publicAPI.setInteractiveQuality = (q) => {
    const changeDetected = internal.setInteractiveQuality(q);
    if (model.viewStream && changeDetected) {
      model.viewStream.setInteractiveQuality(model.interactiveQuality);
    }
    return changeDetected;
  };
  publicAPI.setInteractiveRatio = (r) => {
    const changeDetected = internal.setInteractiveRatio(r);
    if (model.viewStream && changeDetected) {
      model.viewStream.setInteractiveRatio(model.interactiveRatio);
    }
    return changeDetected;
  };
  publicAPI.setStillQuality = (q) => {
    const changeDetected = internal.setStillQuality(q);
    if (model.viewStream && changeDetected) {
      model.viewStream.setStillQuality(model.stillQuality);
    }
    return changeDetected;
  };
  publicAPI.setStillRatio = (r) => {
    const changeDetected = internal.setStillRatio(r);
    if (model.viewStream && changeDetected) {
      model.viewStream.setStillRatio(model.stillRatio);
    }
    return changeDetected;
  };
  if (model.viewStream) {
    publicAPI.setViewStream(model.viewStream);
  }
}
var DEFAULT_VALUES151 = {
  viewId: "-1",
  interactiveQuality: 60,
  interactiveRatio: 1 / window.devicePixelRatio,
  stillQuality: 100,
  stillRatio: 1,
  rpcMouseEvent: "viewport.mouse.interaction",
  rpcGestureEvent: null,
  rpcWheelEvent: null,
  canvasElement: null
};
function extend166(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES151, initialValues);
  macro.obj(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["container", "viewStream", "canvasView", "interactor", "interactorStyle", "interactiveQuality", "interactiveRatio", "stillQuality", "stillRatio", "canvasElement"]);
  macro.setGet(publicAPI, model, ["session", "rpcMouseEvent", "rpcGestureEvent", "rpcWheelEvent"]);
  vtkRemoteView(publicAPI, model);
}
var newInstance159 = macro.newInstance(extend166, "vtkRemoteView");
var vtkRemoteView$1 = {
  newInstance: newInstance159,
  extend: extend166,
  SHARED_IMAGE_STREAM,
  connectImageStream,
  disconnectImageStream
};

// node_modules/@kitware/vtk.js/Rendering/Misc/RenderWindowWithControlBar/RenderWindowWithControlBar.module.css.js
var css_248z5 = ".RenderWindowWithControlBar-module_rootContainer__1xqVd {\n  position: relative;\n}\n\n.RenderWindowWithControlBar-module_renderWindow__2mz6Z {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.RenderWindowWithControlBar-module_control__38_dI {\n  z-index: 1;\n  position: absolute;\n}\n";
var style5 = { "rootContainer": "RenderWindowWithControlBar-module_rootContainer__1xqVd", "renderWindow": "RenderWindowWithControlBar-module_renderWindow__2mz6Z", "control": "RenderWindowWithControlBar-module_control__38_dI" };
styleInject(css_248z5);

// node_modules/@kitware/vtk.js/Rendering/Misc/RenderWindowWithControlBar.js
var CONTROL_STYLE = {
  left(size) {
    return {
      top: "0",
      left: "0",
      bottom: "0",
      right: "unset",
      height: "unset",
      width: `${size}px`
    };
  },
  right(size) {
    return {
      top: "0",
      right: "0",
      bottom: "0",
      left: "unset",
      height: "unset",
      width: `${size}px`
    };
  },
  top(size) {
    return {
      top: "0",
      left: "0",
      right: "0",
      bottom: "unset",
      width: "unset",
      height: `${size}px`
    };
  },
  bottom(size) {
    return {
      bottom: "0",
      left: "0",
      right: "0",
      top: "unset",
      width: "unset",
      height: `${size}px`
    };
  }
};
function applyControlStyle(el, position, size) {
  const styleToApply = CONTROL_STYLE[position](size);
  Object.keys(styleToApply).forEach((key) => {
    el.style[key] = styleToApply[key];
  });
}
function vtkRenderWindowWithControlBar(publicAPI, model) {
  const superClass = {
    ...publicAPI
  };
  function resetStyleToZero(key) {
    model.renderWindowContainer.style[key] = "0px";
  }
  function updateControlerStyle() {
    ["left", "right", "top", "bottom"].forEach(resetStyleToZero);
    model.renderWindowContainer.style[model.controlPosition] = `${model.controlSize}px`;
    applyControlStyle(model.controlContainer, model.controlPosition, model.controlSize);
  }
  model.renderWindowContainer = document.createElement("div");
  model.renderWindowContainer.classList.add(style5.renderWindow);
  superClass.setContainer(model.renderWindowContainer);
  model.controlContainer = document.createElement("div");
  model.controlContainer.classList.add(style5.control);
  publicAPI.setContainer = (el) => {
    if (model.rootContainer) {
      model.rootContainer.removeChild(model.container);
      model.rootContainer.removeChild(model.controlContainer);
      model.rootContainer.classList.remove(style5.rootContainer);
    }
    model.rootContainer = el;
    if (model.rootContainer) {
      model.rootContainer.appendChild(model.container);
      model.rootContainer.appendChild(model.controlContainer);
      model.rootContainer.classList.add(style5.rootContainer);
      updateControlerStyle();
      publicAPI.resize();
    }
  };
  publicAPI.setControlSize = (size) => {
    model.controlSize = size;
    updateControlerStyle();
    publicAPI.modified();
  };
  publicAPI.setControlPosition = (pos) => {
    model.controlPosition = pos;
    updateControlerStyle();
    publicAPI.modified();
  };
  if (model.listenWindowResize) {
    window.addEventListener("resize", publicAPI.resize);
  }
  updateControlerStyle();
  publicAPI.resize();
}
var DEFAULT_VALUES152 = {
  rootContainer: null,
  controlPosition: "left",
  controlSize: 10
};
function extend167(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES152, initialValues);
  vtkGenericRenderWindow$1.extend(publicAPI, model);
  macro.get(publicAPI, model, ["rootContainer", "controlContainer", "renderWindowContainer"]);
  vtkRenderWindowWithControlBar(publicAPI, model);
}
var newInstance160 = macro.newInstance(extend167, "vtkRenderWindowWithControlBar");
var vtkRenderWindowWithControlBar$1 = {
  newInstance: newInstance160,
  extend: extend167
};

// node_modules/@kitware/vtk.js/Rendering/Misc/SynchronizableRenderWindow/BehaviorManager/CameraSynchronizer.js
var MODE_RESET_CAMERA = "resetcamera";
var MODE_ORIENTATION = "orientation";
var MODE_SAME = "same";
var SynchronizationMode = {
  MODE_RESET_CAMERA,
  MODE_ORIENTATION,
  MODE_SAME
};
function vtkCameraSynchronizer(publicAPI, model) {
  model.classHierarchy.push("vtkCameraSynchronizer");
  const cameraState = new Float64Array(9);
  const direction3 = new Float64Array(3);
  const subscriptions = [];
  function updateListeners() {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    if (!model.srcRenderer || !model.dstRenderer) {
      return;
    }
    const srcCamera = model.srcRenderer.getActiveCamera();
    const interactor = model.srcRenderer.getRenderWindow().getInteractor();
    subscriptions.push(srcCamera.onModified(() => {
      if (!interactor.isAnimating()) {
        publicAPI.update();
      }
    }));
    subscriptions.push(interactor.onAnimation(publicAPI.update));
    subscriptions.push(interactor.onEndAnimation(publicAPI.update));
  }
  model._onSrcRendererChanged = updateListeners;
  model._onDstRendererChanged = updateListeners;
  function updatePreviousValues(position, focalPoint, viewUp) {
    if (cameraState[0] !== position[0] || cameraState[1] !== position[1] || cameraState[2] !== position[2] || cameraState[3] !== focalPoint[0] || cameraState[4] !== focalPoint[1] || cameraState[5] !== focalPoint[2] || cameraState[6] !== viewUp[0] || cameraState[7] !== viewUp[1] || cameraState[8] !== viewUp[2]) {
      cameraState[0] = position[0];
      cameraState[1] = position[1];
      cameraState[2] = position[2];
      cameraState[3] = focalPoint[0];
      cameraState[4] = focalPoint[1];
      cameraState[5] = focalPoint[2];
      cameraState[6] = viewUp[0];
      cameraState[7] = viewUp[1];
      cameraState[8] = viewUp[2];
      return cameraState;
    }
    return false;
  }
  publicAPI.update = () => {
    if (!model.active || !model.srcRenderer || !model.dstRenderer) {
      return;
    }
    const srcCamera = model.srcRenderer.getActiveCamera();
    const dstCamera = model.dstRenderer.getActiveCamera();
    const position = srcCamera.getReferenceByName("position");
    const focalPoint = srcCamera.getReferenceByName("focalPoint");
    const viewUp = srcCamera.getReferenceByName("viewUp");
    const change = updatePreviousValues(position, focalPoint, viewUp);
    if (!change) {
      return;
    }
    if (model.mode === MODE_ORIENTATION) {
      direction3[0] = change[0] - change[3];
      direction3[1] = change[1] - change[4];
      direction3[2] = change[2] - change[5];
      normalize(direction3);
      dstCamera.setPosition(model.focalPoint[0] + model.distance * direction3[0], model.focalPoint[1] + model.distance * direction3[1], model.focalPoint[2] + model.distance * direction3[2]);
      dstCamera.setFocalPoint(model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
      dstCamera.setViewUp(change[6], change[7], change[8]);
    } else {
      dstCamera.setPosition(change[0], change[1], change[2]);
      dstCamera.setFocalPoint(change[3], change[4], change[5]);
      dstCamera.setViewUp(change[6], change[7], change[8]);
    }
    if (model.mode === MODE_RESET_CAMERA) {
      model.dstRenderer.resetCamera();
    }
  };
  publicAPI.delete = chain(
    () => publicAPI.setSrcRenderer(null),
    // Will clear any listener
    publicAPI.delete
  );
  updateListeners();
}
var DEFAULT_VALUES153 = {
  mode: MODE_ORIENTATION,
  focalPoint: [0, 0, 0],
  distance: 6.8,
  active: true
  // srcRenderer: null,
  // dstRenderer: null,
};
function extend168(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES153, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["mode", "active", "srcRenderer", "dstRenderer", "distance"]);
  setGetArray(publicAPI, model, ["focalPoint"], 3, 0);
  vtkCameraSynchronizer(publicAPI, model);
}
var newInstance161 = newInstance(extend168, "vtkCameraSynchronizer");
var vtkCameraSynchronizer$1 = {
  newInstance: newInstance161,
  extend: extend168,
  SynchronizationMode
};

// node_modules/@kitware/vtk.js/Rendering/Misc/SynchronizableRenderWindow/BehaviorManager.js
var BEHAVIORS = {};
var CameraSync = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.behavior = vtkCameraSynchronizer$1.newInstance(this.getProperties(config));
    this.behavior.update();
  }
  getProperties(_ref) {
    let {
      actorBounds,
      srcRenderer,
      dstRenderer
    } = _ref;
    const distance = 3.4 * Math.max(actorBounds[1] - actorBounds[0], actorBounds[3] - actorBounds[2], actorBounds[5] - actorBounds[4]);
    const focalPoint = [0.5 * (actorBounds[0] + actorBounds[1]), 0.5 * (actorBounds[2] + actorBounds[3]), 0.5 * (actorBounds[4] + actorBounds[5])];
    const mode = vtkCameraSynchronizer$1.SynchronizationMode.MODE_ORIENTATION;
    return {
      distance,
      focalPoint,
      mode,
      srcRenderer: this.ctx.getInstance(srcRenderer),
      dstRenderer: this.ctx.getInstance(dstRenderer)
    };
  }
  update(config) {
    this.behavior.set(this.getProperties(config));
    this.behavior.update();
  }
  delete() {
    this.behavior.delete();
  }
};
var BEHAVIORS_TYPES = {
  CameraSync
};
function applyBehaviors(renderWindow, state, context) {
  const rwId = renderWindow.get("synchronizedViewId").synchronizedViewId;
  if (!state.behaviors || !rwId) {
    return;
  }
  if (!BEHAVIORS[rwId]) {
    BEHAVIORS[rwId] = {};
  }
  const localBehaviors = BEHAVIORS[rwId];
  if (state.behaviors.autoOrientation) {
    const renderers = renderWindow.getRenderers();
    if (!localBehaviors.autoOrientationAxes && renderers.length === 2) {
      let srcRenderer = null;
      let dstRenderer = null;
      for (let i = 0; i < renderers.length; i++) {
        const renderer = renderers[i];
        if (renderer.getInteractive()) {
          srcRenderer = renderer;
        } else {
          dstRenderer = renderer;
        }
      }
      if (srcRenderer && dstRenderer) {
        localBehaviors.autoOrientationAxes = vtkCameraSynchronizer$1.newInstance({
          srcRenderer,
          dstRenderer
        });
      }
    }
    if (localBehaviors.autoOrientationAxes && renderers.length !== 2) {
      localBehaviors.autoOrientationAxes.delete();
      delete localBehaviors.autoOrientationAxes;
    }
  }
  const currentSets = Object.keys(state.behaviors);
  const existingSets = Object.keys(localBehaviors);
  for (let i = 0; i < currentSets.length; i++) {
    const key = currentSets[i];
    if (!localBehaviors[key]) {
      const config = state.behaviors[key];
      if (BEHAVIORS_TYPES[config.type]) {
        localBehaviors[key] = new BEHAVIORS_TYPES[config.type](context, config);
      } else {
        console.log("No mapping for", config);
      }
    } else {
      localBehaviors[key].update(state.behaviors[key]);
    }
  }
  for (let i = 0; i < existingSets.length; i++) {
    const key = currentSets[i];
    if (!state.behaviors[key]) {
      localBehaviors[key].delete();
      delete localBehaviors[key];
    }
  }
}
var BehaviorManager = {
  applyBehaviors
};

// node_modules/@kitware/vtk.js/Rendering/Misc/SynchronizableRenderWindow/ObjectManager.js
var TYPE_HANDLERS = {};
var WRAPPED_ID_RE = /instance:\${([^}]+)}/;
var WRAP_ID = (id) => `instance:\${${id}}`;
var ONE_TIME_INSTANCE_TRACKERS = {};
var SKIPPED_INSTANCE_IDS = [];
var EXCLUDE_INSTANCE_MAP = {};
var DATA_ARRAY_MAPPER = {
  vtkPoints: vtkPoints$1,
  vtkCellArray: vtkCellArray$1,
  vtkDataArray: vtkDataArray$1
};
function extractCallArgs(synchronizerContext, argList) {
  return argList.map((arg) => {
    const m = WRAPPED_ID_RE.exec(arg);
    if (m) {
      return synchronizerContext.getInstance(m[1]);
    }
    return arg;
  });
}
function extractInstanceIds(argList) {
  return argList.map((arg) => WRAPPED_ID_RE.exec(arg)).filter((m) => m).map((m) => m[1]);
}
function extractDependencyIds(state) {
  let depList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (state.dependencies) {
    state.dependencies.forEach((childState) => {
      depList.push(childState.id);
      extractDependencyIds(childState, depList);
    });
  }
  return depList;
}
function bindArrays(arraysToBind) {
  while (arraysToBind.length) {
    const [fn, args] = arraysToBind.shift();
    fn(...args);
  }
}
function createNewArrayHandler(instance, arrayMetadata, arraysToBind) {
  return (values) => {
    const regMethod = arrayMetadata.registration ? arrayMetadata.registration : "addArray";
    const location = arrayMetadata.location ? instance.getReferenceByName(arrayMetadata.location) : instance;
    let previousArray = null;
    if (arrayMetadata.location) {
      previousArray = instance.getReferenceByName(arrayMetadata.location).getArray(arrayMetadata.name);
    } else {
      previousArray = instance[`get${regMethod.substring(3)}`]();
    }
    if (previousArray) {
      if (previousArray.getData() !== values) {
        arraysToBind.push([previousArray.setData, [values, arrayMetadata.numberOfComponents]]);
      }
      return previousArray;
    }
    const vtkClass = arrayMetadata.vtkClass ? arrayMetadata.vtkClass : "vtkDataArray";
    const array = DATA_ARRAY_MAPPER[vtkClass].newInstance({
      ...arrayMetadata,
      values
    });
    arraysToBind.push([location[regMethod], [array]]);
    return array;
  };
}
function update(type, instance, props, context) {
  if (!instance) {
    return Promise.reject(new Error(`No instance provided.`));
  }
  const handler = TYPE_HANDLERS[type];
  if (handler && handler.update) {
    return handler.update(instance, props, context);
  }
  return Promise.reject(new Error(`No updater for ${type}`));
}
function build(type) {
  let initialProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const handler = TYPE_HANDLERS[type];
  if (handler && handler.build) {
    return handler.build(initialProps);
  }
  console.log("No builder for", type);
  return null;
}
function excludeInstance(type, propertyName, propertyValue) {
  EXCLUDE_INSTANCE_MAP[type] = {
    key: propertyName,
    value: propertyValue
  };
}
function getSupportedTypes() {
  return Object.keys(TYPE_HANDLERS);
}
function clearTypeMapping() {
  Object.keys(TYPE_HANDLERS).forEach((key) => {
    delete TYPE_HANDLERS[key];
  });
}
function updateRenderWindow(instance, props, context) {
  return update("vtkRenderWindow", instance, props, context);
}
function clearAllOneTimeUpdaters() {
  Object.keys(ONE_TIME_INSTANCE_TRACKERS).forEach((key) => {
    delete ONE_TIME_INSTANCE_TRACKERS[key];
  });
}
function clearOneTimeUpdaters() {
  for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
    ids[_key] = arguments[_key];
  }
  if (ids.length === 0) {
    return clearAllOneTimeUpdaters();
  }
  let array = ids;
  if (array.length === 1 && Array.isArray(array[0])) {
    array = array[0];
  }
  array.forEach((instanceId) => {
    delete ONE_TIME_INSTANCE_TRACKERS[instanceId];
  });
  return array;
}
function notSkippedInstance(call) {
  if (call[1].length === 1) {
    return SKIPPED_INSTANCE_IDS.indexOf(call[1][0]) === -1;
  }
  let keep = false;
  for (let i = 0; i < call[1].length; i++) {
    keep = keep || SKIPPED_INSTANCE_IDS.indexOf(call[1][i]) === -1;
  }
  return keep;
}
function genericUpdater(instance, state, context) {
  context.start();
  instance.set(state.properties);
  if (state.dependencies) {
    state.dependencies.forEach((childState) => {
      const {
        id,
        type
      } = childState;
      if (EXCLUDE_INSTANCE_MAP[type]) {
        const {
          key,
          value
        } = EXCLUDE_INSTANCE_MAP[type];
        if (!key || childState.properties[key] === value) {
          SKIPPED_INSTANCE_IDS.push(WRAP_ID(id));
          return;
        }
      }
      let childInstance = context.getInstance(id);
      if (!childInstance) {
        childInstance = build(type, {
          managedInstanceId: id
        });
        context.registerInstance(id, childInstance);
      }
      update(type, childInstance, childState, context);
    });
  }
  if (state.calls) {
    state.calls.filter(notSkippedInstance).forEach((call) => {
      instance[call[0]].apply(null, extractCallArgs(context, call[1]));
    });
  }
  const dependencies = [];
  if (state.arrays) {
    const arraysToBind = [];
    const promises = Object.values(state.arrays).map((arrayMetadata) => {
      context.start();
      return context.getArray(arrayMetadata.hash, arrayMetadata.dataType, context).then(createNewArrayHandler(instance, arrayMetadata, arraysToBind)).catch((error) => {
        console.log("Error fetching array", JSON.stringify(arrayMetadata), error);
      }).finally(context.end);
    });
    context.start();
    dependencies.push(
      Promise.all(promises).then(() => {
        if (arraysToBind.length) {
          instance.modified();
        }
        bindArrays(arraysToBind);
        return true;
      }).catch((error) => {
        console.error("Error in array handling for state", JSON.stringify(state), error);
      }).finally(context.end)
      // -> end(arraysToBind)
    );
  }
  context.end();
  return Promise.all(dependencies);
}
function oneTimeGenericUpdater(instance, state, context) {
  if (!ONE_TIME_INSTANCE_TRACKERS[state.id]) {
    genericUpdater(instance, state, context);
  }
  ONE_TIME_INSTANCE_TRACKERS[state.id] = true;
}
function rendererUpdater(instance, state, context) {
  genericUpdater(instance, state, context);
  const allActorsDeps = /* @__PURE__ */ new Set();
  if (state.dependencies) {
    state.dependencies.forEach((childState) => {
      const viewPropInstance = context.getInstance(childState.id);
      if (viewPropInstance) {
        const flattenedDepIds = extractDependencyIds(childState);
        viewPropInstance.set({
          flattenedDepIds
        }, true);
        flattenedDepIds.forEach((depId) => allActorsDeps.add(depId));
      }
    });
  }
  const unregisterCandidates = /* @__PURE__ */ new Set();
  if (state.calls) {
    state.calls.filter(notSkippedInstance).filter((call) => call[0] === "removeViewProp").forEach((call) => {
      extractInstanceIds(call[1]).forEach((vpId) => {
        const deps = context.getInstance(vpId).get("flattenedDepIds").flattenedDepIds;
        if (deps) {
          deps.forEach((depId) => unregisterCandidates.add(depId));
        }
        unregisterCandidates.add(vpId);
      });
    });
  }
  const idsToUnregister = [...unregisterCandidates].filter((depId) => !allActorsDeps.has(depId));
  idsToUnregister.forEach((depId) => context.unregisterInstance(depId));
}
function vtkRenderWindowUpdater(instance, state, context) {
  if (state.calls) {
    state.calls.filter(notSkippedInstance).filter((call) => call[0] === "removeRenderer").forEach((call) => {
      extractInstanceIds(call[1]).forEach((renId) => {
        const renderer = context.getInstance(renId);
        const viewProps = renderer.getViewProps();
        viewProps.forEach((viewProp) => {
          const deps = viewProp.get("flattenedDepIds").flattenedDepIds;
          if (deps) {
            deps.forEach((depId) => context.unregisterInstance(depId));
          }
          context.unregisterInstance(context.getInstanceId(viewProp));
        });
      });
    });
  }
  instance.render();
  genericUpdater(instance, state, context);
  BehaviorManager.applyBehaviors(instance, state, context);
}
function colorTransferFunctionUpdater(instance, state, context) {
  context.start();
  if (!state.properties.nodes) {
    instance.set(state.properties);
  } else {
    const nodes = state.properties.nodes.map((_ref) => {
      let [x, r, g, b2, midpoint, sharpness] = _ref;
      return {
        x,
        r,
        g,
        b: b2,
        midpoint,
        sharpness
      };
    });
    instance.set({
      ...state.properties,
      nodes
    }, true);
  }
  context.end();
}
function piecewiseFunctionUpdater(instance, state, context) {
  context.start();
  if (!state.properties.nodes) {
    instance.set(state.properties);
  } else {
    const nodes = state.properties.nodes.map((_ref2) => {
      let [x, y, midpoint, sharpness] = _ref2;
      return {
        x,
        y,
        midpoint,
        sharpness
      };
    });
    instance.set({
      ...state.properties,
      nodes
    }, true);
    instance.sortAndUpdateRange();
  }
  context.end();
}
function removeUnavailableArrays(fields, availableNames) {
  const namesToDelete = [];
  const size = fields.getNumberOfArrays();
  for (let i = 0; i < size; i++) {
    const array = fields.getArray(i);
    const name2 = array.getName();
    if (!availableNames.has(name2)) {
      namesToDelete.push(name2);
    }
  }
  for (let i = 0; i < namesToDelete.length; i++) {
    fields.removeArray(namesToDelete[i]);
  }
}
function getArrayKey(arrayMeta) {
  const namePart = arrayMeta.name ? `_${arrayMeta.name}` : "";
  return `${arrayMeta.hash}_${arrayMeta.dataType}${namePart}`;
}
function createDataSetUpdate() {
  let piecesToFetch = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return (instance, state, context) => {
    context.start();
    const localProperties = {
      ...state.properties
    };
    if (!state.arrays) {
      state.arrays = {};
    }
    for (let i = 0; i < piecesToFetch.length; i++) {
      const key = piecesToFetch[i];
      if (state.properties[key]) {
        const arrayMeta = state.properties[key];
        arrayMeta.registration = `set${capitalize(key)}`;
        const arrayKey = getArrayKey(arrayMeta);
        state.arrays[arrayKey] = arrayMeta;
        delete localProperties[key];
      }
    }
    const fieldsArrays = state.properties.fields || [];
    for (let i = 0; i < fieldsArrays.length; i++) {
      const arrayMeta = fieldsArrays[i];
      const arrayKey = getArrayKey(arrayMeta);
      state.arrays[arrayKey] = arrayMeta;
    }
    delete localProperties.fields;
    const arrayToKeep = {
      pointData: /* @__PURE__ */ new Set(),
      cellData: /* @__PURE__ */ new Set(),
      fieldData: /* @__PURE__ */ new Set()
    };
    fieldsArrays.forEach((_ref3) => {
      let {
        location,
        name: name2
      } = _ref3;
      arrayToKeep[location].add(name2);
    });
    removeUnavailableArrays(instance.getPointData(), arrayToKeep.pointData);
    removeUnavailableArrays(instance.getCellData(), arrayToKeep.cellData);
    const cleanState = {
      ...state
    };
    cleanState.properties = localProperties;
    const res = genericUpdater(instance, cleanState, context);
    context.end();
    return res;
  };
}
var polydataUpdater = createDataSetUpdate(["points", "polys", "verts", "lines", "strips"]);
var imageDataUpdater = createDataSetUpdate([]);
function setTypeMapping(type) {
  let buildFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  let updateFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : genericUpdater;
  if (!build && !update) {
    delete TYPE_HANDLERS[type];
    return;
  }
  TYPE_HANDLERS[type] = {
    build: buildFn,
    update: updateFn
  };
}
var DEFAULT_ALIASES = {
  vtkMapper: ["vtkOpenGLPolyDataMapper", "vtkCompositePolyDataMapper2", "vtkDataSetMapper"],
  vtkProperty: ["vtkOpenGLProperty"],
  vtkRenderer: ["vtkOpenGLRenderer"],
  vtkCamera: ["vtkOpenGLCamera"],
  vtkColorTransferFunction: ["vtkPVDiscretizableColorTransferFunction"],
  vtkActor: ["vtkOpenGLActor", "vtkPVLODActor"],
  vtkLight: ["vtkOpenGLLight", "vtkPVLight"],
  vtkTexture: ["vtkOpenGLTexture"],
  vtkImageMapper: ["vtkOpenGLImageSliceMapper"],
  vtkVolumeMapper: ["vtkFixedPointVolumeRayCastMapper"]
};
var DEFAULT_MAPPING = {
  vtkAxesActor: {
    build: vtkAxesActor$1.newInstance,
    update: genericUpdater
  },
  vtkRenderWindow: {
    build: vtkRenderWindow$1.newInstance,
    update: vtkRenderWindowUpdater
  },
  vtkRenderer: {
    build: vtkRenderer$1.newInstance,
    update: rendererUpdater
  },
  vtkLookupTable: {
    build: vtkLookupTable$1.newInstance,
    update: genericUpdater
  },
  vtkCamera: {
    build: vtkCamera$1.newInstance,
    update: oneTimeGenericUpdater
  },
  vtkPolyData: {
    build: vtkPolyData$1.newInstance,
    update: polydataUpdater
  },
  vtkImageData: {
    build: vtkImageData$1.newInstance,
    update: imageDataUpdater
  },
  vtkMapper: {
    build: vtkMapper$1.newInstance,
    update: genericUpdater
  },
  vtkGlyph3DMapper: {
    build: vtkGlyph3DMapper$1.newInstance,
    update: genericUpdater
  },
  vtkProperty: {
    build: vtkProperty$1.newInstance,
    update: genericUpdater
  },
  vtkActor: {
    build: vtkActor$1.newInstance,
    update: genericUpdater
  },
  vtkLight: {
    build: vtkLight$1.newInstance,
    update: genericUpdater
  },
  vtkColorTransferFunction: {
    build: vtkColorTransferFunction$1.newInstance,
    update: colorTransferFunctionUpdater
  },
  vtkTexture: {
    build: vtkTexture$1.newInstance,
    update: genericUpdater
  },
  vtkVolume: {
    build: vtkVolume$1.newInstance,
    update: genericUpdater
  },
  vtkVolumeMapper: {
    build: vtkVolumeMapper$1.newInstance,
    update: genericUpdater
  },
  vtkVolumeProperty: {
    build: vtkVolumeProperty$1.newInstance,
    update: genericUpdater
  },
  vtkImageSlice: {
    build: vtkImageSlice$1.newInstance,
    update: genericUpdater
  },
  vtkImageMapper: {
    build: vtkImageMapper$1.newInstance,
    update: genericUpdater
  },
  vtkImageProperty: {
    build: vtkImageProperty$1.newInstance,
    update: genericUpdater
  },
  vtkPiecewiseFunction: {
    build: vtkPiecewiseFunction$1.newInstance,
    update: piecewiseFunctionUpdater
  },
  vtkCubeAxesActor: {
    build: vtkCubeAxesActor$1.newInstance,
    update: genericUpdater
  },
  vtkScalarBarActor: {
    build: vtkScalarBarActor$1.newInstance,
    update: genericUpdater
  }
};
function setDefaultMapping() {
  let reset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  if (reset) {
    clearTypeMapping();
  }
  Object.keys(DEFAULT_MAPPING).forEach((type) => {
    const mapping2 = DEFAULT_MAPPING[type];
    setTypeMapping(type, mapping2.build, mapping2.update);
  });
}
function applyDefaultAliases() {
  Object.keys(DEFAULT_ALIASES).forEach((name2) => {
    const aliases = DEFAULT_ALIASES[name2];
    aliases.forEach((alias) => {
      TYPE_HANDLERS[alias] = TYPE_HANDLERS[name2];
    });
  });
}
function alwaysUpdateCamera() {
  setTypeMapping("vtkCamera", vtkCamera$1.newInstance);
  applyDefaultAliases();
}
setDefaultMapping();
applyDefaultAliases();
EXCLUDE_INSTANCE_MAP.vtkPVLight = {};
var vtkObjectManager = {
  build,
  update,
  genericUpdater,
  oneTimeGenericUpdater,
  setTypeMapping,
  clearTypeMapping,
  getSupportedTypes,
  clearOneTimeUpdaters,
  updateRenderWindow,
  excludeInstance,
  setDefaultMapping,
  applyDefaultAliases,
  alwaysUpdateCamera
};

// node_modules/@kitware/vtk.js/Rendering/Misc/SynchronizableRenderWindow.js
var SYNCHRONIZER_CONTEXTS = {};
function createArrayHandler2() {
  const dataArrayCache = {};
  let arrayFetcher = null;
  function setFetchArrayFunction(fetcher) {
    arrayFetcher = fetcher;
  }
  function getArray(sha, dataType, context) {
    const arrayEntry = dataArrayCache[sha];
    if (arrayEntry) {
      arrayEntry.mtimes[context.getActiveViewId()] = context.getMTime();
      return new Promise((resolve, reject) => {
        resolve(arrayEntry.array);
      });
    }
    if (!arrayFetcher) {
      return Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'));
    }
    return new Promise((resolve, reject) => {
      arrayFetcher(sha).then((data2) => {
        let buffer = data2;
        if (typeof data2 === "string") {
          buffer = Base64.toArrayBuffer(data2);
        }
        if (buffer instanceof Blob) {
          const fileReader = new FileReader();
          fileReader.onload = () => {
            const array = newTypedArray(dataType, fileReader.result);
            const mtimes = {
              [context.getActiveViewId()]: context.getMTime()
            };
            dataArrayCache[sha] = {
              mtimes,
              array
            };
            resolve(array);
          };
          fileReader.readAsArrayBuffer(buffer);
        } else {
          const array = newTypedArray(dataType, buffer);
          const mtimes = {
            [context.getActiveViewId()]: context.getMTime()
          };
          dataArrayCache[sha] = {
            mtimes,
            array
          };
          resolve(array);
        }
      }, (error) => {
        console.log("Error getting data array:");
        console.log(error);
        reject(error);
      });
    });
  }
  function emptyCachedArrays() {
    Object.keys(dataArrayCache).forEach((key) => {
      delete dataArrayCache[key];
    });
  }
  function freeOldArrays(threshold, context) {
    const mtimeThreshold = context.getMTime() - threshold;
    Object.keys(dataArrayCache).filter((key) => dataArrayCache[key].mtimes[context.getActiveViewId()]).filter((key) => dataArrayCache[key].mtimes[context.getActiveViewId()] < mtimeThreshold).forEach((key) => {
      delete dataArrayCache[key];
    });
  }
  return {
    setFetchArrayFunction,
    getArray,
    emptyCachedArrays,
    freeOldArrays
  };
}
function createInstanceMap() {
  const instances = {};
  function getInstance(id) {
    return instances[id];
  }
  function getInstanceId(instance) {
    let instanceId = null;
    Object.keys(instances).forEach((id) => {
      if (instance === instances[id]) {
        instanceId = id;
      }
    });
    return instanceId;
  }
  function registerInstance(id, instance) {
    instances[id] = instance;
    instance.set({
      remoteId: id
    }, true, true);
  }
  function unregisterInstance(id) {
    delete instances[id];
  }
  function emptyCachedInstances() {
    Object.keys(instances).forEach((key) => {
      delete instances[key];
    });
  }
  return {
    getInstance,
    getInstanceId,
    registerInstance,
    unregisterInstance,
    emptyCachedInstances
  };
}
function createProgressHandler() {
  let readyCount = 0;
  const publicAPI = {
    start() {
      readyCount += 1;
      publicAPI.invokeProgressEvent(readyCount);
    },
    end() {
      readyCount -= 1;
      publicAPI.invokeProgressEvent(readyCount);
      if (readyCount === 0) {
        publicAPI.invokeProgressDone();
      }
    },
    resetProgress() {
      readyCount = 0;
    }
  };
  const model = {};
  event(publicAPI, model, "progressEvent");
  event(publicAPI, model, "progressDone");
  return publicAPI;
}
function createSceneMtimeHandler() {
  const mtimes = {};
  let activeViewId = "default";
  function getMTime(viewId) {
    const key = viewId || activeViewId;
    return mtimes[key] || 1;
  }
  function incrementMTime(viewId) {
    const key = viewId || activeViewId;
    if (!mtimes[key]) {
      mtimes[key] = 1;
    }
    mtimes[key] += 1;
  }
  function setActiveViewId(viewId) {
    activeViewId = viewId;
  }
  function getActiveViewId() {
    return activeViewId;
  }
  return {
    getMTime,
    incrementMTime,
    setActiveViewId,
    getActiveViewId
  };
}
function getSynchronizerContext() {
  let name2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
  let ctx = SYNCHRONIZER_CONTEXTS[name2];
  if (!ctx) {
    ctx = {
      ...createArrayHandler2(),
      ...createInstanceMap(),
      ...createProgressHandler(),
      ...createSceneMtimeHandler()
    };
    SYNCHRONIZER_CONTEXTS[name2] = ctx;
  }
  return ctx;
}
function setSynchronizerContext(name2, ctx) {
  SYNCHRONIZER_CONTEXTS[name2] = ctx;
}
function clearSynchronizerContext(name2) {
  if (name2 && SYNCHRONIZER_CONTEXTS[name2]) {
    delete SYNCHRONIZER_CONTEXTS[name2];
  }
  if (!name2) {
    const keys = Object.keys(SYNCHRONIZER_CONTEXTS);
    for (let i = 0; i < keys.length; i++) {
      delete SYNCHRONIZER_CONTEXTS[keys[i]];
    }
  }
}
function createSyncFunction(renderWindow, synchronizerContext) {
  let lastMtime = -1;
  let gcThreshold = 100;
  const getManagedInstanceId = (instance) => instance.get("managedInstanceId").managedInstanceId;
  const getManagedInstanceIds = () => traverseInstanceTree(renderWindow, getManagedInstanceId);
  function clearOneTimeUpdaters2() {
    vtkObjectManager.clearOneTimeUpdaters(getManagedInstanceIds());
  }
  function setSynchronizedViewId(synchronizedViewId) {
    renderWindow.set({
      synchronizedViewId
    }, true, true);
  }
  function getSynchronizedViewId() {
    return renderWindow.get("synchronizedViewId").synchronizedViewId;
  }
  function updateGarbageCollectorThreshold(v) {
    gcThreshold = v;
  }
  function synchronize(state) {
    if (!getSynchronizedViewId()) {
      setSynchronizedViewId(state.id);
    }
    const mtime = state.mtime || 0;
    if (getSynchronizedViewId() === state.id && lastMtime < mtime) {
      return new Promise((resolve, reject) => {
        const subscription = synchronizerContext.onProgressDone(() => {
          subscription.unsubscribe();
          renderWindow.render();
          resolve(true);
        });
        lastMtime = mtime;
        synchronizerContext.setActiveViewId(state.id);
        synchronizerContext.incrementMTime();
        vtkObjectManager.updateRenderWindow(renderWindow, state, synchronizerContext);
        synchronizerContext.freeOldArrays(gcThreshold, synchronizerContext);
      });
    }
    return Promise.resolve(false);
  }
  return {
    synchronize,
    setSynchronizedViewId,
    getSynchronizedViewId,
    updateGarbageCollectorThreshold,
    getManagedInstanceIds,
    clearOneTimeUpdaters: clearOneTimeUpdaters2
  };
}
function vtkSynchronizableRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkSynchronizableRenderWindow");
  if (!model.synchronizerContext) {
    model.synchronizerContext = getSynchronizerContext(model.synchronizerContextName);
  }
  const addOn = createSyncFunction(publicAPI, model.synchronizerContext);
  Object.keys(addOn).forEach((methodName) => {
    if (publicAPI[methodName]) {
      publicAPI[methodName] = chain(publicAPI[methodName], addOn[methodName]);
    } else {
      publicAPI[methodName] = addOn[methodName];
    }
  });
}
var DEFAULT_VALUES154 = {
  synchronizerContextName: "default",
  synchronizerContext: null,
  synchronizedViewId: null
};
function extend169(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES154, initialValues);
  vtkRenderWindow$1.extend(publicAPI, model);
  get(publicAPI, model, ["synchronizerContext"]);
  vtkSynchronizableRenderWindow(publicAPI, model);
}
var newInstance162 = newInstance(extend169, "vtkSynchronizableRenderWindow");
function decorate(renderWindow) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
  const addOn = createSyncFunction(renderWindow, getSynchronizerContext(name2));
  return {
    ...addOn,
    ...renderWindow,
    delete: chain(renderWindow.delete, addOn.delete)
  };
}
var vtkSynchronizableRenderWindow$1 = {
  newInstance: newInstance162,
  extend: extend169,
  getSynchronizerContext,
  setSynchronizerContext,
  clearSynchronizerContext,
  decorate,
  createInstanceMap,
  createArrayHandler: createArrayHandler2,
  createProgressHandler,
  createSceneMtimeHandler,
  vtkObjectManager
};

// node_modules/@kitware/vtk.js/Rendering/Misc.js
var Misc3 = {
  vtkCanvasView: vtkCanvasView$1,
  vtkFullScreenRenderWindow: vtkFullScreenRenderWindow$1,
  vtkGenericRenderWindow: vtkGenericRenderWindow$1,
  vtkRemoteView: vtkRemoteView$1,
  vtkRenderWindowWithControlBar: vtkRenderWindowWithControlBar$1,
  vtkSynchronizableRenderWindow: vtkSynchronizableRenderWindow$1,
  vtkTextureLODsDownloader: vtkTextureLODsDownloader$1
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Convolution2DPass.js
var {
  vtkErrorMacro: vtkErrorMacro63
} = macro;
function vtkConvolution2DPass(publicAPI, model) {
  model.classHierarchy.push("vtkConvolution2DPass");
  publicAPI.computeKernelWeight = function computeKernelWeight(kernel) {
    const weight = kernel.reduce((prev, curr) => prev + curr);
    return weight <= 0 ? 1 : weight;
  };
  publicAPI.traverse = function(viewNode) {
    if (model.deleted) {
      return;
    }
    if (model.kernelDimension % 2 !== 1) {
      vtkErrorMacro63("Invalid kernel dimension! Kernel dimension must be odd (e.g. 3, 5, 7, ...).");
      return;
    }
    if (model.kernel === null) {
      model.kernel = new Float32Array(model.kernelDimension);
      model.kernel[Math.floor(model.kernelDimension / 2)] = 1;
    }
    const kernelLength = model.kernelDimension * model.kernelDimension;
    if (model.kernel.length !== kernelLength) {
      vtkErrorMacro63(`The given kernel is invalid. 2D convolution kernels have to be 1D arrays with ${kernelLength} components representing the ${model.kernelDimension}x${model.kernelDimension} kernel in row-major form.`);
      return;
    }
    if (model.framebuffer === null) {
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
    }
    const size = viewNode.getSize();
    const gl = viewNode.getContext();
    if (gl === null) {
      model.delegates.forEach((val) => {
        val.traverse(viewNode, publicAPI);
      });
      return;
    }
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      model.tris.setOpenGLRenderWindow(viewNode);
      publicAPI.buildVertexBuffer();
    }
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    model.framebuffer.saveCurrentBindingsAndBuffers();
    const fbSize = model.framebuffer.getSize();
    if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
      model.framebuffer.create(size[0], size[1]);
      model.framebuffer.populateFramebuffer();
    }
    model.framebuffer.bind();
    model.delegates.forEach((val) => {
      val.traverse(viewNode, publicAPI);
    });
    model.framebuffer.restorePreviousBindingsAndBuffers();
    if (model.convolutionShader !== null && model.oldKernelDimension !== model.kernelDimension) {
      model.convolutionShader = null;
      model.oldKernelDimension = model.kernelDimension;
    }
    if (model.convolutionShader === null) {
      model.convolutionShader = viewNode.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "attribute vec2 tcoordTC;", "varying vec2 tcoord;", "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"), publicAPI.getFragmentShaderCode(model.kernelDimension), "");
      const program = model.convolutionShader;
      model.copyVAO = vtkVertexArrayObject.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
      model.tris.getCABO().bind();
      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
        vtkErrorMacro63("Error setting vertexDC in copy shader VAO.");
      }
      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "tcoordTC", model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
        vtkErrorMacro63("Error setting vertexDC in copy shader VAO.");
      }
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.convolutionShader);
    }
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    const tex = model.framebuffer.getColorTexture();
    tex.activate();
    model.convolutionShader.setUniformi("u_image", tex.getTextureUnit());
    model.convolutionShader.setUniform2f("u_textureSize", tex.getWidth(), tex.getHeight());
    model.convolutionShader.setUniformfv("u_kernel", model.kernel);
    model.convolutionShader.setUniformf("u_kernelWeight", publicAPI.computeKernelWeight(model.kernel));
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    tex.deactivate();
  };
  publicAPI.getFragmentShaderCode = (kernelDimension) => {
    const kernelLength = kernelDimension * kernelDimension;
    let shaderCode = ["//VTK::System::Dec", "//VTK::Output::Dec", "uniform sampler2D u_image;", "uniform vec2 u_textureSize;", `uniform float u_kernel[${kernelLength}];`, "uniform float u_kernelWeight;", "varying vec2 tcoord;", "void main(){", "    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;", "    vec4 colorSum =\n"].join("\n");
    const halfDim = Math.floor(kernelDimension / 2);
    let i = 0;
    for (let y = -halfDim; y <= halfDim; ++y) {
      for (let x = -halfDim; x <= halfDim; ++x) {
        shaderCode += `        texture2D(u_image, tcoord + onePixel * vec2(${x}, ${y})) * u_kernel[${i}]`;
        ++i;
        if (i !== kernelLength) {
          shaderCode += " +\n";
        }
      }
    }
    shaderCode += [";", "    gl_FragData[0] = vec4((colorSum / u_kernelWeight).rgb, texture2D(u_image, tcoord).a);", "}"].join("\n");
    return shaderCode;
  };
  publicAPI.buildVertexBuffer = () => {
    const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);
    const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    const points = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName("points");
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName("tcoords");
    const cells = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES155 = {
  framebuffer: null,
  convolutionShader: null,
  tris: null,
  kernel: [0, 0, 0, 0, 1, 0, 0, 0, 0],
  oldKernelDimension: 3,
  kernelDimension: 3
};
function extend170(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES155, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  macro.setGet(publicAPI, model, ["kernel", "kernelDimension"]);
  macro.get(publicAPI, model, ["framebuffer"]);
  vtkConvolution2DPass(publicAPI, model);
}
var newInstance163 = macro.newInstance(extend170, "vtkConvolution2DPass");
var vtkConvolution2DPass$1 = {
  newInstance: newInstance163,
  extend: extend170
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper.js
var {
  vtkErrorMacro: vtkErrorMacro64
} = macro$1;
var {
  Representation: Representation2
} = vtkProperty$1;
var {
  ObjectType: ObjectType2
} = vtkBufferObject;
var {
  PassTypes
} = vtkHardwareSelector;
var StartEvent = {
  type: "StartEvent"
};
var EndEvent = {
  type: "EndEvent"
};
var MAT4_BYTE_SIZE = 64;
var MAT4_ELEMENT_COUNT = 16;
function vtkOpenGLGlyph3DMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLGlyph3DMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData(1);
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro64("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    const gl = model.context;
    if (model._openGLRenderWindow.getWebgl2()) {
      model.hardwareSupport = true;
      model.extension = null;
    } else if (!model.extension) {
      model.extension = model.context.getExtension("ANGLE_instanced_arrays");
      model.hardwareSupport = !!model.extension;
    }
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.multiply4x4WithOffset = (out, a2, b2, off) => {
    const a00 = a2[0];
    const a01 = a2[1];
    const a02 = a2[2];
    const a03 = a2[3];
    const a10 = a2[4];
    const a11 = a2[5];
    const a12 = a2[6];
    const a13 = a2[7];
    const a20 = a2[8];
    const a21 = a2[9];
    const a22 = a2[10];
    const a23 = a2[11];
    const a30 = a2[12];
    const a31 = a2[13];
    const a32 = a2[14];
    const a33 = a2[15];
    let b0 = b2[off];
    let b1 = b2[off + 1];
    let b22 = b2[off + 2];
    let b3 = b2[off + 3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[off + 4];
    b1 = b2[off + 5];
    b22 = b2[off + 6];
    b3 = b2[off + 7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[off + 8];
    b1 = b2[off + 9];
    b22 = b2[off + 10];
    b3 = b2[off + 11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[off + 12];
    b1 = b2[off + 13];
    b22 = b2[off + 14];
    b3 = b2[off + 15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        let VSSource = shaders.Vertex;
        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "attribute mat3 gNormal;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result;
        }
        shaders.Vertex = VSSource;
      }
    }
    superClass.replaceShaderNormal(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let VSSource = shaders.Vertex;
      let FSSource = shaders.Fragment;
      if (model.renderable.getNumberOfClippingPlanes()) {
        const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    vec4 gVertex = gMatrix * vertexMC;", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], gVertex);", "    }"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
      }
      shaders.Vertex = VSSource;
      shaders.Fragment = FSSource;
    }
    superClass.replaceShaderClip(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    if (model.hardwareSupport && model.renderable.getColorArray()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      let colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity"];
      if (lastLightComplexity) {
        colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
      }
      let colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
      }
      colorImpl = colorImpl.concat(["  opacity = opacityUniform;"]);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
      }
      if (!model.drawingEdges) {
        colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 gColor;", "varying vec4 vertexColorVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput = gColor;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
        colorImpl = colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"]);
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
    superClass.replaceShaderColor(shaders, ren, actor);
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let VSSource = shaders.Vertex;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vec4 gVertexMC = gMatrix * vertexMC;", "vertexVCVSOutput = MCVCMatrix * gVertexMC;", "  gl_Position = MCPCMatrix * gVertexMC;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["attribute mat4 gMatrix;", "uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["attribute mat4 gMatrix;", "uniform mat4 MCPCMatrix;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vec4 gVertexMC = gMatrix * vertexMC;", "  gl_Position = MCPCMatrix * gVertexMC;"]).result;
      }
      shaders.Vertex = VSSource;
    }
    superClass.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let FSSource = shaders.Fragment;
      let VSSource = shaders.Vertex;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Dec", ["attribute vec3 mapperIndexVS;", "varying vec3 mapperIndexVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Impl", "  mapperIndexVSOutput = mapperIndexVS;").result;
      shaders.Vertex = VSSource;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["varying vec3 mapperIndexVSOutput;", "uniform vec3 mapperIndex;", "uniform int picking;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", ["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);", "  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result;
      shaders.Fragment = FSSource;
    } else {
      superClass.replaceShaderPicking(shaders, ren, actor);
    }
  };
  publicAPI.updateGlyphShaderParameters = (normalMatrixUsed, mcvcMatrixUsed, cellBO, carray, garray, narray, p, selector) => {
    const program = cellBO.getProgram();
    if (normalMatrixUsed) {
      const a2 = model.normalMatrix;
      const b2 = narray;
      const ofs = p * 9;
      const out = model.tmpMat3;
      const a00 = a2[0];
      const a01 = a2[1];
      const a02 = a2[2];
      const a10 = a2[3];
      const a11 = a2[4];
      const a12 = a2[5];
      const a20 = a2[6];
      const a21 = a2[7];
      const a22 = a2[8];
      const b00 = b2[ofs];
      const b01 = b2[ofs + 1];
      const b02 = b2[ofs + 2];
      const b10 = b2[ofs + 3];
      const b11 = b2[ofs + 4];
      const b12 = b2[ofs + 5];
      const b20 = b2[ofs + 6];
      const b21 = b2[ofs + 7];
      const b22 = b2[ofs + 8];
      out[0] = b00 * a00 + b01 * a10 + b02 * a20;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22;
      out[3] = b10 * a00 + b11 * a10 + b12 * a20;
      out[4] = b10 * a01 + b11 * a11 + b12 * a21;
      out[5] = b10 * a02 + b11 * a12 + b12 * a22;
      out[6] = b20 * a00 + b21 * a10 + b22 * a20;
      out[7] = b20 * a01 + b21 * a11 + b22 * a21;
      out[8] = b20 * a02 + b21 * a12 + b22 * a22;
      program.setUniformMatrix3x3("normalMatrix", model.tmpMat3);
    }
    publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcpcMatrix, garray, p * 16);
    program.setUniformMatrix("MCPCMatrix", model.tmpMat4);
    if (mcvcMatrixUsed) {
      publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcvcMatrix, garray, p * 16);
      program.setUniformMatrix("MCVCMatrix", model.tmpMat4);
    }
    if (carray) {
      const cdata = carray.getData();
      model.tmpColor[0] = cdata[p * 4] / 255;
      model.tmpColor[1] = cdata[p * 4 + 1] / 255;
      model.tmpColor[2] = cdata[p * 4 + 2] / 255;
      program.setUniform3fArray("ambientColorUniform", model.tmpColor);
      program.setUniform3fArray("diffuseColorUniform", model.tmpColor);
    }
    if (selector) {
      program.setUniform3fArray("mapperIndex", selector.getPropColorValue());
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation2.SURFACE;
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLActor.getKeyMatrices();
    mat3_exports.multiply(model.normalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    mat4_exports.multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);
    mat4_exports.multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);
    const garray = model.renderable.getMatrixArray();
    const narray = model.renderable.getNormalArray();
    const carray = model.renderable.getColorArray();
    const numPts = garray.length / 16;
    let compositePass = false;
    if (model._openGLRenderer.getSelector()) {
      if (model._openGLRenderer.getSelector().getCurrentPass() === PassTypes.COMPOSITE_INDEX_PASS) {
        compositePass = true;
      }
    }
    for (let i = model.primTypes.Start; i < model.primTypes.End; i++) {
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.drawingEdges = drawSurfaceWithEdges && (i === model.primTypes.TrisEdges || i === model.primTypes.TriStripsEdges);
        model.lastBoundBO = model.primitives[i];
        model.primitives[i].updateShaders(ren, actor, publicAPI);
        const program = model.primitives[i].getProgram();
        const mode = model.primitives[i].getOpenGLMode(representation);
        const normalMatrixUsed = program.isUniformUsed("normalMatrix");
        const mcvcMatrixUsed = program.isUniformUsed("MCVCMatrix");
        if (model.hardwareSupport) {
          if (model.extension) {
            model.extension.drawArraysInstancedANGLE(mode, 0, cabo.getElementCount(), numPts);
          } else {
            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);
          }
        } else {
          for (let p = 0; p < numPts; ++p) {
            if (compositePass) {
              model._openGLRenderer.getSelector().renderCompositeIndex(p);
            }
            publicAPI.updateGlyphShaderParameters(normalMatrixUsed, mcvcMatrixUsed, model.primitives[i], carray, garray, narray, p, compositePass ? model._openGLRenderer.getSelector() : null);
            gl.drawArrays(mode, 0, cabo.getElementCount());
          }
        }
      }
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.glyphBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("gMatrix")) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.matrixBuffer, "gMatrix", 0, 64, model.context.FLOAT, 4, false, 1)) {
          vtkErrorMacro64("Error setting gMatrix in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gMatrix");
      }
      if (cellBO.getProgram().isAttributeUsed("gNormal")) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.normalBuffer, "gNormal", 0, 36, model.context.FLOAT, 3, false, 1)) {
          vtkErrorMacro64("Error setting gNormal in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gNormal");
      }
      if (cellBO.getProgram().isAttributeUsed("gColor")) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.colorBuffer, "gColor", 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          vtkErrorMacro64("Error setting gColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gColor");
      }
      if (cellBO.getProgram().isAttributeUsed("mapperIndexVS")) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.pickBuffer, "mapperIndexVS", 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          vtkErrorMacro64("Error setting mapperIndexVS in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("mapperIndexVS");
      }
      superClass.setMapperShaderParameters(cellBO, ren, actor);
      cellBO.getAttributeUpdateTime().modified();
      return;
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    model.renderable.buildArrays();
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < model.renderable.getBuildTime().getMTime()) {
      return true;
    }
    return superClass.getNeedToRebuildBufferObjects(ren, actor);
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    if (superClass.getNeedToRebuildShaders(cellBO, ren, actor) || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const garray = model.renderable.getMatrixArray();
    const pts = model.renderable.getInputData(0).getPoints();
    const {
      useShiftAndScale,
      coordShift,
      coordScale
    } = computeCoordShiftAndScale(pts);
    if (model.hardwareSupport) {
      const narray = model.renderable.getNormalArray();
      const carray = model.renderable.getColorArray();
      if (!model.matrixBuffer) {
        model.matrixBuffer = vtkBufferObject.newInstance();
        model.matrixBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.normalBuffer = vtkBufferObject.newInstance();
        model.normalBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.colorBuffer = vtkBufferObject.newInstance();
        model.colorBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.pickBuffer = vtkBufferObject.newInstance();
        model.pickBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (useShiftAndScale) {
        const buf = garray.buffer;
        const shiftScaleMat = computeInverseShiftAndScaleMatrix(coordShift, coordScale);
        mat4_exports.invert(shiftScaleMat, shiftScaleMat);
        for (let ptIdx = 0; ptIdx < garray.byteLength; ptIdx += MAT4_BYTE_SIZE) {
          const mat = new Float32Array(buf, ptIdx, MAT4_ELEMENT_COUNT);
          mat4_exports.multiply(mat, shiftScaleMat, mat);
        }
      }
      if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {
        model.matrixBuffer.upload(garray, ObjectType2.ARRAY_BUFFER);
        model.normalBuffer.upload(narray, ObjectType2.ARRAY_BUFFER);
        if (carray) {
          model.colorBuffer.upload(carray.getData(), ObjectType2.ARRAY_BUFFER);
        } else {
          model.colorBuffer.releaseGraphicsResources();
        }
        const numPts = garray.length / 16;
        const parray = new Uint8Array(4 * numPts);
        for (let i = 0; i < numPts; ++i) {
          let value = i + 1;
          const offset = i * 4;
          parray[offset] = value % 256;
          value -= parray[offset];
          value /= 256;
          parray[offset + 1] = value % 256;
          value -= parray[offset + 1];
          value /= 256;
          parray[offset + 2] = value % 256;
          parray[offset + 3] = 255;
        }
        model.pickBuffer.upload(parray, ObjectType2.ARRAY_BUFFER);
        model.glyphBOBuildTime.modified();
      }
    }
    superClass.buildBufferObjects(ren, actor);
    if (useShiftAndScale) {
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].getCABO().setCoordShiftAndScale(coordShift, coordScale);
      }
    }
  };
}
var DEFAULT_VALUES156 = {
  normalMatrix: null,
  mcpcMatrix: null,
  mcwcMatrix: null
};
function extend171(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES156, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  model.tmpMat3 = mat3_exports.identity(new Float64Array(9));
  model.normalMatrix = mat3_exports.identity(new Float64Array(9));
  model.mcpcMatrix = mat4_exports.identity(new Float64Array(16));
  model.mcvcMatrix = mat4_exports.identity(new Float64Array(16));
  model.tmpColor = [];
  model.glyphBOBuildTime = {};
  obj(model.glyphBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLGlyph3DMapper(publicAPI, model);
}
var newInstance164 = newInstance(extend171, "vtkOpenGLGlyph3DMapper");
var vtkGlyph3DMapper2 = {
  newInstance: newInstance164,
  extend: extend171
};
registerOverride("vtkGlyph3DMapper", newInstance164);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
function getTransferFunctionsHash(transferFunctions, useIndependentComponents, numberOfComponents) {
  return transferFunctions.length > 0 ? `${transferFunctions.map((tf) => (tf == null ? void 0 : tf.getMTime()) ?? "x").join("/")}-${useIndependentComponents}-${numberOfComponents}` : "0";
}
function getImageDataHash(image, scalars) {
  return `${scalars.getMTime()}`;
}

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var {
  vtkErrorMacro: vtkErrorMacro65
} = macro$1;
var {
  SlicingMode: SlicingMode3
} = Constants15;
function splitStringOnEnter(inputString) {
  const lines = inputString.split("\n");
  const trimmedLines = [];
  for (let i = 0; i < lines.length; ++i) {
    const trimmedLine = lines[i].trim();
    if (trimmedLine.length > 0) {
      trimmedLines.push(trimmedLine);
    }
  }
  return trimmedLines;
}
function vtkOpenGLImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageMapper");
  function unregisterGraphicsResources(renderWindow) {
    model.openGLTexture.releaseGraphicsResources(renderWindow);
    [model._colorTransferFunc, model._pwFunc, model._labelOutlineThicknessArray, model._labelOutlineOpacity].forEach((coreObject) => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera(), model.openGLCamera);
      if (model.renderable.isA("vtkImageMapper") && model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (
      // backwards compat with code that (errorneously) set this to boolean
      // eslint-disable-next-line eqeqeq
      model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset
    ) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const actor = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordDec = [
      "varying vec2 tcoordVCVSOutput;",
      // color shift and scale
      "uniform float cshift0;",
      "uniform float cscale0;",
      // pwf shift and scale
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      "uniform sampler2D texture1;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform float opacity;"
    ];
    if (actor.getProperty().getUseLabelOutline()) {
      tcoordDec = tcoordDec.concat([
        // outline thickness
        "uniform sampler2D labelOutlineTexture1;",
        // outline opacity
        "uniform sampler2D labelOutlineOpacityTexture1;"
      ]);
    }
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
          // color shift and scale
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          // weighting shift and scale
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro65("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordDec).result;
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LabelOutline::Dec", ["uniform float vpWidth;", "uniform float vpHeight;", "uniform float vpOffsetX;", "uniform float vpOffsetY;", "uniform mat4 PCWCMatrix;", "uniform mat4 vWCtoIDX;", "uniform ivec3 imageDimensions;", "uniform int sliceAxis;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LabelOutlineHelperFunction", ["#ifdef vtkImageLabelOutlineOn", "vec3 fragCoordToIndexSpace(vec4 fragCoord) {", "  vec4 pcPos = vec4(", "    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,", "    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,", "    (fragCoord.z - 0.5) * 2.0,", "    1.0);", "", "  vec4 worldCoord = PCWCMatrix * pcPos;", "  vec4 vertex = (worldCoord/worldCoord.w);", "", "  vec3 index = (vWCtoIDX * vertex).xyz;", "", "  // half voxel fix for labelmapOutline", "  return (index + vec3(0.5)) / vec3(imageDimensions);", "}", "vec2 getSliceCoords(vec3 coord, int axis) {", "  if (axis == 0) return coord.yz;", "  if (axis == 1) return coord.xz;", "  if (axis == 2) return coord.xy;", "}", "#endif"]).result;
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      let tcoordImpl = ["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];
      for (let comp = 0; comp < tNumComp; comp++) {
        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro65("Unsupported number of independent coordinates.");
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordImpl).result;
    } else {
      switch (tNumComp) {
        case 1:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", [...splitStringOnEnter(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);
                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  float outlineOpacity = texture2D(labelOutlineOpacityTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)]).result;
          break;
        case 2:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "float intensity = tcolor.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;
          break;
        case 3:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    var _a;
    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || ((_a = cellBO.getProgram()) == null ? void 0 : _a.getHandle()) === 0 || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < actor.getProperty().getMTime() || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro65("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro65("Error setting tcoordMC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("texture1", texUnit);
    const numComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; i++) {
        cellBO.getProgram().setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }
    const oglShiftScale = model.openGLTexture.getShiftAndScale();
    for (let i = 0; i < numComp; i++) {
      let cw = actor.getProperty().getColorWindow();
      let cl = actor.getProperty().getColorLevel();
      const target = iComps ? i : 0;
      const cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale = oglShiftScale.scale / cw;
      const shift = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf(`cshift${i}`, shift);
      cellBO.getProgram().setUniformf(`cscale${i}`, scale);
    }
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1;
      let pwfShift = 0;
      const target = iComps ? i : 0;
      const pwfun = actor.getProperty().getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length;
        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;
      }
      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);
      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("colorTexture1", texColorUnit);
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("pwfTexture1", texOpacityUnit);
    if (actor.getProperty().getUseLabelOutline()) {
      const outlineThicknessUnit = model.labelOutlineThicknessTexture.getTextureUnit();
      cellBO.getProgram().setUniformi("labelOutlineTexture1", outlineThicknessUnit);
      const texOutlineOpacityUnit = model.labelOutlineOpacityTexture.getTextureUnit();
      cellBO.getProgram().setUniformi("labelOutlineOpacityTexture1", texOutlineOpacityUnit);
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      mat4_exports.transpose(model.imagemat, model.currentInput.getIndexToWorld());
      mat4_exports.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const actMats = model.openGLImageSlice.getKeyMatrices();
    const image = model.currentInput;
    const i2wmat4 = image.getIndexToWorld();
    mat4_exports.multiply(model.imagemat, actMats.mcwc, i2wmat4);
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    mat4_exports.multiply(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      mat4_exports.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix("MCPCMatrix", model.imagemat);
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const worldToIndex = image.getWorldToIndex();
      const imageDimensions = image.getDimensions();
      let sliceAxis = model.renderable.getClosestIJKAxis().ijkMode;
      if (sliceAxis === SlicingMode3.NONE) {
        sliceAxis = SlicingMode3.K;
      }
      program.setUniform3i("imageDimensions", imageDimensions[0], imageDimensions[1], imageDimensions[2]);
      program.setUniformi("sliceAxis", sliceAxis);
      program.setUniformMatrix("vWCtoIDX", worldToIndex);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);
      mat4_exports.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size[0]);
      program.setUniformf("vpHeight", size[1]);
      const offset = publicAPI.getRenderTargetOffset();
      program.setUniformf("vpOffsetX", offset[0] / size[0]);
      program.setUniformf("vpOffsetY", offset[1] / size[1]);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    if (actor.getProperty().getUseLabelOutline()) {
      model.labelOutlineThicknessTexture.activate();
      model.labelOutlineOpacityTexture.activate();
    }
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    if (actor.getProperty().getUseLabelOutline()) {
      model.labelOutlineThicknessTexture.deactivate();
      model.labelOutlineOpacityTexture.deactivate();
    }
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getCurrentImage();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro65("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    var _a, _b, _c, _d, _e;
    return model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || !((_a = model.openGLTexture) == null ? void 0 : _a.getHandle()) || !((_b = model.colorTexture) == null ? void 0 : _b.getHandle()) || actor.getProperty().getUseLabelOutline() && (!((_c = model.labelOutlineThicknessTexture) == null ? void 0 : _c.getHandle()) || !((_d = model.labelOutlineOpacityTexture) == null ? void 0 : _d.getHandle())) || !((_e = model.pwfTexture) == null ? void 0 : _e.getHandle());
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    var _a, _b, _c, _d;
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const imgScalars = image.getPointData() && image.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    const dataType = imgScalars.getDataType();
    const numComp = imgScalars.getNumberOfComponents();
    const actorProperty = actor.getProperty();
    const iType = actorProperty.getInterpolationType();
    const iComps = actorProperty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunctions = [];
    for (let component = 0; component < numIComps; ++component) {
      colorTransferFunctions.push(actorProperty.getRGBTransferFunction(component));
    }
    const cfunToString = getTransferFunctionsHash(colorTransferFunctions, iComps, numIComps);
    const firstColorTransferFunc = actorProperty.getRGBTransferFunction();
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(firstColorTransferFunc);
    const reBuildC = !((_a = cTex == null ? void 0 : cTex.oglObject) == null ? void 0 : _a.getHandle()) || (cTex == null ? void 0 : cTex.hash) !== cfunToString;
    if (reBuildC) {
      model.colorTexture = vtkOpenGLTexture$1.newInstance({
        resizable: true
      });
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      let cWidth = model.renderable.getColorTextureWidth();
      if (cWidth <= 0) {
        cWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      if (iType === InterpolationType3.NEAREST) {
        model.colorTexture.setMinificationFilter(Filter.NEAREST);
        model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        model.colorTexture.setMinificationFilter(Filter.LINEAR);
        model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      }
      if (firstColorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c2 = 0; c2 < numIComps; c2++) {
          const cfun = actorProperty.getRGBTransferFunction(c2);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c2 * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c2 * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c2 * cWidth * 6 + i] = 255 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw({
          width: cWidth,
          height: textureHeight,
          numComps: 3,
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          data: cTable
        });
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw({
          width: cWidth,
          height: 1,
          numComps: 3,
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          data: cTable
        });
      }
      if (firstColorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(firstColorTransferFunc, model.colorTexture, cfunToString);
        if (firstColorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(firstColorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = firstColorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }
    const opacityFunctions = [];
    for (let component = 0; component < numIComps; ++component) {
      opacityFunctions.push(actorProperty.getPiecewiseFunction(component));
    }
    const pwfunToString = getTransferFunctionsHash(opacityFunctions, iComps, numIComps);
    const firstPwFunc = actorProperty.getPiecewiseFunction();
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(firstPwFunc);
    const reBuildPwf = !((_b = pwfTex == null ? void 0 : pwfTex.oglObject) == null ? void 0 : _b.getHandle()) || (pwfTex == null ? void 0 : pwfTex.hash) !== pwfunToString;
    if (reBuildPwf) {
      let pwfWidth = model.renderable.getOpacityTextureWidth();
      if (pwfWidth <= 0) {
        pwfWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = vtkOpenGLTexture$1.newInstance({
        resizable: true
      });
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (iType === InterpolationType3.NEAREST) {
        model.pwfTexture.setMinificationFilter(Filter.NEAREST);
        model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        model.pwfTexture.setMinificationFilter(Filter.LINEAR);
        model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
      }
      if (firstPwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c2 = 0; c2 < numIComps; ++c2) {
          const pwfun = actorProperty.getPiecewiseFunction(c2);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c2 * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c2 * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c2 * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw({
          width: pwfWidth,
          height: textureHeight,
          numComps: 1,
          dataType: VtkDataTypes.FLOAT,
          data: pwfFloatTable
        });
      } else {
        pwfTable.fill(255);
        model.pwfTexture.create2DFromRaw({
          width: pwfWidth,
          height: 1,
          numComps: 1,
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          data: pwfTable
        });
      }
      if (firstPwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(firstPwFunc, model.pwfTexture, pwfunToString);
        if (firstPwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(firstPwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = firstPwFunc;
      }
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }
    if (actor.getProperty().getUseLabelOutline()) {
      publicAPI.updatelabelOutlineThicknessTexture(actor);
      publicAPI.updateLabelOutlineOpacityTexture(actor);
    }
    const {
      ijkMode
    } = model.renderable.getClosestIJKAxis();
    let slice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      slice = model.renderable.getSliceAtPosition(slice);
    }
    const nSlice = model.renderable.isA("vtkImageArrayMapper") ? model.renderable.getSubSlice() : Math.round(slice);
    const ext = image.getExtent();
    let sliceOffset;
    if (ijkMode === SlicingMode3.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode3.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode3.K || ijkMode === SlicingMode3.NONE) {
      sliceOffset = nSlice - ext[4];
    }
    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getInterpolationType()}`;
    if (model.VBOBuildString !== toString) {
      const dims = image.getDimensions();
      if (!model.openGLTexture) {
        model.openGLTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
      }
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      if (iType === InterpolationType3.NEAREST) {
        if ((/* @__PURE__ */ new Set([1, 3, 4])).has(numComp) && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        if (numComp === 4 && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);
      }
      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);
      const sliceSize = dims[0] * dims[1] * numComp;
      const ptsArray = new Float32Array(12);
      const tcoordArray = new Float32Array(8);
      for (let i = 0; i < 4; i++) {
        tcoordArray[i * 2] = i % 2 ? 1 : 0;
        tcoordArray[i * 2 + 1] = i > 1 ? 1 : 0;
      }
      const sliceDepth = [SlicingMode3.X, SlicingMode3.Y, SlicingMode3.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;
      const spatialExt = image.getSpatialExtent();
      const basicScalars = imgScalars.getData();
      let scalars = null;
      if (ijkMode === SlicingMode3.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let j = 0; j < dims[1]; j++) {
            let bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            const end2 = bsIdx + numComp;
            while (bsIdx < end2) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode3.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let i = 0; i < dims[0]; i++) {
            let bsIdx = (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[0] + i) * numComp;
            const end2 = bsIdx + numComp;
            while (bsIdx < end2) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode3.K || ijkMode === SlicingMode3.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro65("Reformat slicing not yet supported.");
      }
      const ranges = imgScalars.getRanges();
      model.openGLTexture.resetFormatAndType();
      model.openGLTexture.create2DFilterableFromRaw({
        width: dims[0],
        height: dims[1],
        numComps: numComp,
        dataType: imgScalars.getDataType(),
        data: scalars,
        preferSizeOverAccuracy: !!((_d = (_c = model.renderable).getPreferSizeOverAccuracy) == null ? void 0 : _d.call(_c)),
        ranges
      });
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName("tcoords");
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.updateLabelOutlineOpacityTexture = (image) => {
    var _a, _b;
    let labelOutlineOpacity = image.getProperty().getLabelOutlineOpacity();
    if (typeof labelOutlineOpacity === "number") {
      if (((_a = model._cachedLabelOutlineOpacityObj) == null ? void 0 : _a[0]) === labelOutlineOpacity) {
        labelOutlineOpacity = model._cachedLabelOutlineOpacityObj;
      } else {
        labelOutlineOpacity = [labelOutlineOpacity];
      }
      model._cachedLabelOutlineOpacityObj = labelOutlineOpacity;
    }
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineOpacity);
    const toString = `${labelOutlineOpacity.join("-")}`;
    const reBuildL = !((_b = lTex == null ? void 0 : lTex.oglObject) == null ? void 0 : _b.getHandle()) || (lTex == null ? void 0 : lTex.hash) !== toString;
    if (reBuildL) {
      let lWidth = model.renderable.getLabelOutlineTextureWidth();
      if (lWidth <= 0) {
        lWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Float32Array(lSize);
      for (let i = 0; i < lWidth; ++i) {
        lTable[i] = labelOutlineOpacity[i] ?? labelOutlineOpacity[0];
      }
      model.labelOutlineOpacityTexture = vtkOpenGLTexture$1.newInstance({
        resizable: false
      });
      model.labelOutlineOpacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.labelOutlineOpacityTexture.resetFormatAndType();
      model.labelOutlineOpacityTexture.setMinificationFilter(Filter.NEAREST);
      model.labelOutlineOpacityTexture.setMagnificationFilter(Filter.NEAREST);
      model.labelOutlineOpacityTexture.create2DFromRaw({
        width: lWidth,
        height: lHeight,
        numComps: 1,
        dataType: VtkDataTypes.FLOAT,
        data: lTable
      });
      if (labelOutlineOpacity) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineOpacity, model.labelOutlineOpacityTexture, toString);
        if (labelOutlineOpacity !== model._labelOutlineOpacity) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineOpacity, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineOpacity, publicAPI);
        }
        model._labelOutlineOpacity = labelOutlineOpacity;
      }
    } else {
      model.labelOutlineOpacityTexture = lTex.oglObject;
    }
  };
  publicAPI.updatelabelOutlineThicknessTexture = (image) => {
    var _a;
    const labelOutlineThicknessArray = image.getProperty().getLabelOutlineThicknessByReference();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);
    const toString = `${labelOutlineThicknessArray.join("-")}`;
    const reBuildL = !((_a = lTex == null ? void 0 : lTex.oglObject) == null ? void 0 : _a.getHandle()) || (lTex == null ? void 0 : lTex.hash) !== toString;
    if (reBuildL) {
      let lWidth = model.renderable.getLabelOutlineTextureWidth();
      if (lWidth <= 0) {
        lWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);
      for (let i = 0; i < lWidth; ++i) {
        const thickness = typeof labelOutlineThicknessArray[i] !== "undefined" ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      model.labelOutlineThicknessTexture = vtkOpenGLTexture$1.newInstance({
        resizable: false
      });
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.create2DFromRaw({
        width: lWidth,
        height: lHeight,
        numComps: 1,
        dataType: VtkDataTypes.UNSIGNED_CHAR,
        data: lTable
      });
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, toString);
        if (labelOutlineThicknessArray !== model._labelOutlineThicknessArray) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineThicknessArray, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineThicknessArray, publicAPI);
        }
        model._labelOutlineThicknessArray = labelOutlineThicknessArray;
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
  };
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.delete = chain(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}
var DEFAULT_VALUES157 = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  imagematinv: null,
  colorTexture: null,
  pwfTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineOpacityTexture: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0
  // _scalars: null,
  // _colorTransferFunc: null,
  // _pwFunc: null,
  // _labelOutlineThicknessArray: null,
};
function extend172(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES157, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  model.projectionToWorld = mat4_exports.identity(new Float64Array(16));
  model.idxToView = mat4_exports.identity(new Float64Array(16));
  model.idxNormalMatrix = mat3_exports.identity(new Float64Array(9));
  model.modelToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToView = mat4_exports.identity(new Float64Array(16));
  setGet(publicAPI, model, []);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkOpenGLImageMapper(publicAPI, model);
}
var newInstance165 = newInstance(extend172, "vtkOpenGLImageMapper");
var vtkImageMapper2 = {
  newInstance: newInstance165,
  extend: extend172
};
registerOverride("vtkAbstractImageMapper", newInstance165);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
function vtkOpenGLImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageSlice");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseZBufferPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = (renderPass) => publicAPI.traverseOpaquePass(renderPass);
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES158 = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend173(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES158, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLImageSlice(publicAPI, model);
}
var newInstance166 = newInstance(extend173, "vtkOpenGLImageSlice");
var vtkImageSlice2 = {
  newInstance: newInstance166,
  extend: extend173
};
registerOverride("vtkImageSlice", newInstance166);

// node_modules/@kitware/vtk.js/Filters/General/ImageDataOutlineFilter.js
var {
  vtkErrorMacro: vtkErrorMacro66
} = macro;
function vtkImageDataOutlineFilter(publicAPI, model) {
  model.classHierarchy.push("vtkImageDataOutlineFilter");
  const superClass = {
    ...publicAPI
  };
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input || !input.isA("vtkImageData")) {
      vtkErrorMacro66("Invalid or missing input");
      return;
    }
    const spatialExt = input.getSpatialExtent();
    if (!spatialExt) {
      vtkErrorMacro66("Unable to fetch spatial extents of input image.");
      return;
    }
    model._cubeSource.setBounds(spatialExt);
    model._cubeSource.setMatrix(input.getIndexToWorld());
    outData[0] = model._cubeSource.getOutputData();
  };
  publicAPI.getMTime = () => Math.max(superClass.getMTime(), model._cubeSource.getMTime());
  publicAPI.setGenerateFaces = model._cubeSource.setGenerateFaces;
  publicAPI.setGenerateLines = model._cubeSource.setGenerateLines;
  publicAPI.getGenerateFaces = model._cubeSource.getGenerateFaces;
  publicAPI.getGenerateLines = model._cubeSource.getGenerateLines;
}
var DEFAULT_VALUES159 = {};
function extend174(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES159, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  model._cubeSource = vtkCubeSource$1.newInstance();
  macro.moveToProtected(publicAPI, model, ["cubeSource", "tmpOut"]);
  vtkImageDataOutlineFilter(publicAPI, model);
}
var newInstance167 = macro.newInstance(extend174, "vtkImageDataOutlineFilter");
var vtkImageDataOutlineFilter$1 = {
  newInstance: newInstance167,
  extend: extend174
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperVS.glsl.js
var vtkImageResliceMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperFS.glsl.js
var vtkImageResliceMapperFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageResliceMapper.js
var {
  vtkErrorMacro: vtkErrorMacro67
} = macro$1;
function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
  matrixType.identity(tmpMat);
  return matrixArray.reduce((res, matrix, index) => {
    if (index === 0) {
      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
    }
    return matrix ? matrixType.multiply(res, res, matrix) : res;
  }, tmpMat);
}
function vtkOpenGLImageResliceMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageResliceMapper");
  const graphicsResourceReferenceCount = /* @__PURE__ */ new Map();
  function decreaseGraphicsResourceCount(openGLRenderWindow, coreObject) {
    if (!coreObject) {
      return;
    }
    const oldCount = graphicsResourceReferenceCount.get(coreObject) ?? 0;
    const newCount = oldCount - 1;
    if (newCount <= 0) {
      openGLRenderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI);
      graphicsResourceReferenceCount.delete(coreObject);
    } else {
      graphicsResourceReferenceCount.set(coreObject, newCount);
    }
  }
  function increaseGraphicsResourceCount(openGLRenderWindow, coreObject) {
    if (!coreObject) {
      return;
    }
    const oldCount = graphicsResourceReferenceCount.get(coreObject) ?? 0;
    const newCount = oldCount + 1;
    graphicsResourceReferenceCount.set(coreObject, newCount);
    if (oldCount <= 0) {
      openGLRenderWindow.registerGraphicsResourceUser(coreObject, publicAPI);
    }
  }
  function replaceGraphicsResource(openGLRenderWindow, oldResourceCoreObject, newResourceCoreObject) {
    if (oldResourceCoreObject === newResourceCoreObject) {
      return;
    }
    decreaseGraphicsResourceCount(openGLRenderWindow, oldResourceCoreObject);
    increaseGraphicsResourceCount(openGLRenderWindow, newResourceCoreObject);
  }
  function unregisterGraphicsResources(renderWindow) {
    [...graphicsResourceReferenceCount.keys()].forEach((coreObject) => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model._openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const ren = model._openGLRenderer.getRenderable();
      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera(), model.openGLCamera);
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (
      // backwards compat with code that (errorneously) set this to boolean
      // eslint-disable-next-line eqeqeq
      model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset
    ) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const actor = model._openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    const numberOfInputs = model.renderable.getNumberOfInputPorts();
    model.currentValidInputs = [];
    for (let inputIndex = 0; inputIndex < numberOfInputs; ++inputIndex) {
      const imageData = model.renderable.getInputData(inputIndex);
      if (imageData && !imageData.isDeleted()) {
        model.currentValidInputs.push({
          imageData,
          inputIndex
        });
      }
    }
    const numberOfValidInputs = model.currentValidInputs.length;
    if (numberOfValidInputs <= 0) {
      vtkErrorMacro67("No input!");
      return;
    }
    const firstImageData = model.currentValidInputs[0].imageData;
    const firstScalars = firstImageData.getPointData().getScalars();
    model.multiTexturePerVolumeEnabled = numberOfValidInputs > 1;
    model.numberOfComponents = model.multiTexturePerVolumeEnabled ? numberOfValidInputs : firstScalars.getNumberOfComponents();
    publicAPI.updateResliceGeometry();
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
    const actorProperties = actor.getProperties();
    model.currentValidInputs.forEach((_ref) => {
      let {
        inputIndex
      } = _ref;
      const actorProperty = actorProperties[inputIndex];
      const interpolationType = actorProperty.getInterpolationType();
      const scalarTexture = model.scalarTextures[inputIndex];
      if (interpolationType === InterpolationType3.NEAREST) {
        scalarTexture.setMinificationFilter(Filter.NEAREST);
        scalarTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        scalarTexture.setMinificationFilter(Filter.LINEAR);
        scalarTexture.setMagnificationFilter(Filter.LINEAR);
      }
    });
    const firstValidInput = model.currentValidInputs[0];
    const firstProperty = actorProperties[firstValidInput.inputIndex];
    const iType = firstProperty.getInterpolationType();
    if (iType === InterpolationType3.NEAREST) {
      model.colorTexture.setMinificationFilter(Filter.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
    }
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    const allTextures = [...model.scalarTextures, model.colorTexture, model.pwfTexture];
    allTextures.forEach((texture) => texture.activate());
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    allTextures.forEach((texture) => texture.deactivate());
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    var _a, _b, _c;
    return model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < ((_a = actor.getProperty(model.currentValidInputs[0].inputIndex)) == null ? void 0 : _a.getMTime()) || model.currentValidInputs.some((_ref2) => {
      let {
        imageData
      } = _ref2;
      return model.VBOBuildTime.getMTime() < imageData.getMTime();
    }) || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime() || model.scalarTextures.length !== model.currentValidInputs.length || !model.scalarTextures.every((texture) => !!(texture == null ? void 0 : texture.getHandle())) || !((_b = model.colorTexture) == null ? void 0 : _b.getHandle()) || !((_c = model.pwfTexture) == null ? void 0 : _c.getHandle());
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    var _a, _b;
    const actorProperties = actor.getProperties();
    model.currentValidInputs.forEach((_ref3, component) => {
      var _a2;
      let {
        imageData
      } = _ref3;
      const scalars = imageData.getPointData().getScalars();
      const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
      const scalarsHash = getImageDataHash(imageData, scalars);
      const reBuildTex = !((_a2 = tex == null ? void 0 : tex.oglObject) == null ? void 0 : _a2.getHandle()) || (tex == null ? void 0 : tex.hash) !== scalarsHash;
      const actorProperty = actorProperties[component];
      const updatedExtents = actorProperty.getUpdatedExtents();
      const hasUpdatedExtents = !!updatedExtents.length;
      if (reBuildTex && !hasUpdatedExtents) {
        const newScalarTexture = vtkOpenGLTexture$1.newInstance();
        newScalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
        const dims = imageData.getDimensions();
        newScalarTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
        newScalarTexture.resetFormatAndType();
        newScalarTexture.create3DFilterableFromDataArray({
          width: dims[0],
          height: dims[1],
          depth: dims[2],
          dataArray: scalars
        });
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, newScalarTexture, scalarsHash);
        model.scalarTextures[component] = newScalarTexture;
      } else {
        model.scalarTextures[component] = tex.oglObject;
      }
      if (hasUpdatedExtents) {
        actorProperty.setUpdatedExtents([]);
        const dims = imageData.getDimensions();
        model.scalarTextures[component].create3DFilterableFromDataArray({
          width: dims[0],
          height: dims[1],
          depth: dims[2],
          dataArray: scalars,
          updatedExtents
        });
      }
      replaceGraphicsResource(model._openGLRenderWindow, model._scalarTexturesCore[component], scalars);
      model._scalarTexturesCore[component] = scalars;
    });
    const firstValidInput = model.currentValidInputs[0];
    const firstActorProperty = actorProperties[firstValidInput.inputIndex];
    const iComps = firstActorProperty.getIndependentComponents();
    const numIComps = iComps ? model.numberOfComponents : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunctions = [];
    for (let component = 0; component < numIComps; ++component) {
      colorTransferFunctions.push(firstActorProperty.getRGBTransferFunction(component));
    }
    const colorFuncHash = getTransferFunctionsHash(colorTransferFunctions, iComps, numIComps);
    const firstColorTransferFunc = firstActorProperty.getRGBTransferFunction();
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(firstColorTransferFunc);
    const reBuildC = !((_a = cTex == null ? void 0 : cTex.oglObject) == null ? void 0 : _a.getHandle()) || (cTex == null ? void 0 : cTex.hash) !== colorFuncHash;
    if (reBuildC) {
      let cWidth = model.renderable.getColorTextureWidth();
      if (cWidth <= 0) {
        cWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      const newColorTexture = vtkOpenGLTexture$1.newInstance();
      newColorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (firstColorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c2 = 0; c2 < numIComps; c2++) {
          const cfun = firstActorProperty.getRGBTransferFunction(c2);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c2 * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c2 * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c2 * cWidth * 3 + i] = 255 * tmpTable[i];
            }
          }
        }
        newColorTexture.resetFormatAndType();
        newColorTexture.create2DFromRaw({
          width: cWidth,
          height: textureHeight,
          numComps: 3,
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          data: cTable
        });
      } else {
        for (let column = 0; column < cWidth * 3; ++column) {
          const opacity = 255 * column / ((cWidth - 1) * 3);
          for (let row = 0; row < textureHeight; ++row) {
            cTable[row * cWidth * 3 + column + 0] = opacity;
            cTable[row * cWidth * 3 + column + 1] = opacity;
            cTable[row * cWidth * 3 + column + 2] = opacity;
          }
        }
        newColorTexture.resetFormatAndType();
        newColorTexture.create2DFromRaw({
          width: cWidth,
          height: 1,
          numComps: 3,
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          data: cTable
        });
      }
      if (firstColorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(firstColorTransferFunc, newColorTexture, colorFuncHash);
      }
      model.colorTexture = newColorTexture;
    } else {
      model.colorTexture = cTex.oglObject;
    }
    replaceGraphicsResource(model._openGLRenderWindow, model._colorTextureCore, firstColorTransferFunc);
    model._colorTextureCore = firstColorTransferFunc;
    const opacityFunctions = [];
    for (let component = 0; component < numIComps; ++component) {
      opacityFunctions.push(firstActorProperty.getPiecewiseFunction(component));
    }
    const opacityFuncHash = getTransferFunctionsHash(opacityFunctions, iComps, numIComps);
    const firstPwFunc = firstActorProperty.getPiecewiseFunction();
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(firstPwFunc);
    const reBuildPwf = !((_b = pwfTex == null ? void 0 : pwfTex.oglObject) == null ? void 0 : _b.getHandle()) || (pwfTex == null ? void 0 : pwfTex.hash) !== opacityFuncHash;
    if (reBuildPwf) {
      let pwfWidth = model.renderable.getOpacityTextureWidth();
      if (pwfWidth <= 0) {
        pwfWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      const newOpacityTexture = vtkOpenGLTexture$1.newInstance();
      newOpacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (firstPwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c2 = 0; c2 < numIComps; ++c2) {
          const pwfun = firstActorProperty.getPiecewiseFunction(c2);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c2 * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c2 * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[i] = tmpTable[i];
              }
            }
          }
        }
        newOpacityTexture.resetFormatAndType();
        newOpacityTexture.create2DFromRaw({
          width: pwfWidth,
          height: textureHeight,
          numComps: 1,
          dataType: VtkDataTypes.FLOAT,
          data: pwfFloatTable
        });
      } else {
        pwfTable.fill(255);
        newOpacityTexture.resetFormatAndType();
        newOpacityTexture.create2DFromRaw({
          width: pwfWidth,
          height: textureHeight,
          numComps: 1,
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          data: pwfTable
        });
      }
      if (firstPwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(firstPwFunc, newOpacityTexture, opacityFuncHash);
      }
      model.pwfTexture = newOpacityTexture;
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }
    replaceGraphicsResource(model._openGLRenderWindow, model._pwfTextureCore, firstPwFunc);
    model._pwfTextureCore = firstPwFunc;
    const vboString = `${model.resliceGeom.getMTime()}A${model.renderable.getSlabThickness()}`;
    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: model.resliceGeom.getPoints().getData()
      });
      points.setName("points");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: model.resliceGeom.getPolys().getData()
      });
      const options = {
        points,
        cellOffset: 0
      };
      if (model.renderable.getSlabThickness() > 0) {
        const n = model.resliceGeom.getPointData().getNormals();
        if (!n) {
          vtkErrorMacro67("Slab mode requested without normals");
        } else {
          options.normals = n;
        }
      }
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, options);
    }
    model.VBOBuildString = vboString;
    model.VBOBuildTime.modified();
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const firstImageData = model.currentValidInputs[0].imageData;
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      model.scalarTextures.forEach((scalarTexture, component) => {
        program.setUniformi(`volumeTexture[${component}]`, scalarTexture.getTextureUnit());
      });
      if (program.isAttributeUsed("vertexWC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexWC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro67("Error setting vertexWC in shader VAO.");
        }
      }
      if (program.isAttributeUsed("normalWC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "normalWC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro67("Error setting normalWC in shader VAO.");
        }
      }
      if (program.isUniformUsed("slabThickness")) {
        program.setUniformf("slabThickness", model.renderable.getSlabThickness());
      }
      if (program.isUniformUsed("spacing")) {
        program.setUniform3fv("spacing", firstImageData.getSpacing());
      }
      if (program.isUniformUsed("slabType")) {
        program.setUniformi("slabType", model.renderable.getSlabType());
      }
      if (program.isUniformUsed("slabType")) {
        program.setUniformi("slabType", model.renderable.getSlabType());
      }
      if (program.isUniformUsed("slabTrapezoid")) {
        program.setUniformi("slabTrapezoid", model.renderable.getSlabTrapezoidIntegration());
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      if (program.isUniformUsed("WCTCMatrix")) {
        const dim = firstImageData.getDimensions();
        mat4_exports.copy(model.tmpMat4, firstImageData.getIndexToWorld());
        mat4_exports.translate(model.tmpMat4, model.tmpMat4, [-0.5, -0.5, -0.5]);
        mat4_exports.scale(model.tmpMat4, model.tmpMat4, dim);
        mat4_exports.invert(model.tmpMat4, model.tmpMat4);
        if (inverseShiftScaleMatrix) {
          mat4_exports.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
        }
        program.setUniformMatrix("WCTCMatrix", model.tmpMat4);
      }
      if (program.isUniformUsed("vboScaling")) {
        program.setUniform3fv("vboScaling", cellBO.getCABO().getCoordScale() ?? [1, 1, 1]);
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const keyMats = model._openGLCamera.getKeyMatrices(ren);
    const actMats = model._openGLImageSlice.getKeyMatrices();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const program = cellBO.getProgram();
    if (program.isUniformUsed("MCPCMatrix")) {
      mat4_exports.identity(model.tmpMat4);
      program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      mat4_exports.identity(model.tmpMat4);
      program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const firstPpty = actor.getProperty(model.currentValidInputs[0].inputIndex);
    const opacity = firstPpty.getOpacity();
    program.setUniformf("opacity", opacity);
    const numComp = model.numberOfComponents;
    const iComps = firstPpty.getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; ++i) {
        program.setUniformf(`mix${i}`, firstPpty.getComponentWeight(i));
      }
    }
    for (let component = 0; component < numComp; component++) {
      const useMultiTexture = model.multiTexturePerVolumeEnabled;
      const textureIndex = useMultiTexture ? component : 0;
      const volInfoIndex = useMultiTexture ? 0 : component;
      const scalarTexture = model.scalarTextures[textureIndex];
      const volInfo = scalarTexture.getVolumeInfo();
      const volScale = volInfo.scale[volInfoIndex];
      const volOffset = volInfo.offset[volInfoIndex];
      const target = iComps ? component : 0;
      let cw = firstPpty.getColorWindow();
      let cl = firstPpty.getColorLevel();
      const cfun = firstPpty.getRGBTransferFunction(target);
      if (cfun && firstPpty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const colorScale = volScale / cw;
      const colorShift = (volOffset - cl) / cw + 0.5;
      program.setUniformf(`cshift${component}`, colorShift);
      program.setUniformf(`cscale${component}`, colorScale);
      let pwfScale = 1;
      let pwfShift = 0;
      const pwfun = firstPpty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volScale / length;
        pwfShift = (volOffset - mid) / length + 0.5;
      }
      program.setUniformf(`pwfshift${component}`, pwfShift);
      program.setUniformf(`pwfscale${component}`, pwfScale);
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    program.setUniformi("colorTexture1", texColorUnit);
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    program.setUniformi("pwfTexture1", texOpacityUnit);
    program.setUniform4fv("backgroundColor", model.renderable.getBackgroundColor());
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    var _a;
    const iComp = actor.getProperty(model.currentValidInputs[0].inputIndex).getIndependentComponents();
    const slabTh = model.renderable.getSlabThickness();
    const slabType = model.renderable.getSlabType();
    const slabTrap = model.renderable.getSlabTrapezoidIntegration();
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || model.lastNumberOfComponents !== model.numberOfComponents || model.lastMultiTexturePerVolumeEnabled !== model.multiTexturePerVolumeEnabled || ((_a = cellBO.getProgram()) == null ? void 0 : _a.getHandle()) === 0 || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastNumberOfComponents = model.numberOfComponents;
      model.lastMultiTexturePerVolumeEnabled = model.multiTexturePerVolumeEnabled;
      model.lastIndependentComponents = iComp;
      model.lastSlabThickness = slabTh;
      model.lastSlabType = slabType;
      model.lastSlabTrapezoidIntegration = slabTrap;
      return true;
    }
    return false;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkImageResliceMapperVS;
    shaders.Fragment = vtkImageResliceMapperFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
      shaders.Fragment = FSSource;
    }
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const tcoordVSDec = ["uniform mat4 WCTCMatrix;", "out vec3 fragTexCoord;"];
    const slabThickness = model.renderable.getSlabThickness();
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", tcoordVSDec).result;
    const tcoordVSImpl = ["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"];
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", tcoordVSImpl).result;
    const tNumComp = model.numberOfComponents;
    const iComps = actor.getProperty(model.currentValidInputs[0].inputIndex).getIndependentComponents();
    let tcoordFSDec = [
      "in vec3 fragTexCoord;",
      `uniform highp sampler3D volumeTexture[${model.scalarTextures.length}];`,
      "uniform mat4 WCTCMatrix;",
      // color shift and scale
      "uniform float cshift0;",
      "uniform float cscale0;",
      // pwf shift and scale
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      // color and pwf textures
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      // opacity
      "uniform float opacity;",
      // background color
      "uniform vec4 backgroundColor;"
    ];
    tcoordFSDec.push("vec4 rawSampleTexture(vec3 pos) {");
    if (!model.multiTexturePerVolumeEnabled) {
      tcoordFSDec.push("return texture(volumeTexture[0], pos);", "}");
    } else {
      tcoordFSDec.push("vec4 rawSample;");
      for (let component = 0; component < model.scalarTextures.length; ++component) {
        tcoordFSDec.push(`rawSample[${component}] = texture(volumeTexture[${component}], pos)[0];`);
      }
      tcoordFSDec.push("return rawSample;", "}");
    }
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
          // color shift and scale
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          // weighting shift and scale
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro67("Unsupported number of independent coordinates.");
      }
    }
    if (slabThickness > 0) {
      tcoordFSDec = tcoordFSDec.concat(["uniform vec3 spacing;", "uniform float slabThickness;", "uniform int slabType;", "uniform int slabTrapezoid;", "uniform vec3 vboScaling;"]);
      tcoordFSDec = tcoordFSDec.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)", "{", "  vec4 retVal = vec4(1.0);", "  if (slabType == 0) // min", "  {", "    retVal = min(currVal, valToComp);", "  }", "  else if (slabType == 1) // max", "  {", "    retVal = max(currVal, valToComp);", "  }", "  else if (slabType == 3) // sum", "  {", "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ", "  }", "  else // mean", "  {", "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ", "  }", "  return retVal;", "}"]);
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordFSDec).result;
    let tcoordFSImpl = ["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))", "{", "  // set the background color and exit", "  gl_FragData[0] = backgroundColor;", "  return;", "}", "vec4 tvalue = rawSampleTexture(fragTexCoord);"];
    if (slabThickness > 0) {
      tcoordFSImpl = tcoordFSImpl.concat(["// Get the first and last samples", "int numSlices = 1;", "float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;", "vec3 normalxspacing = scaling * normalWCVSOutput;", "float distTraveled = length(normalxspacing);", "int trapezoid = 0;", "while (distTraveled < slabThickness * 0.5)", "{", "  distTraveled += length(normalxspacing);", "  float fnumSlices = float(numSlices);", "  if (distTraveled > slabThickness * 0.5)", "  {", "    // Before stepping outside the slab, sample at the boundaries", "    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;", "    trapezoid = slabTrapezoid;", "  }", "  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;", "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))", "  {", "    vec4 newVal = rawSampleTexture(fragTCoordNeg);", "    tvalue = compositeValue(tvalue, newVal, trapezoid);", "    numSlices += 1;", "  }", "  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;", "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))", "  {", "    vec4 newVal = rawSampleTexture(fragTCoordPos);", "    tvalue = compositeValue(tvalue, newVal, trapezoid);", "    numSlices += 1;", "  }", "}", "// Finally, if slab type is *mean*, divide the sum by the numSlices", "if (slabType == 2)", "{", "  tvalue = tvalue / float(numSlices);", "}"]);
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      for (let comp = 0; comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro67("Unsupported number of independent coordinates.");
      }
    } else {
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["// Dependent components", "float intensity = tvalue.r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float intensity = tvalue.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]);
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordFSImpl).result;
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    shaders.Geometry = GSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const slabThickness = model.renderable.getSlabThickness();
    let posVCVSDec = ["attribute vec4 vertexWC;"];
    posVCVSDec = posVCVSDec.concat([`//${publicAPI.getMTime()}${model.resliceGeomUpdateString}`]);
    if (slabThickness > 0) {
      posVCVSDec = posVCVSDec.concat(["attribute vec3 normalWC;", "varying vec3 normalWCVSOutput;", "varying vec4 vertexWCVSOutput;"]);
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", posVCVSDec).result;
    let posVCVSImpl = ["gl_Position = MCPCMatrix * vertexWC;"];
    if (slabThickness > 0) {
      posVCVSImpl = posVCVSImpl.concat(["normalWCVSOutput = normalWC;", "vertexWCVSOutput = vertexWC;"]);
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", posVCVSImpl).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
    let posVCFSDec = [];
    if (slabThickness > 0) {
      posVCFSDec = posVCFSDec.concat(["varying vec3 normalWCVSOutput;", "varying vec4 vertexWCVSOutput;"]);
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", posVCFSDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  function isVectorAxisAligned(n) {
    vtkMath.normalize(n);
    const tmpN = [0, 0, 0];
    for (let i = 0; i < 3; ++i) {
      vec3_exports.zero(tmpN);
      tmpN[i] = 1;
      const dotP = vtkMath.dot(n, tmpN);
      if (dotP < -0.999999 || dotP > 0.999999) {
        return [true, i];
      }
    }
    return [false, 2];
  }
  publicAPI.updateResliceGeometry = () => {
    var _a;
    let resGeomString = "";
    const firstImageData = model.currentValidInputs[0].imageData;
    const imageBounds = firstImageData == null ? void 0 : firstImageData.getBounds();
    let orthoSlicing = true;
    let orthoAxis = 2;
    const slicePD = model.renderable.getSlicePolyData();
    const slicePlane = model.renderable.getSlicePlane();
    if (slicePD) {
      resGeomString = resGeomString.concat(`PolyData${slicePD.getMTime()}`);
    } else if (slicePlane) {
      resGeomString = resGeomString.concat(`Plane${slicePlane.getMTime()}`);
      const w2io = mat3_exports.create();
      if (firstImageData) {
        resGeomString = resGeomString.concat(`Image${firstImageData.getMTime()}`);
        mat3_exports.set(w2io, ...firstImageData.getDirection());
        mat3_exports.invert(w2io, w2io);
      }
      const imageLocalNormal = [...slicePlane.getNormal()];
      vec3_exports.transformMat3(imageLocalNormal, imageLocalNormal, w2io);
      [orthoSlicing, orthoAxis] = isVectorAxisAligned(imageLocalNormal);
    } else {
      const plane = vtkPlane$1.newInstance();
      plane.setNormal(0, 0, 1);
      let bds = [0, 1, 0, 1, 0, 1];
      if (firstImageData) {
        bds = imageBounds;
      }
      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));
      model.renderable.setSlicePlane(plane);
      resGeomString = resGeomString.concat(`Plane${slicePlane == null ? void 0 : slicePlane.getMTime()}`);
      if (firstImageData) {
        resGeomString = resGeomString.concat(`Image${firstImageData.getMTime()}`);
      }
    }
    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {
      if (slicePD) {
        if (!model.resliceGeom) {
          model.resliceGeom = vtkPolyData$1.newInstance();
        }
        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);
        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);
        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());
      } else if (slicePlane) {
        if (!orthoSlicing) {
          model.outlineFilter.setInputData(firstImageData);
          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());
          model.cutter.setCutFunction(slicePlane);
          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());
          model.lineToSurfaceFilter.update();
          if (!model.resliceGeom) {
            model.resliceGeom = vtkPolyData$1.newInstance();
          }
          const planePD = model.lineToSurfaceFilter.getOutputData();
          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);
          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);
          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals());
          const n = slicePlane.getNormal();
          const npts = model.resliceGeom.getNumberOfPoints();
          vtkMath.normalize(n);
          const normalsData = new Float32Array(npts * 3);
          for (let i = 0; i < npts; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          const normals = vtkDataArray$1.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: "Normals"
          });
          model.resliceGeom.getPointData().setNormals(normals);
        } else {
          const ptsArray = new Float32Array(12);
          const indexSpacePlaneOrigin = firstImageData.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);
          const otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();
          const ext = firstImageData.getSpatialExtent();
          let ptIdx = 0;
          for (let i = 0; i < 2; ++i) {
            for (let j = 0; j < 2; ++j) {
              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];
              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];
              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + i];
              ptIdx += 3;
            }
          }
          model.transform.setMatrix(firstImageData.getIndexToWorld());
          model.transform.transformPoints(ptsArray, ptsArray);
          const cellArray = new Uint16Array(8);
          cellArray[0] = 3;
          cellArray[1] = 0;
          cellArray[2] = 1;
          cellArray[3] = 3;
          cellArray[4] = 3;
          cellArray[5] = 0;
          cellArray[6] = 3;
          cellArray[7] = 2;
          const n = slicePlane.getNormal();
          vtkMath.normalize(n);
          const normalsData = new Float32Array(12);
          for (let i = 0; i < 4; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          if (!model.resliceGeom) {
            model.resliceGeom = vtkPolyData$1.newInstance();
          }
          model.resliceGeom.getPoints().setData(ptsArray, 3);
          model.resliceGeom.getPolys().setData(cellArray, 1);
          const normals = vtkDataArray$1.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: "Normals"
          });
          model.resliceGeom.getPointData().setNormals(normals);
        }
      } else {
        vtkErrorMacro67("Something went wrong.", "A default slice plane should have been created in the beginning of", "updateResliceGeometry.");
      }
      model.resliceGeomUpdateString = resGeomString;
      (_a = model.resliceGeom) == null ? void 0 : _a.modified();
    }
  };
  publicAPI.setScalarTextures = (scalarTextures) => {
    model.scalarTextures = [...scalarTextures];
    model._externalOpenGLTexture = true;
  };
  publicAPI.delete = chain(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}
var DEFAULT_VALUES160 = {
  VBOBuildTime: {},
  VBOBuildString: null,
  haveSeenDepthRequest: false,
  lastHaveSeenDepthRequest: false,
  lastIndependentComponents: false,
  lastNumberOfComponents: 0,
  lastMultiTexturePerVolumeEnabled: false,
  lastSlabThickness: 0,
  lastSlabTrapezoidIntegration: 0,
  lastSlabType: -1,
  scalarTextures: [],
  _scalarTexturesCore: [],
  colorTexture: null,
  _colorTextureCore: null,
  pwfTexture: null,
  _pwfTextureCore: null,
  _externalOpenGLTexture: false,
  resliceGeom: null,
  resliceGeomUpdateString: null,
  tris: null
};
function extend175(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES160, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.scalarTextures = [];
  model.colorTexture = null;
  model.pwfTexture = null;
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.outlineFilter = vtkImageDataOutlineFilter$1.newInstance();
  model.outlineFilter.setGenerateFaces(true);
  model.outlineFilter.setGenerateLines(false);
  model.cubePolyData = vtkPolyData$1.newInstance();
  model.cutter = vtkCutter$1.newInstance();
  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter$1.newInstance();
  model.transform = vtkTransform$1.newInstance();
  get(publicAPI, model, ["scalarTextures"]);
  vtkOpenGLImageResliceMapper(publicAPI, model);
}
var newInstance168 = newInstance(extend175, "vtkOpenGLImageResliceMapper");
var vtkImageResliceMapper2 = {
  newInstance: newInstance168,
  extend: extend175
};
registerOverride("vtkImageResliceMapper", newInstance168);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl.js
var vtkSphereMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js
var {
  vtkErrorMacro: vtkErrorMacro68
} = macro$1;
function vtkOpenGLSphereMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLSphereMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkSphereMapperVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 VCPCMatrix;\n", "uniform mat4 MCVCMatrix;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", ["vec4 vertexVC = vertexVCVSOutput;\n"]).result;
    const replacement = ["uniform float invertedDepth;\n", "uniform int cameraParallel;\n", "varying float radiusVCVSOutput;\n", "varying vec3 centerVCVSOutput;\n", "uniform mat4 VCPCMatrix;\n"];
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", replacement).result;
    let fragString = "";
    if (model.context.getExtension("EXT_frag_depth")) {
      fragString = "gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = "gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", [
      // compute the eye position and unit direction
      "  vec3 EyePos;\n",
      "  vec3 EyeDir;\n",
      "  if (cameraParallel != 0) {\n",
      "    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n",
      "    EyeDir = vec3(0.0,0.0,-1.0); }\n",
      "  else {\n",
      "    EyeDir = vertexVC.xyz;\n",
      "    EyePos = vec3(0.0,0.0,0.0);\n",
      "    float lengthED = length(EyeDir);\n",
      "    EyeDir = normalize(EyeDir);\n",
      // we adjust the EyePos to be closer if it is too far away
      // to prevent floating point precision noise
      "    if (lengthED > radiusVCVSOutput*3.0) {\n",
      "      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n",
      "    }\n",
      // translate to Sphere center
      "  EyePos = EyePos - centerVCVSOutput;\n",
      // scale to radius 1.0
      "  EyePos = EyePos/radiusVCVSOutput;\n",
      // find the intersection
      "  float b = 2.0*dot(EyePos,EyeDir);\n",
      "  float c = dot(EyePos,EyePos) - 1.0;\n",
      "  float d = b*b - 4.0*c;\n",
      "  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n",
      "  if (d < 0.0) { discard; }\n",
      "  else {\n",
      "    float t = (-b - invertedDepth*sqrt(d))*0.5;\n",
      // compute the normal, for unit sphere this is just
      // the intersection point
      "    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n",
      // compute the intersection point in VC
      "    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n",
      "    }\n",
      // compute the pixel's depth
      // ' normalVCVSOutput = vec3(0,0,1);\n'
      "  vec4 pos = VCPCMatrix * vertexVC;\n",
      fragString
    ]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", "").result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float computedZ = (pos.z / pos.w + 1.0) / 2.0;", "float iz = floor(computedZ * 65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed("offsetMC")) {
      if (!cellBO.getVAO().addAttributeArray(
        cellBO.getProgram(),
        cellBO.getCABO(),
        "offsetMC",
        12,
        // 12:this->VBO->ColorOffset+sizeof(float)
        cellBO.getCABO().getStride(),
        model.context.FLOAT,
        2,
        false
      )) {
        vtkErrorMacro68("Error setting 'offsetMC' in shader VAO.");
      }
    }
    if (cellBO.getProgram().isUniformUsed("invertedDepth")) {
      cellBO.getProgram().setUniformf("invertedDepth", model.invert ? -1 : 1);
    }
    if (cellBO.getProgram().isUniformUsed("scaleFactor")) {
      const poly = model.currentInput;
      const pointData = poly.getPointData();
      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
        cellBO.getProgram().setUniformf("scaleFactor", model.renderable.getScaleFactor());
      } else {
        cellBO.getProgram().setUniformf("scaleFactor", 1);
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed("VCPCMatrix")) {
      program.setUniformMatrix("VCPCMatrix", keyMats.vcpc);
    }
    const tmp4 = new Float64Array(16);
    if (program.isUniformUsed("MCVCMatrix")) {
      if (!actor.getIsIdentity()) {
        const actMats = model.openGLActor.getKeyMatrices();
        mat4_exports.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
          mat4_exports.multiply(tmp4, tmp4, cellBO.getCABO().getInverseShiftAndScaleMatrix());
        }
        program.setUniformMatrix("MCVCMatrix", tmp4);
      } else {
        mat4_exports.copy(tmp4, keyMats.wcvc);
        if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
          mat4_exports.multiply(tmp4, tmp4, cellBO.getCABO().getInverseShiftAndScaleMatrix());
        }
        program.setUniformMatrix("MCVCMatrix", tmp4);
      }
    }
    if (program.isUniformUsed("cameraParallel")) {
      cellBO.getProgram().setUniformi("cameraParallel", cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    const c2 = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    const pointSize = 5;
    let scales = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    let colorData = null;
    let colorComponents = 0;
    let packedUCVBO = null;
    if (c2) {
      colorComponents = c2.getNumberOfComponents();
      vbo.setColorOffset(0);
      vbo.setColorBOStride(4);
      colorData = c2.getData();
      packedUCVBO = new Uint8Array(3 * numPoints * 4);
      if (!vbo.getColorBO()) {
        vbo.setColorBO(vtkBufferObject.newInstance());
      }
      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    } else if (vbo.getColorBO()) {
      vbo.setColorBO(null);
    }
    vbo.setColorComponents(colorComponents);
    const packedVBO = new Float32Array(pointSize * numPoints * 3);
    vbo.setStride(pointSize * 4);
    const cos30 = Math.cos(radiansFromDegrees(30));
    let pointIdx = 0;
    let colorIdx = 0;
    const {
      useShiftAndScale,
      coordShift,
      coordScale
    } = computeCoordShiftAndScale(points);
    if (useShiftAndScale) {
      vbo.setCoordShiftAndScale(coordShift, coordScale);
    }
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0; i < numPoints; ++i) {
      let radius = model.renderable.getRadius();
      if (scales) {
        radius = scales[i];
      }
      pointIdx = i * 3;
      const ptX = (pointArray[pointIdx++] - coordShift[0]) * coordScale[0];
      const ptY = (pointArray[pointIdx++] - coordShift[1]) * coordScale[1];
      const ptZ = (pointArray[pointIdx++] - coordShift[2]) * coordScale[2];
      packedVBO[vboIdx++] = ptX;
      packedVBO[vboIdx++] = ptY;
      packedVBO[vboIdx++] = ptZ;
      packedVBO[vboIdx++] = -2 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        colorIdx = i * colorComponents;
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      packedVBO[vboIdx++] = ptX;
      packedVBO[vboIdx++] = ptY;
      packedVBO[vboIdx++] = ptZ;
      packedVBO[vboIdx++] = 2 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      packedVBO[vboIdx++] = ptX;
      packedVBO[vboIdx++] = ptY;
      packedVBO[vboIdx++] = ptZ;
      packedVBO[vboIdx++] = 0;
      packedVBO[vboIdx++] = 2 * radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (c2) {
      vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES161 = {};
function extend176(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES161, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  vtkOpenGLSphereMapper(publicAPI, model);
}
var newInstance169 = newInstance(extend176, "vtkOpenGLSphereMapper");
var vtkSphereMapper2 = {
  newInstance: newInstance169,
  extend: extend176
};
registerOverride("vtkSphereMapper", newInstance169);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl.js
var vtkStickMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js
var {
  vtkErrorMacro: vtkErrorMacro69
} = macro$1;
function vtkOpenGLStickMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLStickMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkStickMapperVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 VCPCMatrix;\n", "uniform mat4 MCVCMatrix;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", "varying vec4 vertexVCVSOutput;").result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", "  vec4 vertexVC = vertexVCVSOutput;\n").result;
    const replacement = ["uniform int cameraParallel;\n", "varying float radiusVCVSOutput;\n", "varying vec3 orientVCVSOutput;\n", "varying float lengthVCVSOutput;\n", "varying vec3 centerVCVSOutput;\n", "uniform mat4 VCPCMatrix;\n"];
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", replacement).result;
    let fragString = "";
    if (model.context.getExtension("EXT_frag_depth")) {
      fragString = "  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = "gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", [
      // compute the eye position and unit direction
      "  vec3 EyePos;\n",
      "  vec3 EyeDir;\n",
      "  if (cameraParallel != 0) {\n",
      "    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n",
      "    EyeDir = vec3(0.0,0.0,-1.0); }\n",
      "  else {\n",
      "    EyeDir = vertexVC.xyz;\n",
      "    EyePos = vec3(0.0,0.0,0.0);\n",
      "    float lengthED = length(EyeDir);\n",
      "    EyeDir = normalize(EyeDir);\n",
      // we adjust the EyePos to be closer if it is too far away
      // to prevent floating point precision noise
      "    if (lengthED > radiusVCVSOutput*3.0) {\n",
      "      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n",
      "    }\n",
      // translate to Stick center
      "  EyePos = EyePos - centerVCVSOutput;\n",
      // rotate to new basis
      // base1, base2, orientVC
      "  vec3 base1;\n",
      "  if (abs(orientVCVSOutput.z) < 0.99) {\n",
      "    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n",
      "  else {\n",
      "    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n",
      "  vec3 base2 = cross(orientVCVSOutput,base1);\n",
      "  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n",
      "  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n",
      // scale by radius
      "  EyePos = EyePos/radiusVCVSOutput;\n",
      // find the intersection
      "  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n",
      "  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n",
      "  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n",
      "  float d = b*b - 4.0*a*c;\n",
      "  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n",
      "  if (d < 0.0) { discard; }\n",
      "  else {\n",
      "    float t =  (-b - sqrt(d))/(2.0*a);\n",
      "    float tz = EyePos.z + t*EyeDir.z;\n",
      "    vec3 iPoint = EyePos + t*EyeDir;\n",
      "    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n",
      // test for end cap
      "      float t2 = (-b + sqrt(d))/(2.0*a);\n",
      "      float tz2 = EyePos.z + t2*EyeDir.z;\n",
      "      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n",
      "      else {\n",
      "        normalVCVSOutput = orientVCVSOutput;\n",
      "        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n",
      "        iPoint = EyePos + t3*EyeDir;\n",
      "        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n",
      "        }\n",
      "      }\n",
      "    else {\n",
      // The normal is the iPoint.xy rotated back into VC
      "      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n",
      // rescale rerotate and translate
      "      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n",
      "      }\n",
      "    }\n",
      //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\n'
      // compute the pixel's depth
      "  vec4 pos = VCPCMatrix * vertexVC;\n",
      fragString
    ]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", "").result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float computedZ = (pos.z / pos.w + 1.0) / 2.0;", "float iz = floor(computedZ * 65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("orientMC")) {
        if (!cellBO.getVAO().addAttributeArray(
          cellBO.getProgram(),
          cellBO.getCABO(),
          "orientMC",
          12,
          // after X Y Z
          cellBO.getCABO().getStride(),
          model.context.FLOAT,
          3,
          false
        )) {
          vtkErrorMacro69("Error setting 'orientMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("offsetMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "offsetMC", 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {
          vtkErrorMacro69("Error setting 'offsetMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("radiusMC")) {
        if (!cellBO.getVAO().addAttributeArray(
          cellBO.getProgram(),
          cellBO.getCABO(),
          "radiusMC",
          24,
          // X Y Z OX OY OZ
          cellBO.getCABO().getStride(),
          model.context.FLOAT,
          1,
          false
        )) {
          vtkErrorMacro69("Error setting 'radiusMC' in shader VAO.");
        }
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed("VCPCMatrix")) {
      program.setUniformMatrix("VCPCMatrix", keyMats.vcpc);
    }
    if (!actor.getIsIdentity()) {
      const actMats = model.openGLActor.getKeyMatrices();
      if (program.isUniformUsed("MCVCMatrix")) {
        const tmp4 = new Float64Array(16);
        mat4_exports.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix("MCVCMatrix", tmp4);
      }
      if (program.isUniformUsed("normalMatrix")) {
        const anorms = new Float64Array(9);
        mat3_exports.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);
        program.setUniformMatrix3x3("normalMatrix", anorms);
      }
    } else {
      if (program.isUniformUsed("MCVCMatrix")) {
        program.setUniformMatrix("MCVCMatrix", keyMats.wcvc);
      }
      if (program.isUniformUsed("normalMatrix")) {
        program.setUniformMatrix3x3("normalMatrix", keyMats.normalMatrix);
      }
    }
    if (program.isUniformUsed("cameraParallel")) {
      cellBO.getProgram().setUniformi("cameraParallel", cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    const c2 = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    let pointSize = 3;
    pointSize += 4;
    let colorData = null;
    let colorComponents = 0;
    vbo.setColorBOStride(4);
    if (!vbo.getColorBO()) {
      vbo.setColorBO(vtkBufferObject.newInstance());
    }
    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    if (c2) {
      colorComponents = c2.getNumberOfComponents();
      vbo.setColorOffset(4);
      colorData = c2.getData();
      vbo.setColorBOStride(8);
    }
    vbo.setColorComponents(colorComponents);
    vbo.setStride(pointSize * 4);
    const packedVBO = new Float32Array(pointSize * numPoints * 12);
    const packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));
    let scales = null;
    let orientationArray = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {
      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();
    } else {
      vtkErrorMacro69(["Error setting orientationArray.\n", "You have to specify the stick orientation"]);
    }
    const verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];
    let pointIdx = 0;
    let colorIdx = 0;
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0; i < numPoints; ++i) {
      let length = model.renderable.getLength();
      let radius = model.renderable.getRadius();
      if (scales) {
        length = scales[i * 2];
        radius = scales[i * 2 + 1];
      }
      for (let j = 0; j < verticesArray.length; ++j) {
        pointIdx = i * 3;
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        pointIdx = i * 3;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = radius;
        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);
        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;
        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;
        packedUCVBO[ucIdx++] = 255;
        colorIdx = i * colorComponents;
        if (colorData) {
          packedUCVBO[ucIdx++] = colorData[colorIdx];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
        }
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES162 = {};
function extend177(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES162, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  vtkOpenGLStickMapper(publicAPI, model);
}
var newInstance170 = newInstance(extend177, "vtkOpenGLStickMapper");
var vtkStickMapper2 = {
  newInstance: newInstance170,
  extend: extend177
};
registerOverride("vtkStickMapper", newInstance170);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
function vtkOpenGLVolume(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolume");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.volumePass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      mat4_exports.copy(model.MCWCMatrix, model.renderable.getMatrix());
      mat4_exports.transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        mat3_exports.identity(model.normalMatrix);
      } else {
        mat3_exports.fromMat4(model.normalMatrix, model.MCWCMatrix);
        mat3_exports.invert(model.normalMatrix, model.normalMatrix);
        mat3_exports.transpose(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}
var DEFAULT_VALUES163 = {
  // context: null,
  // keyMatrixTime: null,
  // normalMatrix: null,
  // MCWCMatrix: null,
  // _openGLRenderWindow: null,
};
function extend178(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES163, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolume(publicAPI, model);
}
var newInstance171 = newInstance(extend178, "vtkOpenGLVolume");
var vtkVolume2 = {
  newInstance: newInstance171,
  extend: extend178
};
registerOverride("vtkVolume", newInstance171);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js
var vtkVolumeVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js
var vtkVolumeFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\nconst float infinity = 3.402823466e38;\n\n// the output of this shader\n//VTK::Output::Dec\n\nin vec3 vertexVCVSOutput;\n\n// From Sources\\Rendering\\Core\\VolumeProperty\\Constants.js\n#define COMPOSITE_BLEND 0\n#define MAXIMUM_INTENSITY_BLEND 1\n#define MINIMUM_INTENSITY_BLEND 2\n#define AVERAGE_INTENSITY_BLEND 3\n#define ADDITIVE_INTENSITY_BLEND 4\n#define RADON_TRANSFORM_BLEND 5\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\n\n#define vtkNumberOfLights //VTK::NumberOfLights\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\n#define vtkNumberOfComponents //VTK::NumberOfComponents\n#define vtkBlendMode //VTK::BlendMode\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\n\n//VTK::EnabledColorFunctions\n\n//VTK::EnabledLightings\n\n//VTK::EnabledMultiTexturePerVolume\n\n//VTK::EnabledGradientOpacity\n\n//VTK::EnabledIndependentComponents\n\n//VTK::vtkProportionalComponents\n\n//VTK::vtkForceNearestComponents\n\nuniform int twoSidedLighting;\n\n#if vtkMaxLaoKernelSize > 0\n  vec2 kernelSample[vtkMaxLaoKernelSize];\n#endif\n\n// Textures\n#ifdef EnabledMultiTexturePerVolume\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\n#else\n  #define vtkNumberOfVolumeTextures 1\n#endif\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\nuniform sampler2D colorTexture;\nuniform sampler2D opacityTexture;\nuniform sampler2D jtexture;\nuniform sampler2D labelOutlineThicknessTexture;\n\nstruct Volume {\n  // ---- Volume geometry settings ----\n\n  vec3 originVC;          // in VC\n  vec3 spacing;           // in VC per IC\n  vec3 inverseSpacing;    // 1/spacing\n  ivec3 dimensions;       // in IC\n  vec3 inverseDimensions; // 1/vec3(dimensions)\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\n  mat4 PCWCMatrix;\n  mat4 worldToIndex;\n  float diagonalLength; // in VC, this is: length(size)\n\n  // ---- Texture settings ----\n\n  // Texture shift and scale\n  vec4 colorTextureScale;\n  vec4 colorTextureShift;\n  vec4 opacityTextureScale;\n  vec4 opacityTextureShift;\n\n  // The heights defined below are the locations for the up to four components\n  // of the transfer functions. The transfer functions have a height of (2 *\n  // numberOfComponents) pixels so the values are computed to hit the middle of\n  // the two rows for that component\n  vec4 transferFunctionsSampleHeight;\n\n  // ---- Mode specific settings ----\n\n  // Independent component default preset settings per component\n  vec4 independentComponentMix;\n\n  // Additive / average blending mode settings\n  vec4 ipScalarRangeMin;\n  vec4 ipScalarRangeMax;\n\n  // ---- Rendering settings ----\n\n  // Lighting\n  float ambient;\n  float diffuse;\n  float specular;\n  float specularPower;\n  int computeNormalFromOpacity;\n\n  // Gradient opacity\n  vec4 gradientOpacityScale;\n  vec4 gradientOpacityShift;\n  vec4 gradientOpacityMin;\n  vec4 gradientOpacityMax;\n\n  // Volume shadow\n  float volumetricScatteringBlending;\n  float globalIlluminationReach;\n  float anisotropy;\n  float anisotropySquared;\n\n  // LAO\n  int kernelSize;\n  int kernelRadius;\n\n  // Label outline\n  float outlineOpacity;\n};\nuniform Volume volume;\n\nstruct Light {\n  vec3 color;\n  vec3 positionVC;\n  vec3 directionVC; // normalized\n  vec3 halfAngleVC;\n  vec3 attenuation;\n  float exponent;\n  float coneAngle;\n  int isPositional;\n};\n#if vtkNumberOfLights > 0\n  uniform Light lights[vtkNumberOfLights];\n#endif\n\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\n\n// Bitmasks for label outline\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n#define MAX_SEGMENTS 256\n#define UINT_SIZE 32\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\n// floor\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\nuint labelOutlineBitmasks[BITMASK_SIZE];\n\n// Set the corresponding bit in the bitmask\nvoid setLabelOutlineBit(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\n}\n\n// Check if a bit is set in the bitmask\nbool isLabelOutlineBitSet(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\n}\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n//VTK::ClipPlane::Dec\n\n// A random number between 0 and 1 that only depends on the fragment\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\n// in screen space\nfloat fragmentSeed;\n\n// sample texture is global\nuniform float sampleDistance;\nuniform float volumeShadowSampleDistance;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics\n// rendering module is complete)\nvec3 rayDirVC;\n\n#define INV4PI 0.0796\n#define EPSILON 0.001\n#define PI 3.1415\n#define PI2 9.8696\n\nvec4 rawSampleTexture(vec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\n  #if vtkNumberOfComponents > 1\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 2\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 3\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\n  #endif\n    return rawSample;\n  #else\n    return texture(volumeTexture[0], pos);\n  #endif\n}\n\nvec4 rawFetchTexture(ivec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    #if vtkNumberOfComponents > 0\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 1\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 2\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 3\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\n    #endif\n    return rawSample;\n  #else\n    return texelFetch(volumeTexture[0], pos, 0);\n  #endif\n}\n\nvec4 getTextureValue(vec3 pos) {\n  vec4 tmp = rawSampleTexture(pos);\n\n  // Force nearest\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\n                      volume.inverseDimensions;\n    vec4 nearestValue = rawSampleTexture(nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  // Set alpha when using dependent components\n  #ifndef EnabledIndependentComponents\n    #if vtkNumberOfComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumberOfComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumberOfComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\n// when using independent component and `0.5` otherwise. Don't move the if\n// statement in these function, as the callers usually already knows if it is\n// using independent component or not\nfloat getOpacityFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\n                       volume.opacityTextureShift[component];\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\n}\nvec3 getColorFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\n                       volume.colorTextureShift[component];\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\n}\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\nvec3 posIStoVC(vec3 posIS) {\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\n}\n\n// convert vector position from vc to idx\nvec3 posVCtoIS(vec3 posVC) {\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\n}\n\n// Rotate vector to view coordinate\nvec3 vecISToVC(vec3 dirIS) {\n  return volume.vecISToVCMatrix * dirIS;\n}\n\n// Rotate vector to idx coordinate\nvec3 vecVCToIS(vec3 dirVC) {\n  return volume.vecVCToISMatrix * dirVC;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(float normalMag, int component) {\n  float goscale = volume.gradientOpacityScale[component];\n  float goshift = volume.gradientOpacityShift[component];\n  float gomin = volume.gradientOpacityMin[component];\n  float gomax = volume.gradientOpacityMax[component];\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n#ifdef vtkClippingPlanesOn\n  bool isPointClipped(vec3 posVC) {\n    for (int i = 0; i < clip_numPlanes; ++i) {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\n        return true;\n      }\n    }\n    return false;\n  }\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward\n// difference\n\n// The output normal is in VC\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\n                          float gradientOpacity, int component) {\n  // Pass the scalars through the opacity functions\n  vec4 opacityG;\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\n                                      opacityTextureHeight);\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\n                                      opacityTextureHeight);\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\n                                      opacityTextureHeight);\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\n                                      opacityTextureHeight);\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\n                                      opacityTextureHeight);\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\n                                      opacityTextureHeight);\n\n  // Divide by spacing and convert to VC\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\n  opacityG.w = length(opacityG.xyz);\n  if (opacityG.w == 0.0) {\n    return vec4(0.0);\n  }\n\n  // Normalize\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\n\n  return opacityG;\n}\n\n// The output normal is in VC\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\n                             const int opacityComponent) {\n  vec3 offsetedPosIS;\n  for (int axis = 0; axis < 3; ++axis) {\n    // Positive direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\n    scalarInterp[0][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[0][axis] = 0.0;\n      }\n    #endif\n\n    // Negative direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\n    scalarInterp[1][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[1][axis] = 0.0;\n      }\n    #endif\n  }\n\n  vec4 result;\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\n  result.w = length(result.xyz);\n  if (result.w == 0.0) {\n    return vec4(0.0);\n  }\n  result.xyz = normalize(vecISToVC(result.xyz));\n  return result;\n}\n\nvec4 fragCoordToPCPos(vec4 fragCoord) {\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n              (fragCoord.z - 0.5) * 2.0, 1.0);\n}\n\nvec4 pcPosToWorldCoord(vec4 pcPos) {\n  return volume.PCWCMatrix * pcPos;\n}\n\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  vec4 vertex = (worldCoord / worldCoord.w);\n\n  vec3 index = (volume.worldToIndex * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) * volume.inverseDimensions;\n}\n\nvec3 fragCoordToWorld(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  return worldCoord.xyz;\n}\n\n//=======================================================================\n// Compute the normals and gradient magnitudes for a position for independent\n// components The output normals are in VC\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\n\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\n\n  // divide by spacing\n  distX *= 0.5 * volume.inverseSpacing.x;\n  distY *= 0.5 * volume.inverseSpacing.y;\n  distZ *= 0.5 * volume.inverseSpacing.z;\n\n  mat4 result;\n\n  // optionally compute the 1st component\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\n    {\n      const int component = 0;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 2nd component\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\n    {\n      const int component = 1;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 3rd component\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\n    {\n      const int component = 2;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 4th component\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\n    {\n      const int component = 3;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n\n// henyey greenstein phase function\nfloat phaseFunction(float cos_angle) {\n  // divide by 2.0 instead of 4pi to increase intensity\n  float anisotropy = volume.anisotropy;\n  if (abs(anisotropy) <= EPSILON) {\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    return 0.5;\n  }\n  float anisotropy2 = volume.anisotropySquared;\n  return ((1.0 - anisotropy2) /\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\n         2.0;\n}\n\n// Compute the two intersection distances of the ray with the volume in VC\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\n// volume is not intersected The ray origin is inside the box when distanceMin <\n// 0.0 < distanceMax\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  // Compute origin and direction in IS\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\n  // Don't check for infinity as the min/max combination afterward will always\n  // find an intersection before infinity\n  vec3 invDir = 1.0 / rayDirIS;\n\n  // We have: bound = origin + t * dir\n  // So: t = (1/dir) * (bound - origin)\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\n  // Min and max distances to plane intersection per plane\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\n  // Overall first and last intersection\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\n  return vec2(distanceMin, distanceMax);\n}\n\n//=======================================================================\n// local ambient occlusion\n#if vtkMaxLaoKernelSize > 0\n\n  // Return a random point on the unit sphere\n  vec3 sampleDirectionUniform(int rayIndex) {\n    // Each ray of each fragment should be different, two sources of randomness\n    // are used. Only depends on ray index\n    vec2 rayRandomness = kernelSample[rayIndex];\n    // Only depends on fragment\n    float fragmentRandomness = fragmentSeed;\n    // Merge both source of randomness in a single uniform random variable using\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\n    // result in a uniform distribution\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\n\n    // Insipred by:\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\n    float u = mergedRandom[0];\n    float v = mergedRandom[1];\n    float theta = u * 2.0 * PI;\n    float phi = acos(2.0 * v - 1.0);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\n  }\n\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\n    // apply LAO only at selected locations, otherwise return full brightness\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\n      return 1.0;\n    }\n\n    #ifdef EnabledGradientOpacity\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\n    #endif\n\n    float visibilitySum = 0.0;\n    float weightSum = 0.0;\n    for (int i = 0; i < volume.kernelSize; i++) {\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\n      // normalDotRay should be negative\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\n      if (normalDotRay > 0.0) {\n        // Flip rayDirectionVC when it is in the wrong hemisphere\n        rayDirectionVC = -rayDirectionVC;\n        normalDotRay = -normalDotRay;\n      }\n\n      vec3 currPosIS = posVCtoIS(posVC);\n      float visibility = 1.0;\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\n      for (int j = 0; j < volume.kernelRadius; j++) {\n        currPosIS += randomDirStepIS;\n        // If out of the volume, we are done\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\n            any(greaterThan(currPosIS, vec3(1.0)))) {\n          break;\n        }\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\n        #ifdef EnabledGradientOpacity\n          opacity *= gradientOpacityFactor;\n        #endif\n        visibility *= 1.0 - opacity;\n        // If visibility is less than EPSILON, consider it to be 0\n        if (visibility < EPSILON) {\n          visibility = 0.0;\n          break;\n        }\n      }\n      float rayWeight = -normalDotRay;\n      visibilitySum += visibility * rayWeight;\n      weightSum += rayWeight;\n    }\n\n    // If no sample, LAO factor is one\n    if (weightSum == 0.0) {\n      return 1.0;\n    }\n\n    // LAO factor is the average visibility:\n    // - visibility low => ambient low\n    // - visibility high => ambient high\n    float lao = visibilitySum / weightSum;\n\n    // Reduce variance by clamping\n    return clamp(lao, 0.3, 1.0);\n  }\n#endif\n\n//=======================================================================\n// Volume shadows\n#if vtkNumberOfLights > 0\n\n  // Non-memoised version\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\n    // modify sample distance with a random number between 1.5 and 3.0\n    float rayStepLength =\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\n\n    // in case the first sample near surface has a very tiled light ray, we need\n    // to offset start position\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\n\n    #ifdef vtkClippingPlanesOn\n      float clippingPlanesMaxDistance = infinity;\n      for (int i = 0; i < clip_numPlanes; ++i) {\n        // Find distance of intersection with the plane\n        // Points are clipped when:\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\n        // This is equivalent to:\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\n        // planeNormal) > 0.0\n        // We precompute the dot products, so we clip ray points when:\n        // dotOrigin - distance * dotDirection > 0.0\n        float dotOrigin =\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\n        if (dotOrigin > 0.0) {\n          // The initialPosVC is clipped by this plane\n          return 1.0;\n        }\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\n        if (dotDirection < 0.0) {\n          // We only hit the plane if dotDirection is negative, as (distance is\n          // positive)\n          float intersectionDistance =\n              dotOrigin / dotDirection; // negative divided by negative => positive\n          clippingPlanesMaxDistance =\n              min(clippingPlanesMaxDistance, intersectionDistance);\n        }\n      }\n    #endif\n\n    vec2 intersectionDistances =\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\n\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\n        intersectionDistances[1] <= 0.0) {\n      // Volume not hit or behind the ray\n      return 1.0;\n    }\n\n    // When globalIlluminationReach is 0, no sample at all\n    // When globalIlluminationReach is 1, the ray will go through the whole\n    // volume\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\n                                  volume.globalIlluminationReach);\n    float startDistance = max(intersectionDistances[0], 0.0);\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\n    #ifdef vtkClippingPlanesOn\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\n    #endif\n    if (endDistance - startDistance < 0.0) {\n      return 1.0;\n    }\n\n    // These two variables are used to compute posIS, without having to call\n    // VCtoIS at each step\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\n    // The light dir is scaled and rotated, but not translated, as it is a\n    // vector (w = 0)\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\n\n    float shadow = 1.0;\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\n          currentDistance += rayStepLength) {\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\n      vec4 scalar = getTextureValue(posIS);\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\n        vec3 scalarInterp[2];\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\n        opacity *= opacityFactor;\n      #endif\n      shadow *= 1.0 - opacity;\n\n      // Early termination if shadow coeff is near 0.0\n      if (shadow < EPSILON) {\n        return 0.0;\n      }\n    }\n    return shadow;\n  }\n\n  // Some cache for volume shadows\n  struct {\n    vec3 posVC;\n    float shadow;\n  } cachedShadows[vtkNumberOfLights];\n\n  // Memoised version\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\n    if (posVC == cachedShadows[lightIdx].posVC) {\n      return cachedShadows[lightIdx].shadow;\n    }\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\n    cachedShadows[lightIdx].posVC = posVC;\n    cachedShadows[lightIdx].shadow = shadow;\n    return shadow;\n  }\n\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkNumberOfLights > 0\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\n      if (df > 0.0) {\n        diffuse += df * lights[lightIdx].color;\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\n        if (sf > 0.0) {\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\n        }\n      }\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\n          specular * volume.specular;\n  }\n\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\n                                  vec4 normalVC) {\n    // everything in VC\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\n      vec3 vertLightDirection;\n      float attenuation;\n      if (lights[ligthIdx].isPositional == 1) {\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\n        float lightDistance = length(vertLightDirection);\n        // Normalize with precomputed length\n        vertLightDirection = vertLightDirection / lightDistance;\n        // Base attenuation\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\n        attenuation =\n            1.0 / (attenuationPolynom[0] +\n                  lightDistance * (attenuationPolynom[1] +\n                                    lightDistance * attenuationPolynom[2]));\n        // Cone attenuation\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\n        // Per OpenGL standard cone angle is 90 or less for a spot light\n        if (lights[ligthIdx].coneAngle <= 90.0) {\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\n            // Inside the cone\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\n          } else {\n            // Outside the cone\n            attenuation = 0.0;\n          }\n        }\n      } else {\n        vertLightDirection = lights[ligthIdx].directionVC;\n        attenuation = 1.0;\n      }\n\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\n        ndotL = -ndotL;\n      }\n      if (ndotL > 0.0) {\n        // Diffuse\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\n        // Specular\n        float vdotR =\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\n        if (vdotR > 0.0) {\n          specular += pow(vdotR, volume.specularPower) * attenuation *\n                      lights[ligthIdx].color;\n        }\n      }\n    }\n    #if vtkMaxLaoKernelSize > 0\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\n    #else\n      const float laoFactor = 1.0;\n    #endif\n    return tColor * (diffuse * volume.diffuse +\n                    volume.ambient * laoFactor) +\n          specular * volume.specular;\n  }\n\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\n    // Here we have no effect of cones and no attenuation\n    vec3 diffuse = vec3(0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\n                            ? normalize(lights[lightIdx].positionVC - posVC)\n                            : -lights[lightIdx].directionVC;\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\n  }\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\n                       vec4 surfaceNormalVC) {\n  #if vtkNumberOfLights > 0\n    // 0 <= volCoeff < EPSILON => only surface shadows\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\n    // 1 - EPSILON <= volCoeff => only volume shadows\n    float volCoeff = volume.volumetricScatteringBlending *\n                    (1.0 - alpha / 2.0) *\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\n\n    // Compute surface lighting if needed\n    vec3 surfaceShadedColor = tColor;\n    #ifdef EnableSurfaceLighting\n      if (volCoeff < 1.0 - EPSILON) {\n        surfaceShadedColor =\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\n      }\n    #endif\n\n    // Compute volume lighting if needed\n    vec3 volumeShadedColor = tColor;\n    #ifdef EnableVolumeLighting\n      if (volCoeff >= EPSILON) {\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\n      }\n    #endif\n\n    // Return the right mix\n    if (volCoeff < EPSILON) {\n      // Surface shadows\n      return surfaceShadedColor;\n    }\n    if (volCoeff >= 1.0 - EPSILON) {\n      // Volume shadows\n      return volumeShadedColor;\n    }\n    // Mix of surface and volume shadows\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\n  #endif\n  return tColor;\n}\n\nvec4 getColorForLabelOutline() {\n  vec3 centerPosIS =\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\n\n  int segmentIndex = int(centerValue.r * 255.0);\n\n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue =\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n  int actualThickness = int(textureValue * 255.0);\n\n  // If it is the background (segment index 0), we should quickly bail out.\n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0) {\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't\n  // invisible. Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord =\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\n               gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = volume.outlineOpacity;\n  }\n\n  return tColor;\n}\n\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLights[2];\n  normalLights[0] = normalMat[0];\n  normalLights[1] = normalMat[1];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      for (int component = 0; component < 2; ++component) {\n        vec3 scalarInterp[2];\n        float height = volume.transferFunctionsSampleHeight[component];\n        computeNormalForDensity(posIS, scalarInterp, component);\n        normalLights[component] =\n            computeDensityNormal(scalarInterp, height, 1.0, component);\n      }\n    }\n  #endif\n\n  // compute opacities\n  float opacities[2];\n  opacities[0] = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  opacities[1] = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n  #ifdef EnabledGradientOpacity\n    for (int component = 0; component < 2; ++component) {\n      opacities[component] *=\n          computeGradientOpacityFactor(normalMat[component].a, component);\n    }\n  #endif\n  float opacitySum = opacities[0] + opacities[1];\n  if (opacitySum <= 0.0) {\n    return vec4(0.0);\n  }\n\n  // mix the colors and opacities\n  vec3 colors[2];\n  for (int component = 0; component < 2; ++component) {\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\n    color = applyAllLightning(color, opacities[component], posVC,\n                              normalLights[component]);\n    colors[component] = color;\n  }\n  vec3 mixedColor =\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\n  return vec4(mixedColor, min(1.0, opacitySum));\n}\n\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLight = normalMat[0];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      vec3 scalarInterp[2];\n      float height = volume.transferFunctionsSampleHeight[0];\n      computeNormalForDensity(posIS, scalarInterp, 0);\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\n    }\n  #endif\n\n  // compute opacities\n  float opacity = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  #ifdef EnabledGradientOpacity\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\n  #endif\n\n  // colorizing component\n  vec3 colorizingColor = getColorFromTexture(\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\n  float colorizingOpacity = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n\n  // mix the colors and opacities\n  vec3 color =\n      getColorFromTexture(tValue[0], 0,\n                          volume.transferFunctionsSampleHeight[0]) *\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\n  color = applyAllLightning(color, opacity, posVC, normalLight);\n  return vec4(color, opacity);\n}\n\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\n\n  // compute the normal vectors as needed\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\n  #endif\n\n  // process color and opacity for each component\n  // initial value of alpha is determined by wether the first component is\n  // proportional or not\n  #if defined(vtkComponent0Proportional)\n    // when it is proportional, it starts at 1 (neutral for multiplications)\n    float alpha = 1.0;\n  #else\n    // when it is not proportional, it starts at 0 (neutral for additions)\n    float alpha = 0.0;\n  #endif\n\n  vec3 mixedColor = vec3(0.0);\n  #if vtkNumberOfComponents > 0\n    {\n      const int component = 0;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent0Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 1\n    {\n      const int component = 1;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent1Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 2\n    {\n      const int component = 2;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent2Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 3\n    {\n      const int component = 3;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent3Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n\n  return vec4(mixedColor, alpha);\n}\n\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\n    // the opacity value\n    vec3 scalarInterp[2];\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\n  #endif\n\n  // get color and opacity\n  #if vtkNumberOfComponents == 1\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 2\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\n                  volume.colorTextureShift[0]);\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 3\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 4\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\n  #endif\n\n  // Apply gradient opacity\n  #if defined(EnabledGradientOpacity)\n    alpha *= gradientOpacity;\n  #endif\n\n  #if vtkNumberOfComponents == 1\n    if (alpha < EPSILON) {\n      return vec4(0.0);\n    }\n  #endif\n\n  // lighting\n  #if vtkNumberOfLights > 0\n    vec4 normalLight;\n    if (volume.computeNormalFromOpacity == 1) {\n      if (normal0[3] != 0.0) {\n        normalLight =\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\n        if (normalLight[3] == 0.0) {\n          normalLight = normal0;\n        }\n      }\n    } else {\n      normalLight = normal0;\n    }\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\n  #endif\n\n  return vec4(tColor, alpha);\n}\n\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #ifdef EnableColorForValueFunctionId0\n    return getColorForDependentComponents(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId1\n    return getColorForAdditivePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId2\n    return getColorForColorizePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId3\n    /*\n      * Mix the color information from all the independent components to get a\n      * single rgba output. See other shader functions like\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\n      * The custom color mix should return a value, but if it doesn't, it will\n      * fallback on the default shading\n      */\n    //VTK::CustomColorMix\n  #endif\n\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\n    return getColorForDefaultIndependentPreset(tValue, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId5\n    return getColorForLabelOutline();\n  #endif\n}\n\nbool valueWithinScalarRange(vec4 val) {\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\n    return false;\n  #endif\n  vec4 rangeMin = volume.ipScalarRangeMin;\n  vec4 rangeMax = volume.ipScalarRangeMax;\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\n    if (val[component] < rangeMin[component] ||\n        rangeMax[component] < val[component]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\n                              int segmentIndex, vec3 stepIS) {\n    vec3 volumeDimensions = vec3(volume.dimensions);\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\n                                  gl_FragCoord.y + float(yFragmentOffset),\n                                  gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS += stepIS;\n    }\n\n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS -= stepIS;\n    }\n\n    // onedge\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\n    vec3 tColorSegment =\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\n    float pwfValueSegment =\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n    return true;\n  }\n#endif\n\nvec4 getColorAtPos(vec3 posVC) {\n  vec3 posIS = posVCtoIS(posVC);\n  vec4 texValue = getTextureValue(posIS);\n  return getColorForValue(texValue, posVC, posIS);\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\n                float maxDistance) {\n  // start slightly inside and apply some jitter\n  vec3 stepVC = rayDirVC * sampleDistance;\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\n\n  // Avoid 0.0 jitter\n  float jitter = 0.01 + 0.99 * fragmentSeed;\n\n  #if vtkBlendMode == COMPOSITE_BLEND\n    // now map through opacity and color\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\n    vec4 firstColor = getColorAtPos(firstPosVC);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\n      gl_FragData[0] = firstColor;\n      return;\n    }\n\n    // first color only counts for `jitter` factor of the step\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\n    vec3 posVC = firstPosVC + jitter * stepVC;\n    float stepsTraveled = jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n      vec4 tColor = getColorAtPos(posVC);\n\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\n      stepsTraveled++;\n      posVC += stepVC;\n      if (color.a > 0.99) {\n        color.a = 1.0;\n        break;\n      }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\n      vec4 tColor = getColorAtPos(endPosVC);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\n  #endif\n\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\n      #define OP max\n    #else\n      #define OP min\n    #endif\n\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // Find a value to initialize the selected variables\n    vec4 selectedValue;\n    vec3 selectedPosVC;\n    vec3 selectedPosIS;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      selectedValue = getTextureValue(posIS);\n      selectedPosVC = posVC;\n      selectedPosIS = posIS;\n    }\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // Get selected values\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n    }\n\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n  #endif\n\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\n    vec4 sum = vec4(0.);\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      float totalWeight = 0.0;\n    #endif\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 value = getTextureValue(posIS);\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\n      return;\n    }\n\n    if (valueWithinScalarRange(value)) {\n      sum += value * jitter;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += jitter;\n      #endif\n    }\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      posIS = posVCtoIS(posVC);\n      value = getTextureValue(posIS);\n      // One can control the scalar range by setting the AverageIPScalarRange to\n      // disregard scalar values, not in the range of interest, from the average\n      // computation. Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(value)) {\n        sum += value;\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n          totalWeight++;\n        #endif\n      }\n\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    posIS = posVCtoIS(posVC);\n    value = getTextureValue(posIS);\n    if (valueWithinScalarRange(value)) {\n      sum += value;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += raySteps - stepsTraveled;\n      #endif\n    }\n\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\n  #endif\n\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\n    float normalizedRayIntensity = 1.0;\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 tValue = getTextureValue(posIS);\n      normalizedRayIntensity -= raySteps * sampleDistance *\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\n      gl_FragData[0] =\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 value = getTextureValue(posIS);\n      // Convert scalar value to normalizedRayIntensity coefficient and\n      // accumulate normalizedRayIntensity\n      normalizedRayIntensity -=\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\n\n      posVC += stepVC;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] =\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n  #endif\n\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n    // Only works with a single volume\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 tValue = getTextureValue(posIS);\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\n      return;\n    }\n\n    vec3 stepIS = vecVCToIS(stepVC);\n    vec4 value = tValue;\n    posIS += jitter * stepIS;\n    stepsTraveled += jitter;\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading\n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the\n      // segment index and later check if the bit is set via bit operations\n      setLabelOutlineBit(segmentIndex);\n    }\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setLabelOutlineBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value = tValue;   // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue;   // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }\n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      vec3 maxPosVC = posIStoVC(maxPosIS);\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\n      return;\n    }\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    vec3 volumeSpacings = volume.spacing;\n    float minVoxelSpacing =\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base =\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\n                          gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\n                          gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not\n      // been seen by the center segment\n      if (!isLabelOutlineBitSet(s)) {\n        continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have\n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue =\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out\n      // faster if we find the edge\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\n                                          stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than\n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety\n      // of the all the fragments inside. i.e., this happens when we zoom out,\n      if (minVoxelSpacing >\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n\n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n        for (int j = -actualThickness; j <= actualThickness; j++) {\n          if (i == 0 && j == 0)\n            continue; // Skip the center\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\n            continue; // Skip corners\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\n            return;\n          }\n        }\n      }\n    }\n\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0, dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick / rayDirVC.z;\n  dists.y = min(farDist, dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\nfloat getFragmentSeed() {\n  // This first noise has a diagonal pattern\n  float firstNoise =\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  // This second noise is made out of blocks of CPU generated noise\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\n  // Combine the two sources of noise in a way that the distribution is uniform\n  // in [0,1[\n  float noiseSum = firstNoise + secondNoise;\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\n}\n\nvoid main() {\n  fragmentSeed = getFragmentSeed();\n\n  if (cameraParallel == 1) {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 rayOriginVC = vertexVCVSOutput;\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\n      rayStartEndDistancesVC[1] <= 0.0) {\n    // Volume not hit or behind the ray\n    discard;\n  }\n\n  // Perform the blending operation along the ray\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
var {
  vtkWarningMacro: vtkWarningMacro18,
  vtkErrorMacro: vtkErrorMacro70
} = macro$1;
var preAllocatedMatrices = {
  idxToView: mat4_exports.identity(new Float64Array(16)),
  vecISToVCMatrix: mat3_exports.identity(new Float64Array(9)),
  modelToView: mat4_exports.identity(new Float64Array(16)),
  projectionToView: mat4_exports.identity(new Float64Array(16)),
  projectionToWorld: mat4_exports.identity(new Float64Array(16))
};
function vtkOpenGLVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolumeMapper");
  function getUseIndependentComponents(actorProperty, numComp) {
    const iComps = actorProperty.getIndependentComponents();
    const colorMixPreset = actorProperty.getColorMixPreset();
    return iComps && numComp >= 2 || !!colorMixPreset;
  }
  function isLabelmapOutlineRequired(actorProperty) {
    return actorProperty.getUseLabelOutline() || model.renderable.getBlendMode() === BlendMode.LABELMAP_EDGE_PROJECTION_BLEND;
  }
  const graphicsResourceReferenceCount = /* @__PURE__ */ new Map();
  function decreaseGraphicsResourceCount(openGLRenderWindow, coreObject) {
    if (!coreObject) {
      return;
    }
    const oldCount = graphicsResourceReferenceCount.get(coreObject) ?? 0;
    const newCount = oldCount - 1;
    if (newCount <= 0) {
      openGLRenderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI);
      graphicsResourceReferenceCount.delete(coreObject);
    } else {
      graphicsResourceReferenceCount.set(coreObject, newCount);
    }
  }
  function increaseGraphicsResourceCount(openGLRenderWindow, coreObject) {
    if (!coreObject) {
      return;
    }
    const oldCount = graphicsResourceReferenceCount.get(coreObject) ?? 0;
    const newCount = oldCount + 1;
    graphicsResourceReferenceCount.set(coreObject, newCount);
    if (oldCount <= 0) {
      openGLRenderWindow.registerGraphicsResourceUser(coreObject, publicAPI);
    }
  }
  function replaceGraphicsResource(openGLRenderWindow, oldResourceCoreObject, newResourceCoreObject) {
    if (oldResourceCoreObject === newResourceCoreObject) {
      return;
    }
    decreaseGraphicsResourceCount(openGLRenderWindow, oldResourceCoreObject);
    increaseGraphicsResourceCount(openGLRenderWindow, newResourceCoreObject);
  }
  function unregisterGraphicsResources(renderWindow) {
    [...graphicsResourceReferenceCount.keys()].forEach((coreObject) => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = () => {
    model.zBufferTexture = null;
  };
  publicAPI.zBufferPass = (prepass, renderPass) => {
    if (prepass) {
      const zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.zBufferPass(prepass, renderPass);
  publicAPI.volumePass = (prepass, renderPass) => {
    if (prepass) {
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType("vtkOpenGLVolume");
      const actor = model.openGLVolume.getRenderable();
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera(), model.openGLCamera);
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::EnabledColorFunctions", `#define EnableColorForValueFunctionId${model.previousState.colorForValueFunctionId}`).result;
    const enabledLightings = [];
    if (model.previousState.surfaceLightingEnabled) {
      enabledLightings.push("Surface");
    }
    if (model.previousState.volumeLightingEnabled) {
      enabledLightings.push("Volume");
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::EnabledLightings", enabledLightings.map((lightingType) => `#define Enable${lightingType}Lighting`)).result;
    if (model.previousState.multiTexturePerVolumeEnabled) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::EnabledMultiTexturePerVolume", "#define EnabledMultiTexturePerVolume").result;
    }
    if (model.previousState.useIndependentComponents) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::EnabledIndependentComponents", "#define EnabledIndependentComponents").result;
    }
    if (model.previousState.gradientOpacityEnabled) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::EnabledGradientOpacity", "#define EnabledGradientOpacity").result;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkProportionalComponents", model.previousState.proportionalComponents.map((component) => `#define vtkComponent${component}Proportional`).join("\n")).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkForceNearestComponents", model.previousState.forceNearestComponents.map((component) => `#define vtkComponent${component}ForceNearest`).join("\n")).result;
    if (model.previousState.hasZBufferTexture) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", ["uniform sampler2D zBufferTexture;", "uniform float vpZWidth;", "uniform float vpZHeight;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));", "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;", "zdepth = zdepth * 2.0 - 1.0;", "if (cameraParallel == 0) {", "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}", "else {", "zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n", "zdepth = -zdepth/rayDirVC.z;", "dists.y = min(zdepth,dists.y);"]).result;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::BlendMode", `${model.previousState.blendMode}`).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::NumberOfLights", `${model.previousState.numberOfLights}`).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::MaxLaoKernelSize", `${model.previousState.maxLaoKernelSize}`).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::NumberOfComponents", `${model.previousState.numberOfComponents}`).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::MaximumNumberOfSamples", `${model.previousState.maximumNumberOfSamples}`).result;
    shaders.Fragment = FSSource;
    const numberOfClippingPlanes = model.previousState.numberOfClippingPlanes;
    if (numberOfClippingPlanes > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Dec", [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, `uniform vec3 vClipPlaneOrigins[6];`, `uniform int clip_numPlanes;`, "//VTK::ClipPlane::Dec", "#define vtkClippingPlanesOn"], false).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Impl", [`for(int i = 0; i < ${numberOfClippingPlanes}; i++) {`, "  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);", "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];", "  if (rayDirRatio == 0.0)", "  {", "    if (equationResult < 0.0) dists.x = dists.y;", "    continue;", "  }", "  float result = -1.0 * equationResult / rayDirRatio;", "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);", "  else dists.x = max(dists.x, result);", "}", "//VTK::ClipPlane::Impl"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    var _a, _b, _c;
    const hasZBufferTexture = !!model.zBufferTexture;
    const numberOfValidInputs = model.currentValidInputs.length;
    const numberOfLights = model.numberOfLights;
    const numberOfComponents = model.numberOfComponents;
    const useIndependentComponents = model.useIndependentComponents;
    const volumeProperties = actor.getProperties();
    const firstValidInput = model.currentValidInputs[0];
    const firstVolumeProperty = volumeProperties[firstValidInput.inputIndex];
    const multiTexturePerVolumeEnabled = numberOfValidInputs > 1;
    const boundsMC = firstValidInput.imageData.getBounds();
    const maximumRayLength = vtkBoundingBox.getDiagonalLength(boundsMC);
    const maximumNumberOfSamples = Math.ceil(maximumRayLength / publicAPI.getCurrentSampleDistance(ren));
    if (maximumNumberOfSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro18(`The number of steps required ${maximumNumberOfSamples} is larger than the specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.
Please either change the volumeMapper sampleDistance or its maximum number of samples.`);
    }
    const numberOfIndependantComponents = useIndependentComponents ? numberOfComponents : 1;
    let gradientOpacityEnabled = false;
    for (let i = 0; i < numberOfIndependantComponents; ++i) {
      if (firstVolumeProperty.getUseGradientOpacity(i)) {
        gradientOpacityEnabled = true;
        break;
      }
    }
    let maxLaoKernelSize = 0;
    const kernelSize = firstVolumeProperty.getLAOKernelSize();
    if (kernelSize > maxLaoKernelSize && firstVolumeProperty.getLocalAmbientOcclusion() && firstVolumeProperty.getAmbient() > 0) {
      maxLaoKernelSize = kernelSize;
    }
    const numberOfClippingPlanes = model.renderable.getClippingPlanes().length;
    const mapperShaderReplacements = (_a = model.renderable.getViewSpecificProperties().OpenGL) == null ? void 0 : _a.ShaderReplacements;
    const renderPassShaderReplacements = (_b = model.currentRenderPass) == null ? void 0 : _b.getShaderReplacement();
    const blendMode = model.renderable.getBlendMode();
    const colorForValueFunctionId = (() => {
      if (blendMode !== BlendMode.LABELMAP_EDGE_PROJECTION_BLEND && isLabelmapOutlineRequired(firstVolumeProperty)) {
        return 5;
      }
      if (useIndependentComponents) {
        switch (firstVolumeProperty.getColorMixPreset()) {
          case ColorMixPreset.ADDITIVE:
            return 1;
          case ColorMixPreset.COLORIZE:
            return 2;
          case ColorMixPreset.CUSTOM:
            return 3;
          default:
            return 4;
        }
      }
      return 0;
    })();
    const surfaceLightingEnabled = firstVolumeProperty.getVolumetricScatteringBlending() < 1;
    const volumeLightingEnabled = firstVolumeProperty.getVolumetricScatteringBlending() > 0;
    let forceNearestInterpolationEnabled = false;
    for (let component = 0; component < numberOfComponents; ++component) {
      if (firstVolumeProperty.getForceNearestInterpolation(component)) {
        forceNearestInterpolationEnabled = true;
        break;
      }
    }
    const proportionalComponents = [];
    const forceNearestComponents = [];
    for (let component = 0; component < numberOfComponents; component++) {
      if (firstVolumeProperty.getOpacityMode(component) === OpacityMode.PROPORTIONAL) {
        proportionalComponents.push(component);
      }
      if (firstVolumeProperty.getForceNearestInterpolation(component)) {
        forceNearestComponents.push(component);
      }
    }
    const currentState = {
      numberOfComponents,
      useIndependentComponents,
      proportionalComponents,
      forceNearestComponents,
      blendMode,
      numberOfLights,
      numberOfValidInputs,
      maximumNumberOfSamples,
      hasZBufferTexture,
      maxLaoKernelSize,
      numberOfClippingPlanes,
      mapperShaderReplacements,
      renderPassShaderReplacements,
      colorForValueFunctionId,
      surfaceLightingEnabled,
      volumeLightingEnabled,
      forceNearestInterpolationEnabled,
      multiTexturePerVolumeEnabled,
      gradientOpacityEnabled
    };
    if (((_c = cellBO.getProgram()) == null ? void 0 : _c.getHandle()) === 0 || !model.previousState || !(0, import_fast_deep_equal.default)(model.previousState, currentState)) {
      model.previousState = currentState;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexDC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexDC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro70("Error setting vertexDC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    const sampleDistance = publicAPI.getCurrentSampleDistance(ren);
    program.setUniformf("sampleDistance", sampleDistance);
    const volumeShadowSampleDistance = sampleDistance * model.renderable.getVolumeShadowSamplingDistFactor();
    program.setUniformf("volumeShadowSampleDistance", volumeShadowSampleDistance);
    model.scalarTextures.forEach((scalarTexture, component) => {
      program.setUniformi(`volumeTexture[${component}]`, scalarTexture.getTextureUnit());
    });
    const volumeProperties = actor.getProperties();
    const firstValidInput = model.currentValidInputs[0];
    const firstVolumeProperty = volumeProperties[firstValidInput.inputIndex];
    const ipScalarRange = firstVolumeProperty.getIpScalarRange();
    const minVals = new Float32Array(4);
    const maxVals = new Float32Array(4);
    const setMinMaxVal = (component, volInfo, volInfoIndex) => {
      var _a;
      if ((_a = volInfo == null ? void 0 : volInfo.dataComputedScale) == null ? void 0 : _a.length) {
        minVals[component] = ipScalarRange[0] * volInfo.dataComputedScale[volInfoIndex] + volInfo.dataComputedOffset[volInfoIndex];
        maxVals[component] = ipScalarRange[1] * volInfo.dataComputedScale[volInfoIndex] + volInfo.dataComputedOffset[volInfoIndex];
        minVals[component] = (minVals[component] - volInfo.offset[volInfoIndex]) / volInfo.scale[volInfoIndex];
        maxVals[component] = (maxVals[component] - volInfo.offset[volInfoIndex]) / volInfo.scale[volInfoIndex];
      }
    };
    if (model.previousState.multiTexturePerVolumeEnabled) {
      model.scalarTextures.forEach((scalarTexture, component) => {
        const volInfo = scalarTexture.getVolumeInfo();
        setMinMaxVal(component, volInfo, 0);
      });
    } else {
      const firstVolInfo = model.scalarTextures[0].getVolumeInfo();
      for (let component = 0; component < 4; ++component) {
        setMinMaxVal(component, firstVolInfo, component);
      }
    }
    const uniformPrefix = "volume";
    program.setUniform4f(`${uniformPrefix}.ipScalarRangeMin`, minVals[0], minVals[1], minVals[2], minVals[3]);
    program.setUniform4f(`${uniformPrefix}.ipScalarRangeMax`, maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    if (model.zBufferTexture !== null) {
      program.setUniformi("zBufferTexture", model.zBufferTexture.getTextureUnit());
      const size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();
      program.setUniformf("vpZWidth", size[0]);
      program.setUniformf("vpZHeight", size[1]);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const {
      idxToView,
      vecISToVCMatrix,
      modelToView,
      projectionToView,
      projectionToWorld
    } = preAllocatedMatrices;
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLVolume.getKeyMatrices();
    mat4_exports.multiply(modelToView, keyMats.wcvc, actMats.mcwc);
    const program = cellBO.getProgram();
    const camera = model.openGLCamera.getRenderable();
    const useParallelProjection = camera.getParallelProjection();
    const clippingRange = camera.getClippingRange();
    program.setUniformf("camThick", clippingRange[1] - clippingRange[0]);
    program.setUniformf("camNear", clippingRange[0]);
    program.setUniformf("camFar", clippingRange[1]);
    program.setUniformi("cameraParallel", useParallelProjection);
    const firstValidInput = model.currentValidInputs[0];
    const boundsMC = firstValidInput.imageData.getBounds();
    const cornersMC = vtkBoundingBox.getCorners(boundsMC, []);
    const cornersDC = cornersMC.map((corner2) => {
      vec3_exports.transformMat4(corner2, corner2, modelToView);
      if (!useParallelProjection) {
        const newScale = -clippingRange[0] / (corner2[2] * vec3_exports.length(corner2));
        vec3_exports.scale(corner2, corner2, newScale);
      }
      vec3_exports.transformMat4(corner2, corner2, keyMats.vcpc);
      return corner2;
    });
    const boundsDC = vtkBoundingBox.addPoints([...vtkBoundingBox.INIT_BOUNDS], cornersDC);
    program.setUniformf("dcxmin", boundsDC[0]);
    program.setUniformf("dcxmax", boundsDC[1]);
    program.setUniformf("dcymin", boundsDC[2]);
    program.setUniformf("dcymax", boundsDC[3]);
    const size = publicAPI.getRenderTargetSize();
    program.setUniformf("vpWidth", size[0]);
    program.setUniformf("vpHeight", size[1]);
    const offset = publicAPI.getRenderTargetOffset();
    program.setUniformf("vpOffsetX", offset[0] / size[0]);
    program.setUniformf("vpOffsetY", offset[1] / size[1]);
    mat4_exports.invert(projectionToView, keyMats.vcpc);
    program.setUniformMatrix("PCVCMatrix", projectionToView);
    program.setUniformi("twoSidedLighting", ren.getTwoSidedLighting());
    const kernelSample = new Array(2 * model.previousState.maxLaoKernelSize);
    for (let i = 0; i < model.previousState.maxLaoKernelSize; i++) {
      kernelSample[i * 2] = Math.random();
      kernelSample[i * 2 + 1] = Math.random();
    }
    program.setUniform2fv("kernelSample", kernelSample);
    if (model.numberOfLights > 0) {
      let lightIndex = 0;
      ren.getLights().forEach((light) => {
        if (light.getSwitch() > 0) {
          const lightPrefix = `lights[${lightIndex}]`;
          const color4 = light.getColor();
          const intensity = light.getIntensity();
          const scaledColor = vec3_exports.scale([], color4, intensity);
          program.setUniform3fv(`${lightPrefix}.color`, scaledColor);
          const position = light.getTransformedPosition();
          vec3_exports.transformMat4(position, position, modelToView);
          program.setUniform3fv(`${lightPrefix}.positionVC`, position);
          const direction3 = [...light.getDirection()];
          vec3_exports.transformMat3(direction3, direction3, keyMats.normalMatrix);
          vec3_exports.normalize(direction3, direction3);
          program.setUniform3fv(`${lightPrefix}.directionVC`, direction3);
          const halfAngle = [-0.5 * direction3[0], -0.5 * direction3[1], -0.5 * (direction3[2] - 1)];
          program.setUniform3fv(`${lightPrefix}.halfAngleVC`, halfAngle);
          const attenuation = light.getAttenuationValues();
          program.setUniform3fv(`${lightPrefix}.attenuation`, attenuation);
          const exponent = light.getExponent();
          program.setUniformf(`${lightPrefix}.exponent`, exponent);
          const coneAngle = light.getConeAngle();
          program.setUniformf(`${lightPrefix}.coneAngle`, coneAngle);
          const isPositional = light.getPositional();
          program.setUniformi(`${lightPrefix}.isPositional`, isPositional);
          lightIndex++;
        }
      });
    }
    const uniformPrefix = "volume";
    const volumeProperties = actor.getProperties();
    const firstVolumeProperty = volumeProperties[firstValidInput.inputIndex];
    const firstImageData = firstValidInput.imageData;
    const spatialExtent = firstImageData.getSpatialExtent();
    const spacing = firstImageData.getSpacing();
    const dimensions = firstImageData.getDimensions();
    const idxToModel = firstImageData.getIndexToWorld();
    const worldToIndex = firstImageData.getWorldToIndex();
    const imageDirection = firstImageData.getDirectionByReference();
    mat4_exports.multiply(idxToView, modelToView, idxToModel);
    program.setUniform3fv(`${uniformPrefix}.spacing`, spacing);
    const inverseSpacing = vec3_exports.inverse([], spacing);
    program.setUniform3fv(`${uniformPrefix}.inverseSpacing`, inverseSpacing);
    program.setUniform3iv(`${uniformPrefix}.dimensions`, dimensions);
    program.setUniform3fv(`${uniformPrefix}.inverseDimensions`, vec3_exports.inverse([], dimensions));
    program.setUniformMatrix(`${uniformPrefix}.worldToIndex`, worldToIndex);
    vecISToVCMatrix.fill(0);
    const sizeVC = vec3_exports.multiply(new Float64Array(3), dimensions, spacing);
    vecISToVCMatrix[0] = sizeVC[0];
    vecISToVCMatrix[4] = sizeVC[1];
    vecISToVCMatrix[8] = sizeVC[2];
    mat3_exports.multiply(vecISToVCMatrix, imageDirection, vecISToVCMatrix);
    mat3_exports.multiply(vecISToVCMatrix, actMats.normalMatrix, vecISToVCMatrix);
    mat3_exports.multiply(vecISToVCMatrix, keyMats.normalMatrix, vecISToVCMatrix);
    program.setUniformMatrix3x3(`${uniformPrefix}.vecISToVCMatrix`, vecISToVCMatrix);
    program.setUniformMatrix3x3(`${uniformPrefix}.vecVCToISMatrix`, mat3_exports.invert(new Float32Array(9), vecISToVCMatrix));
    const spacialExtentMinIC = vec3_exports.fromValues(spatialExtent[0], spatialExtent[2], spatialExtent[4]);
    const originVC = vec3_exports.transformMat4(new Float64Array(3), spacialExtentMinIC, idxToView);
    program.setUniform3fv(`${uniformPrefix}.originVC`, originVC);
    const diagonalLength = vec3_exports.length(sizeVC);
    program.setUniformf(`${uniformPrefix}.diagonalLength`, diagonalLength);
    if (isLabelmapOutlineRequired(firstVolumeProperty)) {
      const distance = camera.getDistance();
      camera.setClippingRange(distance, distance + 0.1);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);
      mat4_exports.invert(projectionToWorld, labelOutlineKeyMats.wcpc);
      camera.setClippingRange(clippingRange[0], clippingRange[1]);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix(`${uniformPrefix}.PCWCMatrix`, projectionToWorld);
    }
    if (firstVolumeProperty.getVolumetricScatteringBlending() > 0) {
      program.setUniformf(`${uniformPrefix}.globalIlluminationReach`, firstVolumeProperty.getGlobalIlluminationReach());
      program.setUniformf(`${uniformPrefix}.volumetricScatteringBlending`, firstVolumeProperty.getVolumetricScatteringBlending());
      program.setUniformf(`${uniformPrefix}.anisotropy`, firstVolumeProperty.getAnisotropy());
      program.setUniformf(`${uniformPrefix}.anisotropySquared`, firstVolumeProperty.getAnisotropy() ** 2);
    }
    if (firstVolumeProperty.getLocalAmbientOcclusion() && firstVolumeProperty.getAmbient() > 0) {
      const kernelSize = firstVolumeProperty.getLAOKernelSize();
      program.setUniformi(`${uniformPrefix}.kernelSize`, kernelSize);
      const kernelRadius = firstVolumeProperty.getLAOKernelRadius();
      program.setUniformi(`${uniformPrefix}.kernelRadius`, kernelRadius);
    } else {
      program.setUniformi(`${uniformPrefix}.kernelSize`, 0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    program.setUniformi("jtexture", model.jitterTexture.getTextureUnit());
    const volumeProperties = actor.getProperties();
    program.setUniformi(`labelOutlineThicknessTexture`, model.labelOutlineThicknessTexture.getTextureUnit());
    program.setUniformi("opacityTexture", model.opacityTexture.getTextureUnit());
    program.setUniformi("colorTexture", model.colorTexture.getTextureUnit());
    const uniformPrefix = "volume";
    const firstValidInput = model.currentValidInputs[0];
    const firstVolumeProperty = volumeProperties[firstValidInput.inputIndex];
    const numberOfComponents = model.previousState.numberOfComponents;
    const useIndependentComponents = model.previousState.useIndependentComponents;
    if (useIndependentComponents) {
      const independentComponentMix = new Float32Array(4);
      for (let i = 0; i < numberOfComponents; i++) {
        independentComponentMix[i] = firstVolumeProperty.getComponentWeight(i);
      }
      program.setUniform4fv(`${uniformPrefix}.independentComponentMix`, independentComponentMix);
      const transferFunctionsSampleHeight = new Float32Array(4);
      const pixelHeight = 1 / numberOfComponents;
      for (let i = 0; i < numberOfComponents; ++i) {
        transferFunctionsSampleHeight[i] = (i + 0.5) * pixelHeight;
      }
      program.setUniform4fv(`${uniformPrefix}.transferFunctionsSampleHeight`, transferFunctionsSampleHeight);
    }
    const colorForValueFunctionId = model.colorForValueFunctionId;
    program.setUniformi(`${uniformPrefix}.colorForValueFunctionId`, colorForValueFunctionId);
    const computeNormalFromOpacity = firstVolumeProperty.getComputeNormalFromOpacity();
    program.setUniformi(`${uniformPrefix}.computeNormalFromOpacity`, computeNormalFromOpacity);
    const colorTextureScale = new Float32Array(4);
    const colorTextureShift = new Float32Array(4);
    const opacityTextureScale = new Float32Array(4);
    const opacityTextureShift = new Float32Array(4);
    for (let component = 0; component < numberOfComponents; component++) {
      const useMultiTexture = model.previousState.multiTexturePerVolumeEnabled;
      const textureIndex = useMultiTexture ? component : 0;
      const volInfoIndex = useMultiTexture ? 0 : component;
      const scalarTexture = model.scalarTextures[textureIndex];
      const volInfo = scalarTexture.getVolumeInfo();
      const target = useIndependentComponents ? component : 0;
      const sscale = volInfo.scale[volInfoIndex];
      const colorFunction = firstVolumeProperty.getRGBTransferFunction(target);
      const colorRange = colorFunction.getRange();
      colorTextureScale[component] = sscale / (colorRange[1] - colorRange[0]);
      colorTextureShift[component] = (volInfo.offset[volInfoIndex] - colorRange[0]) / (colorRange[1] - colorRange[0]);
      const opacityFunction = firstVolumeProperty.getScalarOpacity(target);
      const opacityRange = opacityFunction.getRange();
      opacityTextureScale[component] = sscale / (opacityRange[1] - opacityRange[0]);
      opacityTextureShift[component] = (volInfo.offset[volInfoIndex] - opacityRange[0]) / (opacityRange[1] - opacityRange[0]);
    }
    program.setUniform4fv(`${uniformPrefix}.colorTextureScale`, colorTextureScale);
    program.setUniform4fv(`${uniformPrefix}.colorTextureShift`, colorTextureShift);
    program.setUniform4fv(`${uniformPrefix}.opacityTextureScale`, opacityTextureScale);
    program.setUniform4fv(`${uniformPrefix}.opacityTextureShift`, opacityTextureShift);
    if (model.previousState.gradientOpacityEnabled) {
      const gradientOpacityScale = new Array(4);
      const gradientOpacityShift = new Array(4);
      const gradientOpacityMin = new Array(4);
      const gradientOpacityMax = new Array(4);
      if (useIndependentComponents) {
        for (let component = 0; component < numberOfComponents; ++component) {
          const useMultiTexture = model.previousState.multiTexturePerVolumeEnabled;
          const textureIndex = useMultiTexture ? component : 0;
          const volInfoIndex = useMultiTexture ? 0 : component;
          const scalarTexture = model.scalarTextures[textureIndex];
          const volInfo = scalarTexture.getVolumeInfo();
          const sscale = volInfo.scale[volInfoIndex];
          const useGO = firstVolumeProperty.getUseGradientOpacity(component);
          if (useGO) {
            const goOpacityRange = [firstVolumeProperty.getGradientOpacityMinimumOpacity(component), firstVolumeProperty.getGradientOpacityMaximumOpacity(component)];
            const goValueRange = [firstVolumeProperty.getGradientOpacityMinimumValue(component), firstVolumeProperty.getGradientOpacityMaximumValue(component)];
            gradientOpacityMin[component] = goOpacityRange[0];
            gradientOpacityMax[component] = goOpacityRange[1];
            gradientOpacityScale[component] = sscale * (goOpacityRange[1] - goOpacityRange[0]) / (goValueRange[1] - goValueRange[0]);
            gradientOpacityShift[component] = -goValueRange[0] * (goOpacityRange[1] - goOpacityRange[0]) / (goValueRange[1] - goValueRange[0]) + goOpacityRange[0];
          } else {
            gradientOpacityMin[component] = 1;
            gradientOpacityMax[component] = 1;
            gradientOpacityScale[component] = 0;
            gradientOpacityShift[component] = 1;
          }
        }
      } else {
        const component = numberOfComponents - 1;
        const useMultiTexture = model.previousState.multiTexturePerVolumeEnabled;
        const textureIndex = useMultiTexture ? component : 0;
        const volInfoIndex = useMultiTexture ? 0 : component;
        const scalarTexture = model.scalarTextures[textureIndex];
        const volInfo = scalarTexture.getVolumeInfo();
        const sscale = volInfo.scale[volInfoIndex];
        const goOpacityRange = [firstVolumeProperty.getGradientOpacityMinimumOpacity(0), firstVolumeProperty.getGradientOpacityMaximumOpacity(0)];
        const goValueRange = [firstVolumeProperty.getGradientOpacityMinimumValue(0), firstVolumeProperty.getGradientOpacityMaximumValue(0)];
        gradientOpacityMin[0] = goOpacityRange[0];
        gradientOpacityMax[0] = goOpacityRange[1];
        gradientOpacityScale[0] = sscale * (goOpacityRange[1] - goOpacityRange[0]) / (goValueRange[1] - goValueRange[0]);
        gradientOpacityShift[0] = -goValueRange[0] * (goOpacityRange[1] - goOpacityRange[0]) / (goValueRange[1] - goValueRange[0]) + goOpacityRange[0];
      }
      program.setUniform4f(`${uniformPrefix}.gradientOpacityScale`, gradientOpacityScale);
      program.setUniform4f(`${uniformPrefix}.gradientOpacityShift`, gradientOpacityShift);
      program.setUniform4f(`${uniformPrefix}.gradientOpacityMin`, gradientOpacityMin);
      program.setUniform4f(`${uniformPrefix}.gradientOpacityMax`, gradientOpacityMax);
    }
    const outlineOpacity = firstVolumeProperty.getLabelOutlineOpacity();
    program.setUniformf(`${uniformPrefix}.outlineOpacity`, outlineOpacity);
    if (model.numberOfLights > 0) {
      program.setUniformf(`${uniformPrefix}.ambient`, firstVolumeProperty.getAmbient());
      program.setUniformf(`${uniformPrefix}.diffuse`, firstVolumeProperty.getDiffuse());
      program.setUniformf(`${uniformPrefix}.specular`, firstVolumeProperty.getSpecular());
      const specularPower = firstVolumeProperty.getSpecularPower();
      program.setUniformf(`${uniformPrefix}.specularPower`, specularPower === 0 ? 1 : specularPower);
    }
  };
  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {
    if (model.renderable.getClippingPlanes().length > 0) {
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const clipPlaneNormals = [];
      const clipPlaneDistances = [];
      const clipPlaneOrigins = [];
      const clipPlanes = model.renderable.getClippingPlanes();
      const clipPlaneSize = clipPlanes.length;
      for (let i = 0; i < clipPlaneSize; ++i) {
        const clipPlaneNormal = clipPlanes[i].getNormal();
        const clipPlanePos = clipPlanes[i].getOrigin();
        vec3_exports.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        vec3_exports.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);
        const clipPlaneDist = -1 * vec3_exports.dot(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
        clipPlaneOrigins.push(clipPlanePos[0]);
        clipPlaneOrigins.push(clipPlanePos[1]);
        clipPlaneOrigins.push(clipPlanePos[2]);
      }
      const program = cellBO.getProgram();
      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);
      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);
      program.setUniform3fv(`vClipPlaneOrigins`, clipPlaneOrigins);
      program.setUniformi(`clip_numPlanes`, clipPlaneSize);
    }
  };
  publicAPI.delete = chain(() => {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, () => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.getCurrentSampleDistance = (ren) => {
    const rwi = ren.getVTKWindow().getInteractor();
    const baseSampleDistance = model.renderable.getSampleDistance();
    if (rwi.isAnimating()) {
      const factor = model.renderable.getInteractionSampleDistanceFactor();
      return baseSampleDistance * factor;
    }
    return baseSampleDistance;
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    const rwi = ren.getVTKWindow().getInteractor();
    if (!model._lastScale) {
      model._lastScale = model.renderable.getInitialInteractionScale();
    }
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          const frate = rwi.getRecentAnimationFrameRate();
          const adjustment = rwi.getDesiredUpdateRate() / frate;
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
      });
    }
    if (model._useSmallViewport) {
      const size = model._openGLRenderWindow.getFramebufferSize();
      const scaleFactor = 1 / Math.sqrt(model._lastScale);
      model._smallViewportWidth = Math.ceil(scaleFactor * size[0]);
      model._smallViewportHeight = Math.ceil(scaleFactor * size[1]);
      if (model._smallViewportHeight > size[1]) {
        model._smallViewportHeight = size[1];
      }
      if (model._smallViewportWidth > size[0]) {
        model._smallViewportWidth = size[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        const fbSize = model.framebuffer.getSize();
        if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      const gl = model.context;
      gl.clearColor(0, 0, 0, 0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);
    publicAPI.updateBufferObjects(ren, actor);
    const volumeProperties = actor.getProperties();
    model.currentValidInputs.forEach((_ref) => {
      let {
        inputIndex
      } = _ref;
      const volumeProperty = volumeProperties[inputIndex];
      const interpolationType = volumeProperty.getInterpolationType();
      const scalarTexture = model.scalarTextures[inputIndex];
      if (interpolationType === InterpolationType.NEAREST) {
        scalarTexture.setMinificationFilter(Filter.NEAREST);
        scalarTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        scalarTexture.setMinificationFilter(Filter.LINEAR);
        scalarTexture.setMagnificationFilter(Filter.LINEAR);
      }
    });
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    const allTextures = [...model.scalarTextures, model.colorTexture, model.opacityTexture, model.labelOutlineThicknessTexture, model.jitterTexture];
    allTextures.forEach((texture) => texture.activate());
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    allTextures.forEach((texture) => texture.deactivate());
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "uniform vec2 tfactor;", "varying vec2 tcoord;", "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"), ["//VTK::System::Dec", "//VTK::Output::Dec", "uniform sampler2D texture1;", "varying vec2 tcoord;", "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"), "");
        const program = model.copyShader;
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro70("Error setting vertexDC in copy shader VAO.");
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      const size = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size[0], size[1]);
      const tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi("texture", tex.getTextureUnit());
      model.copyShader.setUniform2f("tfactor", model.fvp[0], model.fvp[1]);
      const gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    const numberOfInputs = model.renderable.getNumberOfInputPorts();
    model.currentValidInputs = [];
    for (let inputIndex = 0; inputIndex < numberOfInputs; ++inputIndex) {
      const imageData = model.renderable.getInputData(inputIndex);
      if (imageData && !imageData.isDeleted()) {
        model.currentValidInputs.push({
          imageData,
          inputIndex
        });
      }
    }
    let newNumberOfLights = 0;
    if (model.currentValidInputs.length > 0) {
      const volumeProperties = actor.getProperties();
      const firstValidInput = model.currentValidInputs[0];
      const firstImageData = firstValidInput.imageData;
      const firstScalars = firstImageData.getPointData().getScalars();
      const firstVolumeProperty = volumeProperties[firstValidInput.inputIndex];
      if (firstVolumeProperty.getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {
        ren.getLights().forEach((light) => {
          if (light.getSwitch() > 0) {
            newNumberOfLights++;
          }
        });
      }
      const numberOfValidInputs = model.currentValidInputs.length;
      const multiTexturePerVolumeEnabled = numberOfValidInputs > 1;
      model.numberOfComponents = multiTexturePerVolumeEnabled ? numberOfValidInputs : firstScalars.getNumberOfComponents();
      model.useIndependentComponents = getUseIndependentComponents(firstVolumeProperty, model.numberOfComponents);
    }
    if (newNumberOfLights !== model.numberOfLights) {
      model.numberOfLights = newNumberOfLights;
      publicAPI.modified();
    }
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (model.currentValidInputs.length === 0) {
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    var _a, _b, _c, _d, _e;
    return model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < ((_a = actor.getProperty(model.currentValidInputs[0].inputIndex)) == null ? void 0 : _a.getMTime()) || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.currentValidInputs.some((_ref2) => {
      let {
        imageData
      } = _ref2;
      return model.VBOBuildTime.getMTime() < imageData.getMTime();
    }) || model.scalarTextures.length !== model.currentValidInputs.length || !model.scalarTextures.every((texture) => !!(texture == null ? void 0 : texture.getHandle())) || !((_b = model.colorTexture) == null ? void 0 : _b.getHandle()) || !((_c = model.opacityTexture) == null ? void 0 : _c.getHandle()) || !((_d = model.labelOutlineThicknessTexture) == null ? void 0 : _d.getHandle()) || !((_e = model.jitterTexture) == null ? void 0 : _e.getHandle());
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    var _a, _b, _c;
    if (!model.jitterTexture.getHandle()) {
      const jitterArray = new Float32Array(32 * 32);
      for (let i = 0; i < 32 * 32; ++i) {
        jitterArray[i] = Math.random();
      }
      model.jitterTexture.setMinificationFilter(Filter.NEAREST);
      model.jitterTexture.setMagnificationFilter(Filter.NEAREST);
      model.jitterTexture.create2DFromRaw({
        width: 32,
        height: 32,
        numComps: 1,
        dataType: VtkDataTypes.FLOAT,
        data: jitterArray
      });
    }
    const volumeProperties = actor.getProperties();
    const firstValidInput = model.currentValidInputs[0];
    const firstVolumeProperty = volumeProperties[firstValidInput.inputIndex];
    const numberOfComponents = model.numberOfComponents;
    const useIndependentComps = model.useIndependentComponents;
    const numIComps = useIndependentComps ? numberOfComponents : 1;
    const opacityFunctions = [];
    for (let component = 0; component < numIComps; ++component) {
      opacityFunctions.push(firstVolumeProperty.getScalarOpacity(component));
    }
    const opacityFuncHash = getTransferFunctionsHash(opacityFunctions, useIndependentComps, numIComps);
    const firstScalarOpacityFunc = firstVolumeProperty.getScalarOpacity();
    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(firstScalarOpacityFunc);
    const reBuildOp = !((_a = opTex == null ? void 0 : opTex.oglObject) == null ? void 0 : _a.getHandle()) || opTex.hash !== opacityFuncHash;
    if (reBuildOp) {
      const newOpacityTexture = vtkOpenGLTexture$1.newInstance();
      newOpacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      let oWidth = model.renderable.getOpacityTextureWidth();
      if (oWidth <= 0) {
        oWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const oSize = oWidth * 2 * numIComps;
      const ofTable = new Float32Array(oSize);
      const tmpTable = new Float32Array(oWidth);
      for (let c2 = 0; c2 < numIComps; ++c2) {
        const ofun = firstVolumeProperty.getScalarOpacity(c2);
        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / firstVolumeProperty.getScalarOpacityUnitDistance(c2);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        for (let i = 0; i < oWidth; ++i) {
          ofTable[c2 * oWidth * 2 + i] = 1 - (1 - tmpTable[i]) ** opacityFactor;
          ofTable[c2 * oWidth * 2 + i + oWidth] = ofTable[c2 * oWidth * 2 + i];
        }
      }
      newOpacityTexture.resetFormatAndType();
      newOpacityTexture.setMinificationFilter(Filter.LINEAR);
      newOpacityTexture.setMagnificationFilter(Filter.LINEAR);
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        newOpacityTexture.create2DFromRaw({
          width: oWidth,
          height: 2 * numIComps,
          numComps: 1,
          dataType: VtkDataTypes.FLOAT,
          data: ofTable
        });
      } else {
        const oTable = new Uint8ClampedArray(oSize);
        for (let i = 0; i < oSize; ++i) {
          oTable[i] = 255 * ofTable[i];
        }
        newOpacityTexture.create2DFromRaw({
          width: oWidth,
          height: 2 * numIComps,
          numComps: 1,
          dataType: VtkDataTypes.UNSIGNED_CHAR,
          data: oTable
        });
      }
      if (firstScalarOpacityFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(firstScalarOpacityFunc, newOpacityTexture, opacityFuncHash);
      }
      model.opacityTexture = newOpacityTexture;
    } else {
      model.opacityTexture = opTex.oglObject;
    }
    replaceGraphicsResource(model._openGLRenderWindow, model._opacityTextureCore, firstScalarOpacityFunc);
    model._opacityTextureCore = firstScalarOpacityFunc;
    const colorTransferFunctions = [];
    for (let component = 0; component < numIComps; ++component) {
      colorTransferFunctions.push(firstVolumeProperty.getRGBTransferFunction(component));
    }
    const colorFuncHash = getTransferFunctionsHash(colorTransferFunctions, useIndependentComps, numIComps);
    const firstColorTransferFunc = firstVolumeProperty.getRGBTransferFunction();
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(firstColorTransferFunc);
    const reBuildC = !((_b = cTex == null ? void 0 : cTex.oglObject) == null ? void 0 : _b.getHandle()) || (cTex == null ? void 0 : cTex.hash) !== colorFuncHash;
    if (reBuildC) {
      const newColorTexture = vtkOpenGLTexture$1.newInstance();
      newColorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      let cWidth = model.renderable.getColorTextureWidth();
      if (cWidth <= 0) {
        cWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const cSize = cWidth * 2 * numIComps * 3;
      const cTable = new Uint8ClampedArray(cSize);
      const tmpTable = new Float32Array(cWidth * 3);
      for (let c2 = 0; c2 < numIComps; ++c2) {
        const cfun = firstVolumeProperty.getRGBTransferFunction(c2);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[c2 * cWidth * 6 + i] = 255 * tmpTable[i];
          cTable[c2 * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
        }
      }
      newColorTexture.resetFormatAndType();
      newColorTexture.setMinificationFilter(Filter.LINEAR);
      newColorTexture.setMagnificationFilter(Filter.LINEAR);
      newColorTexture.create2DFromRaw({
        width: cWidth,
        height: 2 * numIComps,
        numComps: 3,
        dataType: VtkDataTypes.UNSIGNED_CHAR,
        data: cTable
      });
      model._openGLRenderWindow.setGraphicsResourceForObject(firstColorTransferFunc, newColorTexture, colorFuncHash);
      model.colorTexture = newColorTexture;
    } else {
      model.colorTexture = cTex.oglObject;
    }
    replaceGraphicsResource(model._openGLRenderWindow, model._colorTextureCore, firstColorTransferFunc);
    model._colorTextureCore = firstColorTransferFunc;
    model.currentValidInputs.forEach((_ref3, component) => {
      var _a2;
      let {
        imageData,
        inputIndex
      } = _ref3;
      const volumeProperty = volumeProperties[inputIndex];
      const scalars = imageData.getPointData().getScalars();
      const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
      const scalarsHash = getImageDataHash(imageData, scalars);
      const reBuildTex = !((_a2 = tex == null ? void 0 : tex.oglObject) == null ? void 0 : _a2.getHandle()) || (tex == null ? void 0 : tex.hash) !== scalarsHash;
      const updatedExtents = volumeProperty.getUpdatedExtents();
      const hasUpdatedExtents = !!updatedExtents.length;
      if (reBuildTex && !hasUpdatedExtents) {
        const newScalarTexture = vtkOpenGLTexture$1.newInstance();
        newScalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
        const dims = imageData.getDimensions();
        newScalarTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
        newScalarTexture.resetFormatAndType();
        newScalarTexture.create3DFilterableFromDataArray({
          width: dims[0],
          height: dims[1],
          depth: dims[2],
          dataArray: scalars,
          preferSizeOverAccuracy: volumeProperty.getPreferSizeOverAccuracy()
        });
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, newScalarTexture, scalarsHash);
        model.scalarTextures[component] = newScalarTexture;
      } else {
        model.scalarTextures[component] = tex.oglObject;
      }
      if (hasUpdatedExtents) {
        volumeProperty.setUpdatedExtents([]);
        const dims = imageData.getDimensions();
        model.scalarTextures[component].create3DFilterableFromDataArray({
          width: dims[0],
          height: dims[1],
          depth: dims[2],
          dataArray: scalars,
          updatedExtents
        });
      }
      replaceGraphicsResource(model._openGLRenderWindow, model._scalarTexturesCore[component], scalars);
      model._scalarTexturesCore[component] = scalars;
    });
    const labelOutlineThicknessArray = firstVolumeProperty.getLabelOutlineThickness();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);
    const labelOutlineThicknessHash = labelOutlineThicknessArray.join("-");
    const reBuildL = !((_c = lTex == null ? void 0 : lTex.oglObject) == null ? void 0 : _c.getHandle()) || (lTex == null ? void 0 : lTex.hash) !== labelOutlineThicknessHash;
    if (reBuildL) {
      const newLabelOutlineThicknessTexture = vtkOpenGLTexture$1.newInstance();
      newLabelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      let lWidth = model.renderable.getLabelOutlineTextureWidth();
      if (lWidth <= 0) {
        lWidth = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      }
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);
      for (let i = 0; i < lWidth; ++i) {
        const thickness = typeof labelOutlineThicknessArray[i] !== "undefined" ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      newLabelOutlineThicknessTexture.resetFormatAndType();
      newLabelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);
      newLabelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);
      newLabelOutlineThicknessTexture.create2DFromRaw({
        width: lWidth,
        height: lHeight,
        numComps: 1,
        dataType: VtkDataTypes.UNSIGNED_CHAR,
        data: lTable
      });
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, newLabelOutlineThicknessTexture, labelOutlineThicknessHash);
      }
      model.labelOutlineThicknessTexture = newLabelOutlineThicknessTexture;
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
    replaceGraphicsResource(model._openGLRenderWindow, model._labelOutlineThicknessTextureCore, labelOutlineThicknessArray);
    model._labelOutlineThicknessTextureCore = labelOutlineThicknessArray;
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1;
        ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
        ptsArray[i * 3 + 2] = -1;
      }
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES164 = {
  context: null,
  VBOBuildTime: null,
  scalarTextures: [],
  _scalarTexturesCore: [],
  opacityTexture: null,
  _opacityTextureCore: null,
  colorTexture: null,
  _colorTextureCore: null,
  labelOutlineThicknessTexture: null,
  _labelOutlineThicknessTextureCore: null,
  jitterTexture: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1,
  targetXYF: 1,
  zBufferTexture: null,
  lastZBufferTexture: null,
  fullViewportTime: 1,
  idxToView: null,
  vecISToVCMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0,
  avgFrameTime: 0
};
function extend179(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES164, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  model.jitterTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture.setWrapS(Wrap.REPEAT);
  model.jitterTexture.setWrapT(Wrap.REPEAT);
  model.framebuffer = vtkOpenGLFramebuffer.newInstance();
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolumeMapper(publicAPI, model);
}
var newInstance172 = newInstance(extend179, "vtkOpenGLVolumeMapper");
var vtkVolumeMapper2 = {
  newInstance: newInstance172,
  extend: extend179
};
registerOverride("vtkVolumeMapper", newInstance172);

// node_modules/@kitware/vtk.js/Rendering/OpenGL.js
var OpenGL = {
  vtkActor,
  vtkActor2D,
  vtkBufferObject,
  vtkCamera,
  vtkCellArrayBufferObject,
  vtkConvolution2DPass: vtkConvolution2DPass$1,
  vtkForwardPass: vtkForwardPass$1,
  vtkFramebuffer: vtkOpenGLFramebuffer,
  vtkGlyph3DMapper: vtkGlyph3DMapper2,
  vtkHardwareSelector,
  vtkHelper,
  vtkImageMapper: vtkImageMapper2,
  vtkImageSlice: vtkImageSlice2,
  vtkPixelSpaceCallbackMapper,
  vtkPolyDataMapper: vtkOpenGLPolyDataMapper$1,
  vtkPolyDataMapper2D,
  vtkRenderWindow,
  vtkRenderer,
  vtkImageResliceMapper: vtkImageResliceMapper2,
  vtkShader: vtkShader$1,
  vtkShaderCache: vtkShaderCache$1,
  vtkShaderProgram: vtkShaderProgram$1,
  vtkSkybox,
  vtkSphereMapper: vtkSphereMapper2,
  vtkStickMapper: vtkStickMapper2,
  vtkTexture: vtkOpenGLTexture$1,
  vtkTextureUnitManager,
  vtkVertexArrayObject,
  vtkViewNodeFactory,
  vtkVolume: vtkVolume2,
  vtkVolumeMapper: vtkVolumeMapper2
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph.js
var SceneGraph = {
  vtkRenderPass: vtkRenderPass$1,
  vtkRenderWindowViewNode: vtkRenderWindowViewNode$1,
  vtkViewNode: vtkViewNode$1,
  vtkViewNodeFactory: vtkViewNodeFactory$1
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Glyph3DMapper.js
function vtkWebGPUGlyph3DCellArrayMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUGlyph3DCellArrayMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.setGlyphInstances = (val) => {
    model.glyphInstances = val;
  };
  publicAPI.updateBuffers = () => {
    superClass.updateBuffers();
    publicAPI.setNumberOfInstances(model.glyphInstances);
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinInput("u32", "@builtin(instance_index) instanceIndex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    if (!vDesc.hasOutput("vertexVC")) vDesc.addOutput("vec3<f32>", "vertexVC");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var vertexSC: vec4<f32> = mapperUBO.BCSCMatrix*glyphSSBO.values[input.instanceIndex].matrix*vertexBC;", "    output.vertexVC = (rendererUBO.SCVCMatrix*vertexSC).xyz;", "    output.Position = rendererUBO.SCPCMatrix*vertexSC;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    if (vertexInput.hasAttribute("normalMC")) {
      const vDesc = pipeline.getShaderDescription("vertex");
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  output.normalVC = normalize((rendererUBO.WCVCNormals", " * mapperUBO.MCWCNormals", " * glyphSSBO.values[input.instanceIndex].normal*normalMC).xyz);"]).result;
      vDesc.setCode(code);
    }
    superClass.replaceShaderNormal(hash, pipeline, vertexInput);
  };
  model.shaderReplacements.set("replaceShaderNormal", publicAPI.replaceShaderNormal);
  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
    if (!model.renderable.getColorArray()) {
      superClass.replaceShaderColor(hash, pipeline, vertexInput);
      return;
    }
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec4<f32>", "color");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["  output.color = glyphSSBO.values[input.instanceIndex].color;"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["ambientColor = input.color;", "diffuseColor = input.color;", "opacity = mapperUBO.Opacity * input.color.a;"]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderColor", publicAPI.replaceShaderColor);
  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
    if (hash.includes("sel")) {
      const vDesc = pipeline.getShaderDescription("vertex");
      vDesc.addOutput("u32", "compositeID", "flat");
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Select::Impl", ["  output.compositeID = input.instanceIndex;"]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Select::Impl", ["var compositeID: u32 = input.compositeID;"]).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderSelect", publicAPI.replaceShaderSelect);
}
function caExtend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, {}, initialValues);
  vtkWebGPUCellArrayMapper$1.extend(publicAPI, model, initialValues);
  vtkWebGPUGlyph3DCellArrayMapper(publicAPI, model);
}
var caNewInstance = newInstance(caExtend, "vtkWebGPUGlyph3DCellArrayMapper");
function vtkWebGPUGlyph3DMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUGlyph3DMapper");
  publicAPI.createCellArrayMapper = () => {
    const mpr = caNewInstance();
    mpr.setSSBO(model.SSBO);
    mpr.setRenderable(model.renderable);
    return mpr;
  };
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const gpoly = model.renderable.getInputData(1);
      model.renderable.mapScalars(gpoly, 1);
      publicAPI.updateSSBO();
      publicAPI.updateCellArrayMappers(gpoly);
      for (let i = 0; i < model.children.length; i++) {
        const cellMapper = model.children[i];
        cellMapper.setGlyphInstances(model.numInstances);
      }
    }
  };
  publicAPI.updateSSBO = () => {
    model.currentInput = model.renderable.getInputData(1);
    model.renderable.buildArrays();
    const garray = model.renderable.getMatrixArray();
    const narray = model.renderable.getNormalArray();
    model.carray = model.renderable.getColorArray();
    model.numInstances = garray.length / 16;
    if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {
      model.WebGPURenderWindow = publicAPI.getFirstAncestorOfType("vtkWebGPURenderWindow");
      const device = model.WebGPURenderWindow.getDevice();
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(model.numInstances);
      model.SSBO.addEntry("matrix", "mat4x4<f32>");
      model.SSBO.addEntry("normal", "mat4x4<f32>");
      if (model.carray) {
        model.SSBO.addEntry("color", "vec4<f32>");
      }
      model.SSBO.setAllInstancesFromArray("matrix", garray);
      model.SSBO.setAllInstancesFromArray3x3To4x4("normal", narray);
      if (model.carray) {
        model.SSBO.setAllInstancesFromArrayColorToFloat("color", model.carray.getData());
      }
      model.SSBO.send(device);
      model.glyphBOBuildTime.modified();
    }
  };
}
var DEFAULT_VALUES165 = {};
function extend180(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES165, initialValues);
  vtkWebGPUPolyDataMapper$1.extend(publicAPI, model, initialValues);
  model.glyphBOBuildTime = {};
  obj(model.glyphBOBuildTime, {
    mtime: 0
  });
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "glyphSSBO"
  });
  vtkWebGPUGlyph3DMapper(publicAPI, model);
}
var newInstance173 = newInstance(extend180, "vtkWebGPUGlyph3DMapper");
registerOverride2("vtkGlyph3DMapper", newInstance173);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js
var {
  SlicingMode: SlicingMode4
} = Constants15;
var imgFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Image::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  //VTK::Image::Sample

  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);

//VTK::RenderEncoder::Impl

  return output;
}
`;
function computeFnToString(property, fn, numberOfComponents) {
  const pwfun = fn.apply(property);
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return "0";
}
var tmpMat4 = new Float64Array(16);
var tmp2Mat4 = new Float64Array(16);
var tmp3Mat4 = new Float64Array(16);
var ptsArray1 = new Float64Array(4);
var ptsArray2 = new Float64Array(4);
function vtkWebGPUImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType("vtkWebGPUImageSlice");
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      const ren = model.WebGPURenderer.getRenderable();
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.computePipelineHash = () => {
    const ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = "img2";
    } else {
      model.dimensions = 3;
      model.pipelineHash = "img3";
    }
  };
  publicAPI.updateUBO = () => {
    const utime = model.UBO.getSendTime();
    const actor = model.WebGPUImageSlice.getRenderable();
    const volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      const image = volMapr.getInputData();
      const center = model.WebGPURenderer.getStabilizedCenterByReference();
      mat4_exports.identity(tmpMat4);
      mat4_exports.translate(tmpMat4, tmpMat4, center);
      const mcwcmat = actor.getMatrix();
      mat4_exports.transpose(tmp2Mat4, mcwcmat);
      mat4_exports.invert(tmp2Mat4, tmp2Mat4);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const modelToIndex = image.getWorldToIndex();
      mat4_exports.multiply(tmpMat4, modelToIndex, tmpMat4);
      mat4_exports.invert(tmp3Mat4, tmpMat4);
      mat4_exports.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const dims = image.getDimensions();
      mat4_exports.identity(tmp2Mat4);
      mat4_exports.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      model.UBO.setArray("SCTCMatrix", tmpMat4);
      const ext = model.currentInput.getExtent();
      const {
        ijkMode
      } = model.renderable.getClosestIJKAxis();
      let nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      let axis0 = 2;
      let axis1 = 0;
      let axis2 = 1;
      if (ijkMode === SlicingMode4.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode4.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray1[3] = 1;
      vec4_exports.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray("Origin", ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;
      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis1", ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis2", ptsArray2);
      const cScale = [1, 1, 1, 1];
      const cShift = [0, 0, 0, 0];
      const tView = model.textureViews[0];
      const tScale = tView.getTexture().getScale();
      const numComp = tView.getTexture().getNumberOfComponents();
      for (let i = 0; i < numComp; i++) {
        let cw = actor.getProperty().getColorWindow();
        let cl = actor.getProperty().getColorLevel();
        const target = 0;
        const cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun) {
          const cRange = cfun.getRange();
          cw = cRange[1] - cRange[0];
          cl = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i] = tScale / cw;
        cShift[i] = -cl / cw + 0.5;
      }
      model.UBO.setArray("cScale", cScale);
      model.UBO.setArray("cShift", cShift);
      model.UBO.sendIfNeeded(model.device);
    }
  };
  publicAPI.updateLUTImage = () => {
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const tView = publicAPI.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    const numIComps = 1;
    const cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
      let cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        const tmpTable = new Float32Array(model.rowLength * 3);
        for (let c2 = 0; c2 < numIComps; c2++) {
          cfun = actorProperty.getRGBTransferFunction(c2);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (let i = 0; i < model.rowLength; i++) {
              const idx = c2 * model.rowLength * 8 + i * 4;
              colorArray[idx] = 255 * tmpTable[i * 3];
              colorArray[idx + 1] = 255 * tmpTable[i * 3 + 1];
              colorArray[idx + 2] = 255 * tmpTable[i * 3 + 2];
              colorArray[idx + 3] = 255;
              for (let j = 0; j < 4; j++) {
                colorArray[idx + model.rowLength * 4 + j] = colorArray[idx + j];
              }
            }
          }
        }
      } else {
        for (let i = 0; i < model.rowLength; ++i) {
          const grey = 255 * i / (model.rowLength - 1);
          colorArray[i * 4] = grey;
          colorArray[i * 4 + 1] = grey;
          colorArray[i * 4 + 2] = grey;
          colorArray[i * 4 + 3] = 255;
          for (let j = 0; j < 4; j++) {
            colorArray[i * 4 + model.rowLength * 4 + j] = colorArray[i * 4 + j];
          }
        }
      }
      {
        const treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "rgba8unorm"
        };
        const newTex = model.device.getTextureManager().getTexture(treq);
        const tview = newTex.createView("tfunTexture");
        model.textureViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  const superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = () => {
    superClassUpdateBuffers();
    const newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);
    const tViews = model.textureViews;
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      const tview = newTex.createView("imgTexture");
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage();
    publicAPI.updateUBO();
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const iType = actorProperty.getInterpolationType() === InterpolationType3.NEAREST ? "nearest" : "linear";
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: iType,
        magFilter: iType
      });
      model.additionalBindables = [model.clampSampler];
    }
  };
  const sr = publicAPI.getShaderReplacements();
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    const lines = ["var pos: vec4<f32> = mapperUBO.Origin +", "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;", "pos.w = 1.0;"];
    if (model.dimensions === 2) {
      lines.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;");
    } else {
      lines.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;");
    }
    lines.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", lines).result;
    vDesc.setCode(code);
  };
  sr.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    if (model.dimensions === 2) {
      vDesc.addOutput("vec2<f32>", "tcoordVS");
    } else {
      vDesc.addOutput("vec3<f32>", "tcoordVS");
    }
  };
  sr.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var coord: vec2<f32> =`, `      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);`, `    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);`]).result;
    fDesc.setCode(code);
  };
  sr.set("replaceShaderImage", publicAPI.replaceShaderImage);
}
var DEFAULT_VALUES166 = {
  rowLength: 1024
};
function extend181(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES166, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  publicAPI.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SCTCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("Origin", "vec4<f32>");
  model.UBO.addEntry("Axis2", "vec4<f32>");
  model.UBO.addEntry("Axis1", "vec4<f32>");
  model.UBO.addEntry("cScale", "vec4<f32>");
  model.UBO.addEntry("cShift", "vec4<f32>");
  model.lutBuildTime = {};
  obj(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkWebGPUImageMapper(publicAPI, model);
}
var newInstance174 = newInstance(extend181, "vtkWebGPUImageMapper");
registerOverride2("vtkImageMapper", newInstance174);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js
function vtkWebGPUImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageSlice");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      const center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        mat4_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat4_exports.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES167 = {
  bufferShift: void 0,
  keyMatrixTime: null,
  keyMatrices: null,
  propID: void 0
};
function extend182(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES167, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUImageSlice(publicAPI, model);
}
var newInstance175 = newInstance(extend182, "vtkWebGPUImageSlice");
registerOverride2("vtkImageSlice", newInstance175);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/SphereMapper.js
var {
  BufferUsage
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro71
} = macro$1;
var vtkWebGPUSphereMapperVS = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::Color::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);

  //VTK::Color::Impl

  // compute the projected vertex position
  output.centerVC = vertexVC.xyz;
  output.radiusVC = length(offsetMC)*0.5;

  // make the triangle face the camera
  if (rendererUBO.cameraParallel == 0u)
    {
    var dir: vec3<f32> = normalize(-vertexVC.xyz);
    var base2: vec3<f32> = normalize(cross(dir,vec3<f32>(1.0,0.0,0.0)));
    var base1: vec3<f32> = cross(base2,dir);
    dir = vertexVC.xyz + offsetMC.x*base1 + offsetMC.y*base2;
    vertexVC = vec4<f32>(dir, 1.0);
    }
  else
    {
    // add in the offset
    var tmp2: vec2<f32> = vertexVC.xy + offsetMC;
    vertexVC = vec4<f32>(tmp2, vertexVC.zw);
    }

  output.vertexVC = vec4<f32>(vertexVC.xyz, 0.0);

  //VTK::Position::Impl

  return output;
}
`;
function vtkWebGPUSphereMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSphereMapper");
  const cellMapperBuildPass = publicAPI.buildPass;
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      publicAPI.setCellArray(poly.getVerts());
      publicAPI.setCurrentInput(poly);
    }
    cellMapperBuildPass(prepass);
  };
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    if (!vDesc.hasOutput("vertexVC")) vDesc.addOutput("vec4<f32>", "vertexVC");
    vDesc.addOutput("vec3<f32>", "centerVC");
    vDesc.addOutput("f32", "radiusVC");
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinOutput("f32", "@builtin(frag_depth) fragDepth");
    const sphereFrag = `
    // compute the eye position and unit direction
    var vertexVC: vec4<f32>;
    var EyePos: vec3<f32>;
    var EyeDir: vec3<f32>;
    var invertedDepth: f32 = 1.0;
    if (rendererUBO.cameraParallel != 0u) {
      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);
      EyeDir = vec3<f32>(0.0, 0.0, -1.0);
    }
    else {
      EyeDir = input.vertexVC.xyz;
      EyePos = vec3<f32>(0.0,0.0,0.0);
      var lengthED: f32 = length(EyeDir);
      EyeDir = normalize(EyeDir);
      // we adjust the EyePos to be closer if it is too far away
      // to prevent floating point precision noise
      if (lengthED > input.radiusVC*3.0) {
        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;
      }
    }

    // translate to Sphere center
    EyePos = EyePos - input.centerVC;
    // scale to radius 1.0
    EyePos = EyePos * (1.0 / input.radiusVC);
    // find the intersection
    var b: f32 = 2.0*dot(EyePos,EyeDir);
    var c: f32 = dot(EyePos,EyePos) - 1.0;
    var d: f32 = b*b - 4.0*c;
    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);
    if (d < 0.0) { discard; }
    else {
      var t: f32 = (-b - invertedDepth*sqrt(d))*0.5;

      // compute the normal, for unit sphere this is just
      // the intersection point
      normal = invertedDepth*normalize(EyePos + t*EyeDir);
      // compute the intersection point in VC
      vertexVC = vec4<f32>(normal * input.radiusVC + input.centerVC, 1.0);
    }
    // compute the pixel's depth
    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;
    output.fragDepth = pos.z / pos.w;
    `;
    let code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", [sphereFrag]).result;
    fDesc.setCode(code);
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["  output.Position = rendererUBO.VCPCMatrix*vertexVC;"]).result;
    vDesc.setCode(code);
  };
  publicAPI.computePipelineHash = () => {
    model.pipelineHash = "spm";
    if (model.vertexInput.hasAttribute(`colorVI`)) {
      model.pipelineHash += `c`;
    }
    model.pipelineHash += model.renderEncoder.getPipelineHash();
  };
  publicAPI.updateBuffers = () => {
    const poly = model.currentInput;
    model.renderable.mapScalars(poly, 1);
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    publicAPI.setNumberOfInstances(1);
    publicAPI.setNumberOfVertices(3 * numPoints);
    const vertexInput = model.vertexInput;
    let hash = `spm${points.getMTime()}float32x3`;
    if (!model.device.getBufferManager().hasBuffer(hash)) {
      const buffRequest = {
        hash,
        usage: BufferUsage.RawVertex,
        format: "float32x3"
      };
      const tmpVBO = new Float32Array(3 * numPoints * 3);
      let pointIdx = 0;
      let vboIdx = 0;
      for (let id = 0; id < numPoints; ++id) {
        pointIdx = id * 3;
        tmpVBO[vboIdx++] = pointArray[pointIdx];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];
        tmpVBO[vboIdx++] = pointArray[pointIdx];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];
        tmpVBO[vboIdx++] = pointArray[pointIdx];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];
      }
      buffRequest.nativeArray = tmpVBO;
      const buff = model.device.getBufferManager().getBuffer(buffRequest);
      vertexInput.addBuffer(buff, ["vertexBC"]);
    }
    const pointData = poly.getPointData();
    let scales = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    const defaultRadius = model.renderable.getRadius();
    if (scales || defaultRadius !== model._lastRadius) {
      hash = `spm${scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius}float32x2`;
      if (!model.device.getBufferManager().hasBuffer(hash)) {
        const buffRequest = {
          hash,
          usage: BufferUsage.RawVertex,
          format: "float32x2"
        };
        const tmpVBO = new Float32Array(3 * numPoints * 2);
        const cos30 = Math.cos(radiansFromDegrees(30));
        let vboIdx = 0;
        for (let id = 0; id < numPoints; ++id) {
          let radius = model.renderable.getRadius();
          if (scales) {
            radius = scales[id] * model.renderable.getScaleFactor();
          }
          tmpVBO[vboIdx++] = -2 * radius * cos30;
          tmpVBO[vboIdx++] = -radius;
          tmpVBO[vboIdx++] = 2 * radius * cos30;
          tmpVBO[vboIdx++] = -radius;
          tmpVBO[vboIdx++] = 0;
          tmpVBO[vboIdx++] = 2 * radius;
        }
        buffRequest.nativeArray = tmpVBO;
        const buff = model.device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ["offsetMC"]);
      }
      model._lastRadius = defaultRadius;
    }
    let haveColors = false;
    if (model.renderable.getScalarVisibility()) {
      const c2 = model.renderable.getColorMapColors();
      if (c2) {
        hash = `spm${c2.getMTime()}unorm8x4`;
        if (!model.device.getBufferManager().hasBuffer(hash)) {
          const buffRequest = {
            hash,
            usage: BufferUsage.RawVertex,
            format: "unorm8x4"
          };
          const colorComponents = c2.getNumberOfComponents();
          if (colorComponents !== 4) {
            vtkErrorMacro71("this should be 4");
          }
          const tmpVBO = new Uint8ClampedArray(3 * numPoints * 4);
          let vboIdx = 0;
          const colorData = c2.getData();
          for (let id = 0; id < numPoints; ++id) {
            const colorIdx = id * colorComponents;
            for (let v = 0; v < 3; v++) {
              tmpVBO[vboIdx++] = colorData[colorIdx];
              tmpVBO[vboIdx++] = colorData[colorIdx + 1];
              tmpVBO[vboIdx++] = colorData[colorIdx + 2];
              tmpVBO[vboIdx++] = colorData[colorIdx + 3];
            }
          }
          buffRequest.nativeArray = tmpVBO;
          const buff = model.device.getBufferManager().getBuffer(buffRequest);
          vertexInput.addBuffer(buff, ["colorVI"]);
        }
        haveColors = true;
      }
    }
    if (!haveColors) {
      vertexInput.removeBufferIfPresent("colorVI");
    }
    publicAPI.setTopology("triangle-list");
    publicAPI.updateUBO();
  };
}
var DEFAULT_VALUES168 = {};
function extend183(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES168, initialValues);
  vtkWebGPUCellArrayMapper$1.extend(publicAPI, model, initialValues);
  publicAPI.setVertexShaderTemplate(vtkWebGPUSphereMapperVS);
  vtkWebGPUSphereMapper(publicAPI, model);
  const sr = model.shaderReplacements;
  sr.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  sr.set("replaceShaderNormal", publicAPI.replaceShaderNormal);
}
var newInstance176 = newInstance(extend183, "vtkWebGPUSphereMapper");
registerOverride2("vtkSphereMapper", newInstance176);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/StickMapper.js
var {
  BufferUsage: BufferUsage2
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro72
} = macro$1;
var vtkWebGPUStickMapperVS = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::Color::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var offsetsArray: array<vec3<f32>, 12> = array<vec3<f32>, 12>(
    vec3<f32>(-1.0, -1.0, -1.0),
    vec3<f32>(1.0, -1.0, -1.0),
    vec3<f32>(1.0, -1.0, 1.0),

    vec3<f32>(-1.0, -1.0, -1.0),
    vec3<f32>(1.0, -1.0, 1.0),
    vec3<f32>(-1.0, -1.0, 1.0),

    vec3<f32>(-1.0, -1.0, 1.0),
    vec3<f32>(1.0, -1.0, 1.0),
    vec3<f32>(1.0, 1.0, 1.0),

    vec3<f32>(-1.0, -1.0, 1.0),
    vec3<f32>(1.0, 1.0, 1.0),
    vec3<f32>(-1.0, 1.0, 1.0)
  );

  var output : vertexOutput;

  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);

  //VTK::Color::Impl

  // compute the projected vertex position
  output.centerVC = vertexVC.xyz;
  output.radiusVC = radiusMC;
  output.lengthVC = length(orientMC);
  output.orientVC = (rendererUBO.WCVCNormals * vec4<f32>(normalize(orientMC), 0.0)).xyz;

  // make sure it is pointing out of the screen
  if (output.orientVC.z < 0.0)
    {
    output.orientVC = -output.orientVC;
    }

  // make the basis
  var xbase: vec3<f32>;
  var ybase: vec3<f32>;
  var dir: vec3<f32> = vec3<f32>(0.0,0.0,1.0);
  if (rendererUBO.cameraParallel == 0u)
    {
    dir = normalize(-vertexVC.xyz);
    }
  if (abs(dot(dir,output.orientVC)) == 1.0)
    {
    xbase = normalize(cross(vec3<f32>(0.0,1.0,0.0),output.orientVC));
    ybase = cross(xbase,output.orientVC);
    }
  else
    {
    xbase = normalize(cross(output.orientVC,dir));
    ybase = cross(output.orientVC,xbase);
    }


  var vertIdx: u32 = input.vertexIndex % 12u;
  var offsets: vec3<f32> = offsetsArray[vertIdx];

  vertexVC = vec4<f32>(vertexVC.xyz +
    output.radiusVC * offsets.x * xbase +
    output.radiusVC * offsets.y * ybase +
    0.5 * output.lengthVC * offsets.z * output.orientVC, 1.0);

  output.vertexVC = vertexVC;

  //VTK::Position::Impl

  return output;
}
`;
function vtkWebGPUStickMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUStickMapper");
  const cellMapperBuildPass = publicAPI.buildPass;
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      publicAPI.setCellArray(poly.getVerts());
      publicAPI.setCurrentInput(poly);
    }
    cellMapperBuildPass(prepass);
  };
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    if (!vDesc.hasOutput("vertexVC")) vDesc.addOutput("vec4<f32>", "vertexVC");
    vDesc.addOutput("vec3<f32>", "centerVC");
    vDesc.addOutput("vec3<f32>", "orientVC");
    vDesc.addOutput("f32", "radiusVC");
    vDesc.addOutput("f32", "lengthVC");
    vDesc.addBuiltinInput("u32", "@builtin(vertex_index) vertexIndex");
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinOutput("f32", "@builtin(frag_depth) fragDepth");
    const stickFrag = `
    // compute the eye position and unit direction
    var vertexVC: vec4<f32>;
    var EyePos: vec3<f32>;
    var EyeDir: vec3<f32>;

    if (rendererUBO.cameraParallel != 0u)
    {
      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);
      EyeDir = vec3<f32>(0.0, 0.0, -1.0);
    }
    else
    {
      EyeDir = input.vertexVC.xyz;
      EyePos = vec3<f32>(0.0,0.0,0.0);
      var lengthED: f32 = length(EyeDir);
      EyeDir = normalize(EyeDir);
      // we adjust the EyePos to be closer if it is too far away
      // to prevent floating point precision noise
      if (lengthED > input.radiusVC*3.0)
      {
        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;
      }
    }
    // translate to Sphere center
    EyePos = EyePos - input.centerVC;

    // rotate to new basis
    // base1, base2, orientVC
    var base1: vec3<f32>;
    if (abs(input.orientVC.z) < 0.99)
    {
      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,0.0,1.0)));
    }
    else
    {
      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,1.0,0.0)));
    }
    var base2: vec3<f32> = cross(input.orientVC,base1);
    EyePos = vec3<f32>(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,input.orientVC));
    EyeDir = vec3<f32>(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,input.orientVC));

    // scale to radius 1.0
    EyePos = EyePos * (1.0 / input.radiusVC);

    // find the intersection
    var a: f32 = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;
    var b: f32 = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);
    var c: f32 = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;
    var d: f32 = b*b - 4.0*a*c;
    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);
    if (d < 0.0) { discard; }
    else
    {
      var t: f32 = (-b - sqrt(d))*(0.5 / a);
      var tz: f32 = EyePos.z + t*EyeDir.z;
      var iPoint: vec3<f32> = EyePos + t*EyeDir;
      if (abs(iPoint.z)*input.radiusVC > input.lengthVC*0.5)
      {
        // test for end cap
        var t2: f32 = (-b + sqrt(d))*(0.5 / a);
        var tz2: f32 = EyePos.z + t2*EyeDir.z;
        if (tz2*input.radiusVC > input.lengthVC*0.5 || tz*input.radiusVC < -0.5*input.lengthVC) { discard; }
        else
        {
          normal = input.orientVC;
          var t3: f32 = (input.lengthVC*0.5/input.radiusVC - EyePos.z)/EyeDir.z;
          iPoint = EyePos + t3*EyeDir;
          vertexVC = vec4<f32>(input.radiusVC*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*input.orientVC) + input.centerVC, 1.0);
        }
      }
      else
      {
        // The normal is the iPoint.xy rotated back into VC
        normal = iPoint.x*base1 + iPoint.y*base2;
        // rescale rerotate and translate
        vertexVC = vec4<f32>(input.radiusVC*(normal + iPoint.z*input.orientVC) + input.centerVC, 1.0);
      }
    }
    // compute the pixel's depth
    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;
    output.fragDepth = pos.z / pos.w;
  `;
    let code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", [stickFrag]).result;
    fDesc.setCode(code);
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["  output.Position = rendererUBO.VCPCMatrix*vertexVC;"]).result;
    vDesc.setCode(code);
  };
  publicAPI.computePipelineHash = () => {
    model.pipelineHash = "stm";
    if (model.vertexInput.hasAttribute(`colorVI`)) {
      model.pipelineHash += `c`;
    }
    model.pipelineHash += model.renderEncoder.getPipelineHash();
  };
  publicAPI.updateBuffers = () => {
    const poly = model.currentInput;
    model.renderable.mapScalars(poly, 1);
    const device = model.device;
    const points = poly.getPoints();
    const pointData = poly.getPointData();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    publicAPI.setNumberOfInstances(numPoints);
    publicAPI.setNumberOfVertices(12);
    const vertexInput = model.vertexInput;
    let hash = `stm${points.getMTime()}float32x3`;
    if (!device.getBufferManager().hasBuffer(hash)) {
      const buffRequest = {
        hash,
        usage: BufferUsage2.RawVertex,
        format: "float32x3"
      };
      const tmpVBO = new Float32Array(numPoints * 3);
      let pointIdx = 0;
      let vboIdx = 0;
      for (let id = 0; id < numPoints; ++id) {
        pointIdx = id * 3;
        tmpVBO[vboIdx++] = pointArray[pointIdx];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];
        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];
      }
      buffRequest.nativeArray = tmpVBO;
      const buff = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.addBuffer(buff, ["vertexBC"], "instance");
    }
    let scales = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    const defaultRadius = model.renderable.getRadius();
    if (scales || defaultRadius !== model._lastRadius) {
      hash = `stm${scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius}float32`;
      if (!device.getBufferManager().hasBuffer(hash)) {
        const buffRequest = {
          hash,
          usage: BufferUsage2.RawVertex,
          format: "float32"
        };
        const tmpVBO = new Float32Array(numPoints);
        let vboIdx = 0;
        for (let id = 0; id < numPoints; ++id) {
          let radius = model.renderable.getRadius();
          if (scales) {
            radius = scales[id * 2 + 1];
          }
          tmpVBO[vboIdx++] = radius;
        }
        buffRequest.nativeArray = tmpVBO;
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ["radiusMC"], "instance");
      }
      model._lastRadius = defaultRadius;
    }
    let orientationArray = null;
    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {
      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();
    } else {
      vtkErrorMacro72(["Error setting orientationArray.\n", "You have to specify the stick orientation"]);
    }
    hash = `stm${pointData.getArray(model.renderable.getOrientationArray()).getMTime()}float32x3`;
    if (!device.getBufferManager().hasBuffer(hash)) {
      const buffRequest = {
        hash,
        usage: BufferUsage2.RawVertex,
        format: "float32x3"
      };
      const tmpVBO = new Float32Array(numPoints * 3);
      let pointIdx = 0;
      let vboIdx = 0;
      for (let id = 0; id < numPoints; ++id) {
        pointIdx = id * 3;
        let length = model.renderable.getLength();
        if (scales) {
          length = scales[id * 2];
        }
        tmpVBO[vboIdx++] = orientationArray[pointIdx] * length;
        tmpVBO[vboIdx++] = orientationArray[pointIdx + 1] * length;
        tmpVBO[vboIdx++] = orientationArray[pointIdx + 2] * length;
      }
      buffRequest.nativeArray = tmpVBO;
      const buff = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.addBuffer(buff, ["orientMC"], "instance");
    }
    let haveColors = false;
    if (model.renderable.getScalarVisibility()) {
      const c2 = model.renderable.getColorMapColors();
      if (c2) {
        hash = `stm${c2.getMTime()}unorm8x4`;
        if (!device.getBufferManager().hasBuffer(hash)) {
          const buffRequest = {
            usage: BufferUsage2.RawVertex,
            format: "unorm8x4"
          };
          const colorComponents = c2.getNumberOfComponents();
          if (colorComponents !== 4) {
            vtkErrorMacro72("this should be 4");
          }
          const tmpVBO = new Uint8ClampedArray(numPoints * 4);
          let vboIdx = 0;
          const colorData = c2.getData();
          for (let id = 0; id < numPoints; ++id) {
            const colorIdx = id * colorComponents;
            tmpVBO[vboIdx++] = colorData[colorIdx];
            tmpVBO[vboIdx++] = colorData[colorIdx + 1];
            tmpVBO[vboIdx++] = colorData[colorIdx + 2];
            tmpVBO[vboIdx++] = colorData[colorIdx + 3];
          }
          buffRequest.nativeArray = tmpVBO;
          const buff = device.getBufferManager().getBuffer(buffRequest);
          vertexInput.addBuffer(buff, ["colorVI"], "instance");
        }
        haveColors = true;
      }
    }
    if (!haveColors) {
      vertexInput.removeBufferIfPresent("colorVI");
    }
    publicAPI.setTopology("triangle-list");
    publicAPI.updateUBO();
  };
}
var DEFAULT_VALUES169 = {};
function extend184(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES169, initialValues);
  vtkWebGPUCellArrayMapper$1.extend(publicAPI, model, initialValues);
  publicAPI.setVertexShaderTemplate(vtkWebGPUStickMapperVS);
  vtkWebGPUStickMapper(publicAPI, model);
  const sr = model.shaderReplacements;
  sr.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  sr.set("replaceShaderNormal", publicAPI.replaceShaderNormal);
}
var newInstance177 = newInstance(extend184, "vtkWebGPUStickMapper");
registerOverride2("vtkStickMapper", newInstance177);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js
function vtkWebGPUVolume(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolume");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      model.renderable.getMapper().update();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      const bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };
  const idx = new Float64Array(3);
  const vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = (result, offset) => {
    const input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    const extent = input.getExtent();
    const m = model.renderable.getMatrix();
    let count = 0;
    for (let iz = 4; iz < 6; iz++) {
      idx[2] = extent[iz];
      for (let iy = 2; iy < 4; iy++) {
        idx[1] = extent[iy];
        for (let ix = 0; ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          let poffset = offset + count * 3;
          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];
          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];
          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];
          count++;
        }
      }
    }
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      const center = wgpuRen.getStabilizedCenterByReference();
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES170 = {
  propID: void 0,
  keyMatricesTime: null
};
function extend185(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES170, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUVolume(publicAPI, model);
}
var newInstance178 = macro.newInstance(extend185, "vtkWebGPUVolume");
registerOverride2("vtkVolume", newInstance178);

// node_modules/@kitware/vtk.js/Rendering/WebGPU.js
var WebGPU = {
  vtkRenderWindow: vtkRenderWindow2
};

// node_modules/@kitware/vtk.js/Rendering/WebXR/RenderWindowHelper/Constants.js
var XrSessionTypes = {
  HmdVR: 0,
  // Head-mounted display (HMD), two-camera virtual reality session
  MobileAR: 1,
  // Mobile device, single-camera augmented reality session
  LookingGlassVR: 2,
  // Looking Glass hologram display, N-camera virtual reality session
  HmdAR: 3
};
var Constants18 = {
  XrSessionTypes
};

// node_modules/@kitware/vtk.js/Rendering/WebXR/RenderWindowHelper.js
var {
  XrSessionTypes: XrSessionTypes2
} = Constants18;
var DEFAULT_RESET_FACTORS = {
  rescaleFactor: 0.25,
  // isotropic scale factor reduces apparent size of objects
  translateZ: -1.5
  // default translation initializes object in front of camera
};
function createRay() {
  const targetRayLineSource = vtkLineSource$1.newInstance();
  const targetRayMapper = vtkMapper$1.newInstance();
  targetRayMapper.setInputConnection(targetRayLineSource.getOutputPort());
  const targetRayActor = vtkActor$1.newInstance();
  targetRayActor.getProperty().setColor(1, 0, 0);
  targetRayActor.getProperty().setLineWidth(5);
  targetRayActor.setMapper(targetRayMapper);
  targetRayActor.setPickable(false);
  return {
    lineSource: targetRayLineSource,
    mapper: targetRayMapper,
    actor: targetRayActor,
    visible: false
  };
}
function vtkWebXRRenderWindowHelper(publicAPI, model) {
  model.classHierarchy.push("vtkWebXRRenderWindowHelper");
  publicAPI.initialize = (renderWindow) => {
    if (!model.initialized) {
      model.renderWindow = renderWindow;
      model.initialized = true;
    }
  };
  publicAPI.getXrSupported = () => navigator.xr !== void 0;
  publicAPI.startXR = (xrSessionType) => {
    if (navigator.xr === void 0) {
      throw new Error("WebXR is not available");
    }
    model.xrSessionType = xrSessionType !== void 0 ? xrSessionType : XrSessionTypes2.HmdVR;
    const isXrSessionAR = [XrSessionTypes2.HmdAR, XrSessionTypes2.MobileAR].includes(model.xrSessionType);
    const sessionType = isXrSessionAR ? "immersive-ar" : "immersive-vr";
    if (!navigator.xr.isSessionSupported(sessionType)) {
      if (isXrSessionAR) {
        throw new Error("Device does not support AR session");
      } else {
        throw new Error("VR display is not available");
      }
    }
    if (model.xrSession === null) {
      navigator.xr.requestSession(sessionType).then(publicAPI.enterXR, () => {
        throw new Error("Failed to create XR session!");
      });
    } else {
      throw new Error("XR Session already exists!");
    }
  };
  publicAPI.enterXR = async (xrSession) => {
    model.xrSession = xrSession;
    model.initCanvasSize = model.renderWindow.getSize();
    if (model.xrSession !== null) {
      const gl = model.renderWindow.get3DContext();
      await gl.makeXRCompatible();
      const {
        XRWebGLLayer
      } = window;
      const glLayer = new XRWebGLLayer(
        model.xrSession,
        // constructor needs unproxied context
        gl[GET_UNDERLYING_CONTEXT]()
      );
      model.renderWindow.setSize(glLayer.framebufferWidth, glLayer.framebufferHeight);
      model.xrSession.updateRenderState({
        baseLayer: glLayer
      });
      model.xrSession.requestReferenceSpace("local").then((refSpace) => {
        model.xrReferenceSpace = refSpace;
      });
      const isXrSessionAR = [XrSessionTypes2.HmdAR, XrSessionTypes2.MobileAR].includes(model.xrSessionType);
      if (isXrSessionAR) {
        const ren = model.renderWindow.getRenderable().getRenderers()[0];
        model.initBackground = ren.getBackground();
        ren.setBackground([0, 0, 0, 0]);
      }
      publicAPI.resetXRScene();
      model.renderWindow.getRenderable().getInteractor().switchToXRAnimation();
      model.xrSceneFrame = model.xrSession.requestAnimationFrame(model.xrRender);
      publicAPI.modified();
    } else {
      throw new Error("Failed to enter XR with a null xrSession.");
    }
  };
  publicAPI.resetXRScene = function() {
    let rescaleFactor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_RESET_FACTORS.rescaleFactor;
    let translateZ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_RESET_FACTORS.translateZ;
    const ren = model.renderWindow.getRenderable().getRenderers()[0];
    ren.resetCamera();
    const camera = ren.getActiveCamera();
    let physicalScale = camera.getPhysicalScale();
    const physicalTranslation = camera.getPhysicalTranslation();
    const rescaledTranslateZ = translateZ * physicalScale;
    physicalScale /= rescaleFactor;
    physicalTranslation[2] += rescaledTranslateZ;
    camera.setPhysicalScale(physicalScale);
    camera.setPhysicalTranslation(physicalTranslation);
    camera.setClippingRange(0.1 * physicalScale, 100 * physicalScale);
  };
  publicAPI.stopXR = async () => {
    if (navigator.xr === void 0) {
      return;
    }
    if (model.xrSession !== null) {
      model.xrSession.cancelAnimationFrame(model.xrSceneFrame);
      model.renderWindow.getRenderable().getInteractor().returnFromXRAnimation();
      const gl = model.renderWindow.get3DContext();
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      const ren2 = model.renderWindow.getRenderable().getRenderers()[0];
      model.xrSession.inputSources.forEach((inputSource) => {
        if (model.inputSourceToRay[inputSource.handedness]) {
          ren2.removeActor(model.inputSourceToRay[inputSource.handedness].actor);
          model.inputSourceToRay[inputSource.handedness].visible = false;
        }
      });
      await model.xrSession.end().catch((error) => {
        if (!(error instanceof DOMException)) {
          throw error;
        }
      });
      model.xrSession = null;
    }
    if (model.initCanvasSize !== null) {
      model.renderWindow.setSize(...model.initCanvasSize);
    }
    const ren = model.renderWindow.getRenderable().getRenderers()[0];
    if (model.initBackground != null) {
      ren.setBackground(model.initBackground);
      model.initBackground = null;
    }
    ren.getActiveCamera().setProjectionMatrix(null);
    ren.resetCamera();
    ren.setViewport(0, 0, 1, 1);
    model.renderWindow.traverseAllPasses();
    publicAPI.modified();
  };
  model.xrRender = async (t, frame) => {
    const xrSession = frame.session;
    const isXrSessionHMD = [XrSessionTypes2.HmdVR, XrSessionTypes2.HmdAR].includes(model.xrSessionType);
    if (isXrSessionHMD && model.drawControllersRay && model.xrReferenceSpace) {
      const renderer = model.renderWindow.getRenderable().getRenderers()[0];
      const camera = renderer.getActiveCamera();
      const physicalToWorldMatrix = [];
      camera.getPhysicalToWorldMatrix(physicalToWorldMatrix);
      xrSession.inputSources.forEach((inputSource) => {
        if (inputSource.targetRaySpace == null || inputSource.gripSpace == null || inputSource.targetRayMode !== "tracked-pointer") {
          return;
        }
        if (model.inputSourceToRay[inputSource.handedness] == null) {
          model.inputSourceToRay[inputSource.handedness] = createRay();
        }
        const ray = model.inputSourceToRay[inputSource.handedness];
        const targetRayPose = frame.getPose(inputSource.targetRaySpace, model.xrReferenceSpace);
        if (targetRayPose == null) {
          return;
        }
        const targetRayPosition = vec3_exports.fromValues(targetRayPose.transform.position.x, targetRayPose.transform.position.y, targetRayPose.transform.position.z);
        const dir = camera.physicalOrientationToWorldDirection([targetRayPose.transform.orientation.x, targetRayPose.transform.orientation.y, targetRayPose.transform.orientation.z, targetRayPose.transform.orientation.w]);
        const targetRayWorldPosition = vec3_exports.transformMat4([], targetRayPosition, physicalToWorldMatrix);
        const dist = renderer.getActiveCamera().getClippingRange()[1];
        if (!ray.visible) {
          renderer.addActor(ray.actor);
          ray.visible = true;
        }
        ray.lineSource.setPoint1(targetRayWorldPosition[0] - dir[0] * dist, targetRayWorldPosition[1] - dir[1] * dist, targetRayWorldPosition[2] - dir[2] * dist);
        ray.lineSource.setPoint2(...targetRayWorldPosition);
      });
      model.renderWindow.render();
    }
    model.renderWindow.getRenderable().getInteractor().updateXRGamepads(xrSession, frame, model.xrReferenceSpace);
    model.xrSceneFrame = model.xrSession.requestAnimationFrame(model.xrRender);
    const xrPose = frame.getViewerPose(model.xrReferenceSpace);
    if (xrPose) {
      const gl = model.renderWindow.get3DContext();
      if (model.xrSessionType === XrSessionTypes2.MobileAR && model.initCanvasSize !== null) {
        gl.canvas.width = model.initCanvasSize[0];
        gl.canvas.height = model.initCanvasSize[1];
      }
      const glLayer = xrSession.renderState.baseLayer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      model.renderWindow.setSize(glLayer.framebufferWidth, glLayer.framebufferHeight);
      const ren = model.renderWindow.getRenderable().getRenderers()[0];
      xrPose.views.forEach((view, index) => {
        const viewport = glLayer.getViewport(view);
        if (isXrSessionHMD) {
          if (view.eye === "left") {
            ren.setViewport(0, 0, 0.5, 1);
          } else if (view.eye === "right") {
            ren.setViewport(0.5, 0, 1, 1);
          } else {
            return;
          }
        } else if (model.xrSessionType === XrSessionTypes2.LookingGlassVR) {
          const startX = viewport.x / glLayer.framebufferWidth;
          const startY = viewport.y / glLayer.framebufferHeight;
          const endX = (viewport.x + viewport.width) / glLayer.framebufferWidth;
          const endY = (viewport.y + viewport.height) / glLayer.framebufferHeight;
          ren.setViewport(startX, startY, endX, endY);
        } else {
          ren.setViewport(0, 0, 1, 1);
        }
        ren.getActiveCamera().computeViewParametersFromPhysicalMatrix(view.transform.inverse.matrix);
        ren.getActiveCamera().setProjectionMatrix(view.projectionMatrix);
        model.renderWindow.traverseAllPasses();
      });
      gl.scissor(0, 0, glLayer.framebufferWidth, glLayer.framebufferHeight);
      gl.disable(gl.SCISSOR_TEST);
    }
  };
  publicAPI.delete = macro.chain(publicAPI.delete);
}
function defaultValues16() {
  return {
    initialized: false,
    drawControllersRay: false,
    inputSourceToRay: {},
    initCanvasSize: null,
    initBackground: null,
    renderWindow: null,
    xrSession: null,
    xrSessionType: 0,
    xrReferenceSpace: null
  };
}
function extend186(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues16(), initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  macro.get(publicAPI, model, ["xrSession"]);
  macro.setGet(publicAPI, model, ["renderWindow", "drawControllersRay"]);
  vtkWebXRRenderWindowHelper(publicAPI, model);
}
var newInstance179 = macro.newInstance(extend186, "vtkWebXRRenderWindowHelper");
var vtkRenderWindowHelper = {
  newInstance: newInstance179,
  extend: extend186,
  ...Constants18
};

// node_modules/@kitware/vtk.js/Rendering/WebXR.js
var WebXR = {
  vtkRenderWindowHelper
};

// node_modules/@kitware/vtk.js/Rendering/index.js
var Rendering = {
  Core: Core5,
  Misc: Misc3,
  OpenGL,
  SceneGraph,
  WebGPU,
  WebXR
};

// node_modules/@kitware/vtk.js/Proxy/Core/AbstractRepresentationProxy.js
function vtkAbstractRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractRepresentationProxy");
  function updateConnectivity() {
    if (model.input) {
      for (let i = 0; i < model.sourceDependencies.length; ++i) {
        model.sourceDependencies[i].setInputData(model.input.getDataset());
      }
    }
  }
  publicAPI.setInput = (source) => {
    if (model.sourceSubscription) {
      model.sourceSubscription.unsubscribe();
      model.sourceSubscription = null;
    }
    publicAPI.gcPropertyLinks("source");
    model.input = source;
    publicAPI.updateColorByDomain();
    if (model.input) {
      updateConnectivity();
      model.sourceSubscription = model.input.onDatasetChange(updateConnectivity);
    }
    if (model.links) {
      for (let i = 0; i < model.links.length; i++) {
        const {
          link,
          property,
          persistent,
          updateOnBind,
          type
        } = model.links[i];
        if (type === void 0 || type === "source") {
          const sLink = source.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, "source");
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  };
  publicAPI.getInputDataSet = () => model.input ? model.input.getDataset() : null;
  publicAPI.getDataArray = (arrayName, arrayLocation) => {
    const [selectedArray, selectedLocation] = publicAPI.getColorBy();
    const ds = publicAPI.getInputDataSet();
    const fields = ds ? ds.getReferenceByName(arrayLocation || selectedLocation) : null;
    const array = fields ? fields.getArrayByName(arrayName || selectedArray) : null;
    return array;
  };
  publicAPI.getLookupTableProxy = (arrayName) => {
    const arrayNameToUse = arrayName || publicAPI.getColorBy()[0];
    if (arrayNameToUse) {
      return model.proxyManager.getLookupTable(arrayNameToUse);
    }
    return null;
  };
  publicAPI.setLookupTableProxy = () => {
  };
  publicAPI.getPiecewiseFunctionProxy = (arrayName) => {
    const arrayNameToUse = arrayName || publicAPI.getColorBy()[0];
    if (arrayNameToUse) {
      return model.proxyManager.getPiecewiseFunction(arrayNameToUse);
    }
    return null;
  };
  publicAPI.setPiecewiseFunctionProxy = () => {
  };
  publicAPI.rescaleTransferFunctionToDataRange = function(n, l) {
    let c2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    const array = publicAPI.getDataArray(n, l);
    const dataRange = array.getRange(c2);
    model.proxyManager.rescaleTransferFunctionToDataRange(n, dataRange);
  };
  publicAPI.isVisible = () => {
    if (model.actors.length) {
      return model.actors[0].getVisibility();
    }
    if (model.volumes.length) {
      return model.volumes[0].getVisibility();
    }
    return false;
  };
  publicAPI.setVisibility = (visible2) => {
    let change = 0;
    let count = model.actors.length;
    while (count--) {
      change += model.actors[count].setVisibility(visible2);
    }
    count = model.volumes.length;
    while (count--) {
      change += model.volumes[count].setVisibility(visible2);
    }
    if (change) {
      publicAPI.modified();
    }
  };
  publicAPI.setColorBy = function(arrayName, arrayLocation) {
    let componentIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    let colorMode = vtkMapper$1.ColorMode.DEFAULT;
    let scalarMode = vtkMapper$1.ScalarMode.DEFAULT;
    const colorByArrayName = arrayName;
    const activeArray = publicAPI.getDataArray(arrayName, arrayLocation);
    const scalarVisibility = !!activeArray;
    const lookupTable = arrayName ? publicAPI.getLookupTableProxy(arrayName).getLookupTable() : null;
    if (lookupTable) {
      if (componentIndex === -1) {
        lookupTable.setVectorModeToMagnitude();
      } else {
        lookupTable.setVectorModeToComponent();
        lookupTable.setVectorComponent(componentIndex);
      }
    }
    if (scalarVisibility) {
      colorMode = vtkMapper$1.ColorMode.MAP_SCALARS;
      scalarMode = arrayLocation === "pointData" ? vtkMapper$1.ScalarMode.USE_POINT_FIELD_DATA : vtkMapper$1.ScalarMode.USE_CELL_FIELD_DATA;
      if (model.mapper.setLookupTable) {
        model.mapper.setLookupTable(lookupTable);
      }
      if (model.rescaleOnColorBy) {
        publicAPI.rescaleTransferFunctionToDataRange(arrayName, arrayLocation, componentIndex);
      }
    }
    model.mapper.set({
      colorByArrayName,
      colorMode,
      scalarMode,
      scalarVisibility
    }, true);
  };
  publicAPI.getColorBy = () => {
    if (!model.mapper.getColorByArrayName) {
      const ds = publicAPI.getInputDataSet();
      if (ds.getPointData().getScalars()) {
        return [ds.getPointData().getScalars().getName(), "pointData", -1];
      }
      if (ds.getCellData().getScalars()) {
        return [ds.getCellData().getScalars().getName(), "cellData", -1];
      }
      if (ds.getPointData().getNumberOfArrays()) {
        return [ds.getPointData().getArrayByIndex(0).getName(), "pointData", -1];
      }
      if (ds.getCellData().getNumberOfArrays()) {
        return [ds.getCellData().getArrayByIndex(0).getName(), "cellData", -1];
      }
      return [];
    }
    const result = [];
    const {
      colorByArrayName,
      colorMode,
      scalarMode,
      scalarVisibility
    } = model.mapper.get("colorByArrayName", "colorMode", "scalarMode", "scalarVisibility");
    if (scalarVisibility && colorByArrayName) {
      result.push(colorByArrayName);
      result.push(scalarMode === vtkMapper$1.ScalarMode.USE_POINT_FIELD_DATA ? "pointData" : "cellData");
    }
    if (colorMode === vtkMapper$1.ColorMode.MAP_SCALARS && colorByArrayName) {
      const lut = publicAPI.getLookupTableProxy(colorByArrayName).getLookupTable();
      const componentIndex = lut.getVectorMode() === vtkScalarsToColors$1.VectorMode.MAGNITUDE ? -1 : lut.getVectorComponent();
      result.push(componentIndex);
    }
    return result;
  };
  publicAPI.listDataArrays = () => {
    const arrayList = [];
    if (!model.input) {
      return arrayList;
    }
    const dataset = publicAPI.getInputDataSet();
    const pointData = dataset.getPointData();
    let size = pointData.getNumberOfArrays();
    for (let idx = 0; idx < size; idx++) {
      const array = pointData.getArrayByIndex(idx);
      arrayList.push({
        name: array.getName(),
        location: "pointData",
        numberOfComponents: array.getNumberOfComponents(),
        dataRange: array.getRange()
      });
    }
    const cellData = dataset.getCellData();
    size = cellData.getNumberOfArrays();
    for (let idx = 0; idx < size; idx++) {
      const array = cellData.getArrayByIndex(idx);
      arrayList.push({
        name: array.getName(),
        location: "cellData",
        numberOfComponents: array.getNumberOfComponents(),
        dataRange: array.getRange()
      });
    }
    return arrayList;
  };
  publicAPI.updateColorByDomain = () => {
    publicAPI.updateProxyProperty("colorBy", {
      domain: {
        arrays: publicAPI.listDataArrays(),
        solidColor: !model.disableSolidColor
      }
    });
  };
  publicAPI.delete = chain(() => {
    if (model.sourceSubscription) {
      model.sourceSubscription.unsubscribe();
      model.sourceSubscription = null;
    }
  }, publicAPI.delete);
  const nestedProps = [];
  const bbox = [...vtkBoundingBox.INIT_BOUNDS];
  function handleProp(prop) {
    if (prop) {
      vtkBoundingBox.addBounds(bbox, prop.getBounds());
      nestedProps.push(prop);
    }
  }
  publicAPI.getNestedProps = () => nestedProps;
  publicAPI.getBounds = () => {
    if (model.boundMTime < model.mtime) {
      model.boundMTime = model.mtime;
      vtkBoundingBox.reset(bbox);
      nestedProps.length = 0;
      model.actors.forEach(handleProp);
      model.volumes.forEach(handleProp);
    }
    return bbox;
  };
}
var DEFAULT_VALUES171 = {
  boundMTime: 0,
  actors: [],
  volumes: [],
  sourceDependencies: [],
  rescaleOnColorBy: true
};
function extend187(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES171, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  setGet(publicAPI, model, ["rescaleOnColorBy"]);
  get(publicAPI, model, ["input", "mapper", "actors", "volumes"]);
  vtkAbstractRepresentationProxy(publicAPI, model);
  proxy(publicAPI, model);
}
var vtkAbstractRepresentationProxy$1 = {
  extend: extend187
};

// node_modules/@kitware/vtk.js/Proxy/Core/LookupTableProxy/Constants.js
var Mode3 = {
  Preset: 0,
  RGBPoints: 1,
  HSVPoints: 2,
  Nodes: 3
};
var Defaults = {
  Preset: "Cool to Warm",
  RGBPoints: [[0, 0, 0, 0], [1, 1, 1, 1]],
  HSVPoints: [[0, 0, 0, 0], [1, 0, 0, 1]],
  Nodes: [{
    x: 0,
    r: 0,
    g: 0,
    b: 0,
    midpoint: 0.5,
    sharpness: 0
  }, {
    x: 1,
    r: 1,
    g: 1,
    b: 1,
    midpoint: 0.5,
    sharpness: 0
  }]
};
var Constants19 = {
  Defaults,
  Mode: Mode3
};

// node_modules/@kitware/vtk.js/Proxy/Core/LookupTableProxy.js
var {
  Mode: Mode4,
  Defaults: Defaults2
} = Constants19;
function vtkLookupTableProxy(publicAPI, model) {
  model.classHierarchy.push("vtkLookupTableProxy");
  model.lookupTable = model.lookupTable || vtkColorTransferFunction$1.newInstance();
  model.lookupTable.setVectorModeToMagnitude();
  publicAPI.setPresetName = (presetName) => {
    if (model.presetName !== presetName) {
      model.presetName = presetName;
      model.mode = Mode4.Preset;
      publicAPI.applyMode();
    }
  };
  publicAPI.setRGBPoints = (rgbPoints) => {
    if (model.rgbPoints !== rgbPoints) {
      model.rgbPoints = (rgbPoints || Defaults2.RGBPoints).slice();
      publicAPI.applyMode();
    }
  };
  publicAPI.setHSVPoints = (hsvPoints) => {
    if (model.hsvPoints !== hsvPoints) {
      model.hsvPoints = (hsvPoints || Defaults2.HSVPoints).slice();
      publicAPI.applyMode();
    }
  };
  publicAPI.setNodes = (nodes) => {
    if (model.nodes !== nodes) {
      model.nodes = (nodes || Defaults2.Nodes).slice();
      publicAPI.applyMode();
    }
  };
  publicAPI.setMode = (mode) => {
    if (model.mode !== mode) {
      model.mode = mode;
      publicAPI.applyMode();
    }
  };
  publicAPI.applyMode = () => {
    switch (model.mode) {
      case Mode4.Preset:
        {
          const preset = vtkColorMaps4.getPresetByName(model.presetName);
          if (preset) {
            model.lookupTable.applyColorMap(preset);
          }
        }
        break;
      case Mode4.RGBPoints:
        model.lookupTable.removeAllPoints();
        model.rgbPoints.forEach((point) => model.lookupTable.addRGBPointLong(...point));
        break;
      case Mode4.HSVPoints:
        model.lookupTable.removeAllPoints();
        model.hsvPoints.forEach((point) => model.lookupTable.addHSVPointLong(...point));
        break;
      case Mode4.Nodes:
        model.lookupTable.setNodes(model.nodes);
        break;
    }
    model.lookupTable.setMappingRange(model.dataRange[0], model.dataRange[1]);
    model.lookupTable.updateRange();
    publicAPI.modified();
  };
  publicAPI.setDataRange = (min, max2) => {
    if (model.dataRange[0] !== min || model.dataRange[1] !== max2) {
      model.dataRange[0] = min;
      model.dataRange[1] = max2;
      model.lookupTable.setMappingRange(model.dataRange[0], model.dataRange[1]);
      model.lookupTable.updateRange();
      publicAPI.applyMode();
    }
  };
  publicAPI.applyMode();
}
var DEFAULT_VALUES172 = {
  mode: Mode4.Preset,
  presetName: Defaults2.Preset,
  rgbPoints: Defaults2.RGBPoints,
  hsvPoints: Defaults2.HSVPoints,
  nodes: Defaults2.Nodes,
  arrayName: "No array associated",
  arrayLocation: "pointData",
  dataRange: [0, 1]
};
function extend188(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES172, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["arrayName"]);
  macro.get(publicAPI, model, ["mode", "lookupTable", "presetName", "rgbPoints", "hsvPoints", "nodes", "dataRange"]);
  vtkLookupTableProxy(publicAPI, model);
  macro.proxy(publicAPI, model);
}
var newInstance180 = macro.newInstance(extend188, "vtkLookupTableProxy");
var vtkLookupTableProxy$1 = {
  newInstance: newInstance180,
  extend: extend188,
  Mode: Mode4,
  Defaults: Defaults2
};

// node_modules/@kitware/vtk.js/Proxy/Core/PiecewiseFunctionProxy/Constants.js
var Defaults3 = {
  Gaussians: [{
    position: 0.5,
    height: 1,
    width: 0.5,
    xBias: 0.5,
    yBias: 0.5
  }],
  Points: [[0, 0], [1, 1]],
  Nodes: [{
    x: 0,
    y: 0,
    midpoint: 0.5,
    sharpness: 0
  }, {
    x: 1,
    y: 1,
    midpoint: 0.5,
    sharpness: 0
  }]
};
var Mode5 = {
  Gaussians: 0,
  Points: 1,
  Nodes: 2
};
var Constants20 = {
  Defaults: Defaults3,
  Mode: Mode5
};

// node_modules/@kitware/vtk.js/Proxy/Core/PiecewiseFunctionProxy.js
var {
  Mode: Mode6,
  Defaults: Defaults4
} = Constants20;
function applyPointsToPiecewiseFunction(points, range, pwf) {
  const width2 = range[1] - range[0];
  const rescaled = points.map((_ref) => {
    let [x, y] = _ref;
    return [x * width2 + range[0], y];
  });
  pwf.removeAllPoints();
  rescaled.forEach((_ref2) => {
    let [x, y] = _ref2;
    return pwf.addPoint(x, y);
  });
}
function applyNodesToPiecewiseFunction(nodes, range, pwf) {
  const width2 = range[1] - range[0];
  const rescaled = nodes.map((n) => ({
    ...n,
    x: n.x * width2 + range[0]
  }));
  pwf.setNodes(rescaled);
}
function copyGaussians(gaussians) {
  return gaussians.map((g) => ({
    ...g
  }));
}
function vtkPiecewiseFunctionProxy(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseFunctionProxy");
  model.piecewiseFunction = model.piecewiseFunction || vtkPiecewiseFunction$1.newInstance();
  publicAPI.setGaussians = (gaussians) => {
    model.gaussians = copyGaussians(gaussians || []);
    if (model.gaussians.length === 0) {
      model.gaussians = copyGaussians(Defaults4.Gaussians);
    }
    publicAPI.applyMode();
  };
  publicAPI.setPoints = (points) => {
    model.points = (points || []).slice();
    if (model.points.length === 0) {
      model.points = Defaults4.Points.slice();
    }
    publicAPI.applyMode();
  };
  publicAPI.setNodes = (nodes) => {
    model.nodes = (nodes || []).slice();
    if (model.nodes.length === 0) {
      model.nodes = Defaults4.Nodes.slice();
    }
    publicAPI.applyMode();
  };
  publicAPI.setMode = (mode) => {
    if (model.mode === mode) {
      return;
    }
    model.mode = mode;
    publicAPI.applyMode();
  };
  publicAPI.applyMode = () => {
    switch (model.mode) {
      case Mode6.Gaussians:
        vtkPiecewiseGaussianWidget$1.applyGaussianToPiecewiseFunction(model.gaussians, 255, model.dataRange, model.piecewiseFunction);
        publicAPI.modified();
        break;
      case Mode6.Points:
        applyPointsToPiecewiseFunction(model.points, model.dataRange, model.piecewiseFunction);
        publicAPI.modified();
        break;
      case Mode6.Nodes:
        applyNodesToPiecewiseFunction(model.nodes, model.dataRange, model.piecewiseFunction);
        publicAPI.modified();
        break;
    }
  };
  publicAPI.getLookupTableProxy = () => model.proxyManager.getLookupTable(model.arrayName);
  publicAPI.setDataRange = (min, max2) => {
    if (model.dataRange[0] !== min || model.dataRange[1] !== max2) {
      model.dataRange[0] = min;
      model.dataRange[1] = max2;
      publicAPI.applyMode();
    }
  };
  publicAPI.applyMode();
}
var DEFAULT_VALUES173 = {
  mode: Mode6.Gaussians,
  gaussians: Defaults4.Gaussians,
  points: Defaults4.Points,
  nodes: Defaults4.Nodes,
  arrayName: "No array associated",
  arrayLocation: "pointData",
  dataRange: [0, 1]
};
function extend189(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES173, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["arrayName"]);
  macro.get(publicAPI, model, ["piecewiseFunction", "gaussians", "nodes", "points", "mode", "dataRange"]);
  vtkPiecewiseFunctionProxy(publicAPI, model);
  macro.proxy(publicAPI, model);
}
var newInstance181 = macro.newInstance(extend189, "vtkPiecewiseFunctionProxy");
var vtkPiecewiseFunctionProxy$1 = {
  newInstance: newInstance181,
  extend: extend189,
  Mode: Mode6,
  Defaults: Defaults4
};

// node_modules/@kitware/vtk.js/Proxy/Core/ProxyManager/core.js
var {
  vtkErrorMacro: vtkErrorMacro73
} = macro;
function addRegistrationAPI(publicAPI, model) {
  function registerProxy(proxy2) {
    if (!proxy2) {
      return;
    }
    model.proxyIdMapping[proxy2.getProxyId()] = proxy2;
    const group = proxy2.getProxyGroup();
    if (!model.proxyByGroup[group]) {
      model.proxyByGroup[group] = [];
    }
    if (model.proxyByGroup[group].indexOf(proxy2) === -1) {
      model.proxyByGroup[group].push(proxy2);
    }
    proxy2.setProxyManager(publicAPI);
    macro.setImmediate(() => {
      publicAPI.invokeProxyRegistrationChange({
        action: "register",
        proxyId: proxy2.getProxyId(),
        proxyName: proxy2.getProxyName(),
        proxyGroup: proxy2.getProxyGroup(),
        proxy: proxy2
      });
    });
  }
  function unRegisterProxy(proxyOrId) {
    const id = proxyOrId.getProxyId ? proxyOrId.getProxyId() : proxyOrId;
    const proxy2 = model.proxyIdMapping[id];
    Object.keys(model.proxyByGroup).forEach((groupName) => {
      const proxyList = model.proxyByGroup[groupName];
      const index = proxyList.indexOf(proxy2);
      if (index !== -1) {
        proxyList.splice(index, 1);
      }
    });
    delete model.proxyIdMapping[id];
    proxy2.gcPropertyLinks("application");
    proxy2.gcPropertyLinks("source");
    proxy2.setProxyManager(null);
    publicAPI.invokeProxyRegistrationChange({
      action: "unregister",
      proxyId: id,
      proxyName: proxy2.getProxyName(),
      proxyGroup: proxy2.getProxyGroup(),
      proxy: proxy2
    });
    return proxy2;
  }
  publicAPI.setActiveSource = (source) => {
    if (model.activeSource !== source) {
      if (model.activeSourceSubscription) {
        model.activeSourceSubscription.unsubscribe();
        model.activeSourceSubscription = null;
      }
      model.activeSource = source;
      if (source) {
        model.activeSourceSubscription = source.onModified(publicAPI.modified);
      }
      publicAPI.modified();
      publicAPI.invokeActiveSourceChange(source);
    }
  };
  publicAPI.setActiveView = (view) => {
    if (model.activeView !== view) {
      if (model.activeViewSubscription) {
        model.activeViewSubscription.unsubscribe();
        model.activeViewSubscription = null;
      }
      model.activeView = view;
      if (view) {
        model.activeViewSubscription = view.onModified(publicAPI.modified);
      }
      publicAPI.modified();
      publicAPI.invokeActiveViewChange(view);
    }
  };
  publicAPI.getProxyById = (id) => model.proxyIdMapping[id];
  publicAPI.getProxyGroups = () => Object.keys(model.proxyByGroup);
  publicAPI.getProxyInGroup = (name2) => [].concat(model.proxyByGroup[name2] || []);
  publicAPI.getSources = () => [].concat(model.proxyByGroup.Sources || []);
  publicAPI.getRepresentations = () => [].concat(model.proxyByGroup.Representations || []);
  publicAPI.getViews = () => [].concat(model.proxyByGroup.Views || []);
  publicAPI.createProxy = (group, name2, options) => {
    const {
      definitions
    } = model.proxyConfiguration;
    if (!definitions[group] || !definitions[group][name2]) {
      return null;
    }
    const definition = definitions[group][name2];
    const definitionOptions = {
      ...definition.options,
      ...options
    };
    const proxy2 = definition.class.newInstance({
      ...definitionOptions,
      proxyGroup: group,
      proxyName: name2,
      proxyManager: publicAPI
    });
    if (definition.proxyProps) {
      const proxyMap = {};
      Object.keys(definition.proxyProps).forEach((key) => {
        const newProxyDef = definition.proxyProps[key];
        proxyMap[key] = publicAPI.createProxy(newProxyDef.group, newProxyDef.name, newProxyDef.options);
      });
      proxy2.set(proxyMap);
    }
    if (definition.props) {
      proxy2.set(definition.props);
    }
    registerProxy(proxy2);
    if (definitionOptions.activateOnCreate) {
      proxy2.activate();
    }
    return proxy2;
  };
  publicAPI.getRepresentation = (source, view) => {
    const sourceToUse = source || publicAPI.getActiveSource();
    const viewToUse = view || publicAPI.getActiveView();
    if (!sourceToUse || !viewToUse || !sourceToUse.getType()) {
      return null;
    }
    const sourceId = sourceToUse.getProxyId();
    const viewId = viewToUse.getProxyId();
    let viewRepMap = model.sv2rMapping[sourceId];
    if (!viewRepMap) {
      viewRepMap = {};
      model.sv2rMapping[sourceId] = viewRepMap;
    }
    let rep = viewRepMap[viewId];
    if (!rep) {
      const viewName = viewToUse.getProxyName();
      const sourceType = sourceToUse.getType();
      const definition = model.proxyConfiguration.representations[viewName][sourceType];
      if (!definition) {
        vtkErrorMacro73(`No definition for representation of ${sourceType} in view ${viewName}`);
        return null;
      }
      rep = publicAPI.createProxy("Representations", definition.name, definition.options);
      model.r2svMapping[rep.getProxyId()] = {
        sourceId,
        viewId
      };
      viewRepMap[viewId] = rep;
      rep.setInput(sourceToUse);
      viewToUse.addRepresentation(rep);
    }
    return rep;
  };
  publicAPI.deleteProxy = (proxy2) => {
    const group = proxy2.getProxyGroup().toLowerCase();
    if (group === "views") {
      proxy2.getRepresentations().forEach((repProxy) => {
        publicAPI.deleteProxy(repProxy);
      });
      proxy2.setContainer(null);
      unRegisterProxy(proxy2);
      if (publicAPI.getActiveView() === proxy2) {
        publicAPI.setActiveView(publicAPI.getViews()[0]);
      }
    } else if (group === "representations") {
      const {
        sourceId,
        viewId
      } = model.r2svMapping[proxy2.getProxyId()];
      const view = publicAPI.getProxyById(viewId);
      view.removeRepresentation(proxy2);
      delete model.r2svMapping[proxy2.getProxyId()];
      delete model.sv2rMapping[sourceId][viewId];
      unRegisterProxy(proxy2);
    } else if (group === "sources") {
      const viewToRep = model.sv2rMapping[proxy2.getProxyId()];
      Object.keys(viewToRep).forEach((viewId) => {
        publicAPI.deleteProxy(viewToRep[viewId]);
      });
      unRegisterProxy(proxy2);
      if (publicAPI.getActiveSource() === proxy2) {
        publicAPI.setActiveSource(publicAPI.getSources()[0]);
      }
    } else {
      unRegisterProxy(proxy2);
    }
    proxy2.delete();
  };
}

// node_modules/@kitware/vtk.js/Proxy/Core/ProxyManager/state.js
function getProperties(proxy2) {
  const props = {};
  proxy2.listPropertyNames().forEach((name2) => {
    props[name2] = proxy2.getPropertyByName(name2).value;
  });
  return props;
}
function addStateAPI(publicAPI, model) {
  publicAPI.loadState = function(state) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new Promise((resolve, reject) => {
      const proxyMapping = {};
      const $oldToNewIdMapping = {};
      const cameras = {};
      const datasetHandler = options.datasetHandler || vtk;
      const sourcePromises = [];
      state.sources.forEach((_ref) => {
        let {
          id,
          group,
          name: name2,
          props
        } = _ref;
        sourcePromises.push(Promise.resolve(datasetHandler(props.dataset)).then((dataset) => {
          if (dataset) {
            const proxy2 = publicAPI.createProxy(group, name2);
            proxy2.setName(props.name);
            proxy2.setInputData(dataset, props.type);
            proxyMapping[id] = proxy2;
            return proxy2;
          }
          return null;
        }));
      });
      Promise.all(sourcePromises).then(() => {
        const views = publicAPI.getViews();
        state.views.forEach((_ref2) => {
          let {
            id,
            group,
            name: name2,
            props,
            camera
          } = _ref2;
          let proxy2 = null;
          if (state.options.recycleViews) {
            proxy2 = views.find((v) => v.getProxyGroup() === group && v.getProxyName() === name2 && v.getName() === props.name);
          }
          if (!proxy2) {
            proxy2 = publicAPI.createProxy(group, name2, {
              disableAnimation: true
            });
          } else {
            proxy2.setDisableAnimation(true);
          }
          proxy2.set(props, true);
          proxyMapping[id] = proxy2;
          cameras[id] = camera;
        });
        function updateView(view) {
          if (!proxyMapping[view] || !cameras[view]) {
            return;
          }
          proxyMapping[view].resetOrientation().then(() => {
            proxyMapping[view].getCamera().set(cameras[view]);
            proxyMapping[view].getRenderer().updateLightsGeometryToFollowCamera();
            proxyMapping[view].renderLater();
          });
        }
        state.representations.forEach((_ref3) => {
          let {
            source,
            view,
            props
          } = _ref3;
          const proxy2 = publicAPI.getRepresentation(proxyMapping[source], proxyMapping[view]);
          proxy2.set(props, true);
          updateView(view);
        });
        Object.keys(state.fields).forEach((fieldName) => {
          const {
            lookupTable,
            piecewiseFunction
          } = state.fields[fieldName];
          const lutProxy = publicAPI.getLookupTable(fieldName, lookupTable);
          lutProxy.setPresetName(lookupTable.presetName);
          lutProxy.setDataRange(...lookupTable.dataRange);
          const pwfProxy = publicAPI.getPiecewiseFunction(fieldName, piecewiseFunction);
          switch (piecewiseFunction.mode) {
            case vtkPiecewiseFunctionProxy$1.Mode.Gaussians:
              pwfProxy.setGaussians(piecewiseFunction.gaussians);
              break;
            case vtkPiecewiseFunctionProxy$1.Mode.Points:
              pwfProxy.setPoints(piecewiseFunction.points);
              break;
            case vtkPiecewiseFunctionProxy$1.Mode.Nodes:
              pwfProxy.setNodes(piecewiseFunction.nodes);
              break;
          }
          pwfProxy.setMode(piecewiseFunction.mode);
          pwfProxy.setDataRange(...piecewiseFunction.dataRange);
        });
        Object.keys(cameras).forEach(updateView);
        Object.keys(proxyMapping).forEach((originalId) => {
          const newId = proxyMapping[originalId].getProxyId();
          $oldToNewIdMapping[originalId] = newId;
        });
        state.views.forEach((_ref4) => {
          let {
            id
          } = _ref4;
          proxyMapping[id].setDisableAnimation(false);
        });
        resolve({
          ...state.userData,
          $oldToNewIdMapping
        });
      }).catch(reject);
    });
  };
  publicAPI.saveState = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let userData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new Promise((resolve, reject) => {
      const sources = publicAPI.getSources();
      const views = publicAPI.getViews();
      const datasetHandler = options.datasetHandler || ((d2) => d2.getState());
      delete options.datasetHandler;
      const datasets = [];
      const fieldNames = /* @__PURE__ */ new Set();
      const state = {
        userData,
        options,
        sources: [],
        views: [],
        representations: [],
        fields: {}
      };
      sources.forEach((source) => {
        const dataset = Promise.resolve(datasetHandler(source.getDataset(), source));
        datasets.push(dataset);
        state.sources.push({
          id: source.getProxyId(),
          group: source.getProxyGroup(),
          name: source.getProxyName(),
          props: {
            name: source.getName(),
            type: source.getType(),
            dataset
          }
        });
      });
      views.forEach((view) => {
        const camera = view.getCamera().get("position", "viewUp", "focalPoint");
        state.views.push({
          id: view.getProxyId(),
          group: view.getProxyGroup(),
          name: view.getProxyName(),
          props: Object.assign(getProperties(view), view.get("axis", "orientation", "viewUp")),
          camera
        });
        const representations = view.getRepresentations();
        representations.forEach((representation) => {
          state.representations.push({
            source: representation.getInput().getProxyId(),
            view: view.getProxyId(),
            props: getProperties(representation)
          });
          fieldNames.add(representation.getColorBy()[0]);
        });
      });
      fieldNames.forEach((fieldName) => {
        state.fields[fieldName] = {
          lookupTable: publicAPI.getLookupTable(fieldName).get("mode", "presetName", "rgbPoints", "hsvPoints", "nodes", "arrayName", "arrayLocation", "dataRange"),
          piecewiseFunction: publicAPI.getPiecewiseFunction(fieldName).get("mode", "gaussians", "points", "nodes", "arrayName", "arrayLocation", "dataRange")
        };
      });
      Promise.all(datasets).then(() => {
        for (let i = 0; i < state.sources.length; i++) {
          state.sources[i].props.dataset.then((value) => {
            state.sources[i].props.dataset = value;
          });
        }
        resolve(state);
      }).catch(reject);
    });
  };
}

// node_modules/@kitware/vtk.js/Proxy/Core/ProxyManager/view.js
function addViewHandlingAPI(publicAPI, model) {
  publicAPI.create3DView = (options) => publicAPI.createProxy("Views", "View3D", options);
  publicAPI.create2DView = (options) => publicAPI.createProxy("Views", "View2D", options);
  publicAPI.render = (view) => {
    const viewToRender = view || publicAPI.getActiveView();
    if (viewToRender) {
      viewToRender.renderLater();
    }
  };
  publicAPI.renderAllViews = function() {
    let blocking = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const allViews = publicAPI.getViews();
    for (let i = 0; i < allViews.length; i++) {
      allViews[i].render(blocking);
    }
  };
  publicAPI.setAnimationOnAllViews = function() {
    let enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const allViews = publicAPI.getViews().filter((v) => !enable || v.getContainer());
    for (let i = 0; i < allViews.length; i++) {
      allViews[i].setAnimation(enable, publicAPI);
    }
  };
  function clearAnimations() {
    model.animating = false;
    const allViews = publicAPI.getViews();
    for (let i = 0; i < allViews.length; i++) {
      allViews[i].setAnimation(false, publicAPI);
    }
  }
  publicAPI.autoAnimateViews = function() {
    let debouceTimout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
    if (!model.animating) {
      model.animating = true;
      const allViews = publicAPI.getViews().filter((v) => v.getContainer());
      for (let i = 0; i < allViews.length; i++) {
        allViews[i].setAnimation(true, publicAPI);
      }
      model.clearAnimations = macro.debounce(clearAnimations, debouceTimout);
    }
    model.clearAnimations();
  };
  publicAPI.resizeAllViews = () => {
    const allViews = publicAPI.getViews();
    for (let i = 0; i < allViews.length; i++) {
      allViews[i].resize();
    }
  };
  publicAPI.resetCamera = (view) => {
    const viewToRender = view || publicAPI.getActiveView();
    if (viewToRender && viewToRender.resetCamera) {
      viewToRender.resetCamera();
    }
  };
  publicAPI.createRepresentationInAllViews = (source) => {
    const allViews = publicAPI.getViews();
    for (let i = 0; i < allViews.length; i++) {
      publicAPI.getRepresentation(source, allViews[i]);
    }
  };
  publicAPI.resetCameraInAllViews = () => {
    const allViews = publicAPI.getViews();
    for (let i = 0; i < allViews.length; i++) {
      allViews[i].resetCamera();
    }
  };
}

// node_modules/@kitware/vtk.js/Proxy/Core/ProxyManager/properties.js
function addVPropertyHandlingAPI(publicAPI, model) {
  publicAPI.getSections = () => {
    const sections = [];
    const source = publicAPI.getActiveSource();
    if (!source) {
      return [];
    }
    const view = publicAPI.getActiveView();
    if (source) {
      const section = source.getProxySection();
      if (section.ui.length) {
        sections.push(Object.assign(section, {
          collapsed: model.collapseState[section.name]
        }));
      }
    }
    if (source && view) {
      const representation = publicAPI.getRepresentation(source, view);
      if (representation) {
        const section = representation.getProxySection();
        if (section.ui.length) {
          sections.push(Object.assign(section, {
            collapsed: model.collapseState[section.name]
          }));
        }
      }
    }
    if (view) {
      const section = view.getProxySection();
      if (section.ui.length) {
        sections.push(Object.assign(section, {
          collapsed: model.collapseState[section.name]
        }));
      }
    }
    return sections;
  };
  publicAPI.updateCollapseState = (name2, state) => {
    model.collapseState[name2] = state;
    publicAPI.modified();
  };
  publicAPI.applyChanges = (changeSet) => {
    const groupBy = {};
    const keys = Object.keys(changeSet);
    let count = keys.length;
    while (count--) {
      const key = keys[count];
      const [id, prop] = key.split(":");
      if (!groupBy[id]) {
        groupBy[id] = {};
      }
      if (changeSet[key] === "__command_execute__") {
        const obj2 = publicAPI.getProxyById(id);
        if (obj2) {
          obj2[prop]();
        }
      } else {
        groupBy[id][prop] = changeSet[key];
      }
    }
    const objIds = Object.keys(groupBy);
    count = objIds.length;
    while (count--) {
      const id = objIds[count];
      const obj2 = publicAPI.getProxyById(id);
      if (obj2) {
        obj2.set(groupBy[id]);
      }
    }
    publicAPI.modified();
    publicAPI.renderAllViews();
  };
  publicAPI.getLookupTable = (arrayName, options) => {
    if (!model.lookupTables[arrayName]) {
      model.lookupTables[arrayName] = publicAPI.createProxy("Proxy", "LookupTable", {
        arrayName,
        ...options
      });
    }
    return model.lookupTables[arrayName];
  };
  publicAPI.getPiecewiseFunction = (arrayName, options) => {
    if (!model.piecewiseFunctions[arrayName]) {
      model.piecewiseFunctions[arrayName] = publicAPI.createProxy("Proxy", "PiecewiseFunction", {
        arrayName,
        ...options
      });
    }
    return model.piecewiseFunctions[arrayName];
  };
  publicAPI.rescaleTransferFunctionToDataRange = (arrayName, dataRange) => {
    const lut = publicAPI.getLookupTable(arrayName);
    const pwf = publicAPI.getPiecewiseFunction(arrayName);
    lut.setDataRange(dataRange[0], dataRange[1]);
    pwf.setDataRange(dataRange[0], dataRange[1]);
  };
}

// node_modules/@kitware/vtk.js/Proxy/Core/ProxyManager.js
function extend190(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, {
    proxyIdMapping: {},
    proxyByGroup: {},
    proxyConfiguration: {},
    // { definitions: {}, representations: { viewName: { sourceType: representationName } } }
    sv2rMapping: {},
    // sv2rMapping[sourceId][viewId] = rep
    r2svMapping: {},
    // r2svMapping[representationId] = { sourceId, viewId }
    collapseState: {},
    lookupTables: {},
    piecewiseFunctions: {},
    animating: false
  }, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["proxyConfiguration", "activeSource", "activeView"]);
  macro.event(publicAPI, model, "ActiveSourceChange");
  macro.event(publicAPI, model, "ActiveViewChange");
  macro.event(publicAPI, model, "ProxyRegistrationChange");
  addRegistrationAPI(publicAPI, model);
  addStateAPI(publicAPI);
  addViewHandlingAPI(publicAPI, model);
  addVPropertyHandlingAPI(publicAPI, model);
  macro.proxy(publicAPI, model);
  model.classHierarchy.push("vtkProxyManager");
}
var newInstance182 = macro.newInstance(extend190, "vtkProxyManager");
var vtkProxyManager = {
  newInstance: newInstance182,
  extend: extend190
};

// node_modules/@kitware/vtk.js/Proxy/Core/SourceProxy.js
function vtkSourceProxy(publicAPI, model) {
  model.classHierarchy.push("vtkSourceProxy");
  publicAPI.setInputProxy = (source) => {
    if (model.inputSubscription) {
      model.inputSubscription();
      model.inputSubscription = null;
    }
    model.inputProxy = source;
    if (model.inputProxy) {
      model.inputSubscription = source.onModified(publicAPI.update, -1).unsubscribe;
    }
    publicAPI.update();
  };
  publicAPI.setInputData = (ds, type) => {
    if (model.dataset !== ds) {
      model.dataset = ds;
      model.type = type || ds.getClassName();
      publicAPI.modified();
      publicAPI.invokeDatasetChange();
    }
  };
  publicAPI.setInputAlgorithm = function(algo2, type) {
    let autoUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    model.type = type;
    if (model.algo !== algo2) {
      model.algo = algo2;
      if (model.algoSubscription) {
        model.algoSubscription();
        model.algoSubscription = null;
      }
      if (algo2 && autoUpdate) {
        model.algoSubscription = algo2.onModified(() => {
          publicAPI.update();
        }, -1).unsubscribe;
        publicAPI.update();
      }
    }
  };
  publicAPI.update = () => {
    if (model.algo && model.inputProxy) {
      model.algo.setInputData(model.inputProxy.getDataset());
    }
    if (model.updateDomain && model.inputProxy) {
      model.updateDomain(publicAPI, model.inputProxy.getDataset());
    }
    if (model.algo) {
      publicAPI.setInputData(model.algo.getOutputData(), model.type);
    }
  };
  publicAPI.getUpdate = () => model.algo.getMTime() > model.dataset.getMTime();
  publicAPI.delete = macro.chain(() => {
    if (model.algoSubscription) {
      model.algoSubscription();
      model.algoSubscription = null;
    }
    if (model.inputSubscription) {
      model.inputSubscription();
      model.inputSubscription = null;
    }
  }, publicAPI.delete);
  if (model.inputProxy) {
    model.inputSubscription = model.inputProxy.onModified(() => {
      publicAPI.update();
    }, -1).unsubscribe;
  }
  if (model.algoFactory) {
    publicAPI.setInputAlgorithm(model.algoFactory.newInstance(), null, model.autoUpdate);
  }
  publicAPI.update();
}
var DEFAULT_VALUES174 = {
  name: "Default source"
};
function extend191(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES174, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["name", "type", "dataset", "algo", "inputProxy"]);
  macro.set(publicAPI, model, ["name"]);
  macro.event(publicAPI, model, "DatasetChange");
  macro.proxy(publicAPI, model);
  vtkSourceProxy(publicAPI, model);
  if (model.proxyPropertyMapping) {
    macro.proxyPropertyMapping(publicAPI, model, model.proxyPropertyMapping);
  }
}
var newInstance183 = macro.newInstance(extend191, "vtkSourceProxy");
var vtkSourceProxy$1 = {
  newInstance: newInstance183,
  extend: extend191
};

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleManipulator/Presets.js
var MANIPULTOR_TYPES = {
  slice: Manipulators.vtkMouseCameraSliceManipulator,
  multiRotate: Manipulators.vtkMouseCameraTrackballMultiRotateManipulator,
  pan: Manipulators.vtkMouseCameraTrackballPanManipulator,
  roll: Manipulators.vtkMouseCameraTrackballRollManipulator,
  rotate: Manipulators.vtkMouseCameraTrackballRotateManipulator,
  axisRotate: Manipulators.vtkMouseCameraAxisRotateManipulator,
  zoom: Manipulators.vtkMouseCameraTrackballZoomManipulator,
  zoomToMouse: Manipulators.vtkMouseCameraTrackballZoomToMouseManipulator,
  range: Manipulators.vtkMouseRangeManipulator,
  vrPan: Manipulators.vtkVRButtonPanManipulator,
  gestureCamera: Manipulators.vtkGestureCameraManipulator,
  movement: Manipulators.vtkKeyboardCameraManipulator,
  freeLook: Manipulators.vtkMouseCameraTrackballFirstPersonManipulator,
  unicam: Manipulators.vtkMouseCameraUnicamManipulator,
  unicamRotate: Manipulators.vtkMouseCameraUnicamRotateManipulator
};
var STYLES2 = {
  "3D": [{
    type: "rotate"
  }, {
    type: "pan",
    options: {
      shift: true
    }
  }, {
    type: "zoom",
    options: {
      control: true
    }
  }, {
    type: "zoom",
    options: {
      alt: true
    }
  }, {
    type: "zoom",
    options: {
      dragEnabled: false,
      scrollEnabled: true
    }
  }, {
    type: "zoom",
    options: {
      button: 3
    }
  }, {
    type: "roll",
    options: {
      shift: true,
      control: true
    }
  }, {
    type: "roll",
    options: {
      shift: true,
      alt: true
    }
  }, {
    type: "roll",
    options: {
      shift: true,
      button: 3
    }
  }, {
    type: "vrPan"
  }, {
    type: "gestureCamera"
  }],
  "2D": [{
    type: "pan",
    options: {
      shift: true
    }
  }, {
    type: "zoom",
    options: {
      control: true
    }
  }, {
    type: "zoom",
    options: {
      alt: true
    }
  }, {
    type: "zoom",
    options: {
      button: 3
    }
  }, {
    type: "roll",
    options: {
      shift: true,
      alt: true
    }
  }, {
    type: "roll",
    options: {
      shift: true,
      button: 3
    }
  }, {
    type: "roll",
    options: {
      shift: true
    }
  }, {
    type: "vrPan"
  }, {
    type: "gestureCamera"
  }],
  FirstPerson: [{
    type: "movement"
  }, {
    type: "freeLook"
  }],
  Unicam: [{
    type: "unicam"
  }],
  zRotateTop: [{
    type: "pan",
    options: {
      shift: true
    }
  }, {
    type: "axisRotate",
    options: {
      rotationAxis: [0, 0, 1],
      useHalfAxis: true
    }
  }, {
    type: "zoom",
    options: {
      control: true
    }
  }, {
    type: "zoom",
    options: {
      alt: true
    }
  }, {
    type: "zoom",
    options: {
      dragEnabled: false,
      scrollEnabled: true
    }
  }, {
    type: "zoom",
    options: {
      button: 3
    }
  }],
  zRotateAll: [{
    type: "pan",
    options: {
      shift: true
    }
  }, {
    type: "axisRotate",
    options: {
      rotationAxis: [0, 0, 1],
      useHalfAxis: false
    }
  }, {
    type: "zoom",
    options: {
      control: true
    }
  }, {
    type: "zoom",
    options: {
      alt: true
    }
  }, {
    type: "zoom",
    options: {
      dragEnabled: false,
      scrollEnabled: true
    }
  }, {
    type: "zoom",
    options: {
      button: 3
    }
  }]
};
function applyDefinitions2(definitions, manipulatorStyle) {
  manipulatorStyle.removeAllManipulators();
  for (let idx = 0; idx < definitions.length; idx++) {
    const definition = definitions[idx];
    const instance = MANIPULTOR_TYPES[definition.type].newInstance(definition.options);
    if (instance.isA("vtkCompositeVRManipulator")) {
      manipulatorStyle.addVRManipulator(instance);
    } else if (instance.isA("vtkCompositeGestureManipulator")) {
      manipulatorStyle.addGestureManipulator(instance);
    } else if (instance.isA("vtkCompositeKeyboardManipulator")) {
      manipulatorStyle.addKeyboardManipulator(instance);
    } else {
      manipulatorStyle.addMouseManipulator(instance);
    }
  }
  return true;
}
function applyPreset2(name2, manipulatorStyle) {
  return applyDefinitions2(STYLES2[name2], manipulatorStyle);
}
function registerManipulatorType(type, classDef) {
  MANIPULTOR_TYPES[type] = classDef;
}
function registerStylePreset2(name2, definitions) {
  STYLES2[name2] = definitions;
}
var InteractionPresets = {
  applyDefinitions: applyDefinitions2,
  applyPreset: applyPreset2,
  registerManipulatorType,
  registerStylePreset: registerStylePreset2
};

// node_modules/@kitware/vtk.js/Proxy/Core/ViewProxy.js
var EPSILON4 = 1e-6;
function vtkViewProxy(publicAPI, model) {
  model.classHierarchy.push("vtkViewProxy");
  function updateAnnotationColor() {
    const [r, g, b2] = model.renderer.getBackground();
    model.cornerAnnotation.getAnnotationContainer().style.color = r + g + b2 > 1.5 ? "black" : "white";
  }
  model.renderWindow = vtkRenderWindow$1.newInstance();
  model.renderer = vtkRenderer$1.newInstance({
    background: [0, 0, 0]
  });
  model.renderWindow.addRenderer(model.renderer);
  model._openGLRenderWindow = model.renderWindow.newAPISpecificView();
  model.renderWindow.addView(model._openGLRenderWindow);
  model.interactor = vtkRenderWindowInteractor$1.newInstance();
  model.interactor.setView(model._openGLRenderWindow);
  model.interactorStyle3D = vtkInteractorStyleManipulator$1.newInstance();
  model.interactorStyle2D = vtkInteractorStyleManipulator$1.newInstance();
  model._resetCamera = function() {
    let bounds2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return model.renderer.resetCamera(bounds2);
  };
  InteractionPresets.applyPreset("3D", model.interactorStyle3D);
  InteractionPresets.applyPreset("2D", model.interactorStyle2D);
  model.cornerAnnotation = vtkCornerAnnotation$1.newInstance();
  model.interactor.setInteractorStyle(model.useParallelRendering ? model.interactorStyle2D : model.interactorStyle3D);
  model.camera = model.renderer.getActiveCamera();
  model.camera.setParallelProjection(!!model.useParallelRendering);
  model.orientationAxesArrow = vtkAxesActor$1.newInstance();
  model.orientationAxesCube = vtkAnnotatedCubeActor$1.newInstance();
  AnnotatedCubePresets.applyPreset("default", model.orientationAxesCube);
  AnnotatedCubePresets.applyPreset("lps", model.orientationAxesCube);
  model.orientationAxesMap = {
    arrow: model.orientationAxesArrow,
    cube: model.orientationAxesCube
  };
  model.orientationWidget = vtkOrientationMarkerWidget$1.newInstance({
    actor: model.orientationAxesArrow,
    interactor: model.renderWindow.getInteractor()
  });
  model.orientationWidget.setEnabled(true);
  model.orientationWidget.setViewportCorner(vtkOrientationMarkerWidget$1.Corners.BOTTOM_LEFT);
  model.orientationWidget.setViewportSize(0.1);
  publicAPI.setPresetToInteractor3D = (nameOrDefinitions) => {
    if (Array.isArray(nameOrDefinitions)) {
      return InteractionPresets.applyDefinitions(nameOrDefinitions, model.interactorStyle3D);
    }
    return InteractionPresets.applyPreset(nameOrDefinitions, model.interactorStyle3D);
  };
  publicAPI.setPresetToInteractor2D = (nameOrDefinitions) => {
    if (Array.isArray(nameOrDefinitions)) {
      return InteractionPresets.applyDefinitions(nameOrDefinitions, model.interactorStyle2D);
    }
    return InteractionPresets.applyPreset(nameOrDefinitions, model.interactorStyle2D);
  };
  publicAPI.setOrientationAxesType = (type) => {
    const actor = model.orientationAxesMap[type];
    if (actor) {
      model.orientationAxesType = type;
      model.orientationWidget.setActor(actor);
      publicAPI.renderLater();
    }
  };
  publicAPI.registerOrientationAxis = (name2, actor) => {
    model.orientationAxesMap[name2] = actor;
  };
  publicAPI.unregisterOrientationAxis = (name2) => {
    delete model.orientationAxesMap[name2];
  };
  publicAPI.listOrientationAxis = () => Object.keys(model.orientationAxesMap);
  publicAPI.setPresetToOrientationAxes = (nameOrDefinitions) => {
    let changeDetected = false;
    if (typeof nameOrDefinitions === "string") {
      if (model.presetToOrientationAxes !== nameOrDefinitions) {
        model.presetToOrientationAxes = nameOrDefinitions;
        changeDetected = AnnotatedCubePresets.applyPreset(nameOrDefinitions, model.orientationAxesCube);
        publicAPI.modified();
      }
      return changeDetected;
    }
    model.presetToOrientationAxes = "Custom";
    changeDetected = AnnotatedCubePresets.applyDefinitions(nameOrDefinitions, model.orientationAxesCube);
    publicAPI.modified();
    return changeDetected;
  };
  publicAPI.setContainer = (container) => {
    const orientationWidgetEnabled = model.orientationWidget.getEnabled();
    if (model.container) {
      model.orientationWidget.setEnabled(false);
      model.interactor.unbindEvents(model.container);
      model._openGLRenderWindow.setContainer(null);
      model.cornerAnnotation.setContainer(null);
    }
    model.container = container;
    if (container) {
      model._openGLRenderWindow.setContainer(container);
      model.cornerAnnotation.setContainer(container);
      model.interactor.initialize();
      model.interactor.bindEvents(container);
      model.orientationWidget.setEnabled(orientationWidgetEnabled);
    }
  };
  publicAPI.resize = () => {
    if (model.container) {
      const dims = model.container.getBoundingClientRect();
      if (dims.width === dims.height && dims.width === 0) {
        return;
      }
      const devicePixelRatio = window.devicePixelRatio || 1;
      const width2 = Math.max(10, Math.floor(devicePixelRatio * dims.width));
      const height2 = Math.max(10, Math.floor(devicePixelRatio * dims.height));
      model._openGLRenderWindow.setSize(width2, height2);
      publicAPI.invokeResize({
        width: width2,
        height: height2
      });
      publicAPI.renderLater();
    }
  };
  publicAPI.renderLater = () => {
    publicAPI.render(false);
  };
  publicAPI.render = function() {
    let blocking = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (model.representations.length > 0 && model.resetCameraOnFirstRender) {
      model.resetCameraOnFirstRender = false;
      publicAPI.resetCamera();
    }
    model.orientationWidget.updateMarkerOrientation();
    model.renderer.resetCameraClippingRange();
    if (blocking) {
      model.renderWindow.render();
    } else {
      setTimeout(model.renderWindow.render, 0);
    }
  };
  publicAPI.addRepresentation = (representation) => {
    if (!representation) {
      return;
    }
    if (model.representations.indexOf(representation) === -1) {
      model.representations.push(representation);
      model.renderer.addViewProp(representation);
    }
  };
  publicAPI.removeRepresentation = (representation) => {
    if (!representation) {
      return;
    }
    if (model.representations.indexOf(representation) !== -1) {
      model.representations = model.representations.filter((r) => r !== representation);
      model.renderer.removeViewProp(representation);
    }
    if (model.representations.length === 0) {
      model.resetCameraOnFirstRender = true;
    }
  };
  publicAPI.setCameraParameters = (_ref) => {
    let {
      position,
      focalPoint,
      bounds: bounds2,
      parallelScale,
      viewAngle
    } = _ref;
    if (position != null) {
      model.camera.setPosition(...position);
    }
    if (focalPoint != null) {
      model.camera.setFocalPoint(...focalPoint);
    }
    if (bounds2 != null) {
      model.renderer.resetCameraClippingRange(bounds2);
    } else {
      model.renderer.resetCameraClippingRange();
    }
    if (parallelScale != null) {
      model.camera.setParallelScale(parallelScale);
    }
    if (viewAngle != null) {
      model.camera.setViewAngle(viewAngle);
    }
  };
  publicAPI.resetCamera = () => {
    model._resetCamera();
    model.interactorStyle2D.setCenterOfRotation(model.camera.getFocalPoint());
    model.interactorStyle3D.setCenterOfRotation(model.camera.getFocalPoint());
    publicAPI.renderLater();
  };
  publicAPI.captureImage = function() {
    let {
      format: format2 = "image/png",
      ...opts
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return model.renderWindow.captureImages(format2, opts)[0];
  };
  publicAPI.openCaptureImage = function() {
    let target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "_blank";
    const image = new Image();
    return publicAPI.captureImage().then((imageURL) => {
      image.src = imageURL;
      const w = window.open("", target);
      w.document.write(image.outerHTML);
      w.document.title = "vtk.js Image Capture";
      window.focus();
    });
  };
  publicAPI.setCornerAnnotation = (corner2, templateString) => {
    model.cornerAnnotation.updateTemplates({
      [corner2]: (meta) => vtkCornerAnnotation$1.applyTemplate(templateString, meta)
    });
  };
  publicAPI.setCornerAnnotations = function(annotations) {
    let useTemplateString = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (useTemplateString) {
      Object.keys(annotations).forEach((key) => {
        publicAPI.setCornerAnnotation(key, annotations[key]);
      });
    } else {
      model.cornerAnnotation.updateTemplates(annotations);
    }
  };
  publicAPI.updateCornerAnnotation = (meta) => model.cornerAnnotation.updateMetadata(meta);
  publicAPI.setAnnotationOpacity = (opacity) => {
    if (model.annotationOpacity !== Number(opacity)) {
      model.annotationOpacity = Number(opacity);
      model.cornerAnnotation.getAnnotationContainer().style.opacity = opacity;
      publicAPI.modified();
    }
  };
  publicAPI.setBackground = chain(model.renderer.setBackground, updateAnnotationColor);
  publicAPI.getBackground = model.renderer.getBackground;
  publicAPI.setAnimation = function(enable) {
    let requester = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : publicAPI;
    if (model.disableAnimation && enable) {
      return;
    }
    if (enable) {
      model.renderWindow.getInteractor().requestAnimation(requester);
    } else {
      const skipWarning = requester === publicAPI || `${requester}`.indexOf("ViewProxy.moveCamera.") === 0;
      model.renderWindow.getInteractor().cancelAnimation(requester, skipWarning);
    }
  };
  publicAPI.updateOrientation = function(axisIndex, orientation3, viewUp) {
    let animateSteps = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    if (axisIndex === void 0) {
      return Promise.resolve();
    }
    const originalPosition = model.camera.getPosition();
    const originalViewUp = model.camera.getViewUp();
    const originalFocalPoint = model.camera.getFocalPoint();
    model.axis = axisIndex;
    model.orientation = orientation3;
    model.viewUp = viewUp;
    const position = model.camera.getFocalPoint();
    position[model.axis] += model.orientation;
    model.camera.setPosition(...position);
    model.camera.setViewUp(...viewUp);
    model.renderer.resetCamera();
    const destFocalPoint = model.camera.getFocalPoint();
    const destPosition = model.camera.getPosition();
    const destViewUp = model.camera.getViewUp();
    model.camera.setFocalPoint(...originalFocalPoint);
    model.camera.setPosition(...originalPosition);
    model.camera.setViewUp(...originalViewUp);
    return publicAPI.moveCamera(destFocalPoint, destPosition, destViewUp, animateSteps);
  };
  publicAPI.moveCamera = function(focalPoint, position, viewUp) {
    let animateSteps = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const originalFocalPoint = model.camera.getFocalPoint();
    const originalPosition = model.camera.getPosition();
    const originalViewUp = model.camera.getViewUp();
    const animationStack = [{
      focalPoint,
      position,
      viewUp
    }];
    if (animateSteps) {
      const deltaFocalPoint = [(originalFocalPoint[0] - focalPoint[0]) / animateSteps, (originalFocalPoint[1] - focalPoint[1]) / animateSteps, (originalFocalPoint[2] - focalPoint[2]) / animateSteps];
      const deltaPosition = [(originalPosition[0] - position[0]) / animateSteps, (originalPosition[1] - position[1]) / animateSteps, (originalPosition[2] - position[2]) / animateSteps];
      const deltaViewUp = [(originalViewUp[0] - viewUp[0]) / animateSteps, (originalViewUp[1] - viewUp[1]) / animateSteps, (originalViewUp[2] - viewUp[2]) / animateSteps];
      const needSteps = deltaFocalPoint[0] || deltaFocalPoint[1] || deltaFocalPoint[2] || deltaPosition[0] || deltaPosition[1] || deltaPosition[2] || deltaViewUp[0] || deltaViewUp[1] || deltaViewUp[2];
      const focalPointDeltaAxisCount = deltaFocalPoint.map((i) => Math.abs(i) < EPSILON4 ? 0 : 1).reduce((a2, b2) => a2 + b2, 0);
      const positionDeltaAxisCount = deltaPosition.map((i) => Math.abs(i) < EPSILON4 ? 0 : 1).reduce((a2, b2) => a2 + b2, 0);
      const viewUpDeltaAxisCount = deltaViewUp.map((i) => Math.abs(i) < EPSILON4 ? 0 : 1).reduce((a2, b2) => a2 + b2, 0);
      const rotation180Only = viewUpDeltaAxisCount === 1 && positionDeltaAxisCount === 0 && focalPointDeltaAxisCount === 0;
      if (needSteps) {
        if (rotation180Only) {
          const availableAxes = originalFocalPoint.map((fp, i) => Math.abs(originalPosition[i] - fp) < EPSILON4 ? i : null).filter((i) => i !== null);
          const axisCorrectionIndex = availableAxes.find((v) => Math.abs(deltaViewUp[v]) < EPSILON4);
          for (let i = 0; i < animateSteps; i++) {
            const newViewUp = [viewUp[0] + (i + 1) * deltaViewUp[0], viewUp[1] + (i + 1) * deltaViewUp[1], viewUp[2] + (i + 1) * deltaViewUp[2]];
            newViewUp[axisCorrectionIndex] = Math.sin(Math.PI * i / (animateSteps - 1));
            animationStack.push({
              focalPoint,
              position,
              viewUp: newViewUp
            });
          }
        } else {
          for (let i = 0; i < animateSteps; i++) {
            animationStack.push({
              focalPoint: [focalPoint[0] + (i + 1) * deltaFocalPoint[0], focalPoint[1] + (i + 1) * deltaFocalPoint[1], focalPoint[2] + (i + 1) * deltaFocalPoint[2]],
              position: [position[0] + (i + 1) * deltaPosition[0], position[1] + (i + 1) * deltaPosition[1], position[2] + (i + 1) * deltaPosition[2]],
              viewUp: [viewUp[0] + (i + 1) * deltaViewUp[0], viewUp[1] + (i + 1) * deltaViewUp[1], viewUp[2] + (i + 1) * deltaViewUp[2]]
            });
          }
        }
      }
    }
    if (animationStack.length === 1) {
      model.camera.set(animationStack.pop());
      model.renderer.resetCameraClippingRange();
      if (model.interactor.getLightFollowCamera()) {
        model.renderer.updateLightsGeometryToFollowCamera();
      }
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      const now = performance.now().toString();
      const animationRequester = `ViewProxy.moveCamera.${now}`;
      publicAPI.setAnimation(true, animationRequester);
      let intervalId = null;
      const consumeAnimationStack = () => {
        if (animationStack.length) {
          const {
            focalPoint: cameraFocalPoint,
            position: cameraPosition,
            viewUp: cameraViewUp
          } = animationStack.pop();
          model.camera.setFocalPoint(...cameraFocalPoint);
          model.camera.setPosition(...cameraPosition);
          model.camera.setViewUp(...cameraViewUp);
          model.renderer.resetCameraClippingRange();
          if (model.interactor.getLightFollowCamera()) {
            model.renderer.updateLightsGeometryToFollowCamera();
          }
        } else {
          clearInterval(intervalId);
          publicAPI.setAnimation(false, animationRequester);
          resolve();
        }
      };
      intervalId = setInterval(consumeAnimationStack, 1);
    });
  };
  publicAPI.resetOrientation = function() {
    let animateSteps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return publicAPI.updateOrientation(model.axis, model.orientation, model.viewUp, animateSteps);
  };
  publicAPI.rotate = (angle) => {
    const {
      viewUp,
      focalPoint,
      position
    } = model.camera.get("viewUp", "focalPoint", "position");
    const axis = [focalPoint[0] - position[0], focalPoint[1] - position[1], focalPoint[2] - position[2]];
    vtkMatrixBuilder.buildFromDegree().rotate(Number.isNaN(angle) ? 90 : angle, axis).apply(viewUp);
    model.camera.setViewUp(...viewUp);
    model.camera.modified();
    model.orientationWidget.updateMarkerOrientation();
    model.renderWindow.render();
  };
  publicAPI.focusTo = chain(model.camera.setFocalPoint, model.interactorStyle2D.setCenterOfRotation, model.interactorStyle3D.setCenterOfRotation);
  publicAPI.delete = chain(() => {
    publicAPI.setContainer(null);
    model.orientationWidget.setEnabled(false);
    model.orientationWidget.delete();
    model.orientationAxesArrow.delete();
    model.orientationAxesCube.delete();
    model.interactorStyle2D.delete();
    model.interactorStyle3D.delete();
    model.cornerAnnotation.delete();
    model.interactor.delete();
    model.renderer.delete();
    model._openGLRenderWindow.delete();
    model.renderWindow.delete();
  }, publicAPI.delete);
  publicAPI.resetOrientation();
  updateAnnotationColor();
}
var DEFAULT_VALUES175 = {
  representations: [],
  sectionName: "view",
  annotationOpacity: 1,
  resetCameraOnFirstRender: true,
  presetToOrientationAxes: "lps",
  orientationAxesType: "arrow",
  disableAnimation: false,
  axis: 1,
  orientation: 0,
  viewUp: [0, 0, 1]
};
function extend192(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES175, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["name", "disableAnimation", "resetCameraOnFirstRender"]);
  get(publicAPI, model, [
    "annotationOpacity",
    "camera",
    "container",
    "cornerAnnotation",
    "interactor",
    "interactorStyle2D",
    "interactorStyle3D",
    "_openGLRenderWindow",
    // todo breaking? convert to apiSpecificWindow
    "orientationAxesType",
    "presetToOrientationAxes",
    "renderer",
    "renderWindow",
    "representations",
    "useParallelRendering"
  ]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  event(publicAPI, model, "Resize");
  vtkViewProxy(publicAPI, model);
  proxy(publicAPI, model);
  proxyPropertyMapping(publicAPI, model, {
    orientationAxesVisibility: {
      modelKey: "orientationWidget",
      property: "enabled"
    },
    orientationAxesCorner: {
      modelKey: "orientationWidget",
      property: "viewportCorner"
    },
    orientationAxesSize: {
      modelKey: "orientationWidget",
      property: "viewportSize"
    },
    cameraViewUp: {
      modelKey: "camera",
      property: "viewUp",
      modified: false
    },
    cameraPosition: {
      modelKey: "camera",
      property: "position",
      modified: false
    },
    cameraFocalPoint: {
      modelKey: "camera",
      property: "focalPoint",
      modified: false
    }
  });
}
var newInstance184 = newInstance(extend192, "vtkViewProxy");
var vtkViewProxy$1 = {
  newInstance: newInstance184,
  extend: extend192
};

// node_modules/@kitware/vtk.js/Proxy/Core/View2DProxy.js
var DEFAULT_STEP_WIDTH = 512;
function formatAnnotationValue(value) {
  if (Array.isArray(value)) {
    return value.map(formatAnnotationValue).join(", ");
  }
  if (Number.isInteger(value)) {
    return value;
  }
  if (Number.isFinite(value)) {
    if (Math.abs(value) < 0.01) {
      return "0";
    }
    return value.toFixed(2);
  }
  return value;
}
function getPropCoarseHull(prop) {
  var _a, _b, _c;
  if (!prop.getVisibility() || !prop.getUseBounds()) {
    return [];
  }
  let finestBounds = prop.getBounds();
  let finestMatrix = null;
  const mapper = (_a = prop == null ? void 0 : prop.getMapper) == null ? void 0 : _a.call(prop);
  const mapperBounds = (_b = mapper == null ? void 0 : mapper.getBounds) == null ? void 0 : _b.call(mapper);
  if (vtkBoundingBox.isValid(mapperBounds) && prop.getMatrix) {
    finestBounds = mapperBounds;
    finestMatrix = prop.getMatrix().slice();
    mat4_exports.transpose(finestMatrix, finestMatrix);
    if (mapper.isA("vtkImageMapper") && ((_c = mapper.getInputData()) == null ? void 0 : _c.isA("vtkImageData"))) {
      prop.computeMatrix();
      const imageData = mapper.getInputData();
      finestBounds = imageData.getSpatialExtent();
      const imageDataMatrix = imageData.getIndexToWorld();
      mat4_exports.mul(finestMatrix, finestMatrix, imageDataMatrix);
    }
  }
  if (!vtkBoundingBox.isValid(finestBounds)) {
    return [];
  }
  const corners = [];
  vtkBoundingBox.getCorners(finestBounds, corners);
  if (finestMatrix) {
    corners.forEach((pt) => vec3_exports.transformMat4(pt, pt, finestMatrix));
  }
  return corners;
}
function vtkView2DProxy(publicAPI, model) {
  model.classHierarchy.push("vtkView2DProxy");
  publicAPI.updateWidthHeightAnnotation = () => {
    const {
      ijkOrientation,
      dimensions
    } = model.cornerAnnotation.getMetadata();
    if (ijkOrientation && dimensions) {
      let realDimensions = dimensions;
      if (dimensions.length > 3) {
        realDimensions = dimensions.split(",").map(Number);
      }
      const dop = model.camera.getDirectionOfProjection();
      const viewUp = model.camera.getViewUp();
      const viewRight = [0, 0, 0];
      cross(dop, viewUp, viewRight);
      const wIdx = getMajorAxisIndex(viewRight);
      const hIdx = getMajorAxisIndex(viewUp);
      const sliceWidth = realDimensions["IJK".indexOf(ijkOrientation[wIdx])];
      const sliceHeight = realDimensions["IJK".indexOf(ijkOrientation[hIdx])];
      publicAPI.updateCornerAnnotation({
        sliceWidth,
        sliceHeight
      });
    }
  };
  const superUpdateOrientation = publicAPI.updateOrientation;
  publicAPI.updateOrientation = (axisIndex, orientation3, viewUp) => {
    const promise = superUpdateOrientation(axisIndex, orientation3, viewUp);
    let count = model.representations.length;
    while (count--) {
      const rep = model.representations[count];
      const slicingMode = "XYZ"[axisIndex];
      if (rep.setSlicingMode) {
        rep.setSlicingMode(slicingMode);
      }
    }
    publicAPI.updateCornerAnnotation({
      axis: "XYZ"[axisIndex]
    });
    return promise;
  };
  const superAddRepresentation = publicAPI.addRepresentation;
  publicAPI.addRepresentation = (rep) => {
    superAddRepresentation(rep);
    if (rep.setSlicingMode) {
      rep.setSlicingMode("XYZ"[model.axis]);
    }
    publicAPI.bindRepresentationToManipulator(rep);
  };
  const superRemoveRepresentation = publicAPI.removeRepresentation;
  publicAPI.removeRepresentation = (rep) => {
    superRemoveRepresentation(rep);
    if (rep === model.sliceRepresentation) {
      publicAPI.bindRepresentationToManipulator(null);
      let count = model.representations.length;
      while (count--) {
        if (publicAPI.bindRepresentationToManipulator(model.representations[count])) {
          count = 0;
        }
      }
    }
  };
  const superInternalResetCamera = model._resetCamera;
  model._resetCamera = function() {
    let bounds2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const initialReset = superInternalResetCamera(bounds2);
    if (!model.fitProps || !model.useParallelRendering || !initialReset) {
      return initialReset;
    }
    const visiblePoints = [];
    if (bounds2) {
      vtkBoundingBox.getCorners(bounds2, visiblePoints);
    } else {
      publicAPI.getRepresentations().forEach((representationProxy) => [representationProxy.getActors(), representationProxy.getVolumes()].flat().forEach((prop) => visiblePoints.push(...getPropCoarseHull(prop))));
    }
    if (!visiblePoints) {
      return initialReset;
    }
    const viewBounds = vtkBoundingBox.reset([]);
    const viewMatrix = model.camera.getViewMatrix();
    mat4_exports.transpose(viewMatrix, viewMatrix);
    for (let i = 0; i < visiblePoints.length; ++i) {
      const point = visiblePoints[i];
      vec3_exports.transformMat4(point, point, viewMatrix);
      vtkBoundingBox.addPoint(viewBounds, ...point);
    }
    const view = model.renderer.getRenderWindow().getViews()[0];
    const dims = view.getViewportSize(model.renderer);
    const aspect = dims[1] && dims[0] ? dims[0] / dims[1] : 1;
    const xLength = vtkBoundingBox.getLength(viewBounds, 0);
    const yLength = vtkBoundingBox.getLength(viewBounds, 1);
    const parallelScale = 0.5 * Math.max(yLength, xLength / aspect);
    const viewFocalPoint = vtkBoundingBox.getCenter(viewBounds);
    const perspectiveAngle = radiansFromDegrees(model.camera.getViewAngle());
    const distance = parallelScale / Math.tan(perspectiveAngle * 0.5);
    const viewPosition = [viewFocalPoint[0], viewFocalPoint[1], viewBounds[5] + distance];
    const inverseViewMatrix = new Float64Array(16);
    const worldFocalPoint = new Float64Array(3);
    const worldPosition = new Float64Array(3);
    mat4_exports.invert(inverseViewMatrix, viewMatrix);
    vec3_exports.transformMat4(worldFocalPoint, viewFocalPoint, inverseViewMatrix);
    vec3_exports.transformMat4(worldPosition, viewPosition, inverseViewMatrix);
    if (parallelScale <= 0) {
      return initialReset;
    }
    const worldBounds = vtkBoundingBox.transformBounds(viewBounds, inverseViewMatrix);
    publicAPI.setCameraParameters({
      position: worldPosition,
      focalPoint: worldFocalPoint,
      bounds: worldBounds,
      parallelScale
    });
    return true;
  };
  model.rangeManipulator = vtkMouseRangeManipulator$1.newInstance({
    button: 1,
    scrollEnabled: true
  });
  model.interactorStyle2D.addMouseManipulator(model.rangeManipulator);
  function setWindowWidth(windowWidth) {
    publicAPI.updateCornerAnnotation({
      windowWidth
    });
    if (model.sliceRepresentation && model.sliceRepresentation.setWindowWidth) {
      model.sliceRepresentation.setWindowWidth(windowWidth);
    }
  }
  function setWindowLevel(windowLevel) {
    publicAPI.updateCornerAnnotation({
      windowLevel
    });
    if (model.sliceRepresentation && model.sliceRepresentation.setWindowLevel) {
      model.sliceRepresentation.setWindowLevel(windowLevel);
    }
  }
  function setSlice(sliceRaw) {
    const numberSliceRaw = Number(sliceRaw);
    const slice = Number.isInteger(numberSliceRaw) ? sliceRaw : numberSliceRaw.toFixed(2);
    const annotation = {
      slice
    };
    if (model.sliceRepresentation && model.sliceRepresentation.setSlice) {
      model.sliceRepresentation.setSlice(numberSliceRaw);
    }
    if (model.sliceRepresentation && model.sliceRepresentation.getAnnotations) {
      const addOn = model.sliceRepresentation.getAnnotations();
      Object.keys(addOn).forEach((key) => {
        annotation[key] = formatAnnotationValue(addOn[key]);
      });
    }
    publicAPI.updateCornerAnnotation(annotation);
  }
  publicAPI.bindRepresentationToManipulator = (representation) => {
    let nbListeners = 0;
    if (!representation.getProxyId) {
      return nbListeners;
    }
    model.rangeManipulator.removeAllListeners();
    model.sliceRepresentation = representation;
    while (model.sliceRepresentationSubscriptions.length) {
      model.sliceRepresentationSubscriptions.pop().unsubscribe();
    }
    if (representation) {
      model.sliceRepresentationSubscriptions.push(model.camera.onModified(publicAPI.updateWidthHeightAnnotation));
      if (representation.getWindowWidth) {
        const update2 = () => setWindowWidth(representation.getWindowWidth());
        const windowWidth = representation.getPropertyDomainByName("windowWidth");
        const {
          min,
          max: max2
        } = windowWidth;
        let {
          step
        } = windowWidth;
        if (!step || step === "any") {
          step = 1 / DEFAULT_STEP_WIDTH;
        }
        model.rangeManipulator.setVerticalListener(min, max2, step, representation.getWindowWidth, setWindowWidth);
        model.sliceRepresentationSubscriptions.push(representation.onModified(update2));
        update2();
        nbListeners++;
      }
      if (representation.getWindowLevel) {
        const update2 = () => setWindowLevel(representation.getWindowLevel());
        const windowLevel = representation.getPropertyDomainByName("windowLevel");
        const {
          min,
          max: max2
        } = windowLevel;
        let {
          step
        } = windowLevel;
        if (!step || step === "any") {
          step = 1 / DEFAULT_STEP_WIDTH;
        }
        model.rangeManipulator.setHorizontalListener(min, max2, step, representation.getWindowLevel, setWindowLevel);
        model.sliceRepresentationSubscriptions.push(representation.onModified(update2));
        update2();
        nbListeners++;
      }
      const domain = representation.getPropertyDomainByName("slice");
      if (representation.getSlice && domain) {
        const update2 = () => setSlice(representation.getSlice());
        model.rangeManipulator.setScrollListener(domain.min, domain.max, domain.step, representation.getSlice, setSlice);
        model.sliceRepresentationSubscriptions.push(representation.onModified(update2));
        update2();
        nbListeners++;
      }
    }
    return nbListeners;
  };
}
var DEFAULT_VALUES176 = {
  axis: 2,
  orientation: -1,
  viewUp: [0, 1, 0],
  useParallelRendering: true,
  sliceRepresentationSubscriptions: [],
  fitProps: false
};
function extend193(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES176, initialValues);
  vtkViewProxy$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["axis"]);
  macro.setGet(publicAPI, model, ["fitProps"]);
  vtkView2DProxy(publicAPI, model);
}
var newInstance185 = macro.newInstance(extend193, "vtkView2DProxy");
var vtkView2DProxy$1 = {
  newInstance: newInstance185,
  extend: extend193
};

// node_modules/@kitware/vtk.js/Proxy/Core.js
var Core6 = {
  vtkAbstractRepresentationProxy: vtkAbstractRepresentationProxy$1,
  vtkLookupTableProxy: vtkLookupTableProxy$1,
  vtkPiecewiseFunctionProxy: vtkPiecewiseFunctionProxy$1,
  vtkProxyManager,
  vtkSourceProxy: vtkSourceProxy$1,
  vtkView2DProxy: vtkView2DProxy$1,
  vtkViewProxy: vtkViewProxy$1
};

// node_modules/@kitware/vtk.js/Proxy/Representations/GeometryRepresentationProxy.js
var PROPERTIES_STATE = {
  representation: {
    "Surface with edges": {
      property: {
        edgeVisibility: true,
        representation: 2
      }
    },
    Surface: {
      property: {
        edgeVisibility: false,
        representation: 2
      }
    },
    Wireframe: {
      property: {
        edgeVisibility: false,
        representation: 1
      }
    },
    Points: {
      property: {
        edgeVisibility: false,
        representation: 0
      }
    }
  }
};
var PROPERTIES_DEFAULT = {
  representation: "Surface"
};
function vtkGeometryRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkGeometryRepresentationProxy");
  model.mapper = vtkMapper$1.newInstance({
    interpolateScalarsBeforeMapping: true,
    useLookupTableScalarRange: true,
    scalarVisibility: false
  });
  model.actor = vtkActor$1.newInstance();
  model.property = model.actor.getProperty();
  model.sourceDependencies.push(model.mapper);
  model.actor.setMapper(model.mapper);
  model.actors.push(model.actor);
}
var DEFAULT_VALUES177 = {
  representation: "Surface"
};
function extend194(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES177, initialValues);
  vtkAbstractRepresentationProxy$1.extend(publicAPI, model, initialValues);
  vtkGeometryRepresentationProxy(publicAPI, model);
  macro.proxyPropertyState(publicAPI, model, PROPERTIES_STATE, PROPERTIES_DEFAULT);
  macro.proxyPropertyMapping(publicAPI, model, {
    opacity: {
      modelKey: "property",
      property: "opacity"
    },
    visibility: {
      modelKey: "actor",
      property: "visibility"
    },
    color: {
      modelKey: "property",
      property: "diffuseColor"
    },
    interpolateScalarsBeforeMapping: {
      modelKey: "mapper",
      property: "interpolateScalarsBeforeMapping"
    },
    pointSize: {
      modelKey: "property",
      property: "pointSize"
    },
    useShadow: {
      modelKey: "property",
      property: "lighting"
    },
    lineWidth: {
      modelKey: "property",
      property: "lineWidth"
    },
    useBounds: {
      modelKey: "actor",
      property: "useBounds"
    }
  });
}
var newInstance186 = macro.newInstance(extend194, "vtkGeometryRepresentationProxy");
var vtkGeometryRepresentationProxy$1 = {
  newInstance: newInstance186,
  extend: extend194
};

// node_modules/@kitware/vtk.js/Proxy/Representations/GlyphRepresentationProxy.js
function vtkGlyphRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkGlyphRepresentationProxy");
  model.property = vtkProperty$1.newInstance();
  function processJSON(description) {
    model.actors.length = 0;
    const lookupTable = vtkColorTransferFunction$1.newInstance();
    lookupTable.applyColorMap({
      RGBPoints: description.rgbPoints
    });
    model.glyph = {};
    let count = description.glyph.length;
    while (count--) {
      const glyph = description.glyph[count];
      model.glyph[glyph.id] = vtk(glyph);
    }
    count = description.mapping.length;
    while (count--) {
      const sourceDesc = description.mapping[count];
      const glyph = model.glyph[sourceDesc.glyphId];
      const source = vtkPolyData$1.newInstance();
      source.getPoints().setData(Float32Array.from(sourceDesc.coordinates), 3);
      if (sourceDesc.scale) {
        source.getPointData().addArray(vtkDataArray$1.newInstance({
          name: "scaling",
          values: Float32Array.from(sourceDesc.scale),
          numberOfComponents: 3
        }));
      }
      const mapper = vtkGlyph3DMapper$1.newInstance({
        useLookupTableScalarRange: true,
        lookupTable,
        orient: false,
        scaling: !!sourceDesc.scale,
        scaleArray: "scaling",
        scaleMode: vtkGlyph3DMapper$1.ScaleModes.SCALE_BY_COMPONENTS
      });
      const actor = vtkActor$1.newInstance();
      if (model.property) {
        actor.setProperty(model.property);
      }
      actor.setMapper(mapper);
      mapper.setInputData(source, 0);
      mapper.setInputConnection(glyph.getOutputPort(), 1);
      model.actors.push(actor);
    }
  }
  model.sourceDependencies.push({
    setInputData: processJSON
  });
  publicAPI.setColorBy = () => {
  };
  publicAPI.getColorBy = () => [];
  publicAPI.listDataArrays = () => [];
}
var DEFAULT_VALUES178 = {};
function extend195(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES178, initialValues);
  vtkAbstractRepresentationProxy$1.extend(publicAPI, model, initialValues);
  vtkGlyphRepresentationProxy(publicAPI, model);
  macro.proxyPropertyMapping(publicAPI, model, {
    edgeVisibility: {
      modelKey: "property",
      property: "edgeVisibility"
    }
  });
}
var newInstance187 = macro.newInstance(extend195, "vtkGlyphRepresentationProxy");
var vtkGlyphRepresentationProxy$1 = {
  newInstance: newInstance187,
  extend: extend195
};

// node_modules/@kitware/vtk.js/Proxy/Representations/MoleculeRepresentationProxy.js
function vtkMoleculeRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkMoleculeRepresentationProxy");
  model.filter = vtkMoleculeToRepresentation$1.newInstance();
  model.sphereMapper = vtkSphereMapper$1.newInstance();
  model.stickMapper = vtkStickMapper$1.newInstance();
  model.sphereActor = vtkActor$1.newInstance();
  model.stickActor = vtkActor$1.newInstance();
  model.sourceDependencies.push(model.filter);
  model.sphereMapper.setInputConnection(model.filter.getOutputPort(0));
  model.sphereMapper.setScaleArray(model.filter.getSphereScaleArrayName());
  model.sphereActor.setMapper(model.sphereMapper);
  model.stickMapper.setInputConnection(model.filter.getOutputPort(1));
  model.stickMapper.setScaleArray("stickScales");
  model.stickMapper.setOrientationArray("orientation");
  model.stickActor.setMapper(model.stickMapper);
  model.actors.push(model.sphereActor);
  model.actors.push(model.stickActor);
  publicAPI.setColorBy = () => {
  };
  publicAPI.getColorBy = () => [];
  publicAPI.listDataArrays = () => [];
}
var DEFAULT_VALUES179 = {};
function extend196(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES179, initialValues);
  vtkAbstractRepresentationProxy$1.extend(publicAPI, model, initialValues);
  vtkMoleculeRepresentationProxy(publicAPI, model);
  macro.proxyPropertyMapping(publicAPI, model, {
    tolerance: {
      modelKey: "filter",
      property: "tolerance"
    },
    atomicRadiusScaleFactor: {
      modelKey: "filter",
      property: "atomicRadiusScaleFactor"
    },
    bondRadius: {
      modelKey: "filter",
      property: "bondRadius"
    },
    deltaBondFactor: {
      modelKey: "filter",
      property: "deltaBondFactor"
    },
    radiusType: {
      modelKey: "filter",
      property: "radiusType"
    },
    hideElements: {
      modelKey: "filter",
      property: "hideElements"
    }
  });
}
var newInstance188 = macro.newInstance(extend196, "vtkMoleculeRepresentationProxy");
var vtkMoleculeRepresentationProxy$1 = {
  newInstance: newInstance188,
  extend: extend196
};

// node_modules/@kitware/vtk.js/Proxy/Representations/SkyboxRepresentationProxy.js
function vtkSkyboxRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkSkyboxRepresentationProxy");
  model.actor = vtkSkybox$1.newInstance();
  model.actors.push(model.actor);
  function updateTexture(texture) {
    model.actor.removeAllTextures();
    model.actor.addTexture(texture);
    const values = model.input.getAlgo().getPositions();
    publicAPI.updateProxyProperty("position", {
      values
    });
  }
  model.sourceDependencies.push({
    setInputData: updateTexture
  });
  publicAPI.setColorBy = () => {
  };
  publicAPI.getColorBy = () => [];
  publicAPI.listDataArrays = () => [];
  publicAPI.setPosition = (value) => {
    model.input.getAlgo().setPosition(value);
  };
  publicAPI.getPosition = () => model.input.getAlgo().getPosition();
}
var DEFAULT_VALUES180 = {};
function extend197(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES180, initialValues);
  vtkAbstractRepresentationProxy$1.extend(publicAPI, model, initialValues);
  vtkSkyboxRepresentationProxy(publicAPI, model);
}
var newInstance189 = macro.newInstance(extend197, "vtkSkyboxRepresentationProxy");
var vtkSkyboxRepresentationProxy$1 = {
  newInstance: newInstance189,
  extend: extend197
};

// node_modules/@kitware/vtk.js/Proxy/Representations/SliceRepresentationProxy.js
function sum(a2, b2) {
  return a2 + b2;
}
function mean() {
  for (var _len = arguments.length, array = new Array(_len), _key = 0; _key < _len; _key++) {
    array[_key] = arguments[_key];
  }
  return array.reduce(sum, 0) / array.length;
}
function updateDomains(dataset, dataArray, model, updateProp) {
  const dataRange = dataArray.getRange();
  const spacing = dataset.getSpacing();
  const bounds2 = dataset.getBounds();
  const extent = dataset.getExtent();
  let sliceMin;
  let sliceMax;
  let stepVal;
  let axisIndex;
  const sliceMode = model.mapper.getSlicingMode();
  const sliceModeLabel = "IJKXYZ"[sliceMode];
  switch (sliceMode) {
    case vtkImageMapper$1.SlicingMode.I:
    case vtkImageMapper$1.SlicingMode.J:
    case vtkImageMapper$1.SlicingMode.K:
      axisIndex = "IJK".indexOf(sliceModeLabel);
      sliceMin = extent[axisIndex * 2];
      sliceMax = extent[axisIndex * 2 + 1];
      stepVal = 1;
      break;
    case vtkImageMapper$1.SlicingMode.X:
    case vtkImageMapper$1.SlicingMode.Y:
    case vtkImageMapper$1.SlicingMode.Z:
      {
        axisIndex = "XYZ".indexOf(sliceModeLabel);
        sliceMin = bounds2[axisIndex * 2];
        sliceMax = bounds2[axisIndex * 2 + 1];
        const {
          ijkMode
        } = model.mapper.getClosestIJKAxis();
        stepVal = spacing[ijkMode];
      }
      break;
  }
  const propToUpdate = {
    slice: {
      domain: {
        min: sliceMin,
        max: sliceMax,
        step: stepVal
      }
    },
    windowWidth: {
      domain: {
        min: 0,
        max: dataRange[1] - dataRange[0],
        step: "any"
      }
    },
    windowLevel: {
      domain: {
        min: dataRange[0],
        max: dataRange[1],
        step: "any"
      }
    }
  };
  updateProp("slice", propToUpdate.slice);
  updateProp("windowWidth", propToUpdate.windowWidth);
  updateProp("windowLevel", propToUpdate.windowLevel);
  return {
    slice: mean(propToUpdate.slice.domain.min, propToUpdate.slice.domain.max),
    windowWidth: propToUpdate.windowWidth.domain.max,
    windowLevel: Math.floor(mean(propToUpdate.windowLevel.domain.min, propToUpdate.windowLevel.domain.max))
  };
}
function vtkSliceRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkSliceRepresentationProxy");
  model.mapper = vtkImageMapper$1.newInstance();
  model.actor = vtkImageSlice$1.newInstance();
  model.property = model.actor.getProperty();
  model.actor.setMapper(model.mapper);
  model.actors.push(model.actor);
  function setInputData(inputDataset) {
    const state = updateDomains(inputDataset, publicAPI.getDataArray(), model, publicAPI.updateProxyProperty);
    publicAPI.set(state);
    const bounds2 = inputDataset.getBounds();
    const extent = inputDataset.getExtent();
    switch (model.mapper.getSlicingMode()) {
      case vtkImageMapper$1.SlicingMode.I:
        publicAPI.setSlice(Math.floor(mean(extent[0], extent[1])));
        break;
      case vtkImageMapper$1.SlicingMode.J:
        publicAPI.setSlice(Math.floor(mean(extent[2], extent[3])));
        break;
      case vtkImageMapper$1.SlicingMode.K:
        publicAPI.setSlice(Math.floor(mean(extent[4], extent[5])));
        break;
      case vtkImageMapper$1.SlicingMode.X:
        publicAPI.setSlice(mean(bounds2[0], bounds2[1]));
        break;
      case vtkImageMapper$1.SlicingMode.Y:
        publicAPI.setSlice(mean(bounds2[2], bounds2[3]));
        break;
      case vtkImageMapper$1.SlicingMode.Z:
        publicAPI.setSlice(mean(bounds2[4], bounds2[5]));
        break;
    }
  }
  model.sourceDependencies.push(model.mapper);
  model.sourceDependencies.push({
    setInputData
  });
  function updateSlicingMode(mode) {
    model.mapper.setSlicingMode(vtkImageMapper$1.SlicingMode[mode]);
    const modelKey = `${mode.toLowerCase()}Slice`;
    if (modelKey in model && model[modelKey] !== void 0) {
      model.mapper.setSlice(model[modelKey]);
    }
    if (model.input) {
      const state = updateDomains(publicAPI.getInputDataSet(), publicAPI.getDataArray(), model, publicAPI.updateProxyProperty);
      publicAPI.set(state);
    }
    publicAPI.modified();
  }
  publicAPI.setSlicingMode = (mode) => {
    if (!mode) {
      return false;
    }
    if (model.slicingMode !== mode) {
      model.slicingMode = mode;
      updateSlicingMode(mode);
      return true;
    }
    return false;
  };
  publicAPI.getSliceIndex = () => {
    if ("XYZ".indexOf(model.slicingMode) !== -1) {
      return model.mapper.getSliceAtPosition(model.mapper.getSlice());
    }
    return model.mapper.getSlice();
  };
  publicAPI.getAnnotations = () => {
    const dynamicAddOn = {};
    const sliceIndex = publicAPI.getSliceIndex();
    const sliceBounds = model.mapper.getBoundsForSlice();
    const sliceNormal = model.mapper.getSlicingModeNormal();
    const {
      ijkMode
    } = model.mapper.getClosestIJKAxis();
    const sliceOrigin = [(sliceBounds[0] + sliceBounds[1]) * 0.5, (sliceBounds[2] + sliceBounds[3]) * 0.5, (sliceBounds[4] + sliceBounds[5]) * 0.5];
    let slicePosition = 0;
    if (sliceBounds[1] - sliceBounds[0] < Number.EPSILON) {
      slicePosition = sliceBounds[0];
    }
    if (sliceBounds[3] - sliceBounds[2] < Number.EPSILON) {
      slicePosition = sliceBounds[2];
    }
    if (sliceBounds[5] - sliceBounds[4] < Number.EPSILON) {
      slicePosition = sliceBounds[4];
    }
    const imageData = model.mapper.getInputData();
    if (imageData) {
      dynamicAddOn.sliceSpacing = imageData.getSpacing()[ijkMode];
      dynamicAddOn.dimensions = imageData.getDimensions();
      dynamicAddOn.sliceCount = imageData.getDimensions()[ijkMode];
      const ijkOrientation = [];
      for (let i = 0; i < 3; i++) {
        const extent = [0, 0, 0, 0, 0, 0];
        extent[i * 2 + 1] = 1;
        const tmpBounds = imageData.extentToBounds(extent);
        if (tmpBounds[1] - tmpBounds[0] > Number.EPSILON) {
          ijkOrientation[0] = "IJK"[i];
        }
        if (tmpBounds[3] - tmpBounds[2] > Number.EPSILON) {
          ijkOrientation[1] = "IJK"[i];
        }
        if (tmpBounds[5] - tmpBounds[4] > Number.EPSILON) {
          ijkOrientation[2] = "IJK"[i];
        }
      }
      dynamicAddOn.ijkOrientation = ijkOrientation.join("");
    }
    return {
      ijkMode,
      sliceBounds,
      sliceIndex,
      sliceNormal,
      sliceOrigin,
      slicePosition,
      ...dynamicAddOn
    };
  };
  const parentSetColorBy = publicAPI.setColorBy;
  publicAPI.setColorBy = function(arrayName, arrayLocation) {
    let componentIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    if (arrayName === null) {
      model.property.setRGBTransferFunction(null);
      model.property.setPiecewiseFunction(null);
    } else {
      parentSetColorBy(arrayName, arrayLocation, componentIndex);
      const lutProxy = publicAPI.getLookupTableProxy(arrayName);
      const pwfProxy = publicAPI.getPiecewiseFunctionProxy(arrayName);
      model.property.setRGBTransferFunction(lutProxy.getLookupTable());
      model.property.setPiecewiseFunction(pwfProxy.getPiecewiseFunction());
    }
  };
  updateSlicingMode(model.slicingMode || "X");
}
var DEFAULT_VALUES181 = {};
function extend198(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES181, initialValues);
  vtkAbstractRepresentationProxy$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["slicingMode"]);
  vtkSliceRepresentationProxy(publicAPI, model);
  macro.proxyPropertyMapping(publicAPI, model, {
    visibility: {
      modelKey: "actor",
      property: "visibility"
    },
    windowWidth: {
      modelKey: "property",
      property: "colorWindow"
    },
    windowLevel: {
      modelKey: "property",
      property: "colorLevel"
    },
    interpolationType: {
      modelKey: "property",
      property: "interpolationType"
    },
    slice: {
      modelKey: "mapper",
      property: "slice"
    }
  });
}
var newInstance190 = macro.newInstance(extend198, "vtkSliceRepresentationProxy");
var vtkSliceRepresentationProxy$1 = {
  newInstance: newInstance190,
  extend: extend198
};

// node_modules/@kitware/vtk.js/Proxy/Representations/SlicedGeometryRepresentationProxy.js
function vtkSlicedGeometryRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkSlicedGeometryRepresentationProxy");
  model.plane = vtkPlane$1.newInstance();
  model.cutter = vtkCutter$1.newInstance();
  model.cutter.setCutFunction(model.plane);
  model.mapper = vtkMapper$1.newInstance();
  model.actor = vtkActor$1.newInstance();
  model.property = model.actor.getProperty();
  model.property.setLighting(false);
  model.mapper.setInputConnection(model.cutter.getOutputPort());
  model.actor.setMapper(model.mapper);
  model.actors.push(model.actor);
  model.sourceDependencies.push(model.cutter);
  publicAPI.setSlice = function() {
    let slice = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const stateModified = model.slice !== slice;
    model.slice = slice;
    const n = model.plane.getNormal();
    const planeModified = model.plane.setOrigin(n[0] * slice, n[1] * slice, n[2] * slice);
    if (planeModified || stateModified) {
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.setOffset = function() {
    let offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const stateModified = model.offset !== offset;
    model.offset = offset;
    const normal = model.plane.getNormal();
    const actorModified = model.actor.setPosition(offset * normal[0], offset * normal[1], offset * normal[2]);
    if (actorModified || stateModified) {
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.setSlicingMode = (mode) => {
    if (model.slicingMode === mode || !mode) {
      console.log("skip setSlicingMode", mode);
      return;
    }
    model.slicingMode = mode;
    switch (vtkImageMapper$1.SlicingMode[mode]) {
      case vtkImageMapper$1.SlicingMode.X:
        model.plane.setNormal(1, 0, 0);
        break;
      case vtkImageMapper$1.SlicingMode.Y:
        model.plane.setNormal(0, 1, 0);
        break;
      case vtkImageMapper$1.SlicingMode.Z:
        model.plane.setNormal(0, 0, 1);
        break;
      default:
        return;
    }
    let alreadyModified = publicAPI.setSlice(model.slice);
    alreadyModified = publicAPI.setOffset(model.offset) || alreadyModified;
    if (!alreadyModified) {
      publicAPI.modified();
    }
  };
}
var DEFAULT_VALUES182 = {
  slicingMode: vtkImageMapper$1.SlicingMode.NONE,
  slice: 0,
  offset: 0
};
function extend199(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES182, initialValues);
  vtkAbstractRepresentationProxy$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["slicingMode", "slice", "offset"]);
  vtkSlicedGeometryRepresentationProxy(publicAPI, model);
  macro.proxyPropertyState(publicAPI, model);
  macro.proxyPropertyMapping(publicAPI, model, {
    opacity: {
      modelKey: "property",
      property: "opacity"
    },
    visibility: {
      modelKey: "actor",
      property: "visibility"
    },
    color: {
      modelKey: "property",
      property: "diffuseColor"
    },
    useShadow: {
      modelKey: "property",
      property: "lighting"
    },
    useBounds: {
      modelKey: "actor",
      property: "useBounds"
    }
  });
}
var newInstance191 = macro.newInstance(extend199, "vtkSlicedGeometryRepresentationProxy");
var vtkSlicedGeometryRepresentationProxy$1 = {
  newInstance: newInstance191,
  extend: extend199
};

// node_modules/@kitware/vtk.js/Proxy/Representations/VolumeRepresentationProxy.js
function sum2(a2, b2) {
  return a2 + b2;
}
function mean2() {
  for (var _len = arguments.length, array = new Array(_len), _key = 0; _key < _len; _key++) {
    array[_key] = arguments[_key];
  }
  return array.reduce(sum2, 0) / array.length;
}
function updateDomains2(dataset, dataArray, model, updateProp) {
  const dataRange = dataArray.getRange();
  const spacing = dataset.getSpacing();
  const bounds2 = dataset.getBounds();
  const {
    ijkMode: xIJKAxis
  } = model.mapperX.getClosestIJKAxis();
  const {
    ijkMode: yIJKAxis
  } = model.mapperY.getClosestIJKAxis();
  const {
    ijkMode: zIJKAxis
  } = model.mapperZ.getClosestIJKAxis();
  const propToUpdate = {
    xSlice: {
      domain: {
        min: bounds2[0],
        max: bounds2[1],
        step: spacing[xIJKAxis]
      }
    },
    ySlice: {
      domain: {
        min: bounds2[2],
        max: bounds2[3],
        step: spacing[yIJKAxis]
      }
    },
    zSlice: {
      domain: {
        min: bounds2[4],
        max: bounds2[5],
        step: spacing[zIJKAxis]
      }
    },
    windowWidth: {
      domain: {
        min: 0,
        max: dataRange[1] - dataRange[0],
        step: "any"
      }
    },
    windowLevel: {
      domain: {
        min: dataRange[0],
        max: dataRange[1],
        step: "any"
      }
    }
  };
  updateProp("xSlice", propToUpdate.xSlice);
  updateProp("ySlice", propToUpdate.ySlice);
  updateProp("zSlice", propToUpdate.zSlice);
  updateProp("windowWidth", propToUpdate.windowWidth);
  updateProp("windowLevel", propToUpdate.windowLevel);
  return {
    xSlice: mean2(propToUpdate.xSlice.domain.min, propToUpdate.xSlice.domain.max),
    ySlice: mean2(propToUpdate.ySlice.domain.min, propToUpdate.ySlice.domain.max),
    zSlice: mean2(propToUpdate.zSlice.domain.min, propToUpdate.zSlice.domain.max),
    windowWidth: propToUpdate.windowWidth.domain.max,
    windowLevel: Math.floor(mean2(propToUpdate.windowLevel.domain.min, propToUpdate.windowLevel.domain.max))
  };
}
function updateConfiguration(dataset, dataArray, _ref) {
  let {
    mapper,
    property
  } = _ref;
  property.setInterpolationTypeToLinear();
  const numberOfComponents = dataArray.getNumberOfComponents();
  const scalarOpacityUnitDistance = vtkBoundingBox.getDiagonalLength(dataset.getBounds()) / Math.max(...dataset.getDimensions());
  for (let component = 0; component < numberOfComponents; component++) {
    property.setScalarOpacityUnitDistance(component, scalarOpacityUnitDistance);
    const dataRange = dataArray.getRange(component);
    property.setGradientOpacityMinimumValue(component, 0);
    property.setGradientOpacityMaximumValue(component, (dataRange[1] - dataRange[0]) * 0.05);
    property.setShade(true);
    property.setUseGradientOpacity(component, true);
    property.setGradientOpacityMinimumOpacity(component, 0);
    property.setGradientOpacityMaximumOpacity(component, 1);
  }
  property.setAmbient(0.2);
  property.setDiffuse(0.7);
  property.setSpecular(0.3);
  property.setSpecularPower(8);
}
function vtkVolumeRepresentationProxy(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeRepresentationProxy");
  model.mapper = vtkVolumeMapper$1.newInstance();
  model.volume = vtkVolume$1.newInstance();
  model.property = model.volume.getProperty();
  model.cropFilter = vtkImageCropFilter$1.newInstance();
  model.mapper.setInputConnection(model.cropFilter.getOutputPort());
  model.sourceDependencies.push(model.cropFilter);
  model.mapperX = vtkImageMapper$1.newInstance({
    slicingMode: vtkImageMapper$1.SlicingMode.X
  });
  model.actorX = vtkImageSlice$1.newInstance({
    visibility: false
  });
  model.propertySlices = model.actorX.getProperty();
  model.mapperY = vtkImageMapper$1.newInstance({
    slicingMode: vtkImageMapper$1.SlicingMode.Y
  });
  model.actorY = vtkImageSlice$1.newInstance({
    visibility: false,
    property: model.propertySlices
  });
  model.mapperZ = vtkImageMapper$1.newInstance({
    slicingMode: vtkImageMapper$1.SlicingMode.Z
  });
  model.actorZ = vtkImageSlice$1.newInstance({
    visibility: false,
    property: model.propertySlices
  });
  model.mapperX.setInputConnection(model.cropFilter.getOutputPort());
  model.mapperY.setInputConnection(model.cropFilter.getOutputPort());
  model.mapperZ.setInputConnection(model.cropFilter.getOutputPort());
  model.volume.setMapper(model.mapper);
  model.volumes.push(model.volume);
  model.actorX.setMapper(model.mapperX);
  model.actors.push(model.actorX);
  model.actorY.setMapper(model.mapperY);
  model.actors.push(model.actorY);
  model.actorZ.setMapper(model.mapperZ);
  model.actors.push(model.actorZ);
  function setInputData(inputDataset) {
    const [name2, location] = publicAPI.getColorBy();
    publicAPI.rescaleTransferFunctionToDataRange(name2, location);
    const lutProxy = publicAPI.getLookupTableProxy(name2);
    const pwfProxy = publicAPI.getPiecewiseFunctionProxy(name2);
    model.property.setRGBTransferFunction(0, lutProxy.getLookupTable());
    model.property.setScalarOpacity(0, pwfProxy.getPiecewiseFunction());
    updateConfiguration(inputDataset, publicAPI.getDataArray(), model);
    if (model.sampleDistance < 0 || model.sampleDistance > 1) {
      publicAPI.setSampleDistance();
    }
    if (model.edgeGradient < 0 || model.edgeGradient > 1) {
      publicAPI.setEdgeGradient();
    }
    const state = updateDomains2(inputDataset, publicAPI.getDataArray(), model, publicAPI.updateProxyProperty);
    publicAPI.set(state);
    const numberOfDimensions = inputDataset.getDimensions().reduce((number, dimension) => number + (dimension > 1 ? 1 : 0), 0);
    if (numberOfDimensions === 2) {
      publicAPI.setIs2DVolume(true);
    }
  }
  model.sourceDependencies.push({
    setInputData
  });
  publicAPI.setIs2DVolume = (is2D) => {
    model.is2DVolume = is2D;
    if (is2D) {
      if (publicAPI.getVisibility()) {
        publicAPI.setSliceVisibility(true);
      }
      model.volume.setVisibility(false);
    }
  };
  publicAPI.isVisible = () => model.volume.getVisibility();
  publicAPI.setVisibility = (isVisible) => {
    if (isVisible) {
      if (model.is2DVolume) {
        publicAPI.setSliceVisibility(true);
      } else {
        model.volume.setVisibility(true);
      }
    } else {
      model.volume.setVisibility(false);
      publicAPI.setSliceVisibility(false);
    }
  };
  publicAPI.getVisibility = () => model.volume.getVisibility() || publicAPI.getSliceVisibility();
  publicAPI.isVisible = publicAPI.getVisibility;
  publicAPI.setSliceVisibility = (isVisible) => {
    if (isVisible && model.is2DVolume) {
      const normalAxis = publicAPI.getInputDataSet().getDimensions().indexOf(1);
      if (model.actors[normalAxis]) {
        model.actors[normalAxis].setVisibility(true);
      }
    } else {
      model.actors.forEach((actor) => actor.setVisibility(isVisible));
    }
  };
  publicAPI.getSliceVisibility = () => model.actorX.getVisibility() || model.actorY.getVisibility() || model.actorZ.getVisibility();
  publicAPI.setSampleDistance = function() {
    let distance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.4;
    if (model.sampleDistance !== distance) {
      model.sampleDistance = distance;
      const sourceDS = publicAPI.getInputDataSet();
      const sampleDistance = 0.7 * Math.sqrt(sourceDS.getSpacing().map((v) => v * v).reduce((a2, b2) => a2 + b2, 0));
      model.mapper.setSampleDistance(sampleDistance * 2 ** (distance * 3 - 1.5));
      publicAPI.modified();
    }
  };
  publicAPI.setEdgeGradient = function() {
    let edgeGradient = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.2;
    if (model.edgeGradient !== edgeGradient) {
      model.edgeGradient = edgeGradient;
      const dataArray = publicAPI.getDataArray();
      const numberOfComponents = dataArray.getNumberOfComponents();
      if (edgeGradient === 0) {
        for (let component = 0; component < numberOfComponents; component++) {
          model.volume.getProperty().setUseGradientOpacity(component, false);
        }
      } else {
        for (let component = 0; component < numberOfComponents; component++) {
          const dataRange = dataArray.getRange(component);
          model.volume.getProperty().setUseGradientOpacity(component, true);
          const minV = Math.max(0, edgeGradient - 0.3) / 0.7;
          if (minV > 0) {
            model.volume.getProperty().setGradientOpacityMinimumValue(component, Math.exp(Math.log((dataRange[1] - dataRange[0]) * 0.2) * minV * minV));
          } else {
            model.volume.getProperty().setGradientOpacityMinimumValue(component, 0);
          }
          model.volume.getProperty().setGradientOpacityMaximumValue(component, Math.exp(Math.log((dataRange[1] - dataRange[0]) * 1) * edgeGradient * edgeGradient));
        }
      }
      publicAPI.modified();
    }
  };
  const parentSetColorBy = publicAPI.setColorBy;
  publicAPI.setColorBy = function(arrayName, arrayLocation) {
    let componentIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    parentSetColorBy(arrayName, arrayLocation, componentIndex);
    const lutProxy = publicAPI.getLookupTableProxy(arrayName);
    const pwfProxy = publicAPI.getPiecewiseFunctionProxy(arrayName);
    model.property.setRGBTransferFunction(0, lutProxy.getLookupTable());
    model.property.setScalarOpacity(0, pwfProxy.getPiecewiseFunction());
  };
}
var DEFAULT_VALUES183 = {
  sampleDistance: -1,
  edgeGradient: -1,
  disableSolidColor: true,
  is2DVolume: false
};
function extend200(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES183, initialValues);
  vtkAbstractRepresentationProxy$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["sampleDistance", "edgeGradient", "cropFilter", "is2DVolume"]);
  vtkVolumeRepresentationProxy(publicAPI, model);
  macro.proxyPropertyMapping(publicAPI, model, {
    xSlice: {
      modelKey: "mapperX",
      property: "slice"
    },
    ySlice: {
      modelKey: "mapperY",
      property: "slice"
    },
    zSlice: {
      modelKey: "mapperZ",
      property: "slice"
    },
    volumeVisibility: {
      modelKey: "volume",
      property: "visibility"
    },
    xSliceVisibility: {
      modelKey: "actorX",
      property: "visibility"
    },
    ySliceVisibility: {
      modelKey: "actorY",
      property: "visibility"
    },
    zSliceVisibility: {
      modelKey: "actorZ",
      property: "visibility"
    },
    windowWidth: {
      modelKey: "propertySlices",
      property: "colorWindow"
    },
    windowLevel: {
      modelKey: "propertySlices",
      property: "colorLevel"
    },
    useShadow: {
      modelKey: "property",
      property: "shade"
    },
    croppingPlanes: {
      modelKey: "cropFilter",
      property: "croppingPlanes"
    }
  });
}
var newInstance192 = macro.newInstance(extend200, "vtkVolumeRepresentationProxy");
var vtkVolumeRepresentationProxy$1 = {
  newInstance: newInstance192,
  extend: extend200,
  updateConfiguration
};

// node_modules/@kitware/vtk.js/Proxy/Representations.js
var Representations = {
  vtkGeometryRepresentationProxy: vtkGeometryRepresentationProxy$1,
  vtkGlyphRepresentationProxy: vtkGlyphRepresentationProxy$1,
  vtkMoleculeRepresentationProxy: vtkMoleculeRepresentationProxy$1,
  vtkSkyboxRepresentationProxy: vtkSkyboxRepresentationProxy$1,
  vtkSliceRepresentationProxy: vtkSliceRepresentationProxy$1,
  vtkSlicedGeometryRepresentationProxy: vtkSlicedGeometryRepresentationProxy$1,
  vtkVolumeRepresentationProxy: vtkVolumeRepresentationProxy$1
};

// node_modules/@kitware/vtk.js/Proxy/index.js
var VTKProxy = {
  Core: Core6,
  Representations
};

// node_modules/@kitware/vtk.js/Widgets/Core/WidgetManager/Constants.js
var ViewTypes = {
  DEFAULT: 0,
  GEOMETRY: 1,
  SLICE: 2,
  VOLUME: 3,
  YZ_PLANE: 4,
  // Sagittal
  XZ_PLANE: 5,
  // Coronal
  XY_PLANE: 6
  // Axial
};
var RenderingTypes = {
  PICKING_BUFFER: 0,
  FRONT_BUFFER: 1
};
var CaptureOn = {
  MOUSE_MOVE: 0,
  MOUSE_RELEASE: 1
};
var WidgetManagerConst = {
  ViewTypes,
  RenderingTypes,
  CaptureOn
};

// node_modules/@kitware/vtk.js/Widgets/Core/AbstractWidget/Constants.js
var WIDGET_PRIORITY = 0.5;

// node_modules/@kitware/vtk.js/Widgets/Core/AbstractWidget.js
function vtkAbstractWidget(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractWidget");
  model.actorToRepresentationMap = /* @__PURE__ */ new WeakMap();
  publicAPI.getBounds = model.widgetState.getBounds;
  publicAPI.getNestedProps = () => model.representations;
  publicAPI.activateHandle = (_ref) => {
    let {
      selectedState,
      representation
    } = _ref;
    model.widgetState.activateOnly(selectedState);
    model.activeState = selectedState;
    if (selectedState && selectedState.updateManipulator) {
      selectedState.updateManipulator();
    }
    publicAPI.invokeActivateHandle({
      selectedState,
      representation
    });
    if (publicAPI.updateCursor) {
      publicAPI.updateCursor();
    }
  };
  publicAPI.deactivateAllHandles = () => {
    model.widgetState.deactivate();
  };
  publicAPI.hasActor = (actor) => model.actorToRepresentationMap.has(actor);
  publicAPI.grabFocus = () => {
    model.hasFocus = true;
  };
  publicAPI.loseFocus = () => {
    model.hasFocus = false;
  };
  publicAPI.hasFocus = () => model.hasFocus;
  publicAPI.placeWidget = (bounds2) => model.widgetState.placeWidget(bounds2);
  publicAPI.getPlaceFactor = () => model.widgetState.getPlaceFactor();
  publicAPI.setPlaceFactor = (factor) => model.widgetState.setPlaceFactor(factor);
  publicAPI.getRepresentationFromActor = (actor) => model.actorToRepresentationMap.get(actor);
  publicAPI.updateRepresentationForRender = function() {
    let renderingType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RenderingTypes.FRONT_BUFFER;
    for (let i = 0; i < model.representations.length; i++) {
      const representation = model.representations[i];
      representation.updateActorVisibility(renderingType, model.contextVisibility, model.handleVisibility);
    }
  };
  publicAPI.getViewWidgets = () => model._factory.getViewWidgets();
  publicAPI.setPriority(WIDGET_PRIORITY);
}
var DEFAULT_VALUES184 = {
  contextVisibility: true,
  handleVisibility: true,
  hasFocus: false
};
function extend201(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES184, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  vtkInteractorObserver$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["contextVisibility", "handleVisibility", "_widgetManager"]);
  macro.get(publicAPI, model, [
    "representations",
    "widgetState",
    "activeState"
    // stores the last activated sub state(handle)
  ]);
  macro.moveToProtected(publicAPI, model, ["widgetManager"]);
  macro.event(publicAPI, model, "ActivateHandle");
  vtkAbstractWidget(publicAPI, model);
}
var newInstance193 = macro.newInstance(extend201, "vtkAbstractWidget");
var vtkAbstractWidget$1 = {
  newInstance: newInstance193,
  extend: extend201
};

// node_modules/@kitware/vtk.js/Widgets/Core/WidgetManager.js
var {
  ViewTypes: ViewTypes2,
  RenderingTypes: RenderingTypes2,
  CaptureOn: CaptureOn2
} = WidgetManagerConst;
var {
  vtkErrorMacro: vtkErrorMacro74
} = macro;
var viewIdCount = 1;
function extractRenderingComponents(renderer) {
  const camera = renderer.getActiveCamera();
  const renderWindow = renderer.getRenderWindow();
  const interactor = renderWindow.getInteractor();
  const apiSpecificRenderWindow = interactor.getView();
  return {
    renderer,
    renderWindow,
    interactor,
    apiSpecificRenderWindow,
    camera
  };
}
function getPixelWorldHeightAtCoord(worldCoord, displayScaleParams) {
  const {
    dispHeightFactor,
    cameraPosition,
    cameraDir,
    isParallel,
    rendererPixelDims
  } = displayScaleParams;
  let scale = 1;
  if (isParallel) {
    scale = dispHeightFactor;
  } else {
    const worldCoordToCamera = [...worldCoord];
    vtkMath.subtract(worldCoordToCamera, cameraPosition, worldCoordToCamera);
    scale = vtkMath.dot(worldCoordToCamera, cameraDir) * dispHeightFactor;
  }
  const rHeight = rendererPixelDims[1];
  return scale / rHeight;
}
function vtkWidgetManager(publicAPI, model) {
  if (!model.viewId) {
    model.viewId = `view-${viewIdCount++}`;
  }
  model.classHierarchy.push("vtkWidgetManager");
  const propsWeakMap = /* @__PURE__ */ new WeakMap();
  const subscriptions = [];
  function updateWidgetWeakMap(widget) {
    const representations = widget.getRepresentations();
    for (let i = 0; i < representations.length; i++) {
      const representation = representations[i];
      const origin3 = {
        widget,
        representation
      };
      const actors = representation.getActors();
      for (let j = 0; j < actors.length; j++) {
        const actor = actors[j];
        propsWeakMap.set(actor, origin3);
      }
    }
  }
  function getViewWidget(widget) {
    return widget && (widget.isA("vtkAbstractWidget") ? widget : widget.getWidgetForView({
      viewId: model.viewId
    }));
  }
  function updateDisplayScaleParams() {
    const {
      _apiSpecificRenderWindow,
      _camera,
      _renderer
    } = model;
    if (_renderer && _apiSpecificRenderWindow && _camera) {
      const [rwW, rwH] = _apiSpecificRenderWindow.getSize();
      const [vxmin, vymin, vxmax, vymax] = _renderer.getViewport();
      const pixelRatio = _apiSpecificRenderWindow.getComputedDevicePixelRatio();
      const rendererPixelDims = [rwW * (vxmax - vxmin) / pixelRatio, rwH * (vymax - vymin) / pixelRatio];
      const cameraPosition = _camera.getPosition();
      const cameraDir = _camera.getDirectionOfProjection();
      const isParallel = _camera.getParallelProjection();
      const dispHeightFactor = isParallel ? 2 * _camera.getParallelScale() : 2 * Math.tan(vtkMath.radiansFromDegrees(_camera.getViewAngle()) / 2);
      model.widgets.forEach((w) => {
        w.getNestedProps().forEach((r) => {
          if (r.getScaleInPixels()) {
            r.setDisplayScaleParams({
              dispHeightFactor,
              cameraPosition,
              cameraDir,
              isParallel,
              rendererPixelDims
            });
          }
        });
      });
    }
  }
  async function updateSelection(callData, fromTouchEvent, callID) {
    const {
      position
    } = callData;
    const {
      requestCount: requestCount3,
      selectedState,
      representation,
      widget
    } = await publicAPI.getSelectedDataForXY(position.x, position.y);
    if (requestCount3 || callID !== model._currentUpdateSelectionCallID) {
      return;
    }
    function activateHandle(w) {
      if (fromTouchEvent) {
        model._interactor.invokeLeftButtonRelease(callData);
      }
      w.activateHandle({
        selectedState,
        representation
      });
      if (fromTouchEvent) {
        model._interactor.invokeLeftButtonPress(callData);
      }
    }
    const cursorStyles = publicAPI.getCursorStyles();
    const style6 = widget ? "hover" : "default";
    const cursor = cursorStyles[style6];
    if (cursor) {
      model._apiSpecificRenderWindow.setCursor(cursor);
    }
    model.activeWidget = null;
    let wantRender = false;
    if (model.widgetInFocus === widget && widget.hasFocus()) {
      activateHandle(widget);
      model.activeWidget = widget;
      wantRender = true;
    } else {
      for (let i = 0; i < model.widgets.length; i++) {
        const w = model.widgets[i];
        if (w === widget && w.getNestedPickable()) {
          activateHandle(w);
          model.activeWidget = w;
          wantRender = true;
        } else {
          wantRender || (wantRender = !!w.getActiveState());
          w.deactivateAllHandles();
        }
      }
    }
    if (wantRender) {
      model._interactor.render();
    }
  }
  const deactivateAllWidgets = () => {
    let wantRender = false;
    for (let i = 0; i < model.widgets.length; i++) {
      const w = model.widgets[i];
      wantRender || (wantRender = !!w.getActiveState());
      w.deactivateAllHandles();
    }
    if (wantRender) model._interactor.render();
  };
  const handleEvent = async function(callData) {
    let fromTouchEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!model.isAnimating && model.pickingEnabled && callData.pokedRenderer === model._renderer) {
      const callID = Symbol("UpdateSelection");
      model._currentUpdateSelectionCallID = callID;
      await updateSelection(callData, fromTouchEvent, callID);
    } else {
      deactivateAllWidgets();
    }
  };
  function updateWidgetForRender(w) {
    w.updateRepresentationForRender(model.renderingType);
  }
  function renderPickingBuffer() {
    model.renderingType = RenderingTypes2.PICKING_BUFFER;
    model.widgets.forEach(updateWidgetForRender);
  }
  function renderFrontBuffer() {
    model.renderingType = RenderingTypes2.FRONT_BUFFER;
    model.widgets.forEach(updateWidgetForRender);
  }
  async function captureBuffers(x1, y1, x2, y2) {
    if (model._captureInProgress) {
      await model._captureInProgress;
      return;
    }
    renderPickingBuffer();
    model._capturedBuffers = null;
    model._captureInProgress = model._selector.getSourceDataAsync(model._renderer, x1, y1, x2, y2);
    model._capturedBuffers = await model._captureInProgress;
    model._captureInProgress = null;
    model.previousSelectedData = null;
    renderFrontBuffer();
  }
  publicAPI.enablePicking = () => {
    model.pickingEnabled = true;
    publicAPI.renderWidgets();
  };
  publicAPI.renderWidgets = () => {
    if (model.pickingEnabled && model.captureOn === CaptureOn2.MOUSE_RELEASE) {
      const [w, h] = model._apiSpecificRenderWindow.getSize();
      captureBuffers(0, 0, w, h);
    }
    renderFrontBuffer();
    publicAPI.modified();
  };
  publicAPI.disablePicking = () => {
    model.pickingEnabled = false;
  };
  publicAPI.setRenderer = (renderer) => {
    const renderingComponents = extractRenderingComponents(renderer);
    Object.assign(model, renderingComponents);
    macro.moveToProtected({}, model, Object.keys(renderingComponents));
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    model._selector = model._apiSpecificRenderWindow.createSelector();
    model._selector.setFieldAssociation(FieldAssociations.FIELD_ASSOCIATION_POINTS);
    subscriptions.push(model._apiSpecificRenderWindow.onWindowResizeEvent(updateDisplayScaleParams));
    subscriptions.push(model._camera.onModified(updateDisplayScaleParams));
    updateDisplayScaleParams();
    subscriptions.push(model._interactor.onStartAnimation(() => {
      model.isAnimating = true;
    }));
    subscriptions.push(model._interactor.onEndAnimation(() => {
      model.isAnimating = false;
      publicAPI.renderWidgets();
    }));
    subscriptions.push(model._interactor.onMouseMove((eventData) => {
      handleEvent(eventData);
      return macro.VOID;
    }));
    subscriptions.push(model._interactor.onLeftButtonPress((eventData) => {
      const {
        deviceType
      } = eventData;
      const touchEvent = deviceType === "touch" || deviceType === "pen";
      if (touchEvent) {
        handleEvent(eventData, touchEvent);
      }
      return macro.VOID;
    }, WIDGET_PRIORITY / 2));
    publicAPI.modified();
    if (model.pickingEnabled) {
      publicAPI.enablePicking();
    }
  };
  function addWidgetInternal(viewWidget) {
    viewWidget.setWidgetManager(publicAPI);
    updateWidgetWeakMap(viewWidget);
    updateDisplayScaleParams();
    model._renderer.addActor(viewWidget);
  }
  publicAPI.addWidget = (widget, viewType, initialValues) => {
    if (!model._renderer) {
      vtkErrorMacro74("Widget manager MUST BE link to a view before registering widgets");
      return null;
    }
    const {
      viewId,
      _renderer
    } = model;
    const w = widget.getWidgetForView({
      viewId,
      renderer: _renderer,
      viewType: viewType || ViewTypes2.DEFAULT,
      initialValues
    });
    if (w != null && model.widgets.indexOf(w) === -1) {
      model.widgets.push(w);
      addWidgetInternal(w);
      publicAPI.modified();
    }
    return w;
  };
  function removeWidgetInternal(viewWidget) {
    model._renderer.removeActor(viewWidget);
    viewWidget.delete();
  }
  function onWidgetRemoved() {
    model._renderer.getRenderWindow().getInteractor().render();
    publicAPI.renderWidgets();
  }
  publicAPI.removeWidgets = () => {
    model.widgets.forEach(removeWidgetInternal);
    model.widgets = [];
    model.widgetInFocus = null;
    onWidgetRemoved();
  };
  publicAPI.removeWidget = (widget) => {
    const viewWidget = getViewWidget(widget);
    const index = model.widgets.indexOf(viewWidget);
    if (index !== -1) {
      model.widgets.splice(index, 1);
      const isWidgetInFocus = model.widgetInFocus === viewWidget;
      if (isWidgetInFocus) {
        publicAPI.releaseFocus();
      }
      removeWidgetInternal(viewWidget);
      onWidgetRemoved();
    }
  };
  publicAPI.getSelectedDataForXY = async (x, y) => {
    model.selections = null;
    if (model.pickingEnabled) {
      if (!model._capturedBuffers || model.captureOn === CaptureOn2.MOUSE_MOVE) {
        await captureBuffers(x, y, x, y);
      } else {
        const capturedRegion = model._capturedBuffers.area;
        if (x < capturedRegion[0] || x > capturedRegion[2] || y < capturedRegion[1] || y > capturedRegion[3]) {
          await captureBuffers(x, y, x, y);
        }
      }
      model.selections = model._capturedBuffers.generateSelection(x, y, x, y);
    }
    return publicAPI.getSelectedData();
  };
  publicAPI.getSelectedData = () => {
    if (!model.selections || !model.selections.length) {
      model.previousSelectedData = null;
      return {};
    }
    const {
      propID,
      compositeID,
      prop
    } = model.selections[0].getProperties();
    let {
      widget,
      representation
    } = model.selections[0].getProperties();
    if (model.previousSelectedData && model.previousSelectedData.prop === prop && model.previousSelectedData.widget === widget && model.previousSelectedData.compositeID === compositeID) {
      model.previousSelectedData.requestCount++;
      return model.previousSelectedData;
    }
    if (propsWeakMap.has(prop)) {
      const props = propsWeakMap.get(prop);
      widget = props.widget;
      representation = props.representation;
    }
    if (widget && representation) {
      const selectedState = representation.getSelectedState(prop, compositeID);
      model.previousSelectedData = {
        requestCount: 0,
        propID,
        compositeID,
        prop,
        widget,
        representation,
        selectedState
      };
      return model.previousSelectedData;
    }
    model.previousSelectedData = null;
    return {};
  };
  publicAPI.grabFocus = (widget) => {
    const viewWidget = getViewWidget(widget);
    if (model.widgetInFocus && model.widgetInFocus !== viewWidget) {
      model.widgetInFocus.loseFocus();
    }
    model.widgetInFocus = viewWidget;
    if (model.widgetInFocus) {
      model.widgetInFocus.grabFocus();
    }
  };
  publicAPI.releaseFocus = () => publicAPI.grabFocus(null);
  const superDelete = publicAPI.delete;
  publicAPI.delete = () => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    superDelete();
  };
}
var defaultValues17 = function() {
  let initialValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    // _camera: null,
    // _selector: null,
    // _currentUpdateSelectionCallID: null,
    viewId: null,
    widgets: [],
    activeWidget: null,
    renderer: null,
    viewType: ViewTypes2.DEFAULT,
    isAnimating: false,
    pickingEnabled: true,
    selections: null,
    previousSelectedData: null,
    widgetInFocus: null,
    captureOn: CaptureOn2.MOUSE_MOVE,
    ...initialValues,
    cursorStyles: initialValues.cursorStyles ? {
      ...initialValues.cursorStyles
    } : {
      default: "default",
      hover: "pointer"
    }
  };
};
function extend202(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues17(initialValues));
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["captureOn", "cursorStyles", {
    type: "enum",
    name: "viewType",
    enum: ViewTypes2
  }]);
  macro.get(publicAPI, model, ["selections", "widgets", "viewId", "pickingEnabled", "activeWidget"]);
  vtkWidgetManager(publicAPI, model);
}
var newInstance194 = macro.newInstance(extend202, "vtkWidgetManager");
var vtkWidgetManager$1 = {
  newInstance: newInstance194,
  extend: extend202,
  Constants: WidgetManagerConst,
  getPixelWorldHeightAtCoord
};

// node_modules/@kitware/vtk.js/Widgets/Core/AbstractWidgetFactory.js
function NoOp2() {
}
function vtkAbstractWidgetFactory(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractWidgetFactory");
  const viewToWidget = {};
  publicAPI.getWidgetForView = (_ref) => {
    let {
      viewId,
      renderer,
      viewType,
      initialValues
    } = _ref;
    if (!viewToWidget[viewId]) {
      if (!renderer) {
        return null;
      }
      const {
        interactor,
        apiSpecificRenderWindow,
        camera
      } = extractRenderingComponents(renderer);
      const widgetModel = {};
      const widgetPublicAPI = {};
      macro.obj(widgetPublicAPI, widgetModel);
      Object.assign(widgetPublicAPI, {
        onWidgetChange: publicAPI.onWidgetChange
      });
      Object.assign(widgetModel, {
        widgetState: model.widgetState,
        manipulator: model.manipulator,
        viewType,
        renderer,
        camera,
        apiSpecificRenderWindow,
        factory: publicAPI
      });
      macro.moveToProtected(widgetPublicAPI, widgetModel, ["renderer", "camera", "apiSpecificRenderWindow", "factory"]);
      macro.get(widgetPublicAPI, widgetModel, ["viewType"]);
      macro.safeArrays(widgetModel);
      vtkAbstractWidget$1.extend(widgetPublicAPI, widgetModel, initialValues);
      const widgetInitialValues = initialValues;
      widgetModel.representations = publicAPI.getRepresentationsForViewType(viewType).map((_ref2) => {
        let {
          builder,
          labels,
          initialValues: initialValues2
        } = _ref2;
        return builder.newInstance({
          _parentProp: widgetPublicAPI,
          labels,
          ...initialValues2,
          ...widgetInitialValues
        });
      });
      widgetModel.representations.forEach((r) => {
        r.setInputData(widgetModel.widgetState);
        r.getActors().forEach((actor) => {
          widgetModel.actorToRepresentationMap.set(actor, r);
        });
      });
      model.behavior(widgetPublicAPI, widgetModel);
      ["coincidentTopologyParameters", ...model.methodsToLink || []].forEach((methodName) => {
        const set = `set${macro.capitalize(methodName)}`;
        const get3 = `get${macro.capitalize(methodName)}`;
        const methods = {
          [methodName]: [],
          [set]: [],
          [get3]: []
        };
        widgetModel.representations.forEach((representation) => {
          if (representation[methodName]) {
            methods[methodName].push(representation[methodName]);
          }
          if (representation[set]) {
            methods[set].push(representation[set]);
          }
          if (representation[get3]) {
            methods[get3].push(representation[get3]);
          }
        });
        Object.keys(methods).forEach((name2) => {
          const calls = methods[name2];
          if (calls.length === 1) {
            widgetPublicAPI[name2] = calls[0];
          } else if (calls.length > 1) {
            widgetPublicAPI[name2] = macro.chain(...calls);
          }
        });
      });
      widgetPublicAPI.delete = macro.chain(() => {
        delete viewToWidget[viewId];
      }, widgetPublicAPI.delete);
      widgetPublicAPI.setInteractor(interactor);
      const viewWidget = Object.freeze(widgetPublicAPI);
      viewToWidget[viewId] = viewWidget;
      return viewWidget;
    }
    return viewToWidget[viewId];
  };
  publicAPI.getViewIds = () => Object.keys(viewToWidget);
  publicAPI.getViewWidgets = () => Object.values(viewToWidget);
  publicAPI.setVisibility = (value) => {
    const viewIds = Object.keys(viewToWidget);
    for (let i = 0; i < viewIds.length; i++) {
      viewToWidget[viewIds[i]].setVisibility(value);
    }
  };
  publicAPI.setPickable = (value) => {
    const viewIds = Object.keys(viewToWidget);
    for (let i = 0; i < viewIds.length; i++) {
      viewToWidget[viewIds[i]].setPickable(value);
    }
  };
  publicAPI.setDragable = (value) => {
    const viewIds = Object.keys(viewToWidget);
    for (let i = 0; i < viewIds.length; i++) {
      viewToWidget[viewIds[i]].setDragable(value);
    }
  };
  publicAPI.setContextVisibility = (value) => {
    const viewIds = Object.keys(viewToWidget);
    for (let i = 0; i < viewIds.length; i++) {
      viewToWidget[viewIds[i]].setContextVisibility(value);
    }
  };
  publicAPI.setHandleVisibility = (value) => {
    const viewIds = Object.keys(viewToWidget);
    for (let i = 0; i < viewIds.length; i++) {
      viewToWidget[viewIds[i]].setHandleVisibility(value);
    }
  };
  publicAPI.placeWidget = (bounds2) => model.widgetState.placeWidget(bounds2);
  publicAPI.getPlaceFactor = () => model.widgetState.getPlaceFactor();
  publicAPI.setPlaceFactor = (factor) => model.widgetState.setPlaceFactor(factor);
  let unsubscribe = NoOp2;
  publicAPI.delete = macro.chain(publicAPI.delete, () => unsubscribe());
  if (model.widgetState) {
    unsubscribe = model.widgetState.onModified(() => publicAPI.invokeWidgetChange(model.widgetState)).unsubscribe;
  }
}
function extend203(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["widgetState"]);
  macro.event(publicAPI, model, "WidgetChange");
  vtkAbstractWidgetFactory(publicAPI, model);
}
var newInstance195 = macro.newInstance(extend203, "vtkAbstractWidget");
var vtkAbstractWidgetFactory$1 = {
  newInstance: newInstance195,
  extend: extend203
};

// node_modules/@kitware/vtk.js/Widgets/Core/WidgetState.js
var DEFAULT_LABEL = "default";
function removeObjectInArray(array, obj2) {
  const idx = array.indexOf(obj2);
  if (idx !== -1) {
    array.splice(idx, 1);
  }
}
function vtkWidgetState(publicAPI, model) {
  model.classHierarchy.push("vtkWidgetState");
  const subscriptions = [];
  model.labels = {};
  model.nestedStates = [];
  publicAPI.bindState = function(nested) {
    let labels = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [DEFAULT_LABEL];
    model.nestedStates.push(nested);
    subscriptions.push(nested.onModified(publicAPI.modified));
    if (Array.isArray(labels) && labels.length) {
      for (let i = 0; i < labels.length; i++) {
        const label = labels[i];
        if (!model.labels[label]) {
          model.labels[label] = [];
        }
        model.labels[label].push(nested);
      }
    } else {
      const labelToUse = Array.isArray(labels) ? DEFAULT_LABEL : labels || DEFAULT_LABEL;
      if (!model.labels[labelToUse]) {
        model.labels[labelToUse] = [];
      }
      model.labels[labelToUse].push(nested);
    }
  };
  publicAPI.unbindState = (nested) => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    removeObjectInArray(model.nestedStates, nested);
    for (let i = 0; i < model.nestedStates.length; i++) {
      subscriptions.push(model.nestedStates[i].onModified(publicAPI.modified));
    }
    Object.keys(model.labels).forEach((label) => {
      const list = model.labels[label];
      removeObjectInArray(list, nested);
    });
  };
  publicAPI.unbindAll = () => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    model.nestedStates = [];
  };
  publicAPI.activate = () => publicAPI.setActive(true);
  publicAPI.deactivate = (excludingState) => {
    if (excludingState !== publicAPI) {
      publicAPI.setActive(false);
    }
    for (let i = 0; i < model.nestedStates.length; i++) {
      model.nestedStates[i].deactivate(excludingState);
    }
  };
  publicAPI.activateOnly = (subState) => {
    if (subState) {
      subState.setActive(true);
    }
    publicAPI.deactivate(subState);
  };
  publicAPI.getStatesWithLabel = (name2) => model.labels[name2];
  publicAPI.getAllNestedStates = () => model.nestedStates;
  publicAPI.delete = macro.chain(publicAPI.unbindAll, publicAPI.delete);
}
var DEFAULT_VALUES185 = {
  active: false
};
function extend204(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES185, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["active"]);
  vtkWidgetState(publicAPI, model);
}
var vtkWidgetState$1 = {
  extend: extend204
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/boundsMixin.js
function vtkBoundsMixin(publicAPI, model) {
  const sourceBounds = [];
  const bbox = [...vtkBoundingBox.INIT_BOUNDS];
  publicAPI.containsPoint = (x, y, z) => {
    if (Array.isArray(x)) {
      return vtkBoundingBox.containsPoint(bbox, x[0], x[1], x[2]);
    }
    return vtkBoundingBox.containsPoint(bbox, x, y, z);
  };
  publicAPI.placeWidget = (bounds2) => {
    model.bounds = [];
    const center = [(bounds2[0] + bounds2[1]) / 2, (bounds2[2] + bounds2[3]) / 2, (bounds2[4] + bounds2[5]) / 2];
    for (let i = 0; i < 6; i++) {
      const axisCenter = center[Math.floor(i / 2)];
      sourceBounds[i] = bounds2[i];
      model.bounds[i] = (bounds2[i] - axisCenter) * model.placeFactor + axisCenter;
    }
    vtkBoundingBox.setBounds(bbox, model.bounds);
    publicAPI.invokeBoundsChange(model.bounds);
    publicAPI.modified();
  };
  publicAPI.setPlaceFactor = (factor) => {
    if (model.placeFactor !== factor) {
      model.placeFactor = factor;
      model.bounds = [];
      const center = [(sourceBounds[0] + sourceBounds[1]) / 2, (sourceBounds[2] + sourceBounds[3]) / 2, (sourceBounds[4] + sourceBounds[5]) / 2];
      for (let i = 0; i < 6; i++) {
        const axisCenter = center[Math.floor(i / 2)];
        model.bounds[i] = (sourceBounds[i] - axisCenter) * model.placeFactor + axisCenter;
      }
      vtkBoundingBox.setBounds(bbox, model.bounds);
      publicAPI.invokeBoundsChange(model.bounds);
      publicAPI.modified();
    }
  };
}
var DEFAULT_VALUES186 = {
  bounds: [-1, 1, -1, 1, -1, 1],
  placeFactor: 1
};
function extend205(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES186, initialValues);
  macro.setGetArray(publicAPI, model, ["bounds"], 6);
  macro.get(publicAPI, model, ["placeFactor"]);
  macro.event(publicAPI, model, "BoundsChange");
  model.bounds = model.bounds.slice();
  vtkBoundsMixin(publicAPI, model);
}
var bounds = {
  extend: extend205
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/colorMixin.js
var DEFAULT_VALUES187 = {
  color: 0.5
};
function extend206(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES187, initialValues);
  macro.setGet(publicAPI, model, ["color"]);
}
var color = {
  extend: extend206
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/color3Mixin.js
var DEFAULT_VALUES188 = {
  color3: [255, 255, 255],
  opacity: 255
};
function extend207(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES188, initialValues);
  macro.setGetArray(publicAPI, model, ["color3"], 3, 255);
  macro.setGet(publicAPI, model, ["opacity"]);
}
var color3 = {
  extend: extend207
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/cornerMixin.js
function vtkCornerMixin(publicAPI, model) {
  publicAPI.translate = (dx, dy, dz) => {
    const [x, y, z] = publicAPI.getCornerByReference();
    publicAPI.setCorner(x + dx, y + dy, z + dz);
  };
}
var DEFAULT_VALUES189 = {
  corner: [0, 0, 0]
};
function extend208(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES189, initialValues);
  macro.setGetArray(publicAPI, model, ["corner"], 3);
  vtkCornerMixin(publicAPI);
}
var corner = {
  extend: extend208
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/directionMixin.js
function vtkDirectionMixin(publicAPI, model) {
  const transform = model.angleUnit === "degree" ? vtkMatrixBuilder.buildFromDegree() : vtkMatrixBuilder.buildFromRadian();
  publicAPI.rotateFromDirections = (originDirection, targetDirection) => {
    transform.identity().rotateFromDirections(originDirection, targetDirection).apply(model.direction);
    publicAPI.modified();
  };
  publicAPI.rotate = (angle, axis) => {
    transform.identity().rotate(angle, axis).apply(model.direction);
  };
  publicAPI.rotateX = (angle) => {
    transform.identity().rotateX(angle).apply(model.direction);
  };
  publicAPI.rotateY = (angle) => {
    transform.identity().rotateY(angle).apply(model.direction);
  };
  publicAPI.rotateZ = (angle) => {
    transform.identity().rotateZ(angle).apply(model.direction);
  };
}
var DEFAULT_VALUES190 = {
  direction: [1, 0, 0]
};
function extend209(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES190, initialValues);
  macro.setGetArray(publicAPI, model, ["direction"], 3);
  vtkDirectionMixin(publicAPI, model);
}
var direction = {
  extend: extend209
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/manipulatorMixin.js
function vtkManipulatorMixin(publicAPI, model) {
  publicAPI.updateManipulator = () => {
    if (model.manipulator) {
      const {
        origin: origin3,
        normal,
        direction: direction3
      } = model;
      const {
        setHandleOrigin,
        setHandleCenter,
        setHandleNormal,
        setHandleDirection
      } = model.manipulator;
      if (origin3 && setHandleOrigin) {
        setHandleOrigin(origin3);
      } else if (origin3 && setHandleCenter) {
        setHandleCenter(origin3);
      }
      if (direction3 && setHandleDirection) {
        setHandleDirection(direction3);
      } else if (direction3 && !normal && setHandleNormal) {
        setHandleNormal(direction3);
      } else if (normal && setHandleDirection) {
        setHandleDirection(normal);
      }
    }
  };
}
var DEFAULT_VALUES191 = {
  manipulator: null
};
function extend210(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES191, initialValues);
  macro.setGet(publicAPI, model, ["manipulator"]);
  vtkManipulatorMixin(publicAPI, model);
}
var manipulator = {
  extend: extend210
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/nameMixin.js
var DEFAULT_VALUES192 = {
  name: ""
};
function extend211(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES192, initialValues);
  macro.setGet(publicAPI, model, ["name"]);
}
var name = {
  extend: extend211
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/orientationMixin.js
function eq(v1, v2) {
  return v1.length === 3 && v2.length === 3 && v1[0] === v2[0] && v1[1] === v2[1] && v1[2] === v2[2];
}
function isSame(o, p1, p2, before) {
  return eq(o, before.o) && eq(p1, before.p1) && eq(p2, before.p2);
}
function vtkOrientationMixin(publicAPI, model) {
  const previousPoints = {
    o: [],
    p1: [],
    p2: []
  };
  publicAPI.normalize = () => {
    normalize(model.up);
    normalize(model.right);
    normalize(model.direction);
    publicAPI.modified();
  };
  publicAPI.updateFromOriginRightUp = (o, p1, p2) => {
    if (isSame(o, p1, p2, previousPoints)) {
      return;
    }
    previousPoints.o = o.slice();
    previousPoints.p1 = p1.slice();
    previousPoints.p2 = p2.slice();
    model.up = [p2[0] - o[0], p2[1] - o[1], p2[2] - o[2]];
    model.right = [p1[0] - o[0], p1[1] - o[1], p1[2] - o[2]];
    cross(model.up, model.right, model.direction);
    cross(model.direction, model.up, model.right);
    publicAPI.normalize();
    publicAPI.modified();
  };
}
var DEFAULT_VALUES193 = {
  up: [0, 1, 0],
  right: [1, 0, 0],
  direction: [0, 0, 1]
};
function extend212(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES193, initialValues);
  macro.setGetArray(publicAPI, model, ["up", "right", "direction"], 3);
  vtkOrientationMixin(publicAPI, model);
}
var orientation2 = {
  extend: extend212
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/originMixin.js
function vtkOriginMixin(publicAPI, model) {
  const superClass = {
    ...publicAPI
  };
  publicAPI.translate = (dx, dy, dz) => {
    const [x, y, z] = publicAPI.getOriginByReference();
    publicAPI.setOrigin(x + dx, y + dy, z + dz);
  };
  publicAPI.getOrigin = (displayScaleParams) => {
    const origin3 = superClass.getOrigin();
    if (!model.offset) {
      return origin3;
    }
    if (!displayScaleParams) {
      return vtkMath.add(origin3, model.offset, origin3);
    }
    const pixelWorldHeight = getPixelWorldHeightAtCoord(origin3, displayScaleParams);
    const {
      rendererPixelDims
    } = displayScaleParams;
    const totalSize = Math.min(rendererPixelDims[0], rendererPixelDims[1]);
    return vtkMath.multiplyAccumulate(origin3, model.offset, totalSize * pixelWorldHeight, origin3);
  };
}
var DEFAULT_VALUES194 = {
  origin: null,
  offset: null
};
function extend213(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES194, initialValues);
  macro.setGetArray(publicAPI, model, ["origin", "offset"], 3);
  vtkOriginMixin(publicAPI, model);
}
var origin = {
  extend: extend213
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/scale1Mixin.js
var DEFAULT_VALUES195 = {
  scale1: 0.5
};
function extend214(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES195, initialValues);
  macro.setGet(publicAPI, model, ["scale1"]);
}
var scale1 = {
  extend: extend214
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/scale3Mixin.js
var DEFAULT_VALUES196 = {
  scale3: [1, 1, 1]
};
function extend215(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES196, initialValues);
  macro.setGetArray(publicAPI, model, ["scale3"], 3);
}
var scale3 = {
  extend: extend215
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/textMixin.js
var DEFAULT_VALUES197 = {
  text: "DefaultText"
};
function extend216(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES197, initialValues);
  macro.setGet(publicAPI, model, ["text"]);
}
var text = {
  extend: extend216
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/visibleMixin.js
var DEFAULT_VALUES198 = {
  visible: true
};
function extend217(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES198, initialValues);
  macro.setGet(publicAPI, model, ["visible"]);
  publicAPI.isVisible = publicAPI.getVisible;
}
var visible = {
  extend: extend217
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder/shapeMixin.js
var DEFAULT_VALUES199 = {
  shape: ""
};
function extend218(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES199, initialValues);
  macro.setGet(publicAPI, model, ["shape"]);
}
var shape = {
  extend: extend218
};

// node_modules/@kitware/vtk.js/Widgets/Core/StateBuilder.js
var {
  vtkErrorMacro: vtkErrorMacro75
} = macro;
var MIXINS = {
  bounds,
  color,
  color3,
  corner,
  direction,
  manipulator,
  name,
  orientation: orientation2,
  origin,
  scale1,
  scale3,
  text,
  visible,
  shape
};
function newInstance196(mixins, initialValues) {
  let publicAPI = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let model = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  let skipWidgetState = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  if (!skipWidgetState) {
    vtkWidgetState$1.extend(publicAPI, model, initialValues);
  }
  for (let i = 0; i < mixins.length; i++) {
    const mixin = MIXINS[mixins[i]];
    if (mixin) {
      mixin.extend(publicAPI, model, initialValues);
    } else {
      vtkErrorMacro75("Invalid mixin name:", mixins[i]);
    }
  }
  macro.safeArrays(model);
  return Object.freeze(publicAPI);
}
var Builder = class {
  constructor() {
    this.publicAPI = {};
    this.model = {};
    vtkWidgetState$1.extend(this.publicAPI, this.model);
    bounds.extend(this.publicAPI, this.model);
  }
  /* eslint-disable no-shadow */
  addDynamicMixinState(_ref) {
    let {
      labels,
      mixins,
      name: name2,
      initialValues
    } = _ref;
    const listName = `${name2}List`;
    this.model[listName] = [];
    this.publicAPI[`add${macro.capitalize(name2)}`] = (values) => {
      const instance = newInstance196(mixins, {
        ...initialValues,
        ...values
      });
      this.publicAPI.bindState(instance, labels);
      this.model[listName].push(instance);
      this.publicAPI.modified();
      return instance;
    };
    this.publicAPI[`remove${macro.capitalize(name2)}`] = (instanceOrIndex) => {
      let removeIndex = this.model[listName].indexOf(instanceOrIndex);
      if (removeIndex === -1 && instanceOrIndex < this.model[listName].length) {
        removeIndex = instanceOrIndex;
      }
      const instance = this.model[listName][removeIndex];
      if (instance) {
        this.publicAPI.unbindState(instance);
      }
      this.model[listName].splice(removeIndex, 1);
      this.publicAPI.modified();
    };
    this.publicAPI[`get${macro.capitalize(name2)}List`] = () => this.model[listName].slice();
    this.publicAPI[`clear${macro.capitalize(name2)}List`] = () => {
      while (this.model[listName].length) {
        const instance = this.model[listName].pop();
        if (instance) {
          this.publicAPI.unbindState(instance);
        }
      }
      this.publicAPI.modified();
    };
    return this;
  }
  addStateFromMixin(_ref2) {
    let {
      labels,
      mixins,
      name: name2,
      initialValues
    } = _ref2;
    const instance = newInstance196(mixins, initialValues);
    this.model[name2] = instance;
    this.publicAPI.bindState(instance, labels);
    macro.setGet(this.publicAPI, this.model, [name2]);
    return this;
  }
  addStateFromInstance(_ref3) {
    let {
      labels,
      name: name2,
      instance
    } = _ref3;
    this.model[name2] = instance;
    this.publicAPI.bindState(instance, labels);
    macro.setGet(this.publicAPI, this.model, [name2]);
    return this;
  }
  addField(_ref4) {
    let {
      name: name2,
      initialValue
    } = _ref4;
    if (Array.isArray(initialValue)) {
      macro.setGetArray(this.publicAPI, this.model, [name2], initialValue.length);
    } else {
      macro.setGet(this.publicAPI, this.model, [name2]);
    }
    this.model[name2] = initialValue;
    return this;
  }
  build() {
    for (var _len = arguments.length, mixins = new Array(_len), _key = 0; _key < _len; _key++) {
      mixins[_key] = arguments[_key];
    }
    return newInstance196(mixins, {}, this.publicAPI, this.model, true);
  }
};
function createBuilder() {
  return new Builder();
}
var vtkStateBuilder = {
  createBuilder
};

// node_modules/@kitware/vtk.js/Widgets/Core.js
var Core7 = {
  vtkAbstractWidget: vtkAbstractWidget$1,
  vtkAbstractWidgetFactory: vtkAbstractWidgetFactory$1,
  vtkStateBuilder,
  vtkWidgetManager: vtkWidgetManager$1,
  vtkWidgetState: vtkWidgetState$1
};

// node_modules/@kitware/vtk.js/Widgets/Manipulators/AbstractManipulator.js
function vtkAbstractManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractManipulator");
  model._prevWorldCoords = [];
  publicAPI.getOrigin = (callData) => {
    if (model.userOrigin) return model.userOrigin;
    if (model.useCameraFocalPoint) return callData.pokedRenderer.getActiveCamera().getFocalPoint();
    if (model.handleOrigin) return model.handleOrigin;
    if (model.widgetOrigin) return model.widgetOrigin;
    return [0, 0, 0];
  };
  publicAPI.getNormal = (callData) => {
    if (model.userNormal) return model.userNormal;
    if (model.useCameraNormal) return callData.pokedRenderer.getActiveCamera().getDirectionOfProjection();
    if (model.handleNormal) return model.handleNormal;
    if (model.widgetNormal) return model.widgetNormal;
    return [0, 0, 1];
  };
  model._computeDeltaFromPrevCoords = (curWorldCoords) => {
    var _a;
    if (!((_a = model._prevWorldCoords) == null ? void 0 : _a.length) || !(curWorldCoords == null ? void 0 : curWorldCoords.length)) return [0, 0, 0];
    return subtract(curWorldCoords, model._prevWorldCoords, []);
  };
  model._addWorldDeltas = (manipulatorResults) => {
    const {
      worldCoords: curWorldCoords
    } = manipulatorResults;
    const worldDelta = model._computeDeltaFromPrevCoords(curWorldCoords);
    if (curWorldCoords) model._prevWorldCoords = curWorldCoords;
    const deltas = {
      worldDelta
    };
    return {
      ...manipulatorResults,
      ...deltas
    };
  };
}
var DEFAULT_VALUES200 = {
  // userOrigin: null,
  // handleOrigin: null,
  // widgetOrigin: null,
  // userNormal: null,
  // handleNormal: null,
  // widgetNormal: null
  useCameraFocalPoint: false,
  useCameraNormal: false
};
function extend219(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES200, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["useCameraFocalPoint", "useCameraNormal"]);
  macro.setGetArray(publicAPI, model, ["userOrigin", "handleOrigin", "widgetOrigin", "userNormal", "handleNormal", "widgetNormal"], 3);
  vtkAbstractManipulator(publicAPI, model);
}
var newInstance197 = macro.newInstance(extend219, "vtkAbstractManipulator");
var vtkAbstractManipulator$1 = {
  extend: extend219,
  newInstance: newInstance197
};

// node_modules/@kitware/vtk.js/Widgets/Manipulators/PickerManipulator.js
function vtkPickerManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkPickerManipulator");
  publicAPI.handleEvent = (callData) => {
    const {
      position,
      pokedRenderer
    } = callData;
    model.picker.pick([position.x, position.y, 0], pokedRenderer);
    if (model.picker.getPickedPositions().length > 0) {
      model.position = model.picker.getPickedPositions()[0];
    } else {
      model.position = null;
    }
    return model._addWorldDeltas({
      worldCoords: model.position
    });
  };
}
function defaultValues18(initialValues) {
  if (!initialValues.picker) {
    const picker = vtkCellPicker$1.newInstance();
    picker.initializePickList();
    picker.setPickFromList(true);
    picker.setTolerance(0);
    initialValues.picker = picker;
  }
  return {
    ...initialValues
  };
}
function extend220(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkAbstractManipulator$1.extend(publicAPI, model, defaultValues18(initialValues));
  macro.setGet(publicAPI, model, ["picker"]);
  vtkPickerManipulator(publicAPI, model);
}
var newInstance198 = macro.newInstance(extend220, "vtkPickerManipulator");
var vtkPickerManipulator$1 = {
  extend: extend220,
  newInstance: newInstance198
};

// node_modules/@kitware/vtk.js/Widgets/Manipulators/LineManipulator.js
function projectDisplayToLine(x, y, lineOrigin, lineDirection, renderer, glRenderWindow) {
  const dotProduct = Math.abs(dot(renderer.getActiveCamera().getViewPlaneNormal(), lineDirection));
  if (1 - dotProduct < EPSILON) {
    return [];
  }
  const near = glRenderWindow.displayToWorld(x, y, 0, renderer);
  const far = glRenderWindow.displayToWorld(x, y, 1, renderer);
  const viewDir = [0, 0, 0];
  subtract(far, near, viewDir);
  const normal = [0, 0, 0];
  cross(lineDirection, viewDir, normal);
  cross(normal, viewDir, normal);
  const numerator = dot([near[0] - lineOrigin[0], near[1] - lineOrigin[1], near[2] - lineOrigin[2]], normal);
  const denominator = dot(normal, lineDirection);
  const result = lineDirection.slice();
  if (denominator === 0) {
    multiplyScalar(result, 0);
  } else {
    multiplyScalar(result, numerator / denominator);
  }
  add(lineOrigin, result, result);
  return result;
}
function vtkLineManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkLineManipulator");
  publicAPI.handleEvent = (callData, glRenderWindow) => model._addWorldDeltas({
    worldCoords: projectDisplayToLine(callData.position.x, callData.position.y, publicAPI.getOrigin(callData), publicAPI.getNormal(callData), callData.pokedRenderer, glRenderWindow)
  });
}
function defaultValues19(initialValues) {
  return {
    ...initialValues
  };
}
function extend221(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkAbstractManipulator$1.extend(publicAPI, model, defaultValues19(initialValues));
  vtkLineManipulator(publicAPI, model);
}
var newInstance199 = macro.newInstance(extend221, "vtkLineManipulator");
var vtkLineManipulator$1 = {
  projectDisplayToLine,
  extend: extend221,
  newInstance: newInstance199
};

// node_modules/@kitware/vtk.js/Widgets/Manipulators/PlaneManipulator.js
function intersectDisplayWithPlane(x, y, planeOrigin, planeNormal, renderer, glRenderWindow) {
  const near = glRenderWindow.displayToWorld(x, y, 0, renderer);
  const far = glRenderWindow.displayToWorld(x, y, 1, renderer);
  return vtkPlane$1.intersectWithLine(near, far, planeOrigin, planeNormal).x;
}
function vtkPlaneManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkPlaneManipulator");
  publicAPI.handleEvent = (callData, glRenderWindow) => model._addWorldDeltas({
    worldCoords: intersectDisplayWithPlane(callData.position.x, callData.position.y, publicAPI.getOrigin(callData), publicAPI.getNormal(callData), callData.pokedRenderer, glRenderWindow)
  });
}
function defaultValues20(initialValues) {
  return {
    ...initialValues
  };
}
function extend222(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkAbstractManipulator$1.extend(publicAPI, model, defaultValues20(initialValues));
  vtkPlaneManipulator(publicAPI, model);
}
var newInstance200 = macro.newInstance(extend222, "vtkPlaneManipulator");
var vtkPlaneManipulator$1 = {
  intersectDisplayWithPlane,
  extend: extend222,
  newInstance: newInstance200
};

// node_modules/@kitware/vtk.js/Widgets/Manipulators/TrackballManipulator.js
function trackballRotate(prevX, prevY, curX, curY, origin3, direction3, renderer, glRenderWindow) {
  const dx = curX - prevX;
  const dy = curY - prevY;
  const camera = renderer.getActiveCamera();
  const viewUp = camera.getViewUp();
  const dop = camera.getDirectionOfProjection();
  const size = renderer.getRenderWindow().getInteractor().getView().getViewportSize(renderer);
  const xdeg = 360 * dx / size[0];
  const ydeg = 360 * dy / size[1];
  const newDirection = new Float64Array([direction3[0], direction3[1], direction3[2]]);
  const xDisplayAxis = viewUp;
  const yDisplayAxis = [0, 0, 0];
  cross(dop, viewUp, yDisplayAxis);
  const rot = mat4_exports.identity(new Float64Array(16));
  mat4_exports.rotate(rot, rot, radiansFromDegrees(xdeg), xDisplayAxis);
  mat4_exports.rotate(rot, rot, radiansFromDegrees(-ydeg), yDisplayAxis);
  vec3_exports.transformMat4(newDirection, newDirection, rot);
  return newDirection;
}
function vtkTrackballManipulator(publicAPI, model) {
  model.classHierarchy.push("vtkTrackballManipulator");
  let prevX = 0;
  let prevY = 0;
  publicAPI.handleEvent = (callData, glRenderWindow) => {
    const newDirection = trackballRotate(prevX, prevY, callData.position.x, callData.position.y, publicAPI.getOrigin(callData), publicAPI.getNormal(callData), callData.pokedRenderer);
    prevX = callData.position.x;
    prevY = callData.position.y;
    return model._addWorldDeltas({
      worldCoords: newDirection
    });
  };
  publicAPI.reset = (callData) => {
    prevX = callData.position.x;
    prevY = callData.position.y;
  };
}
function defaultValues21(initialValues) {
  return {
    ...initialValues
  };
}
function extend223(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkAbstractManipulator$1.extend(publicAPI, model, defaultValues21(initialValues));
  vtkTrackballManipulator(publicAPI, model);
}
var newInstance201 = macro.newInstance(extend223, "vtkTrackballManipulator");
var vtkTrackballManipulator$1 = {
  trackballRotate,
  extend: extend223,
  newInstance: newInstance201
};

// node_modules/@kitware/vtk.js/Widgets/Manipulators.js
var Manipulators2 = {
  vtkPickerManipulator: vtkPickerManipulator$1,
  vtkLineManipulator: vtkLineManipulator$1,
  vtkPlaneManipulator: vtkPlaneManipulator$1,
  vtkTrackballManipulator: vtkTrackballManipulator$1
};

// node_modules/@kitware/vtk.js/Widgets/Representations/WidgetRepresentation/Constants.js
var Behavior = {
  HANDLE: 0,
  CONTEXT: 1
};

// node_modules/@kitware/vtk.js/Widgets/Representations/WidgetRepresentation.js
var {
  vtkErrorMacro: vtkErrorMacro76,
  vtkWarningMacro: vtkWarningMacro19
} = macro;
var STYLE_CATEGORIES = ["active", "inactive", "static"];
function applyCoincidentTopologyParametersToMapper(mapper, parameters) {
  if (mapper && mapper.setResolveCoincidentTopologyToPolygonOffset) {
    mapper.setResolveCoincidentTopologyToPolygonOffset();
    CATEGORIES.forEach((category) => {
      if (parameters[category]) {
        const methodName = `setRelativeCoincidentTopology${category}OffsetParameters`;
        if (mapper[methodName]) {
          const {
            factor,
            offset
          } = parameters[category];
          mapper[methodName](factor, offset);
        }
      }
    });
  }
}
function mergeStyles(elementNames) {
  for (var _len = arguments.length, stylesToMerge = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    stylesToMerge[_key - 1] = arguments[_key];
  }
  const newStyleObject = {
    active: {},
    inactive: {},
    static: {}
  };
  STYLE_CATEGORIES.forEach((category) => {
    const cat = newStyleObject[category];
    elementNames.forEach((name2) => {
      if (!cat[name2]) {
        cat[name2] = {};
      }
      stylesToMerge.filter((s) => s && s[category] && s[category][name2]).forEach((s) => Object.assign(cat[name2], s[category][name2]));
    });
  });
  return newStyleObject;
}
function applyStyles(pipelines, styles, activeActor) {
  if (!activeActor) {
    Object.keys(styles.static).forEach((name2) => {
      if (pipelines[name2]) {
        pipelines[name2].actor.getProperty().set(styles.static[name2]);
      }
    });
    Object.keys(styles.inactive).forEach((name2) => {
      if (pipelines[name2]) {
        pipelines[name2].actor.getProperty().set(styles.inactive[name2]);
      }
    });
  } else {
    Object.keys(pipelines).forEach((name2) => {
      const style6 = pipelines[name2].actor === activeActor ? styles.active[name2] : styles.inactive[name2];
      if (style6) {
        pipelines[name2].actor.getProperty().set(style6);
      }
    });
  }
}
function connectPipeline(pipeline) {
  let source = pipeline.source;
  if (pipeline.filter) {
    if (source.isA("vtkDataSet")) {
      pipeline.filter.setInputData(source);
    } else {
      pipeline.filter.setInputConnection(source.getOutputPort());
    }
    source = pipeline.filter;
  }
  if (source) {
    if (source.isA("vtkDataSet")) {
      pipeline.mapper.setInputData(source);
    } else {
      pipeline.mapper.setInputConnection(source.getOutputPort());
    }
  }
  if (pipeline.glyph) {
    pipeline.mapper.setInputConnection(pipeline.glyph.getOutputPort(), 1);
  }
  pipeline.actor.setMapper(pipeline.mapper);
}
function allocateArray(polyData, name2, numberOfTuples, dataType, numberOfComponents) {
  var _a;
  let dataArray = ((_a = polyData[`get${macro.capitalize(name2)}`]) == null ? void 0 : _a.call(polyData)) || polyData.getPointData().getArrayByName(name2);
  if (!dataArray || dataType !== void 0 && dataArray.getDataType() !== dataType || numberOfComponents !== void 0 && dataArray.getNumberOfComponents() !== numberOfComponents) {
    let arrayType = vtkDataArray$1;
    let arrayDataType = dataType;
    let arrayNumberOfComponents = numberOfComponents;
    if (name2 === "points") {
      arrayType = vtkPoints$1;
      arrayDataType = arrayDataType ?? "Float32Array";
      arrayNumberOfComponents = numberOfComponents ?? 3;
    } else if (POLYDATA_FIELDS.includes(name2)) {
      arrayType = vtkCellArray$1;
      arrayDataType = arrayDataType ?? "Uint16Array";
      arrayNumberOfComponents = numberOfComponents ?? 1;
    } else {
      arrayDataType = arrayDataType ?? "Float32Array";
      arrayNumberOfComponents = numberOfComponents ?? 1;
    }
    dataArray = arrayType.newInstance({
      name: name2,
      dataType: arrayDataType,
      numberOfComponents: arrayNumberOfComponents,
      size: arrayNumberOfComponents * numberOfTuples,
      empty: numberOfTuples === 0
    });
    if (name2 === "points" || POLYDATA_FIELDS.includes(name2)) {
      polyData[`set${macro.capitalize(name2)}`](dataArray);
    } else {
      polyData.getPointData().addArray(dataArray);
    }
  } else if (dataArray.getNumberOfTuples() !== numberOfTuples) {
    dataArray.resize(numberOfTuples);
  }
  return dataArray;
}
function vtkWidgetRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkWidgetRepresentation");
  const cache = {
    mtimes: {},
    states: []
  };
  model._onCoincidentTopologyParametersChanged = () => {
    publicAPI.getActors().forEach((actor) => {
      applyCoincidentTopologyParametersToMapper(actor.getMapper(), model.coincidentTopologyParameters);
    });
  };
  publicAPI.getActors = () => model.actors;
  publicAPI.getNestedProps = publicAPI.getActors;
  publicAPI.setLabels = function() {
    for (var _len2 = arguments.length, labels = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      labels[_key2] = arguments[_key2];
    }
    if (labels.length === 1) {
      model.labels = [].concat(labels[0]);
    } else {
      model.labels = labels;
    }
    publicAPI.modified();
  };
  publicAPI.getRepresentationStates = function() {
    let input = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.inputData[0];
    if (cache.mtimes.representation === publicAPI.getMTime() && cache.mtimes.input === input.getMTime()) {
      return cache.states;
    }
    cache.mtimes.representation = publicAPI.getMTime();
    cache.mtimes.input = input.getMTime();
    cache.states = [];
    model.labels.forEach((name2) => {
      cache.states = cache.states.concat(input.getStatesWithLabel(name2) || []);
    });
    return cache.states;
  };
  publicAPI.getSelectedState = (prop, compositeID) => {
    const representationStates = publicAPI.getRepresentationStates();
    if (compositeID < representationStates.length) {
      return representationStates[compositeID];
    }
    vtkErrorMacro76(`Representation ${publicAPI.getClassName()} should implement getSelectedState(prop, compositeID) method.`);
    return null;
  };
  publicAPI.updateActorVisibility = function() {
    let renderingType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RenderingTypes.FRONT_BUFFER;
    let ctxVisible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let handleVisible = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let otherFlag = true;
    switch (model.behavior) {
      case Behavior.HANDLE:
        otherFlag = renderingType === RenderingTypes.PICKING_BUFFER || handleVisible;
        break;
      case Behavior.CONTEXT:
        otherFlag = ctxVisible;
        break;
      default:
        otherFlag = true;
        break;
    }
    const visibilityFlag = otherFlag;
    for (let i = 0; i < model.actors.length; i++) {
      if (model.visibilityFlagArray) {
        model.actors[i].setVisibility(visibilityFlag && model.visibilityFlagArray[i]);
      } else {
        model.actors[i].setVisibility(visibilityFlag);
      }
    }
    if (model.alwaysVisibleActors) {
      for (let i = 0; i < model.alwaysVisibleActors.length; i++) {
        model.alwaysVisibleActors[i].setVisibility(true);
      }
    }
  };
  model.actors.push = function() {
    vtkWarningMacro19("You should use publicAPI.addActor() to initialize the actor properly");
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    args.forEach((actor) => publicAPI.addActor(actor));
  };
  publicAPI.addActor = (actor) => {
    applyCoincidentTopologyParametersToMapper(actor.getMapper(), model.coincidentTopologyParameters);
    Array.prototype.push.apply(model.actors, [actor]);
  };
  publicAPI.setLabels(model.labels);
}
function defaultValues22(initialValues) {
  return {
    activeScaleFactor: 1.2,
    activeColor: 1,
    useActiveColor: true,
    actors: [],
    labels: [],
    behavior: Behavior.CONTEXT,
    coincidentTopologyParameters: {
      Point: {
        factor: -1,
        offset: -1
      },
      Line: {
        factor: -1,
        offset: -1
      },
      Polygon: {
        factor: -1,
        offset: -1
      }
    },
    scaleInPixels: false,
    displayScaleParams: {
      dispHeightFactor: 1,
      cameraPosition: [0, 0, 0],
      cameraDir: [1, 0, 0],
      isParallel: false,
      rendererPixelDims: [1, 1]
    },
    _internalArrays: {},
    ...initialValues
  };
}
function extend224(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkProp$1.extend(publicAPI, model, defaultValues22(initialValues));
  macro.algo(publicAPI, model, 1, 1);
  macro.get(publicAPI, model, ["labels", "displayScaleParams", "coincidentTopologyParameters"]);
  macro.set(publicAPI, model, [{
    type: "object",
    name: "displayScaleParams"
  }, {
    type: "object",
    name: "coincidentTopologyParameters"
  }]);
  macro.setGet(publicAPI, model, ["scaleInPixels", "activeScaleFactor", "activeColor", "useActiveColor"]);
  vtkWidgetRepresentation(publicAPI, model);
}
var vtkWidgetRepresentation$1 = {
  extend: extend224,
  mergeStyles,
  applyStyles,
  connectPipeline
};

// node_modules/@kitware/vtk.js/Widgets/Representations/HandleRepresentation.js
function vtkHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkHandleRepresentation");
}
var DEFAULT_VALUES201 = {
  behavior: Behavior.HANDLE,
  pickable: true,
  dragable: true,
  scaleInPixels: true
};
function extend225(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const newDefault = {
    ...DEFAULT_VALUES201,
    ...initialValues
  };
  vtkWidgetRepresentation$1.extend(publicAPI, model, newDefault);
  vtkHandleRepresentation(publicAPI, model);
}
var vtkHandleRepresentation$1 = {
  extend: extend225
};

// node_modules/@kitware/vtk.js/Widgets/Representations/ContextRepresentation.js
function vtkContextRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkContextRepresentation");
}
var DEFAULT_VALUES202 = {
  behavior: Behavior.CONTEXT,
  pickable: false,
  dragable: true
};
function extend226(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const newDefault = {
    ...DEFAULT_VALUES202,
    ...initialValues
  };
  vtkWidgetRepresentation$1.extend(publicAPI, model, newDefault);
  vtkContextRepresentation(publicAPI, model);
}
var vtkContextRepresentation$1 = {
  extend: extend226
};

// node_modules/@kitware/vtk.js/Widgets/Representations/GlyphRepresentation.js
function origin2(publicAPI, model) {
  return (polyData, states) => {
    const points = allocateArray(polyData, "points", states.length).getData();
    let j = 0;
    for (let i = 0; i < states.length; ++i) {
      const coord = states[i].getOrigin(model.scaleInPixels && model.displayScaleParams);
      points[j++] = coord[0];
      points[j++] = coord[1];
      points[j++] = coord[2];
    }
  };
}
function noPosition(publicAPI, model) {
  return (polyData, states) => {
    allocateArray(polyData, "points", 0);
  };
}
function color32(publicAPI, model) {
  return (polyData, states) => {
    model._pipeline.mapper.setColorByArrayName("color");
    const colorArray = allocateArray(
      polyData,
      "color",
      states.length,
      "Uint8Array",
      // RGBA
      4
    );
    const colors = colorArray.getData();
    let j = 0;
    for (let i = 0; i < states.length; ++i) {
      let c3 = states[i].getColor3();
      if (states[i].getActive() && model.useActiveColor) {
        c3 = model.activeColor;
      }
      colors[j++] = c3[0];
      colors[j++] = c3[1];
      colors[j++] = c3[2];
      colors[j++] = states[i].getOpacity();
    }
    colorArray.dataChange();
  };
}
function color2(publicAPI, model) {
  return (polyData, states) => {
    model._pipeline.mapper.setColorByArrayName("color");
    const colors = allocateArray(polyData, "color", states.length).getData();
    for (let i = 0; i < states.length; ++i) {
      let c2 = states[i].getColor();
      if (states[i].getActive() && model.useActiveColor) {
        c2 = model.activeColor;
      }
      colors[i] = c2;
    }
  };
}
function noColor(publicAPI, model) {
  return (polyData, states) => {
    model._pipeline.mapper.setColorByArrayName(null);
  };
}
function scale32(publicAPI, model) {
  return (polyData, states) => {
    var _a;
    model._pipeline.mapper.setScaleArray("scale");
    model._pipeline.mapper.setScaleFactor(1);
    model._pipeline.mapper.setScaling(true);
    model._pipeline.mapper.setScaleMode(vtkGlyph3DMapper$1.ScaleModes.SCALE_BY_COMPONENTS);
    const scales = allocateArray(polyData, "scale", states.length, "Float32Array", 3).getData();
    let j = 0;
    for (let i = 0; i < states.length; ++i) {
      const state = states[i];
      let scaleFactor = state.getActive() ? model.activeScaleFactor : 1;
      if (publicAPI.getScaleInPixels()) {
        scaleFactor *= getPixelWorldHeightAtCoord(state.getOrigin(), model.displayScaleParams);
      }
      const scale = ((_a = state.getScale3) == null ? void 0 : _a.call(state)) ?? model.defaultScale;
      scales[j++] = scaleFactor * scale[0];
      scales[j++] = scaleFactor * scale[1];
      scales[j++] = scaleFactor * scale[2];
    }
  };
}
function scale12(publicAPI, model) {
  return (polyData, states) => {
    var _a;
    model._pipeline.mapper.setScaleArray("scale");
    model._pipeline.mapper.setScaleFactor(1);
    model._pipeline.mapper.setScaling(true);
    const scales = allocateArray(polyData, "scale", states.length).getData();
    for (let i = 0; i < states.length; ++i) {
      const state = states[i];
      let scaleFactor = state.getActive() ? model.activeScaleFactor : 1;
      if (publicAPI.getScaleInPixels()) {
        scaleFactor *= getPixelWorldHeightAtCoord(state.getOrigin(), model.displayScaleParams);
      }
      const scale = ((_a = state.getScale1) == null ? void 0 : _a.call(state)) ?? model.defaultScale;
      scales[i] = scaleFactor * scale;
    }
  };
}
function noScale(publicAPI, model) {
  return (polyData, states) => {
    model._pipeline.mapper.setScaleArray(null);
    model._pipeline.mapper.setScaleFactor(model.defaultScale);
    model._pipeline.mapper.setScaling(model.defaultScale !== 1);
  };
}
function direction2(publicAPI, model) {
  return (polyData, states) => {
    model._pipeline.mapper.setOrientationArray("orientation");
    model._pipeline.mapper.setOrientationMode(OrientationModes.MATRIX);
    const orientation3 = allocateArray(polyData, "orientation", states.length, "Float64Array", 9).getData();
    for (let i = 0; i < states.length; ++i) {
      const state = states[i];
      const right = state.getRight ? state.getRight() : [1, 0, 0];
      const up = state.getUp ? state.getUp() : [0, 1, 0];
      const dir = state.getDirection ? state.getDirection() : [0, 0, 1];
      orientation3.set(right, 9 * i);
      orientation3.set(up, 9 * i + 3);
      orientation3.set(dir, 9 * i + 6);
    }
  };
}
function noOrientation(publicAPI, model) {
  return (polyData, states) => {
    model._pipeline.mapper.setOrientationArray(null);
  };
}
function vtkGlyphRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkGlyphRepresentation");
  const superClass = {
    ...publicAPI
  };
  const internalPolyData = vtkPolyData$1.newInstance({
    mtime: 0
  });
  function hasMixin(states) {
    for (var _len = arguments.length, requiredMixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      requiredMixins[_key - 1] = arguments[_key];
    }
    return requiredMixins.every((requiredMixin) => {
      var _a, _b;
      return ((_b = (_a = states[0]) == null ? void 0 : _a[`get${macro.capitalize(requiredMixin)}`]) == null ? void 0 : _b.call(_a)) != null;
    });
  }
  publicAPI.getRepresentationStates = function() {
    let input = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.inputData[0];
    return superClass.getRepresentationStates(input).filter((state) => {
      var _a, _b;
      return ((_a = state.getOrigin) == null ? void 0 : _a.call(state)) && (((_b = state.isVisible) == null ? void 0 : _b.call(state)) ?? true);
    });
  };
  publicAPI.getMixins = (states) => {
    const glyphProperties = {};
    if (hasMixin(states, "origin")) {
      glyphProperties.position = model.applyMixin.origin;
    } else {
      glyphProperties.position = model.applyMixin.noPosition;
    }
    if (hasMixin(states, "color3")) {
      glyphProperties.color = model.applyMixin.color3;
    } else if (hasMixin(states, "color")) {
      glyphProperties.color = model.applyMixin.color;
    } else {
      glyphProperties.color = model.applyMixin.noColor;
    }
    if (hasMixin(states, "scale3")) {
      glyphProperties.scale = model.applyMixin.scale3;
    } else if (hasMixin(states, "scale1")) {
      glyphProperties.scale = model.applyMixin.scale1;
    } else {
      glyphProperties.scale = model.applyMixin.noScale;
    }
    if (hasMixin(states, "direction")) {
      glyphProperties.orientation = model.applyMixin.direction;
    } else {
      glyphProperties.orientation = model.applyMixin.noOrientation;
    }
    return glyphProperties;
  };
  publicAPI.requestData = (inData, outData) => {
    const states = publicAPI.getRepresentationStates(inData[0]);
    outData[0] = internalPolyData;
    const glyphProperties = publicAPI.getMixins(states);
    Object.values(glyphProperties).forEach((property) => property(internalPolyData, states));
    internalPolyData.getPoints().modified();
    internalPolyData.modified();
  };
  vtkWidgetRepresentation$1.connectPipeline(model._pipeline);
  publicAPI.addActor(model._pipeline.actor);
}
function defaultValues23(publicAPI, model, initialValues) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  return {
    defaultScale: 1,
    ...initialValues,
    _pipeline: {
      source: ((_a = initialValues._pipeline) == null ? void 0 : _a.source) ?? publicAPI,
      glyph: ((_b = initialValues._pipeline) == null ? void 0 : _b.glyph) ?? // in case glyph was provided
      vtkSphereSource$1.newInstance({
        phiResolution: 8,
        thetaResolution: 8
      }),
      mapper: ((_c = initialValues._pipeline) == null ? void 0 : _c.mapper) ?? // in case mapper was provided
      vtkGlyph3DMapper$1.newInstance({
        scalarMode: ScalarMode.USE_POINT_FIELD_DATA
      }),
      actor: ((_d = initialValues._pipeline) == null ? void 0 : _d.actor) ?? // in case actor was provided
      vtkActor$1.newInstance({
        parentProp: publicAPI
      }),
      ...initialValues._pipeline
      // in case there is something else to add to pipeline
    },
    applyMixin: {
      origin: ((_e = initialValues.applyMixin) == null ? void 0 : _e.origin) ?? origin2(publicAPI, model),
      noPosition: ((_f = initialValues.applyMixin) == null ? void 0 : _f.noPosition) ?? noPosition(),
      color3: ((_g = initialValues.applyMixin) == null ? void 0 : _g.color3) ?? color32(publicAPI, model),
      color: ((_h = initialValues.applyMixin) == null ? void 0 : _h.color) ?? color2(publicAPI, model),
      noColor: ((_i = initialValues.applyMixin) == null ? void 0 : _i.noColor) ?? noColor(publicAPI, model),
      scale3: ((_j = initialValues.applyMixin) == null ? void 0 : _j.scale3) ?? scale32(publicAPI, model),
      scale1: ((_k = initialValues.applyMixin) == null ? void 0 : _k.scale1) ?? scale12(publicAPI, model),
      noScale: ((_l = initialValues.applyMixin) == null ? void 0 : _l.noScale) ?? noScale(publicAPI, model),
      direction: ((_m = initialValues.applyMixin) == null ? void 0 : _m.direction) ?? direction2(publicAPI, model),
      noOrientation: ((_n = initialValues.applyMixin) == null ? void 0 : _n.noOrientation) ?? noOrientation(publicAPI, model),
      ...initialValues.applyMixin
    }
  };
}
function extend227(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (initialValues.behavior === Behavior.CONTEXT) {
    vtkContextRepresentation$1.extend(publicAPI, model, defaultValues23(publicAPI, model, initialValues));
  } else {
    vtkHandleRepresentation$1.extend(publicAPI, model, defaultValues23(publicAPI, model, initialValues));
  }
  if ("lighting" in initialValues) {
    model._pipeline.actor.getProperty().setLighting(initialValues.lighting);
  }
  macro.setGet(publicAPI, model._pipeline, ["defaultScale"]);
  macro.get(publicAPI, model._pipeline, ["glyph", "mapper", "actor"]);
  macro.setGet(publicAPI, model.applyMixin, Object.keys(model.applyMixin));
  vtkGlyphRepresentation(publicAPI, model);
}
var newInstance202 = macro.newInstance(extend227, "vtkGlyphRepresentation");
var vtkGlyphRepresentation$1 = {
  newInstance: newInstance202,
  extend: extend227
};

// node_modules/@kitware/vtk.js/Widgets/Representations/CircleContextRepresentation.js
function vtkCircleContextRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkCircleContextRepresentation");
  model._pipeline.actor.getProperty().setOpacity(0.2);
  model._pipeline.mapper.setResolveCoincidentTopology(Resolve.PolygonOffset);
  model._pipeline.mapper.setRelativeCoincidentTopologyPolygonOffsetParameters(-1, -1);
  publicAPI.setGlyphResolution = macro.chain(publicAPI.setGlyphResolution, model._pipeline.glyph.setResolution);
  publicAPI.setDrawBorder = macro.chain(publicAPI.setDrawBorder, (draw) => model._pipeline.glyph.setLines(draw));
  publicAPI.setDrawFace = macro.chain(publicAPI.setDrawFace, (draw) => model._pipeline.glyph.setFace(draw));
  publicAPI.setOpacity = (opacity) => {
    model._pipeline.actor.getProperty().setOpacity(opacity);
  };
}
function defaultValues24(initialValues) {
  var _a;
  return {
    behavior: Behavior.CONTEXT,
    glyphResolution: 32,
    drawBorder: false,
    drawFace: true,
    ...initialValues,
    _pipeline: {
      glyph: ((_a = initialValues == null ? void 0 : initialValues.pipeline) == null ? void 0 : _a.glyph) ?? vtkCircleSource$1.newInstance({
        resolution: initialValues.glyphResolution ?? 32,
        radius: 1,
        lines: initialValues.drawBorder ?? false,
        face: initialValues.drawFace ?? true,
        direction: [0, 0, 1]
      }),
      ...initialValues == null ? void 0 : initialValues.pipeline
    }
  };
}
function extend228(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, defaultValues24(initialValues));
  macro.setGet(publicAPI, model, ["glyphResolution", "drawFace", "drawBorder"]);
  macro.get(publicAPI, model._pipeline, ["glyph", "mapper", "actor"]);
  vtkCircleContextRepresentation(publicAPI, model);
}
var newInstance203 = macro.newInstance(extend228, "vtkCircleContextRepresentation");
var vtkCircleContextRepresentation$1 = {
  newInstance: newInstance203,
  extend: extend228
};

// node_modules/@kitware/vtk.js/Widgets/Representations/ConvexFaceContextRepresentation.js
function vtkConvexFaceContextRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkConvexFaceContextRepresentation");
  model.internalPolyData = vtkPolyData$1.newInstance({
    mtime: 0
  });
  model.points = new Float32Array(3 * 4);
  model.cells = new Uint8Array([4, 0, 1, 2, 3]);
  model.internalPolyData.getPoints().setData(model.points, 3);
  model.internalPolyData.getPolys().setData(model.cells);
  function allocateSize(polyData, size) {
    const points = allocateArray(polyData, "points", size).getData();
    const oldCellsSize = polyData.getPolys().getNumberOfValues();
    const cells = allocateArray(polyData, "polys", size + 1).getData();
    if (oldCellsSize !== cells.length) {
      cells[0] = size;
      for (let i = 0; i < size; i++) {
        cells[i + 1] = i;
      }
    }
    return points;
  }
  model.mapper = vtkMapper$1.newInstance({
    scalarVisibility: false
  });
  model.actor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.actor.getProperty().setOpacity(model.opacity);
  model.mapper.setInputConnection(publicAPI.getOutputPort());
  model.actor.setMapper(model.mapper);
  publicAPI.addActor(model.actor);
  publicAPI.requestData = (inData, outData) => {
    const list = publicAPI.getRepresentationStates(inData[0]);
    const validState = list.filter((state) => state.getOrigin());
    const points = allocateSize(model.internalPolyData, validState.length);
    for (let i = 0; i < validState.length; i++) {
      const coords = validState[i].getOrigin();
      points[i * 3] = coords[0];
      points[i * 3 + 1] = coords[1];
      points[i * 3 + 2] = coords[2];
    }
    model.internalPolyData.modified();
    outData[0] = model.internalPolyData;
  };
  publicAPI.getSelectedState = (prop, compositeID) => {
    const state = model.inputData[0];
    const list = publicAPI.getRepresentationStates(state);
    if (state.updateFromOriginRightUp) {
      state.updateFromOriginRightUp(list[0].getOrigin(), list[list.length - 1].getOrigin(), list[1].getOrigin());
    }
    return state;
  };
  const superUpdateActorVisibility = publicAPI.updateActorVisibility;
  publicAPI.updateActorVisibility = function() {
    let renderingType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RenderingTypes.FRONT_BUFFER;
    let ctxVisible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let handleVisible = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    switch (model.behavior) {
      case Behavior.HANDLE:
        if (renderingType === RenderingTypes.PICKING_BUFFER) {
          model.actor.getProperty().setOpacity(1);
        } else {
          model.actor.getProperty().setOpacity(model.opacity);
        }
        break;
      case Behavior.CONTEXT:
      default:
        model.actor.getProperty().setOpacity(model.opacity);
        break;
    }
    superUpdateActorVisibility(renderingType, ctxVisible, handleVisible);
  };
}
var DEFAULT_VALUES203 = {
  defaultColor: [1, 0, 0.5],
  opacity: 0.2
};
function extend229(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES203, initialValues);
  vtkContextRepresentation$1.extend(publicAPI, model, initialValues);
  macro.setGetArray(publicAPI, model, ["defaultColor"], 3);
  macro.get(publicAPI, model, ["mapper", "actor"]);
  macro.setGet(publicAPI, model, ["opacity"]);
  vtkConvexFaceContextRepresentation(publicAPI, model);
}
var newInstance204 = macro.newInstance(extend229, "vtkConvexFaceContextRepresentation");
var vtkConvexFaceContextRepresentation$1 = {
  newInstance: newInstance204,
  extend: extend229
};

// node_modules/@kitware/vtk.js/Widgets/Representations/CubeHandleRepresentation.js
function vtkCubeHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkCubeHandleRepresentation");
}
function defaultValues25(initialValues) {
  return {
    _pipeline: {
      glyph: vtkCubeSource$1.newInstance()
    },
    ...initialValues
  };
}
function extend230(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, defaultValues25(initialValues));
  vtkCubeHandleRepresentation(publicAPI, model);
}
var newInstance205 = macro.newInstance(extend230, "vtkCubeHandleRepresentation");
var vtkCubeHandleRepresentation$1 = {
  newInstance: newInstance205,
  extend: extend230
};

// node_modules/@kitware/vtk.js/Widgets/Representations/ImplicitPlaneRepresentation.js
var {
  RenderingTypes: RenderingTypes3
} = WidgetManagerConst;
var {
  Interpolation,
  Representation: Representation3
} = PropertyConst;
function generateState() {
  return vtkStateBuilder.createBuilder().addField({
    name: "origin",
    initialValue: [0, 0, 0]
  }).addField({
    name: "normal",
    initialValue: [0, 0, 1]
  }).addField({
    name: "activeHandle",
    initialValue: null
  }).addField({
    name: "updateMethodName"
  }).build();
}
var STYLE_PIPELINE_NAMES = ["plane", "outline", "normal", "origin", "display2D"];
var STYLE_DEFAULT = {
  active: {
    plane: {
      opacity: 1,
      color: [0, 0.9, 0]
    },
    normal: {
      opacity: 1,
      color: [0, 0.9, 0]
    },
    origin: {
      opacity: 1,
      color: [0, 0.9, 0]
    }
  },
  inactive: {
    plane: {
      opacity: 0.6,
      color: [1, 1, 1]
    },
    normal: {
      opacity: 1,
      color: [0.9, 0, 0]
    },
    origin: {
      opacity: 1,
      color: [1, 0, 0]
    }
  },
  static: {
    display2D: {
      representation: Representation3.POINT
    },
    outline: {
      color: [1, 1, 1],
      opacity: 1,
      representation: Representation3.WIREFRAME,
      interpolation: Interpolation.FLAT
    }
  }
};
function vtkImplicitPlaneRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkImplicitPlaneRepresentation");
  model.plane = vtkPlane$1.newInstance();
  model.matrix = vtkMatrixBuilder.buildFromDegree();
  model._pipelines = {};
  model._pipelines.outline = {
    source: vtkCubeSource$1.newInstance(),
    mapper: vtkMapper$1.newInstance(),
    actor: vtkActor$1.newInstance({
      pickable: false,
      _parentProp: publicAPI
    })
  };
  model._pipelines.plane = {
    source: vtkCutter$1.newInstance({
      cutFunction: model.plane
    }),
    filter: vtkClosedPolyLineToSurfaceFilter$1.newInstance(),
    mapper: vtkMapper$1.newInstance(),
    actor: vtkActor$1.newInstance({
      pickable: true,
      _parentProp: publicAPI
    })
  };
  model._pipelines.origin = {
    source: vtkSphereSource$1.newInstance(),
    mapper: vtkMapper$1.newInstance(),
    actor: vtkActor$1.newInstance({
      pickable: true,
      _parentProp: publicAPI
    })
  };
  model._pipelines.normal = {
    source: vtkCylinderSource$1.newInstance(),
    mapper: vtkMapper$1.newInstance(),
    actor: vtkActor$1.newInstance({
      pickable: true,
      _parentProp: publicAPI
    })
  };
  model._pipelines.display2D = {
    source: publicAPI,
    mapper: vtkPixelSpaceCallbackMapper$1.newInstance(),
    actor: vtkActor$1.newInstance({
      pickable: false,
      _parentProp: publicAPI
    })
  };
  model._pipelines.plane.source.setInputConnection(model._pipelines.outline.source.getOutputPort());
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.outline);
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.plane);
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.origin);
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.normal);
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.display2D);
  publicAPI.addActor(model._pipelines.outline.actor);
  publicAPI.addActor(model._pipelines.plane.actor);
  publicAPI.addActor(model._pipelines.origin.actor);
  publicAPI.addActor(model._pipelines.normal.actor);
  publicAPI.addActor(model._pipelines.display2D.actor);
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const state = inData[0];
    const origin3 = state.getOrigin();
    if (!origin3) {
      return;
    }
    const normal = state.getNormal();
    const bounds2 = state.getBounds();
    model.plane.setOrigin(origin3);
    model.plane.setNormal(normal);
    model._pipelines.outline.source.setCenter((bounds2[0] + bounds2[1]) * 0.5, (bounds2[2] + bounds2[3]) * 0.5, (bounds2[4] + bounds2[5]) * 0.5);
    const xRange = bounds2[1] - bounds2[0];
    const yRange = bounds2[3] - bounds2[2];
    const zRange = bounds2[5] - bounds2[4];
    model._pipelines.outline.source.setXLength(xRange);
    model._pipelines.outline.source.setYLength(yRange);
    model._pipelines.outline.source.setZLength(zRange);
    let pixelScale = 1;
    if (model.scaleInPixels) {
      pixelScale = getPixelWorldHeightAtCoord(origin3, model.displayScaleParams);
    }
    model._pipelines.normal.source.set({
      height: Math.max(xRange, yRange, zRange),
      radius: model.handleSizeRatio * Math.min(xRange, yRange, zRange) * model.axisScale * pixelScale,
      resolution: model.sphereResolution
    });
    const yAxis = model._pipelines.normal.source.getOutputData();
    const newAxis = vtkPolyData$1.newInstance();
    newAxis.shallowCopy(yAxis);
    newAxis.getPoints().setData(Float32Array.from(yAxis.getPoints().getData()), 3);
    newAxis.getPointData().removeAllArrays();
    model.matrix.identity().translate(origin3[0], origin3[1], origin3[2]).rotateFromDirections([0, 1, 0], normal).apply(newAxis.getPoints().getData());
    model._pipelines.normal.mapper.setInputData(newAxis);
    model._pipelines.origin.actor.setPosition(origin3);
    const handleScale = model.handleSizeRatio * Math.min(xRange, yRange, zRange) * pixelScale;
    model._pipelines.origin.actor.setScale(handleScale, handleScale, handleScale);
    vtkWidgetRepresentation$1.applyStyles(model._pipelines, model.representationStyle, state.getActive() && state.getActiveHandle());
    const output = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    output.shallowCopy(model._pipelines.plane.filter.getOutputData());
    outData[0] = output;
  };
  publicAPI.setSphereResolution = (res) => {
    model.sphereResolution = res;
    return model._pipelines.origin.source.setPhiResolution(res) && model._pipelines.origin.source.setThetaResolution(res);
  };
  publicAPI.setRepresentationStyle = (style6) => {
    model.representationStyle = vtkWidgetRepresentation$1.mergeStyles(STYLE_PIPELINE_NAMES, model.representationStyle, style6);
    vtkWidgetRepresentation$1.applyStyles(model._pipelines, model.representationStyle);
    publicAPI.modified();
  };
  publicAPI.updateActorVisibility = (renderingType, ctxVisible, hVisible) => {
    const {
      planeVisible,
      originVisible,
      normalVisible,
      outlineVisible
    } = model;
    if (renderingType === RenderingTypes3.PICKING_BUFFER) {
      model._pipelines.plane.actor.setVisibility(planeVisible);
      model._pipelines.origin.actor.setVisibility(originVisible);
      model._pipelines.normal.actor.setVisibility(normalVisible);
      model._pipelines.plane.actor.getProperty().setOpacity(1);
    } else {
      model._pipelines.outline.actor.setVisibility(outlineVisible && ctxVisible);
      model._pipelines.plane.actor.setVisibility(planeVisible && hVisible);
      model._pipelines.origin.actor.setVisibility(originVisible && hVisible);
      model._pipelines.normal.actor.setVisibility(normalVisible && hVisible);
      const state = model.inputData[0];
      if (state) {
        vtkWidgetRepresentation$1.applyStyles(model._pipelines, model.representationStyle, state.getActive() && state.getActiveHandle());
      }
    }
  };
  publicAPI.getSelectedState = (prop, compositeID) => {
    const state = model.inputData[0];
    state.setActiveHandle(prop);
    switch (prop) {
      case model._pipelines.plane.actor:
        state.setUpdateMethodName("updateFromPlane");
        break;
      case model._pipelines.origin.actor:
        state.setUpdateMethodName("updateFromOrigin");
        break;
      case model._pipelines.normal.actor:
        state.setUpdateMethodName("updateFromNormal");
        break;
      default:
        state.setUpdateMethodName("updateFromPlane");
        break;
    }
    return state;
  };
  publicAPI.setRepresentationStyle(STYLE_DEFAULT);
  publicAPI.setSphereResolution(model.sphereResolution);
}
var DEFAULT_VALUES204 = {
  sphereResolution: 24,
  handleSizeRatio: 0.05,
  axisScale: 0.1,
  normalVisible: true,
  originVisible: true,
  planeVisible: true,
  outlineVisible: true
};
function extend231(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES204, initialValues);
  vtkWidgetRepresentation$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["sphereResolution", "representationStyle"]);
  macro.setGet(publicAPI, model, ["handleSizeRatio", "axisScale", "normalVisible", "originVisible", "planeVisible", "outlineVisible"]);
  vtkImplicitPlaneRepresentation(publicAPI, model);
}
var newInstance206 = macro.newInstance(extend231, "vtkImplicitPlaneRepresentation");
var vtkImplicitPlaneRepresentation$1 = {
  newInstance: newInstance206,
  extend: extend231,
  generateState
};

// node_modules/@kitware/vtk.js/Widgets/Representations/LineHandleRepresentation.js
var INFINITE_RATIO = 1e5;
function vtkLineHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkLineHandleRepresentation");
  model.displayMapper = vtkPixelSpaceCallbackMapper$1.newInstance();
  model.displayActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.displayActor.setMapper(model.displayMapper);
  model.displayMapper.setInputConnection(publicAPI.getOutputPort());
  publicAPI.addActor(model.displayActor);
  model.alwaysVisibleActors = [model.displayActor];
  publicAPI.setGlyphResolution = macro.chain(publicAPI.setGlyphResolution, model._pipeline.glyph.setThetaResolution, model._pipeline.glyph.setPhiResolution);
  function callbackProxy(coords) {
    if (model.displayCallback) {
      const filteredList = [];
      const states = publicAPI.getRepresentationStates();
      for (let i = 0; i < states.length; i++) {
        if (states[i].getActive()) {
          filteredList.push(coords[i]);
        }
      }
      if (filteredList.length) {
        model.displayCallback(filteredList);
        return;
      }
    }
    model.displayCallback();
  }
  publicAPI.setDisplayCallback = (callback) => {
    model.displayCallback = callback;
    model.displayMapper.setCallback(callback ? callbackProxy : null);
  };
  const superPublicAPI = {
    ...publicAPI
  };
  publicAPI.requestData = (inData, outData) => {
    superPublicAPI.requestData(inData, outData);
    if (!model.holeWidth) {
      return;
    }
    const internalPolyData = outData[0];
    const points = internalPolyData.getPoints();
    const dataArrays = internalPolyData.getPointData().getArrays();
    [points, ...dataArrays].forEach((array) => {
      const oldNumberOfValues = array.getNumberOfValues();
      array.resize(2 * array.getNumberOfTuples());
      const arrayData = array.getData();
      for (let i = 0; i < oldNumberOfValues; ++i) {
        arrayData[i + oldNumberOfValues] = arrayData[i];
      }
    });
    const states = publicAPI.getRepresentationStates(inData[0]);
    const nStates = states.length;
    const scaleArray = internalPolyData.getPointData().getArrayByName("scale");
    const orientationArray = internalPolyData.getPointData().getArrayByName("orientation");
    const defaultScale = [1, 1, 1];
    const defaultOrientation = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    for (let i = 0; i < nStates; ++i) {
      const j = i + nStates;
      const scale = (scaleArray == null ? void 0 : scaleArray.getTuple(i)) ?? defaultScale;
      const orientationMatrix = (orientationArray == null ? void 0 : orientationArray.getTuple(i)) ?? defaultOrientation;
      const originalPoint = points.getTuple(i);
      scale[2] *= 0.5;
      scaleArray == null ? void 0 : scaleArray.setTuple(i, scale);
      scaleArray == null ? void 0 : scaleArray.setTuple(j, scale);
      let holeWidth = model.holeWidth;
      if (publicAPI.getScaleInPixels()) {
        holeWidth *= getPixelWorldHeightAtCoord(originalPoint, model.displayScaleParams);
      }
      const offset = vec3_exports.fromValues(0, 0, 0.5 * scale[2] + holeWidth);
      vec3_exports.transformMat3(offset, offset, orientationMatrix);
      points.setTuple(i, vec3_exports.add(vec3_exports.create(), originalPoint, offset));
      points.setTuple(j, vec3_exports.sub(vec3_exports.create(), originalPoint, offset));
    }
  };
  publicAPI.getSelectedState = (prop, compositeID) => {
    const representationStates = publicAPI.getRepresentationStates();
    return representationStates[compositeID % representationStates.length];
  };
  const superScale3 = publicAPI.getScale3();
  publicAPI.setScale3((polyData, states) => {
    superScale3(polyData, states);
    if (model.infiniteLine) {
      const scales = allocateArray(polyData, "scale", states.length, "Float32Array", 3).getData();
      for (let i = 0; i < states.length; ++i) {
        scales[3 * i + 2] = INFINITE_RATIO;
      }
    }
  });
}
function defaultValues26(initialValues) {
  return {
    infiniteLine: true,
    glyphResolution: 4,
    holeWidth: 0,
    _pipeline: {
      glyph: vtkCylinderSource$1.newInstance({
        resolution: initialValues.glyphResolution ?? 4,
        initAngle: initialValues.glyphAngle ?? Math.PI / 4,
        direction: [0, 0, 1]
      })
    },
    ...initialValues
  };
}
function extend232(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, defaultValues26(initialValues));
  macro.setGet(publicAPI, model, ["infiniteLine", "glyphResolution", "holeWidth"]);
  vtkLineHandleRepresentation(publicAPI, model);
}
var newInstance207 = macro.newInstance(extend232, "vtkLineHandleRepresentation");
var vtkLineHandleRepresentation$1 = {
  newInstance: newInstance207,
  extend: extend232
};

// node_modules/@kitware/vtk.js/Widgets/Representations/OutlineContextRepresentation.js
function vtkOutlineContextRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkOutlineContextRepresentation");
  model.bbox = [...vtkBoundingBox.INIT_BOUNDS];
  model.internalPolyData = vtkPolyData$1.newInstance({
    mtime: 0
  });
  model.points = new Float32Array(8 * 3);
  model.internalPolyData.getPoints().setData(model.points, 3);
  model.internalPolyData.getLines().setData(Uint16Array.from(LINE_ARRAY));
  model.mapper = vtkMapper$1.newInstance({
    scalarVisibility: false
  });
  model.actor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.actor.getProperty().setEdgeColor(...model.edgeColor);
  model.mapper.setInputConnection(publicAPI.getOutputPort());
  model.actor.setMapper(model.mapper);
  publicAPI.addActor(model.actor);
  publicAPI.requestData = (inData, outData) => {
    const list = publicAPI.getRepresentationStates(inData[0]).filter((state) => state.getOrigin && state.getOrigin());
    vtkBoundingBox.reset(model.bbox);
    for (let i = 0; i < list.length; i++) {
      const pt = list[i].getOrigin();
      if (pt) {
        vtkBoundingBox.addPoint(model.bbox, ...pt);
      }
    }
    for (let i = 0; i < BOUNDS_MAP.length; i++) {
      model.points[i] = model.bbox[BOUNDS_MAP[i]];
    }
    model.internalPolyData.getPoints().modified();
    model.internalPolyData.modified();
    outData[0] = model.internalPolyData;
  };
}
var DEFAULT_VALUES205 = {
  edgeColor: [1, 1, 1]
};
function extend233(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES205, initialValues);
  vtkContextRepresentation$1.extend(publicAPI, model, initialValues);
  macro.setGetArray(publicAPI, model, ["edgeColor"], 3);
  macro.get(publicAPI, model, ["mapper", "actor"]);
  vtkOutlineContextRepresentation(publicAPI, model);
}
var newInstance208 = macro.newInstance(extend233, "vtkOutlineContextRepresentation");
var vtkOutlineContextRepresentation$1 = {
  newInstance: newInstance208,
  extend: extend233
};

// node_modules/@kitware/vtk.js/Widgets/Representations/PolyLineRepresentation.js
function vtkPolyLineRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkPolyLineRepresentation");
  const superClass = {
    ...publicAPI
  };
  const internalPolyData = vtkPolyData$1.newInstance({
    mtime: 0
  });
  function allocateSize(polyData, size) {
    let closePolyLine = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let points = null;
    if (size < 2) {
      points = allocateArray(polyData, "points", 1).getData();
      points.set([0, 0, 0]);
      allocateArray(polyData, "lines", 0).getData();
    } else if (!polyData.getPoints() || polyData.getPoints().length !== size * 3) {
      points = allocateArray(polyData, "points", size).getData();
      const cellSize = size + (closePolyLine ? 1 : 0);
      if (polyData.getLines().getNumberOfCells() !== 1 || polyData.getLines().getCellSizes()[0] !== cellSize) {
        const lines = allocateArray(polyData, "lines", cellSize + 1);
        const cellData = lines.getData();
        cellData[0] = cellSize;
        for (let i = 1; i <= cellSize; i++) {
          cellData[i] = i - 1;
        }
        if (closePolyLine) {
          cellData[cellSize] = 0;
        }
        lines.setData(cellData);
      }
    }
    return points;
  }
  function applyLineThickness(lineThickness) {
    let scaledLineThickness = lineThickness;
    if (publicAPI.getScaleInPixels() && internalPolyData) {
      const center = vtkBoundingBox.getCenter(internalPolyData.getBounds());
      scaledLineThickness *= getPixelWorldHeightAtCoord(center, model.displayScaleParams);
    }
    model._pipelines.tubes.filter.setRadius(scaledLineThickness);
  }
  model._pipelines = {
    tubes: {
      source: publicAPI,
      filter: vtkTubeFilter$1.newInstance({
        radius: model.lineThickness,
        numberOfSides: 12,
        capping: false
      }),
      mapper: vtkMapper$1.newInstance(),
      actor: vtkActor$1.newInstance({
        parentProp: publicAPI
      })
    }
  };
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.tubes);
  publicAPI.addActor(model._pipelines.tubes.actor);
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const state = inData[0];
    outData[0] = internalPolyData;
    const list = publicAPI.getRepresentationStates(state).reduce((subStates, subState) => {
      const subStateOrigin = subState.getOrigin && subState.getOrigin() ? subState.getOrigin() : null;
      const previousSubStateOrigin = subStates.length && subStates[subStates.length - 1].getOrigin();
      if (!subStateOrigin || previousSubStateOrigin && areEquals(subStateOrigin, previousSubStateOrigin)) {
        return subStates;
      }
      subStates.push(subState);
      return subStates;
    }, []);
    const size = list.length;
    const points = allocateSize(outData[0], size, model.closePolyLine && size > 2);
    if (points) {
      for (let i = 0; i < size; i++) {
        const coords = list[i].getOrigin();
        points[i * 3] = coords[0];
        points[i * 3 + 1] = coords[1];
        points[i * 3 + 2] = coords[2];
      }
    }
    outData[0].getPoints().modified();
    outData[0].modified();
    const lineThickness = ((_a = state.getLineThickness) == null ? void 0 : _a.call(state)) ?? model.lineThickness;
    applyLineThickness(lineThickness);
  };
  publicAPI.getSelectedState = (prop, compositeID) => model.inputData[0];
  publicAPI.updateActorVisibility = (renderingType, ctxVisible, hVisible) => {
    var _a;
    const state = model.inputData[0];
    let lineThickness = ((_a = state.getLineThickness) == null ? void 0 : _a.call(state)) ?? model.lineThickness;
    if (renderingType === RenderingTypes.PICKING_BUFFER) {
      lineThickness = Math.max(4, lineThickness);
    }
    applyLineThickness(lineThickness);
    return superClass.updateActorVisibility(renderingType, ctxVisible, hVisible);
  };
}
var DEFAULT_VALUES206 = {
  threshold: Number.EPSILON,
  closePolyLine: false,
  lineThickness: 2,
  scaleInPixels: true
};
function extend234(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const newDefault = {
    ...DEFAULT_VALUES206,
    ...initialValues
  };
  vtkWidgetRepresentation$1.extend(publicAPI, model, newDefault);
  macro.setGet(publicAPI, model, ["threshold", "closePolyLine", "lineThickness"]);
  vtkPolyLineRepresentation(publicAPI, model);
}
var newInstance209 = macro.newInstance(extend234, "vtkPolyLineRepresentation");
var vtkPolyLineRepresentation$1 = {
  newInstance: newInstance209,
  extend: extend234
};

// node_modules/@kitware/vtk.js/Widgets/Representations/RotateTransformHandleRepresentation.js
function vtkRotateTransformHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkRotateTransformHandleRepresentation");
}
function defaultValues27(initialValues) {
  return {
    _pipeline: {
      glyph: vtkTorusSource$1.newInstance({})
    },
    ...initialValues
  };
}
function extend235(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, defaultValues27(initialValues));
  vtkRotateTransformHandleRepresentation(publicAPI, model);
}
var newInstance210 = macro.newInstance(extend235, "vtkRotateTransformHandleRepresentation");
var vtkRotateTransformHandleRepresentation$1 = {
  newInstance: newInstance210,
  extend: extend235
};

// node_modules/@kitware/vtk.js/Widgets/Representations/TranslateTransformHandleRepresentation/TransformHandleSource.js
function rotatePolyData(pd, direction3) {
  const points = pd.getPoints().getData();
  vtkMatrixBuilder.buildFromRadian().rotateFromDirections([0, 1, 0], direction3).apply(points);
  pd.getPoints().modified();
  pd.modified();
}
function translatePolyData(pd, translation) {
  const points = pd.getPoints().getData();
  vtkMatrixBuilder.buildFromRadian().translate(...translation).apply(points);
  pd.modified();
}
function vtkTransformHandleSource(publicAPI, model) {
  model.classHierarchy.push("vtkTransformHandleSource");
  function requestData(inData, outData) {
    const cylinderSource = vtkCylinderSource$1.newInstance({
      height: model.height,
      initAngle: model.initAngle,
      radius: model.radius,
      resolution: model.resolution,
      capping: model.capping,
      pointType: model.pointType,
      center: [0, 0, 0],
      direction: [0, 1, 0]
    });
    const appendFilter = vtkAppendPolyData$1.newInstance();
    appendFilter.setInputConnection(cylinderSource.getOutputPort(), 0);
    if (inData[0]) {
      translatePolyData(inData[0], [0, model.height / 2, 0]);
      appendFilter.addInputData(inData[0]);
    }
    if (inData[1]) {
      rotatePolyData(inData[1], [0, -1, 0]);
      translatePolyData(inData[1], [0, -model.height / 2, 0]);
      appendFilter.addInputData(inData[1]);
    }
    const poly = appendFilter.getOutputData();
    const points = poly.getPoints().getData();
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([0, 1, 0], model.direction).translate(...model.center.map((c2) => c2 * -1)).apply(points);
    outData[0] = poly;
  }
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES207 = {
  capPolyData: null
};
function extend236(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES207, initialValues);
  vtkCylinderSource$1.extend(publicAPI, model, initialValues);
  macro.algo(publicAPI, model, 2, 1);
  vtkTransformHandleSource(publicAPI, model);
}
var newInstance211 = macro.newInstance(extend236, "vtkTransformHandleSource");
var vtkTransformHandleSource$1 = {
  newInstance: newInstance211,
  extend: extend236
};

// node_modules/@kitware/vtk.js/Widgets/Representations/ScaleTransformHandleRepresentation.js
function vtkScaleTransformHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkScaleTransformHandleRepresentation");
}
function defaultValues28(initialValues) {
  const source = vtkTransformHandleSource$1.newInstance({
    height: initialValues.height ?? 1,
    radius: initialValues.radius ?? 1,
    resolution: initialValues.glyphResolution ?? 12,
    direction: [0, 0, 1]
  });
  const cube1 = vtkCubeSource$1.newInstance(initialValues.cubeSource);
  const cube2 = vtkCubeSource$1.newInstance(initialValues.cubeSource);
  source.addInputConnection(cube1.getOutputPort());
  source.addInputConnection(cube2.getOutputPort());
  return {
    _pipeline: {
      glyph: source
    },
    ...initialValues
  };
}
function extend237(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, defaultValues28(initialValues));
  vtkScaleTransformHandleRepresentation(publicAPI, model);
}
var newInstance212 = macro.newInstance(extend237, "vtkScaleTransformHandleRepresentation");
var vtkScaleTransformHandleRepresentation$1 = {
  newInstance: newInstance212,
  extend: extend237
};

// node_modules/@kitware/vtk.js/Widgets/Representations/SphereHandleRepresentation.js
function vtkSphereHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkSphereHandleRepresentation");
  model.displayMapper = vtkPixelSpaceCallbackMapper$1.newInstance();
  model.displayActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.displayActor.setMapper(model.displayMapper);
  model.displayMapper.setInputConnection(publicAPI.getOutputPort());
  publicAPI.addActor(model.displayActor);
  model.alwaysVisibleActors = [model.displayActor];
  publicAPI.getGlyphResolution = () => model._pipeline.glyph.getPhiResolution();
  publicAPI.setGlyphResolution = (resolution) => model._pipeline.glyph.setPhiResolution(resolution) || model._pipeline.glyph.setThetaResolution(resolution);
  function callbackProxy(coords) {
    if (model.displayCallback) {
      const filteredList = [];
      const states = publicAPI.getRepresentationStates();
      for (let i = 0; i < states.length; i++) {
        if (states[i].getActive()) {
          filteredList.push(coords[i]);
        }
      }
      if (filteredList.length) {
        model.displayCallback(filteredList);
        return;
      }
    }
    model.displayCallback();
  }
  publicAPI.setDisplayCallback = (callback) => {
    model.displayCallback = callback;
    model.displayMapper.setCallback(callback ? callbackProxy : null);
  };
}
function extend238(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, initialValues);
  vtkSphereHandleRepresentation(publicAPI, model);
}
var newInstance213 = macro.newInstance(extend238, "vtkSphereHandleRepresentation");
var vtkSphereHandleRepresentation$1 = {
  newInstance: newInstance213,
  extend: extend238
};

// node_modules/@kitware/vtk.js/Common/DataModel/Spline1D.js
var {
  vtkErrorMacro: vtkErrorMacro77
} = macro;
function vtkSpline1D(publicAPI, model) {
  model.classHierarchy.push("vtkSpline1D");
  publicAPI.computeCloseCoefficients = (size, work, x, y) => {
    vtkErrorMacro77(`${model.classHierarchy.slice(-1)[0]} should implement computeCloseCoefficients`);
  };
  publicAPI.computeOpenCoefficients = function(size, work, x, y) {
    vtkErrorMacro77(`${model.classHierarchy.slice(-1)[0]} should implement computeOpenCoefficients`);
  };
  publicAPI.getValue = (intervalIndex, t) => {
    vtkErrorMacro77(`${model.classHierarchy.slice(-1)[0]} should implement getValue`);
  };
}
var DEFAULT_VALUES208 = {};
function extend239(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES208, initialValues);
  macro.obj(publicAPI, model);
  vtkSpline1D(publicAPI, model);
}
var newInstance214 = macro.newInstance(extend239, "vtkSpline1D");
var vtkSpline1D$1 = {
  newInstance: newInstance214,
  extend: extend239
};

// node_modules/@kitware/vtk.js/Common/DataModel/Spline1D/Constants.js
var BoundaryCondition = {
  DEFAULT: 0,
  DERIVATIVE: 1,
  SECOND_DERIVATIVE: 2,
  SECOND_DERIVATIVE_INTERIOR_POINT: 3
};

// node_modules/@kitware/vtk.js/Common/DataModel/CardinalSpline1D.js
var VTK_EPSILON = 1e-4;
function vtkCardinalSpline1D(publicAPI, model) {
  model.classHierarchy.push("vtkCardinalSpline1D");
  publicAPI.computeCloseCoefficients = (size, work, x, y) => {
    if (!model.coefficients || model.coefficients.length !== 4 * size) {
      model.coefficients = new Float32Array(4 * size);
    }
    const N2 = size - 1;
    for (let k = 1; k < N2; k++) {
      const xlk2 = x[k] - x[k - 1];
      const xlkp2 = x[k + 1] - x[k];
      model.coefficients[4 * k + 0] = xlkp2;
      model.coefficients[4 * k + 1] = 2 * (xlkp2 + xlk2);
      model.coefficients[4 * k + 2] = xlk2;
      work[k] = 3 * (xlkp2 * (y[k] - y[k - 1]) / xlk2 + xlk2 * (y[k + 1] - y[k]) / xlkp2);
    }
    const xlk = x[N2] - x[N2 - 1];
    const xlkp = x[1] - x[0];
    model.coefficients[4 * N2 + 0] = xlkp;
    model.coefficients[4 * N2 + 1] = 2 * (xlkp + xlk);
    model.coefficients[4 * N2 + 2] = xlk;
    work[N2] = 3 * (xlkp * (y[N2] - y[N2 - 1]) / xlk + xlk * (y[1] - y[0]) / xlkp);
    const aN = model.coefficients[4 * N2 + 0];
    const bN = model.coefficients[4 * N2 + 1];
    const cN = model.coefficients[4 * N2 + 2];
    const dN = work[N2];
    model.coefficients[4 * 0 + 2] = 0;
    work[0] = 0;
    model.coefficients[4 * 0 + 3] = 1;
    for (let k = 1; k <= N2; k++) {
      model.coefficients[4 * k + 1] -= model.coefficients[4 * k + 0] * model.coefficients[4 * (k - 1) + 2];
      model.coefficients[4 * k + 2] = model.coefficients[4 * k + 2] / model.coefficients[4 * k + 1];
      work[k] = (work[k] - model.coefficients[4 * k + 0] * work[k - 1]) / model.coefficients[4 * k + 1];
      model.coefficients[4 * k + 3] = -model.coefficients[4 * k + 0] * model.coefficients[4 * (k - 1) + 3] / model.coefficients[4 * k + 1];
    }
    model.coefficients[4 * N2 + 0] = 1;
    model.coefficients[4 * N2 + 1] = 0;
    for (let k = N2 - 1; k > 0; k--) {
      model.coefficients[4 * k + 0] = model.coefficients[4 * k + 3] - model.coefficients[4 * k + 2] * model.coefficients[4 * (k + 1) + 0];
      model.coefficients[4 * k + 1] = work[k] - model.coefficients[4 * k + 2] * model.coefficients[4 * (k + 1) + 1];
    }
    work[0] = (dN - cN * model.coefficients[4 * 1 + 1] - aN * model.coefficients[4 * (N2 - 1) + 1]) / (bN + cN * model.coefficients[4 * 1 + 0] + aN * model.coefficients[4 * (N2 - 1) + 0]);
    work[N2] = work[0];
    for (let k = 1; k < N2; k++) {
      work[k] = model.coefficients[4 * k + 0] * work[N2] + model.coefficients[4 * k + 1];
    }
    for (let k = 0; k < N2; k++) {
      const b2 = x[k + 1] - x[k];
      model.coefficients[4 * k + 0] = y[k];
      model.coefficients[4 * k + 1] = work[k];
      model.coefficients[4 * k + 2] = 3 * (y[k + 1] - y[k]) / (b2 * b2) - (work[k + 1] + 2 * work[k]) / b2;
      model.coefficients[4 * k + 3] = 2 * (y[k] - y[k + 1]) / (b2 * b2 * b2) + (work[k + 1] + work[k]) / (b2 * b2);
    }
    model.coefficients[4 * N2 + 0] = y[N2];
    model.coefficients[4 * N2 + 1] = work[N2];
    model.coefficients[4 * N2 + 2] = model.coefficients[4 * 0 + 2];
    model.coefficients[4 * N2 + 3] = model.coefficients[4 * 0 + 3];
  };
  publicAPI.computeOpenCoefficients = function(size, work, x, y) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    if (!model.coefficients || model.coefficients.length !== 4 * size) {
      model.coefficients = new Float32Array(4 * size);
    }
    const N2 = size - 1;
    switch (options.leftConstraint) {
      case BoundaryCondition.DERIVATIVE:
        model.coefficients[4 * 0 + 1] = 1;
        model.coefficients[4 * 0 + 2] = 0;
        work[0] = options.leftValue;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE:
        model.coefficients[4 * 0 + 1] = 2;
        model.coefficients[4 * 0 + 2] = 1;
        work[0] = 3 * ((y[1] - y[0]) / (x[1] - x[0])) - 0.5 * (x[1] - x[0]) * options.leftValue;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE_INTERIOR_POINT:
        model.coefficients[4 * 0 + 1] = 2;
        if (Math.abs(options.leftValue + 2) > VTK_EPSILON) {
          model.coefficients[4 * 0 + 2] = 4 * ((0.5 + options.leftValue) / (2 + options.leftValue));
          work[0] = 6 * ((1 + options.leftValue) / (2 + options.leftValue)) * ((y[1] - y[0]) / (x[1] - x[0]));
        } else {
          model.coefficients[4 * 0 + 2] = 0;
          work[0] = 0;
        }
        break;
      case BoundaryCondition.DEFAULT:
      default:
        model.coefficients[4 * 0 + 1] = 1;
        model.coefficients[4 * 0 + 2] = 0;
        work[0] = y[2] - y[0];
        break;
    }
    for (let k = 1; k < N2; k++) {
      const xlk = x[k] - x[k - 1];
      const xlkp = x[k + 1] - x[k];
      model.coefficients[4 * k + 0] = xlkp;
      model.coefficients[4 * k + 1] = 2 * (xlkp + xlk);
      model.coefficients[4 * k + 2] = xlk;
      work[k] = 3 * (xlkp * (y[k] - y[k - 1]) / xlk + xlk * (y[k + 1] - y[k]) / xlkp);
    }
    switch (options.rightConstraint) {
      case BoundaryCondition.DERIVATIVE:
        model.coefficients[4 * N2 + 0] = 0;
        model.coefficients[4 * N2 + 1] = 1;
        work[N2] = options.rightValue;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE:
        model.coefficients[4 * N2 + 0] = 1;
        model.coefficients[4 * N2 + 1] = 2;
        work[N2] = 3 * ((y[N2] - y[N2 - 1]) / (x[N2] - x[N2 - 1])) + 0.5 * (x[N2] - x[N2 - 1]) * options.rightValue;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE_INTERIOR_POINT:
        model.coefficients[4 * N2 + 1] = 2;
        if (Math.abs(options.rightValue + 2) > VTK_EPSILON) {
          model.coefficients[4 * N2 + 0] = 4 * ((0.5 + options.rightValue) / (2 + options.rightValue));
          work[N2] = 6 * ((1 + options.rightValue) / (2 + options.rightValue)) * ((y[N2] - y[size - 2]) / (x[N2] - x[size - 2]));
        } else {
          model.coefficients[4 * N2 + 0] = 0;
          work[N2] = 0;
        }
        break;
      case BoundaryCondition.DEFAULT:
      default:
        model.coefficients[4 * N2 + 0] = 0;
        model.coefficients[4 * N2 + 1] = 1;
        work[N2] = y[N2] - y[N2 - 2];
        break;
    }
    model.coefficients[4 * 0 + 2] /= model.coefficients[4 * 0 + 1];
    work[0] /= model.coefficients[4 * N2 + 1];
    model.coefficients[4 * N2 + 3] = 1;
    for (let k = 1; k <= N2; k++) {
      model.coefficients[4 * k + 1] -= model.coefficients[4 * k + 0] * model.coefficients[4 * (k - 1) + 2];
      model.coefficients[4 * k + 2] /= model.coefficients[4 * k + 1];
      work[k] = (work[k] - model.coefficients[4 * k + 0] * work[k - 1]) / model.coefficients[4 * k + 1];
    }
    for (let k = N2 - 1; k >= 0; k--) {
      work[k] -= model.coefficients[4 * k + 2] * work[k + 1];
    }
    for (let k = 0; k < N2; k++) {
      const b2 = x[k + 1] - x[k];
      model.coefficients[4 * k + 0] = y[k];
      model.coefficients[4 * k + 1] = work[k];
      model.coefficients[4 * k + 2] = 3 * (y[k + 1] - y[k]) / (b2 * b2) - (work[k + 1] + 2 * work[k]) / b2;
      model.coefficients[4 * k + 3] = 2 * (y[k] - y[k + 1]) / (b2 * b2 * b2) + (work[k + 1] + work[k]) / (b2 * b2);
    }
    model.coefficients[4 * N2 + 0] = y[N2];
    model.coefficients[4 * N2 + 1] = work[N2];
    model.coefficients[4 * N2 + 2] = model.coefficients[4 * 0 + 2];
    model.coefficients[4 * N2 + 3] = model.coefficients[4 * 0 + 3];
  };
  publicAPI.getValue = (intervalIndex, t) => {
    const t2 = t * t;
    const t3 = t * t * t;
    return model.coefficients[4 * intervalIndex + 3] * t3 + model.coefficients[4 * intervalIndex + 2] * t2 + model.coefficients[4 * intervalIndex + 1] * t + model.coefficients[4 * intervalIndex + 0];
  };
}
var DEFAULT_VALUES209 = {};
function extend240(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES209, initialValues);
  vtkSpline1D$1.extend(publicAPI, model, initialValues);
  macro.obj(publicAPI, model);
  vtkCardinalSpline1D(publicAPI, model);
}
var newInstance215 = macro.newInstance(extend240, "vtkCardinalSpline1D");
var vtkCardinalSpline1D$1 = {
  newInstance: newInstance215,
  extend: extend240
};

// node_modules/@kitware/vtk.js/Common/DataModel/KochanekSpline1D.js
var VTK_EPSILON2 = 1e-4;
function vtkKochanekSpline1D(publicAPI, model) {
  model.classHierarchy.push("vtkKochanekSpline1D");
  publicAPI.computeCloseCoefficients = (size, work, x, y) => {
    if (!model.coefficients || model.coefficients.length !== 4 * size) {
      model.coefficients = new Float32Array(4 * size);
    }
    const N2 = size - 1;
    for (let i = 1; i < N2; i++) {
      const cs2 = y[i] - y[i - 1];
      const cd2 = y[i + 1] - y[i];
      let ds2 = cs2 * ((1 - model.tension) * (1 - model.continuity) * (1 + model.bias)) + cd2 * ((1 - model.tension) * (1 + model.continuity) * (1 - model.bias));
      let dd2 = cs2 * ((1 - model.tension) * (1 + model.continuity) * (1 + model.bias)) + cd2 * ((1 - model.tension) * (1 - model.continuity) * (1 - model.bias));
      const n12 = x[i + 1] - x[i];
      const n02 = x[i] - x[i - 1];
      ds2 *= n02 / (n02 + n12);
      dd2 *= n12 / (n02 + n12);
      model.coefficients[4 * i + 0] = y[i];
      model.coefficients[4 * i + 1] = dd2;
      model.coefficients[4 * i + 2] = ds2;
    }
    model.coefficients[4 * 0 + 0] = y[0];
    model.coefficients[4 * N2 + 0] = y[N2];
    model.coefficients[4 * N2 + 1] = 0;
    model.coefficients[4 * N2 + 2] = 0;
    model.coefficients[4 * N2 + 3] = 0;
    const cs = y[N2] - y[N2 - 1];
    const cd = y[1] - y[0];
    let ds = cs * ((1 - model.tension) * (1 - model.continuity) * (1 + model.bias)) + cd * ((1 - model.tension) * (1 + model.continuity) * (1 - model.bias));
    let dd = cs * ((1 - model.tension) * (1 + model.continuity) * (1 + model.bias)) + cd * ((1 - model.tension) * (1 - model.continuity) * (1 - model.bias));
    const n1 = x[1] - x[0];
    const n0 = x[N2] - x[N2 - 1];
    ds *= n0 / (n0 + n1);
    dd *= n1 / (n0 + n1);
    model.coefficients[4 * 0 + 1] = dd;
    model.coefficients[4 * 0 + 2] = ds;
    model.coefficients[4 * N2 + 1] = dd;
    model.coefficients[4 * N2 + 2] = ds;
    for (let i = 0; i < N2; i++) {
      model.coefficients[4 * i + 2] = -3 * y[i] + 3 * y[i + 1] + -2 * model.coefficients[4 * i + 1] + -1 * model.coefficients[4 * (i + 1) + 2];
      model.coefficients[4 * i + 3] = 2 * y[i] + -2 * y[i + 1] + 1 * model.coefficients[4 * i + 1] + 1 * model.coefficients[4 * (i + 1) + 2];
    }
  };
  publicAPI.computeOpenCoefficients = function(size, work, x, y) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    if (!model.coefficients || model.coefficients.length !== 4 * size) {
      model.coefficients = new Float32Array(4 * size);
    }
    const N2 = size - 1;
    for (let i = 1; i < N2; i++) {
      const cs = y[i] - y[i - 1];
      const cd = y[i + 1] - y[i];
      let ds = cs * ((1 - model.tension) * (1 - model.continuity) * (1 + model.bias)) + cd * ((1 - model.tension) * (1 + model.continuity) * (1 - model.bias));
      let dd = cs * ((1 - model.tension) * (1 + model.continuity) * (1 + model.bias)) + cd * ((1 - model.tension) * (1 - model.continuity) * (1 - model.bias));
      const n1 = x[i + 1] - x[i];
      const n0 = x[i] - x[i - 1];
      ds *= n0 / (n0 + n1);
      dd *= n1 / (n0 + n1);
      model.coefficients[4 * i + 0] = y[i];
      model.coefficients[4 * i + 1] = dd;
      model.coefficients[4 * i + 2] = ds;
    }
    model.coefficients[4 * 0 + 0] = y[0];
    model.coefficients[4 * N2 + 0] = y[N2];
    switch (options.leftConstraint) {
      case BoundaryCondition.DERIVATIVE:
        model.coefficients[4 * 0 + 1] = options.leftValue;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE:
        model.coefficients[4 * 0 + 1] = (6 * (y[1] - y[0]) - 2 * model.coefficients[4 * 1 + 2] - options.leftValue) / 4;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE_INTERIOR_POINT:
        if (Math.abs(options.leftValue + 2) > VTK_EPSILON2) {
          model.coefficients[4 * 0 + 1] = (3 * (1 + options.leftValue) * (y[1] - y[0]) - (1 + 2 * options.leftValue) * model.coefficients[4 * 1 + 2]) / (2 + options.leftValue);
        } else {
          model.coefficients[4 * 0 + 1] = 0;
        }
        break;
      case BoundaryCondition.DEFAULT:
      default:
        model.coefficients[4 * 0 + 1] = y[2] - y[0];
        break;
    }
    switch (options.rightConstraint) {
      case BoundaryCondition.DERIVATIVE:
        model.coefficients[4 * N2 + 2] = options.leftValue;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE:
        model.coefficients[4 * N2 + 2] = (6 * (y[N2] - y[N2 - 1]) - 2 * model.coefficients[4 * (N2 - 1) + 1] + options.leftValue) / 4;
        break;
      case BoundaryCondition.SECOND_DERIVATIVE_INTERIOR_POINT:
        if (Math.abs(options.leftValue + 2) > VTK_EPSILON2) {
          model.coefficients[4 * N2 + 2] = (3 * (1 + options.leftValue) * (y[N2] - y[N2 - 1]) - (1 + 2 * options.leftValue) * model.coefficients[4 * (N2 - 1) + 1]) / (2 + options.leftValue);
        } else {
          model.coefficients[4 * N2 + 2] = 0;
        }
        break;
      case BoundaryCondition.DEFAULT:
      default:
        model.coefficients[4 * N2 + 2] = y[N2] - y[N2 - 2];
        break;
    }
    for (let i = 0; i < N2; i++) {
      model.coefficients[4 * i + 2] = -3 * y[i] + 3 * y[i + 1] + -2 * model.coefficients[4 * i + 1] + -1 * model.coefficients[4 * (i + 1) + 2];
      model.coefficients[4 * i + 3] = 2 * y[i] + -2 * y[i + 1] + 1 * model.coefficients[4 * i + 1] + 1 * model.coefficients[4 * (i + 1) + 2];
    }
  };
  publicAPI.getValue = (intervalIndex, t) => {
    const t2 = t * t;
    const t3 = t * t * t;
    return model.coefficients[4 * intervalIndex + 3] * t3 + model.coefficients[4 * intervalIndex + 2] * t2 + model.coefficients[4 * intervalIndex + 1] * t + model.coefficients[4 * intervalIndex + 0];
  };
}
var DEFAULT_VALUES210 = {
  tension: 0,
  bias: 0,
  continuity: 0
};
function extend241(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES210, initialValues);
  vtkSpline1D$1.extend(publicAPI, model, initialValues);
  macro.obj(publicAPI, model);
  vtkKochanekSpline1D(publicAPI, model);
}
var newInstance216 = macro.newInstance(extend241, "vtkKochanekSpline1D");
var vtkKochanekSpline1D$1 = {
  newInstance: newInstance216,
  extend: extend241
};

// node_modules/@kitware/vtk.js/Common/DataModel/Spline3D/Constants.js
var splineKind = {
  CARDINAL_SPLINE: "CARDINAL_SPLINE",
  KOCHANEK_SPLINE: "KOCHANEK_SPLINE"
};

// node_modules/@kitware/vtk.js/Common/DataModel/Spline3D.js
var {
  vtkErrorMacro: vtkErrorMacro78
} = macro;
function vtkSpline3D(publicAPI, model) {
  model.classHierarchy.push("vtkSpline3D");
  function computeCoefficients1D(spline, points, boundaryConditionValue) {
    if (points.length === 0) {
      vtkErrorMacro78("Splines require at least one points");
    }
    if (points.length === 1) {
      points.push(points[0]);
    }
    const size = points.length;
    let work = null;
    let intervals = null;
    work = new Float32Array(size);
    if (model.intervals.length === 0) {
      intervals = new Float32Array(size);
      for (let i = 0; i < intervals.length; i++) {
        intervals[i] = i;
      }
    } else {
      intervals = model.intervals;
    }
    if (model.close) {
      spline.computeCloseCoefficients(size, work, intervals, points);
    } else {
      spline.computeOpenCoefficients(size, work, intervals, points, {
        leftConstraint: model.boundaryCondition,
        leftValue: boundaryConditionValue,
        rightConstraint: model.boundaryCondition,
        rightValue: boundaryConditionValue
      });
    }
  }
  publicAPI.computeCoefficients = (points) => {
    const x = points.map((pt) => pt[0]);
    const y = points.map((pt) => pt[1]);
    const z = points.map((pt) => pt[2]);
    computeCoefficients1D(model.splineX, x, model.boundaryConditionValues[0]);
    computeCoefficients1D(model.splineY, y, model.boundaryConditionValues[1]);
    computeCoefficients1D(model.splineZ, z, model.boundaryConditionValues[2]);
  };
  publicAPI.getPoint = (intervalIndex, t) => [model.splineX.getValue(intervalIndex, t), model.splineY.getValue(intervalIndex, t), model.splineZ.getValue(intervalIndex, t)];
  if (model.kind === splineKind.KOCHANEK_SPLINE) {
    model.splineX = vtkKochanekSpline1D$1.newInstance({
      tension: model.tension,
      continuity: model.continuity,
      bias: model.bias
    });
    model.splineY = vtkKochanekSpline1D$1.newInstance({
      tension: model.tension,
      continuity: model.continuity,
      bias: model.bias
    });
    model.splineZ = vtkKochanekSpline1D$1.newInstance({
      tension: model.tension,
      continuity: model.continuity,
      bias: model.bias
    });
  } else if (model.kind === splineKind.CARDINAL_SPLINE) {
    model.splineX = vtkCardinalSpline1D$1.newInstance();
    model.splineY = vtkCardinalSpline1D$1.newInstance();
    model.splineZ = vtkCardinalSpline1D$1.newInstance();
  } else {
    vtkErrorMacro78(`Unknown spline type ${model.kind}`);
  }
}
var DEFAULT_VALUES211 = {
  close: false,
  intervals: [],
  kind: splineKind.KOCHANEK_SPLINE,
  boundaryConditionValues: [0, 0, 0],
  // Passed to the vtkKochanekSpline1D
  tension: 0,
  continuity: 0,
  bias: 0
};
function extend242(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES211, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["close", "intervals"]);
  vtkSpline3D(publicAPI, model);
}
var newInstance217 = macro.newInstance(extend242, "vtkSpline3D");
var vtkSpline3D$1 = {
  newInstance: newInstance217,
  extend: extend242
};

// node_modules/@kitware/vtk.js/Widgets/Representations/SplineContextRepresentation.js
function vtkSplineContextRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkSplineContextRepresentation");
  model.internalPolyData = vtkPolyData$1.newInstance({
    mtime: 0
  });
  model._pipelines = {
    area: {
      source: publicAPI,
      filter: vtkTriangleFilter$1.newInstance(),
      mapper: vtkMapper$1.newInstance(),
      actor: vtkActor$1.newInstance({
        parentProp: publicAPI
      })
    },
    border: {
      source: publicAPI,
      filter: vtkLineFilter$1.newInstance(),
      mapper: vtkMapper$1.newInstance(),
      actor: vtkActor$1.newInstance({
        parentProp: publicAPI
      })
    }
  };
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.area);
  model._pipelines.area.actor.getProperty().setOpacity(0.2);
  model._pipelines.area.actor.getProperty().setColor(0, 1, 0);
  publicAPI.addActor(model._pipelines.area.actor);
  vtkWidgetRepresentation$1.connectPipeline(model._pipelines.border);
  model._pipelines.border.actor.getProperty().setOpacity(1);
  model._pipelines.border.actor.getProperty().setColor(0.1, 1, 0.1);
  model._pipelines.border.actor.setVisibility(model.outputBorder);
  publicAPI.addActor(model._pipelines.border.actor);
  const superGetRepresentationStates = publicAPI.getRepresentationStates;
  publicAPI.getRepresentationStates = function() {
    let input = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.inputData[0];
    return superGetRepresentationStates(input).filter((state) => {
      var _a, _b;
      return ((_a = state.getOrigin) == null ? void 0 : _a.call(state)) && ((_b = state.isVisible) == null ? void 0 : _b.call(state));
    });
  };
  publicAPI.requestData = (inData, outData) => {
    const widgetState = inData[0];
    outData[0] = model.internalPolyData;
    const closed = widgetState.getSplineClosed();
    const list = publicAPI.getRepresentationStates(widgetState);
    const inPoints = list.map((state) => state.getOrigin());
    if (inPoints.length <= 1) {
      return;
    }
    let numVertices = inPoints.length;
    if (!closed) {
      --numVertices;
    } else {
      inPoints.push(inPoints[0]);
    }
    const spline = vtkSpline3D$1.newInstance({
      close: widgetState.getSplineClosed(),
      kind: widgetState.getSplineKind(),
      tension: widgetState.getSplineTension(),
      bias: widgetState.getSplineBias(),
      continuity: widgetState.getSplineContinuity(),
      boundaryCondition: widgetState.getSplineBoundaryCondition(),
      boundaryConditionValues: widgetState.getSplineBoundaryConditionValues()
    });
    spline.computeCoefficients(inPoints);
    const outPoints = allocateArray(model.internalPolyData, "points", (numVertices + !closed) * model.resolution).getData();
    const outCells = new Uint32Array(numVertices * model.resolution + 2);
    outCells[0] = numVertices * model.resolution + 1;
    outCells[numVertices * model.resolution + 1] = 0;
    for (let i = 0; i < numVertices; i++) {
      for (let j = 0; j < model.resolution; j++) {
        const t = j / model.resolution;
        const point = spline.getPoint(i, t);
        outPoints[3 * (i * model.resolution + j) + 0] = point[0];
        outPoints[3 * (i * model.resolution + j) + 1] = point[1];
        outPoints[3 * (i * model.resolution + j) + 2] = point[2];
        outCells[i * model.resolution + j + 1] = i * model.resolution + j;
      }
    }
    if (closed) {
      outCells[numVertices * model.resolution + 1] = 0;
    } else {
      const lastPointIndex = numVertices * model.resolution + 1;
      const lastPoint = spline.getPoint(numVertices, 0);
      outPoints[3 * lastPointIndex + 0] = lastPoint[0];
      outPoints[3 * lastPointIndex + 1] = lastPoint[1];
      outPoints[3 * lastPointIndex + 2] = lastPoint[2];
      outCells[numVertices * model.resolution + 1] = lastPointIndex;
    }
    if (model.fill) {
      model.internalPolyData.getPolys().setData(outCells);
    }
    model.internalPolyData.getLines().setData(model.outputBorder ? outCells : []);
    model.internalPolyData.modified();
    model._pipelines.area.filter.update();
    model._pipelines.border.actor.getProperty().setColor(...inPoints.length <= 3 || model._pipelines.area.filter.getErrorCount() === 0 ? model.borderColor : model.errorBorderColor);
  };
  publicAPI.getSelectedState = (prop, compositeID) => model.state;
  function updateAreaVisibility() {
    model._pipelines.area.actor.setVisibility(model.fill);
  }
  publicAPI.setFill = macro.chain(publicAPI.setFill, updateAreaVisibility);
  publicAPI.setOutputBorder = macro.chain(publicAPI.setOutputBorder, (v) => model._pipelines.border.actor.setVisibility(v));
}
var DEFAULT_VALUES212 = {
  resolution: 16,
  fill: true,
  // boundaryCondition : BoundaryCondition.DEFAULT
  outputBorder: false,
  borderColor: [0.1, 1, 0.1],
  errorBorderColor: [1, 0, 0]
};
function extend243(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES212, initialValues);
  vtkContextRepresentation$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["mapper"]);
  macro.setGet(publicAPI, model, ["resolution", "boundaryCondition", "fill", "outputBorder"]);
  macro.setGetArray(publicAPI, model, ["borderColor", "errorBorderColor"], 3);
  vtkSplineContextRepresentation(publicAPI, model);
}
var newInstance218 = macro.newInstance(extend243, "vtkSplineContextRepresentation");
var vtkSplineContextRepresentation$1 = {
  newInstance: newInstance218,
  extend: extend243
};

// node_modules/@kitware/vtk.js/Widgets/Representations/TranslateTransformHandleRepresentation.js
function vtkTranslateTransformHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkTranslateTransformHandleRepresentation");
}
function defaultValues29(initialValues) {
  const source = vtkTransformHandleSource$1.newInstance({
    height: initialValues.height ?? 1,
    radius: initialValues.radius ?? 1,
    resolution: initialValues.glyphResolution ?? 12,
    direction: [0, 0, 1]
  });
  const cone1 = vtkConeSource$1.newInstance(initialValues.coneSource);
  const cone2 = vtkConeSource$1.newInstance(initialValues.coneSource);
  source.addInputConnection(cone1.getOutputPort());
  source.addInputConnection(cone2.getOutputPort());
  return {
    _pipeline: {
      glyph: source
    },
    ...initialValues
  };
}
function extend244(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, defaultValues29(initialValues));
  vtkTranslateTransformHandleRepresentation(publicAPI, model);
}
var newInstance219 = macro.newInstance(extend244, "vtkTranslateTransformHandleRepresentation");
var vtkTranslateTransformHandleRepresentation$1 = {
  newInstance: newInstance219,
  extend: extend244
};

// node_modules/@kitware/vtk.js/Widgets/Representations.js
var Representations2 = {
  vtkCircleContextRepresentation: vtkCircleContextRepresentation$1,
  vtkContextRepresentation: vtkContextRepresentation$1,
  vtkConvexFaceContextRepresentation: vtkConvexFaceContextRepresentation$1,
  vtkCubeHandleRepresentation: vtkCubeHandleRepresentation$1,
  vtkGlyphRepresentation: vtkGlyphRepresentation$1,
  vtkHandleRepresentation: vtkHandleRepresentation$1,
  vtkImplicitPlaneRepresentation: vtkImplicitPlaneRepresentation$1,
  vtkLineHandleRepresentation: vtkLineHandleRepresentation$1,
  vtkOutlineContextRepresentation: vtkOutlineContextRepresentation$1,
  vtkPolyLineRepresentation: vtkPolyLineRepresentation$1,
  vtkRotateTransformHandleRepresentation: vtkRotateTransformHandleRepresentation$1,
  vtkScaleTransformHandleRepresentation: vtkScaleTransformHandleRepresentation$1,
  vtkSphereHandleRepresentation: vtkSphereHandleRepresentation$1,
  vtkSplineContextRepresentation: vtkSplineContextRepresentation$1,
  vtkTranslateTransformHandleRepresentation: vtkTranslateTransformHandleRepresentation$1,
  vtkWidgetRepresentation: vtkWidgetRepresentation$1
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/AngleWidget/behavior.js
var MAX_POINTS = 3;
function widgetBehavior(publicAPI, model) {
  model.classHierarchy.push("vtkAngleWidgetProp");
  model._isDragging = false;
  const picker = vtkPointPicker$1.newInstance();
  picker.setPickFromList(1);
  publicAPI.getBounds = () => model.widgetState.getHandleList().reduce((bounds2, handle) => vtkBoundingBox.inflate(vtkBoundingBox.addPoint(bounds2, ...handle.getOrigin()), publicAPI.getScaleInPixels() ? 0 : handle.getScale1() / 2), [...vtkBoundingBox.INIT_BOUNDS]);
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  function ignoreKey(e2) {
    return e2.altKey || e2.controlKey || e2.shiftKey;
  }
  publicAPI.handleLeftButtonPress = (e2) => {
    var _a, _b;
    if (!model.activeState || !model.activeState.getActive() || !model.pickable || ignoreKey(e2)) {
      return macro.VOID;
    }
    picker.initializePickList();
    picker.setPickList(publicAPI.getNestedProps());
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    const {
      worldCoords
    } = manipulator2.handleEvent(e2, model._apiSpecificRenderWindow);
    if (model.activeState === model.widgetState.getMoveHandle() && model.widgetState.getHandleList().length < MAX_POINTS && manipulator2) {
      const moveHandle = model.widgetState.getMoveHandle();
      moveHandle.setOrigin(...worldCoords);
      const newHandle = model.widgetState.addHandle();
      newHandle.setOrigin(...moveHandle.getOrigin());
      newHandle.setColor(moveHandle.getColor());
      newHandle.setScale1(moveHandle.getScale1());
      newHandle.setManipulator(manipulator2);
    } else if (model.dragable) {
      model._isDragging = true;
      model._apiSpecificRenderWindow.setCursor("grabbing");
      model._interactor.requestAnimation(publicAPI);
    }
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (manipulator2 && model.pickable && model.dragable && model.activeState && model.activeState.getActive() && !ignoreKey(callData)) {
      const {
        worldCoords,
        worldDelta
      } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
      const isHandleMoving = model.activeState === model.widgetState.getMoveHandle() || model._isDragging;
      if (isHandleMoving && worldCoords.length && model.activeState.setOrigin) {
        const curOrigin = model.activeState.getOrigin();
        if (curOrigin) {
          model.activeState.setOrigin(add(curOrigin, worldDelta, []));
        } else {
          model.activeState.setOrigin(worldCoords);
        }
        publicAPI.invokeInteractionEvent();
        return macro.EVENT_ABORT;
      }
    }
    if (model.hasFocus) {
      model._widgetManager.disablePicking();
    }
    return macro.VOID;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    if (model.hasFocus && model.widgetState.getHandleList().length === MAX_POINTS) {
      publicAPI.loseFocus();
      return macro.VOID;
    }
    if (model._isDragging) {
      model._apiSpecificRenderWindow.setCursor("pointer");
      model.widgetState.deactivate();
      model._interactor.cancelAnimation(publicAPI);
      model._isDragging = false;
    } else if (model.activeState !== model.widgetState.getMoveHandle()) {
      model.widgetState.deactivate();
    }
    if (model.hasFocus && !model.activeState || model.activeState && !model.activeState.getActive()) {
      model._widgetManager.enablePicking();
      model._interactor.render();
    }
    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.grabFocus = () => {
    if (!model.hasFocus && model.widgetState.getHandleList().length < MAX_POINTS) {
      model.activeState = model.widgetState.getMoveHandle();
      model.activeState.activate();
      model.activeState.setVisible(true);
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent();
    }
    model.hasFocus = true;
  };
  publicAPI.loseFocus = () => {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent();
    }
    model.widgetState.deactivate();
    model.widgetState.getMoveHandle().deactivate();
    model.widgetState.getMoveHandle().setVisible(false);
    model.widgetState.getMoveHandle().setOrigin(null);
    model.activeState = null;
    model.hasFocus = false;
    model._widgetManager.enablePicking();
    model._interactor.render();
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/AngleWidget/state.js
function generateState2() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "moveHandle",
    initialValues: {
      scale1: 30,
      visible: false
    }
  }).addDynamicMixinState({
    labels: ["handles"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "handle",
    initialValues: {
      scale1: 30
    }
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/AngleWidget.js
function vtkAngleWidget(publicAPI, model) {
  model.classHierarchy.push("vtkAngleWidget");
  model.methodsToLink = ["activeScaleFactor", "activeColor", "useActiveColor", "glyphResolution", "defaultScale", "scaleInPixels"];
  model._onManipulatorChanged = () => {
    model.widgetState.getMoveHandle().setManipulator(model.manipulator);
    model.widgetState.getHandleList().forEach((handle) => {
      handle.setManipulator(model.manipulator);
    });
  };
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation$1,
          labels: ["handles", "moveHandle"]
        }, {
          builder: vtkPolyLineRepresentation$1,
          labels: ["handles", "moveHandle"]
        }];
    }
  };
  publicAPI.getAngle = () => {
    const handles = model.widgetState.getHandleList();
    if (handles.length !== 3) {
      return 0;
    }
    if (!handles[0].getOrigin() || !handles[1].getOrigin() || !handles[2].getOrigin()) {
      return 0;
    }
    const vec1 = [0, 0, 0];
    const vec2 = [0, 0, 0];
    subtract(handles[0].getOrigin(), handles[1].getOrigin(), vec1);
    subtract(handles[2].getOrigin(), handles[1].getOrigin(), vec2);
    return angleBetweenVectors(vec1, vec2);
  };
  model.widgetState.onBoundsChange((bounds2) => {
    const center = [(bounds2[0] + bounds2[1]) * 0.5, (bounds2[2] + bounds2[3]) * 0.5, (bounds2[4] + bounds2[5]) * 0.5];
    model.widgetState.getMoveHandle().setOrigin(center);
  });
  publicAPI.setManipulator(model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
}
var defaultValues30 = (initialValues) => ({
  // manipulator: null,
  behavior: widgetBehavior,
  widgetState: generateState2(),
  ...initialValues
});
function extend245(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues30(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["manipulator"]);
  vtkAngleWidget(publicAPI, model);
}
var newInstance220 = macro.newInstance(extend245, "vtkAngleWidget");
var vtkAngleWidget$1 = {
  newInstance: newInstance220,
  extend: extend245
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ShapeWidget/Constants.js
var BehaviorCategory = {
  POINTS: "POINTS",
  PLACEMENT: "PLACEMENT",
  RATIO: "RATIO"
};
var ShapeBehavior = {
  [BehaviorCategory.POINTS]: {
    CORNER_TO_CORNER: 0,
    CENTER_TO_CORNER: 1,
    RADIUS: 2,
    DIAMETER: 3
  },
  [BehaviorCategory.PLACEMENT]: {
    CLICK: 0,
    DRAG: 1,
    CLICK_AND_DRAG: 2
  },
  [BehaviorCategory.RATIO]: {
    FIXED: 0,
    FREE: 1
  }
};
var TextPosition = {
  MIN: "MIN",
  CENTER: "CENTER",
  MAX: "MAX"
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ShapeWidget.js
function vtkShapeWidget(publicAPI, model) {
  model.classHierarchy.push("vtkShapeWidget");
  const superClass = {
    ...publicAPI
  };
  model.methodsToLink = ["scaleInPixels"];
  publicAPI.setManipulator = (manipulator2) => {
    superClass.setManipulator(manipulator2);
    model.widgetState.getStatesWithLabel("moveHandle").forEach((handle) => handle.setManipulator(manipulator2));
  };
}
function defaultValues31(initialValues) {
  return {
    // manipulator: null,
    modifierBehavior: {
      None: {
        [BehaviorCategory.PLACEMENT]: ShapeBehavior[BehaviorCategory.PLACEMENT].CLICK_AND_DRAG,
        [BehaviorCategory.POINTS]: ShapeBehavior[BehaviorCategory.POINTS].CORNER_TO_CORNER,
        [BehaviorCategory.RATIO]: ShapeBehavior[BehaviorCategory.RATIO].FREE
      }
    },
    resetAfterPointPlacement: false,
    ...initialValues
  };
}
function extend246(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues31(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["manipulator", "modifierBehavior", "resetAfterPointPlacement"]);
  vtkShapeWidget(publicAPI, model);
}
var newInstance221 = macro.newInstance(extend246, "vtkShapeWidget");
var vtkShapeWidget$1 = {
  newInstance: newInstance221,
  extend: extend246
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ResliceCursorWidget/Constants.js
var ScrollingMethods = {
  MIDDLE_MOUSE_BUTTON: 0,
  LEFT_MOUSE_BUTTON: 1,
  RIGHT_MOUSE_BUTTON: 2
};
var InteractionMethodsName = {
  TranslateAxis: "translateAxis",
  RotateLine: "rotateLine",
  TranslateCenter: "translateCenter",
  TranslateCenterAndUpdatePlanes: "translateCenterAndUpdatePlanes"
};
var defaultViewUpFromViewType = {
  [ViewTypes.YZ_PLANE]: [0, 0, 1],
  // Sagittal
  [ViewTypes.XZ_PLANE]: [0, 0, 1],
  // Coronal
  [ViewTypes.XY_PLANE]: [0, -1, 0]
  // Axial
};
var xyzToViewType = [ViewTypes.YZ_PLANE, ViewTypes.XZ_PLANE, ViewTypes.XY_PLANE];
var viewTypeToXYZ = {
  [ViewTypes.YZ_PLANE]: 0,
  [ViewTypes.XZ_PLANE]: 1,
  [ViewTypes.XY_PLANE]: 2
};
var planeNames = ["X", "Y", "Z"];
var viewTypeToPlaneName = {
  [ViewTypes.YZ_PLANE]: "X",
  [ViewTypes.XZ_PLANE]: "Y",
  [ViewTypes.XY_PLANE]: "Z"
};
var planeNameToViewType = {
  X: ViewTypes.YZ_PLANE,
  Y: ViewTypes.XZ_PLANE,
  Z: ViewTypes.XY_PLANE
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ResliceCursorWidget/helpers.js
var EPSILON5 = 1e-6;
function boundPlane(bounds2, origin3, p1, p2) {
  const v1 = [];
  subtract(p1, origin3, v1);
  normalize(v1);
  const v2 = [];
  subtract(p2, origin3, v2);
  normalize(v2);
  const n = [0, 0, 1];
  cross(v1, v2, n);
  normalize(n);
  const inflatedBounds = [...bounds2];
  const eps = [...n];
  multiplyScalar(eps, EPSILON5);
  vtkBoundingBox.addBounds(inflatedBounds, bounds2[0] + eps[0], bounds2[1] + eps[0], bounds2[2] + eps[1], bounds2[3] + eps[1], bounds2[4] + eps[2], bounds2[5] + eps[2]);
  vtkBoundingBox.addBounds(inflatedBounds, bounds2[0] - eps[0], bounds2[1] - eps[0], bounds2[2] - eps[1], bounds2[3] - eps[1], bounds2[4] - eps[2], bounds2[5] - eps[2]);
  const plane = vtkPlane$1.newInstance();
  plane.setOrigin(...origin3);
  plane.setNormal(...n);
  const cubeSource = vtkCubeSource$1.newInstance();
  cubeSource.setBounds(inflatedBounds);
  const cutter = vtkCutter$1.newInstance();
  cutter.setCutFunction(plane);
  cutter.setInputConnection(cubeSource.getOutputPort());
  const cutBounds = cutter.getOutputData();
  if (cutBounds.getNumberOfPoints() === 0) {
    return false;
  }
  const localBounds = STATIC.computeLocalBounds(cutBounds.getPoints(), v1, v2, n);
  for (let i = 0; i < 3; i += 1) {
    origin3[i] = localBounds[0] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];
    p1[i] = localBounds[1] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];
    p2[i] = localBounds[0] * v1[i] + localBounds[3] * v2[i] + localBounds[4] * n[i];
  }
  return true;
}
function boundPointOnPlane(p1, p2, bounds2) {
  const dir12 = [0, 0, 0];
  subtract(p2, p1, dir12);
  const out = [0, 0, 0];
  const tolerance = [0, 0, 0];
  vtkBoundingBox.intersectBox(bounds2, p1, dir12, out, tolerance);
  return out;
}
function rotateVector(vectorToBeRotated, axis, angle) {
  const rotatedVector = [...vectorToBeRotated];
  vtkMatrixBuilder.buildFromRadian().rotate(angle, axis).apply(rotatedVector);
  return rotatedVector;
}
function getPlaneNames(widgetState) {
  return Object.keys(widgetState.getPlanes()).map((viewType) => viewTypeToPlaneName[viewType]);
}
function getLinePlaneName(lineName) {
  return lineName[0];
}
function getLineInPlaneName(lineName) {
  return lineName[3];
}
function getPlanesLineNames() {
  let planes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : planeNames;
  const lines = [];
  planes.forEach((plane) => {
    planes.forEach((inPlane) => {
      if (plane !== inPlane) {
        lines.push(`${plane}in${inPlane}`);
      }
    });
  });
  return lines;
}
function getLineNames(widgetState) {
  const planes = Object.keys(widgetState.getPlanes()).map((viewType) => viewTypeToPlaneName[viewType]);
  return getPlanesLineNames(planes);
}
function getOtherLineName(widgetState, lineName) {
  const linePlaneName = getLinePlaneName(lineName);
  const lineInPlaneName = getLineInPlaneName(lineName);
  const otherLineName = getPlaneNames(widgetState).find((planeName) => planeName !== linePlaneName && planeName !== lineInPlaneName);
  return `${otherLineName}in${lineInPlaneName}`;
}
function computeRotationHandleOriginOffset(axis, rotationHandlePosition, volumeDiagonalLength, scaleInPixels) {
  return multiplyScalar([...axis], rotationHandlePosition * (scaleInPixels ? 1 : volumeDiagonalLength) / 2);
}
function updateState(widgetState, scaleInPixels, rotationHandlePosition) {
  const planes = Object.keys(widgetState.getPlanes()).map((viewType) => viewTypeToPlaneName[viewType]);
  const axes = planes.reduce((res, plane) => {
    planes.filter((otherPlane) => plane !== otherPlane).forEach((otherPlane) => {
      const cross$1 = cross(widgetState.getPlanes()[planeNameToViewType[plane]].normal, widgetState.getPlanes()[planeNameToViewType[otherPlane]].normal, []);
      res[`${plane}${otherPlane}`] = cross$1;
      res[`${otherPlane}${plane}`] = cross$1;
    });
    return res;
  }, {});
  const bounds2 = widgetState.getImage().getBounds();
  const center = widgetState.getCenter();
  const pdLength = vtkBoundingBox.getDiagonalLength(bounds2);
  widgetState.getCenterHandle().setOrigin(center);
  getPlanesLineNames(planes).forEach((lineName) => {
    var _a, _b, _c, _d, _e, _f;
    const planeName = getLinePlaneName(lineName);
    const inPlaneName = getLineInPlaneName(lineName);
    const direction3 = axes[`${planeName}${inPlaneName}`];
    widgetState[`getRotationHandle${lineName}0`]().setOrigin(center);
    (_a = widgetState[`getRotationHandle${lineName}0`]().getManipulator()) == null ? void 0 : _a.setHandleOrigin(center);
    (_b = widgetState[`getRotationHandle${lineName}0`]().getManipulator()) == null ? void 0 : _b.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);
    widgetState[`getRotationHandle${lineName}0`]().setOffset(computeRotationHandleOriginOffset(direction3, rotationHandlePosition, pdLength, scaleInPixels));
    widgetState[`getRotationHandle${lineName}1`]().setOrigin(center);
    (_c = widgetState[`getRotationHandle${lineName}1`]().getManipulator()) == null ? void 0 : _c.setHandleOrigin(center);
    (_d = widgetState[`getRotationHandle${lineName}1`]().getManipulator()) == null ? void 0 : _d.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);
    widgetState[`getRotationHandle${lineName}1`]().setOffset(computeRotationHandleOriginOffset(direction3, -rotationHandlePosition, pdLength, scaleInPixels));
    const lineHandle = widgetState[`getAxis${lineName}`]();
    lineHandle.setOrigin(center);
    (_e = lineHandle.getManipulator()) == null ? void 0 : _e.setHandleOrigin(center);
    (_f = lineHandle.getManipulator()) == null ? void 0 : _f.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);
    normalize(direction3);
    const right = widgetState.getPlanes()[planeNameToViewType[inPlaneName]].normal;
    const up = cross(direction3, right, []);
    lineHandle.setRight(right);
    lineHandle.setUp(up);
    lineHandle.setDirection(direction3);
  });
}
function transformPlane(planeToTransform, targetCenter, targetNormal, targetViewUp) {
  planeToTransform.setNormal(targetNormal);
  const viewUp = subtract(planeToTransform.getPoint2(), planeToTransform.getOrigin(), []);
  const angle = signedAngleBetweenVectors(viewUp, targetViewUp, targetNormal);
  planeToTransform.rotate(angle, targetNormal);
  planeToTransform.setCenter(targetCenter);
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ShapeWidget/behavior.js
var {
  vtkErrorMacro: vtkErrorMacro79
} = macro;
var EPSILON6 = 1e-6;
function widgetBehavior2(publicAPI, model) {
  model.classHierarchy.push("vtkShapeWidgetProp");
  model._isDragging = false;
  model.keysDown = {};
  const superClass = {
    ...publicAPI
  };
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  publicAPI.setText = (text2) => {
    model.widgetState.getText().setText(text2);
    model._interactor.render();
  };
  publicAPI.setResetAfterPointPlacement = model._factory.setResetAfterPointPlacement;
  publicAPI.getResetAfterPointPlacement = model._factory.getResetAfterPointPlacement;
  publicAPI.setModifierBehavior = model._factory.setModifierBehavior;
  publicAPI.getModifierBehavior = model._factory.getModifierBehavior;
  publicAPI.isBehaviorActive = (category, flag) => Object.keys(model.keysDown).some((key) => model.keysDown[key] && publicAPI.getModifierBehavior()[key] && publicAPI.getModifierBehavior()[key][category] === flag);
  publicAPI.isOppositeBehaviorActive = (category, flag) => Object.values(ShapeBehavior[category]).some((flagToTry) => flag !== flagToTry && publicAPI.isBehaviorActive(category, flagToTry));
  publicAPI.getActiveBehaviorFromCategory = (category) => Object.values(ShapeBehavior[category]).find((flag) => publicAPI.isBehaviorActive(category, flag) || !publicAPI.isOppositeBehaviorActive(category, flag) && publicAPI.getModifierBehavior().None[category] === flag);
  publicAPI.isRatioFixed = () => publicAPI.getActiveBehaviorFromCategory(BehaviorCategory.RATIO) === ShapeBehavior[BehaviorCategory.RATIO].FIXED;
  publicAPI.isDraggingEnabled = () => {
    const behavior = publicAPI.getActiveBehaviorFromCategory(BehaviorCategory.PLACEMENT);
    return behavior === ShapeBehavior[BehaviorCategory.PLACEMENT].DRAG || behavior === ShapeBehavior[BehaviorCategory.PLACEMENT].CLICK_AND_DRAG;
  };
  publicAPI.isDraggingForced = () => publicAPI.isBehaviorActive(BehaviorCategory.PLACEMENT, ShapeBehavior[BehaviorCategory.PLACEMENT].DRAG) || publicAPI.getModifierBehavior().None[BehaviorCategory.PLACEMENT] === ShapeBehavior[BehaviorCategory.PLACEMENT].DRAG;
  publicAPI.getPoint1 = () => model.point1;
  publicAPI.getPoint2 = () => model.point2;
  publicAPI.setPoints = (point1, point2) => {
    model.point1 = point1;
    model.point2 = point2;
    model.point1Handle.setOrigin(model.point1);
    model.point2Handle.setOrigin(model.point2);
    publicAPI.updateShapeBounds();
  };
  publicAPI.placePoint1 = (point) => {
    if (model.hasFocus) {
      publicAPI.setPoints(point, point);
      model.point1Handle.deactivate();
      model.point2Handle.activate();
      model.activeState = model.point2Handle;
      model.point2Handle.setVisible(true);
      model.widgetState.getText().setVisible(true);
      publicAPI.updateShapeBounds();
      model.shapeHandle.setVisible(true);
    }
  };
  publicAPI.placePoint2 = (point2) => {
    if (model.hasFocus) {
      model.point2 = point2;
      model.point2Handle.setOrigin(model.point2);
      publicAPI.updateShapeBounds();
    }
  };
  publicAPI.makeSquareFromPoints = (point1, point2) => {
    const diagonal = [0, 0, 0];
    vec3_exports.subtract(diagonal, point2, point1);
    const dir = model.shapeHandle.getDirection();
    const right = model.shapeHandle.getRight();
    const up = model.shapeHandle.getUp();
    const dirComponent = vec3_exports.dot(diagonal, dir);
    let rightComponent = vec3_exports.dot(diagonal, right);
    let upComponent = vec3_exports.dot(diagonal, up);
    const absRightComponent = Math.abs(rightComponent);
    const absUpComponent = Math.abs(upComponent);
    if (absRightComponent < EPSILON6) {
      rightComponent = upComponent;
    } else if (absUpComponent < EPSILON6) {
      upComponent = rightComponent;
    } else if (absRightComponent > absUpComponent) {
      upComponent = upComponent / absUpComponent * absRightComponent;
    } else {
      rightComponent = rightComponent / absRightComponent * absUpComponent;
    }
    return [point1[0] + rightComponent * right[0] + upComponent * up[0] + dirComponent * dir[0], point1[1] + rightComponent * right[1] + upComponent * up[1] + dirComponent * dir[1], point1[2] + rightComponent * right[2] + upComponent * up[2] + dirComponent * dir[2]];
  };
  const getCornersFromRadius = (center, pointOnCircle) => {
    const radius = vec3_exports.distance(center, pointOnCircle);
    const up = model.shapeHandle.getUp();
    const right = model.shapeHandle.getRight();
    const point1 = [center[0] + (up[0] - right[0]) * radius, center[1] + (up[1] - right[1]) * radius, center[2] + (up[2] - right[2]) * radius];
    const point2 = [center[0] + (right[0] - up[0]) * radius, center[1] + (right[1] - up[1]) * radius, center[2] + (right[2] - up[2]) * radius];
    return {
      point1,
      point2
    };
  };
  const getCornersFromDiameter = (point1, point2) => {
    const center = [0.5 * (point1[0] + point2[0]), 0.5 * (point1[1] + point2[1]), 0.5 * (point1[2] + point2[2])];
    return getCornersFromRadius(center, point1);
  };
  publicAPI.getBounds = () => model.point1 && model.point2 ? vtkBoundingBox.addPoints(vtkBoundingBox.reset([]), [model.point1, model.point2]) : vtkMath.uninitializeBounds([]);
  publicAPI.setCorners = (point1, point2) => {
    publicAPI.updateTextPosition(point1, point2);
  };
  publicAPI.updateShapeBounds = () => {
    if (model.point1 && model.point2) {
      const point1 = [...model.point1];
      let point2 = [...model.point2];
      if (publicAPI.isRatioFixed()) {
        point2 = publicAPI.makeSquareFromPoints(point1, point2);
      }
      switch (publicAPI.getActiveBehaviorFromCategory(BehaviorCategory.POINTS)) {
        case ShapeBehavior[BehaviorCategory.POINTS].CORNER_TO_CORNER: {
          publicAPI.setCorners(point1, point2);
          break;
        }
        case ShapeBehavior[BehaviorCategory.POINTS].CENTER_TO_CORNER: {
          const diagonal = [0, 0, 0];
          vec3_exports.subtract(diagonal, point1, point2);
          vec3_exports.add(point1, point1, diagonal);
          publicAPI.setCorners(point1, point2);
          break;
        }
        case ShapeBehavior[BehaviorCategory.POINTS].RADIUS: {
          const points = getCornersFromRadius(point1, point2);
          publicAPI.setCorners(points.point1, points.point2);
          break;
        }
        case ShapeBehavior[BehaviorCategory.POINTS].DIAMETER: {
          const points = getCornersFromDiameter(point1, point2);
          publicAPI.setCorners(points.point1, points.point2);
          break;
        }
        default:
          vtkErrorMacro79("vtk internal error");
      }
    }
  };
  const computePositionVector = (textPosition, minPoint, maxPoint) => {
    const positionVector = [0, 0, 0];
    switch (textPosition) {
      case TextPosition.MIN:
        break;
      case TextPosition.MAX:
        vtkMath.subtract(maxPoint, minPoint, positionVector);
        break;
      case TextPosition.CENTER:
      default:
        vtkMath.subtract(maxPoint, minPoint, positionVector);
        vtkMath.multiplyScalar(positionVector, 0.5);
        break;
    }
    return positionVector;
  };
  const computeTextPosition = function(worldBounds, textPosition) {
    let worldMargin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const viewPlaneOrigin = vtkBoundingBox.getCenter(worldBounds);
    const viewPlaneNormal = model._renderer.getActiveCamera().getDirectionOfProjection();
    const viewUp = model._renderer.getActiveCamera().getViewUp();
    const positionMargin = Array.isArray(worldMargin) ? [...worldMargin] : [worldMargin, worldMargin, viewPlaneOrigin ? worldMargin : 0];
    const minPoint = model._apiSpecificRenderWindow.worldToDisplay(...vtkBoundingBox.getMinPoint(worldBounds), model._renderer);
    const maxPoint = model._apiSpecificRenderWindow.worldToDisplay(...vtkBoundingBox.getMaxPoint(worldBounds), model._renderer);
    const displayBounds = vtkBoundingBox.addPoints(vtkBoundingBox.reset([]), [minPoint, maxPoint]);
    let planeOrigin = [];
    let p1 = [];
    let p2 = [];
    let p3 = [];
    if (viewPlaneOrigin && viewPlaneNormal && viewUp && vtkBoundingBox.intersectPlane(displayBounds, viewPlaneOrigin, viewPlaneNormal)) {
      const displayPlaneOrigin = model._apiSpecificRenderWindow.worldToDisplay(...viewPlaneOrigin, model._renderer);
      const planeNormalPoint = vtkMath.add(viewPlaneOrigin, viewPlaneNormal, []);
      const displayPlaneNormalPoint = model._apiSpecificRenderWindow.worldToDisplay(...planeNormalPoint, model._renderer);
      const displayPlaneNormal = vtkMath.subtract(displayPlaneNormalPoint, displayPlaneOrigin, []);
      const largeDistance = 10 * vtkBoundingBox.getDiagonalLength(displayBounds);
      vtkPlane$1.projectPoint(vtkBoundingBox.getCenter(displayBounds), displayPlaneOrigin, displayPlaneNormal, planeOrigin);
      const planeU = vtkMath.cross(viewUp, displayPlaneNormal, []);
      vtkMath.normalize(planeU);
      vtkMath.normalize(viewUp);
      vtkMath.normalize(displayPlaneNormal);
      vtkMath.multiplyAccumulate(planeOrigin, viewUp, -largeDistance, planeOrigin);
      vtkMath.multiplyAccumulate(planeOrigin, planeU, -largeDistance, planeOrigin);
      p1 = vtkMath.multiplyAccumulate(planeOrigin, planeU, 2 * largeDistance, []);
      p2 = vtkMath.multiplyAccumulate(planeOrigin, viewUp, 2 * largeDistance, []);
      p3 = planeOrigin;
      boundPlane(displayBounds, planeOrigin, p1, p2);
    } else {
      planeOrigin = [displayBounds[0], displayBounds[2], displayBounds[4]];
      p1 = [displayBounds[1], displayBounds[2], displayBounds[4]];
      p2 = [displayBounds[0], displayBounds[3], displayBounds[4]];
      p3 = [displayBounds[0], displayBounds[2], displayBounds[5]];
    }
    const u = computePositionVector(textPosition[0], planeOrigin, p1);
    const v = computePositionVector(textPosition[1], planeOrigin, p2);
    const w = computePositionVector(textPosition[2], planeOrigin, p3);
    const finalPosition = planeOrigin;
    vtkMath.add(finalPosition, u, finalPosition);
    vtkMath.add(finalPosition, v, finalPosition);
    vtkMath.add(finalPosition, w, finalPosition);
    vtkMath.add(finalPosition, positionMargin, finalPosition);
    return model._apiSpecificRenderWindow.displayToWorld(...finalPosition, model._renderer);
  };
  publicAPI.updateTextPosition = (point1, point2) => {
    const bounds2 = vtkBoundingBox.addPoints(vtkBoundingBox.reset([]), [point1, point2]);
    const screenPosition = computeTextPosition(bounds2, model.widgetState.getTextPosition(), model.widgetState.getTextWorldMargin());
    const textHandle = model.widgetState.getText();
    textHandle.setOrigin(screenPosition);
  };
  publicAPI.reset = () => {
    model.point1 = null;
    model.point2 = null;
    model.widgetState.getText().setVisible(false);
    model.point1Handle.setOrigin(null);
    model.point2Handle.setOrigin(null);
    model.shapeHandle.setOrigin(null);
    model.shapeHandle.setVisible(false);
    model.point2Handle.setVisible(false);
    model.point2Handle.deactivate();
    if (model.hasFocus) {
      model.point1Handle.activate();
      model.activeState = model.point1Handle;
    } else {
      model.point1Handle.setVisible(false);
      model.point1Handle.deactivate();
      model.activeState = null;
    }
    publicAPI.updateShapeBounds();
  };
  publicAPI.handleMouseMove = (callData) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (!manipulator2 || !model.activeState || !model.activeState.getActive() || !model.pickable || !model.dragable) {
      return macro.VOID;
    }
    if (!model.point2) {
      const normal = model._camera.getDirectionOfProjection();
      const up = model._camera.getViewUp();
      const right = [];
      vec3_exports.cross(right, up, normal);
      vtkMath.normalize(right);
      vec3_exports.cross(up, normal, right);
      vtkMath.normalize(up);
      model.shapeHandle.setUp(up);
      model.shapeHandle.setRight(right);
      model.shapeHandle.setDirection(normal);
    }
    const {
      worldCoords,
      worldDelta
    } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
    if (!worldCoords.length) {
      return macro.VOID;
    }
    if (model.hasFocus) {
      if (!model.point1) {
        model.point1Handle.setOrigin(worldCoords);
      } else {
        model.point2Handle.setOrigin(worldCoords);
        model.point2 = worldCoords;
        publicAPI.updateShapeBounds();
        publicAPI.invokeInteractionEvent();
      }
    } else if (model._isDragging) {
      if (model.activeState === model.point1Handle) {
        vtkMath.add(model.point1Handle.getOrigin(), worldDelta, model.point1);
        model.point1Handle.setOrigin(model.point1);
      } else {
        vtkMath.add(model.point2Handle.getOrigin(), worldDelta, model.point2);
        model.point2Handle.setOrigin(model.point2);
      }
      publicAPI.updateShapeBounds();
      publicAPI.invokeInteractionEvent();
    }
    return model.hasFocus || model._isDragging ? macro.EVENT_ABORT : macro.VOID;
  };
  publicAPI.handleLeftButtonPress = (e2) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (!model.activeState || !model.activeState.getActive() || !model.pickable || !manipulator2) {
      return macro.VOID;
    }
    const {
      worldCoords
    } = manipulator2.handleEvent(e2, model._apiSpecificRenderWindow);
    if (model.hasFocus) {
      if (!model.point1) {
        model.point1Handle.setOrigin(worldCoords);
        publicAPI.placePoint1(model.point1Handle.getOrigin());
        publicAPI.invokeStartInteractionEvent();
      } else {
        model.point2Handle.setOrigin(worldCoords);
        publicAPI.placePoint2(model.point2Handle.getOrigin());
        publicAPI.invokeInteractionEvent();
        publicAPI.invokeEndInteractionEvent();
        if (publicAPI.getResetAfterPointPlacement()) {
          publicAPI.reset();
        } else {
          publicAPI.loseFocus();
        }
      }
      return macro.EVENT_ABORT;
    }
    if (model.point1 && (model.activeState === model.point1Handle || model.activeState === model.point2Handle) && model.dragable) {
      model._isDragging = true;
      model._apiSpecificRenderWindow.setCursor("grabbing");
      model._interactor.requestAnimation(publicAPI);
    }
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleLeftButtonRelease = (e2) => {
    if (model._isDragging) {
      model._isDragging = false;
      model._apiSpecificRenderWindow.setCursor("pointer");
      model.widgetState.deactivate();
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent();
      return macro.EVENT_ABORT;
    }
    if (!model.hasFocus || !model.pickable) {
      return macro.VOID;
    }
    const viewSize = model._apiSpecificRenderWindow.getSize();
    if (e2.position.x < 0 || e2.position.x > viewSize[0] - 1 || e2.position.y < 0 || e2.position.y > viewSize[1] - 1) {
      return macro.VOID;
    }
    if (model.point1) {
      publicAPI.placePoint2(model.point2Handle.getOrigin());
      if (publicAPI.isDraggingEnabled()) {
        const distance = vec3_exports.squaredDistance(model.point1, model.point2);
        const maxDistance = 100;
        if (distance > maxDistance || publicAPI.isDraggingForced()) {
          publicAPI.invokeInteractionEvent();
          publicAPI.invokeEndInteractionEvent();
          if (publicAPI.getResetAfterPointPlacement()) {
            publicAPI.reset();
          } else {
            publicAPI.loseFocus();
          }
        }
      }
    }
    return macro.EVENT_ABORT;
  };
  publicAPI.handleKeyDown = (_ref) => {
    let {
      key
    } = _ref;
    if (key === "Escape") {
      if (model.hasFocus) {
        publicAPI.reset();
        publicAPI.loseFocus();
        publicAPI.invokeEndInteractionEvent();
      }
    } else {
      model.keysDown[key] = true;
    }
    if (model.hasFocus) {
      if (model.point1) {
        model.point2 = model.point2Handle.getOrigin();
        publicAPI.updateShapeBounds();
      }
    }
  };
  publicAPI.handleKeyUp = (_ref2) => {
    let {
      key
    } = _ref2;
    model.keysDown[key] = false;
    if (model.hasFocus) {
      if (model.point1) {
        model.point2 = model.point2Handle.getOrigin();
        publicAPI.updateShapeBounds();
      }
    }
  };
  publicAPI.grabFocus = () => {
    if (!model.hasFocus) {
      publicAPI.reset();
      model.point1Handle.activate();
      model.activeState = model.point1Handle;
      model.point1Handle.setVisible(true);
      model.shapeHandle.setVisible(false);
      model._interactor.requestAnimation(publicAPI);
    }
    superClass.grabFocus();
  };
  publicAPI.loseFocus = () => {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);
    }
    if (!model.point1) {
      model.point1Handle.setVisible(false);
      model.point2Handle.setVisible(false);
    }
    model.widgetState.deactivate();
    model.point1Handle.deactivate();
    model.point2Handle.deactivate();
    model.activeState = null;
    model._interactor.render();
    model._widgetManager.enablePicking();
    superClass.loseFocus();
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/EllipseWidget/behavior.js
function widgetBehavior3(publicAPI, model) {
  model.shapeHandle = model.widgetState.getEllipseHandle();
  model.point1Handle = model.widgetState.getPoint1Handle();
  model.point2Handle = model.widgetState.getPoint2Handle();
  model.point1Handle.setManipulator(model.manipulator);
  model.point2Handle.setManipulator(model.manipulator);
  widgetBehavior2(publicAPI, model);
  const superClass = {
    ...publicAPI
  };
  model.classHierarchy.push("vtkEllipseWidgetProp");
  publicAPI.setCorners = (point1, point2) => {
    if (superClass.setCorners) {
      superClass.setCorners(point1, point2);
    }
    const center = [0.5 * (point1[0] + point2[0]), 0.5 * (point1[1] + point2[1]), 0.5 * (point1[2] + point2[2])];
    const diagonal = [0, 0, 0];
    vec3_exports.subtract(diagonal, point2, center);
    const right = model.shapeHandle.getRight();
    const up = model.shapeHandle.getUp();
    const dir = model.shapeHandle.getDirection();
    const rightComponent = vec3_exports.dot(diagonal, right);
    const upComponent = vec3_exports.dot(diagonal, up);
    const dirComponent = vec3_exports.dot(diagonal, dir);
    model.shapeHandle.setOrigin(center);
    model.shapeHandle.setScale3([rightComponent, upComponent, dirComponent]);
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/EllipseWidget/state.js
function generateState3() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "point1Handle",
    initialValues: {
      scale1: 10,
      visible: false
    }
  }).addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "point2Handle",
    initialValues: {
      scale1: 10,
      visible: false
    }
  }).addStateFromMixin({
    labels: ["ellipseHandle"],
    mixins: ["origin", "color", "scale3", "visible", "orientation"],
    name: "ellipseHandle",
    initialValues: {
      // visible: false,
      scale3: [1, 1, 1]
    }
  }).addStateFromMixin({
    labels: ["SVGtext"],
    mixins: ["origin", "color", "text", "visible"],
    name: "text",
    initialValues: {
      /* text is empty to set a text filed in the SVGLayer and to avoid
       * displaying text before positioning the handles */
      text: ""
    }
  }).addField({
    name: "textPosition",
    initialValue: [TextPosition.CENTER, TextPosition.CENTER, TextPosition.CENTER]
  }).addField({
    name: "textWorldMargin",
    initialValue: 0
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/EllipseWidget.js
function vtkEllipseWidget(publicAPI, model) {
  model.classHierarchy.push("vtkEllipseWidget");
  model.methodsToLink = [...model.methodsToLink, "activeScaleFactor", "activeColor", "useActiveColor", "glyphResolution", "defaultScale", "drawBorder", "drawFace", "opacity"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation$1,
          labels: ["moveHandle"]
        }, {
          builder: vtkCircleContextRepresentation$1,
          labels: ["ellipseHandle"]
        }];
    }
  };
  publicAPI.setManipulator(model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
}
function defaultValues32(initialValues) {
  return {
    behavior: widgetBehavior3,
    widgetState: generateState3(),
    modifierBehavior: {
      None: {
        [BehaviorCategory.PLACEMENT]: ShapeBehavior[BehaviorCategory.PLACEMENT].CLICK_AND_DRAG,
        [BehaviorCategory.POINTS]: ShapeBehavior[BehaviorCategory.POINTS].CENTER_TO_CORNER,
        [BehaviorCategory.RATIO]: ShapeBehavior[BehaviorCategory.RATIO].FREE
      },
      Shift: {
        [BehaviorCategory.RATIO]: ShapeBehavior[BehaviorCategory.RATIO].FIXED
      },
      Control: {
        [BehaviorCategory.POINTS]: ShapeBehavior[BehaviorCategory.POINTS].CORNER_TO_CORNER
      }
    },
    ...initialValues
  };
}
function extend247(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkShapeWidget$1.extend(publicAPI, model, defaultValues32(initialValues));
  macro.setGet(publicAPI, model, ["widgetState"]);
  vtkEllipseWidget(publicAPI, model);
}
var newInstance222 = macro.newInstance(extend247, "vtkEllipseWidget");
var vtkEllipseWidget$1 = {
  newInstance: newInstance222,
  extend: extend247
};

// node_modules/@kitware/vtk.js/Widgets/Representations/CroppingOutlineRepresentation.js
var {
  vtkErrorMacro: vtkErrorMacro80
} = macro;
var OUTLINE_ARRAY = [2, 0, 1, 2, 0, 2, 2, 0, 4, 2, 1, 3, 2, 1, 5, 2, 2, 3, 2, 2, 6, 2, 3, 7, 2, 4, 5, 2, 4, 6, 2, 5, 7, 2, 6, 7];
function vtkCroppingOutlineRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkCroppingOutlineRepresentation");
  model.internalPolyData = vtkPolyData$1.newInstance({
    mtime: 0
  });
  allocateArray(model.internalPolyData, "lines", OUTLINE_ARRAY.length).getData().set(OUTLINE_ARRAY);
  const applyOrigin = origin2(publicAPI, model);
  model.mapper = vtkMapper$1.newInstance({
    scalarVisibility: false
  });
  model.actor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.actor.getProperty().setEdgeColor(...model.edgeColor);
  model.mapper.setInputConnection(publicAPI.getOutputPort());
  model.actor.setMapper(model.mapper);
  publicAPI.addActor(model.actor);
  publicAPI.requestData = (inData, outData) => {
    const list = publicAPI.getRepresentationStates(inData[0]).filter((state) => state.getOrigin && state.getOrigin());
    if (list.length === 8) {
      applyOrigin(model.internalPolyData, list);
      model.internalPolyData.getPoints().modified();
      model.internalPolyData.modified();
      outData[0] = model.internalPolyData;
    } else {
      vtkErrorMacro80("CroppingOutlineRepresentation did not get 8 states");
    }
  };
}
var DEFAULT_VALUES213 = {
  edgeColor: [1, 1, 1]
};
function extend248(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES213, initialValues);
  vtkContextRepresentation$1.extend(publicAPI, model, initialValues);
  macro.setGetArray(publicAPI, model, ["edgeColor"], 3);
  macro.get(publicAPI, model, ["mapper", "actor"]);
  vtkCroppingOutlineRepresentation(publicAPI, model);
}
var newInstance223 = macro.newInstance(extend248, "vtkCroppingOutlineRepresentation");
var vtkCroppingOutlineRepresentation$1 = {
  newInstance: newInstance223,
  extend: extend248
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ImageCroppingWidget/helpers.js
var AXES = ["-", "=", "+"];
function transformVec3(ain, transform) {
  const vout = new Float64Array(3);
  vec3_exports.transformMat4(vout, ain, transform);
  return vout;
}
function handleTypeFromName(name2) {
  const [i, j, k] = name2.split("").map((l) => AXES.indexOf(l) - 1);
  if (i * j * k !== 0) {
    return "corners";
  }
  if (i * j !== 0 || j * k !== 0 || k * i !== 0) {
    return "edges";
  }
  return "faces";
}
function calculateCropperCenter(planes, transform) {
  const center = [(planes[0] + planes[1]) / 2, (planes[2] + planes[3]) / 2, (planes[4] + planes[5]) / 2];
  return transformVec3(center, transform);
}
function calculateDirection(v1, v2) {
  const direction3 = vec3_exports.create();
  vec3_exports.subtract(direction3, v1, v2);
  vec3_exports.normalize(direction3, direction3);
  return direction3;
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ImageCroppingWidget/behavior.js
function widgetBehavior4(publicAPI, model) {
  model._isDragging = false;
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  publicAPI.handleLeftButtonPress = (callData) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    if (model.dragable) {
      model.activeState.getManipulator().handleEvent(callData, model._apiSpecificRenderWindow);
      model._isDragging = true;
      model._apiSpecificRenderWindow.setCursor("grabbing");
      model._interactor.requestAnimation(publicAPI);
    }
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => {
    if (model._isDragging) {
      return publicAPI.handleEvent(callData);
    }
    return macro.VOID;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    if (model._isDragging) {
      model._isDragging = false;
      model._interactor.cancelAnimation(publicAPI);
      model.widgetState.deactivate();
    }
    return macro.EVENT_ABORT;
  };
  publicAPI.handleEvent = (callData) => {
    if (model.pickable && model.activeState && model.activeState.getActive()) {
      const manipulator2 = model.activeState.getManipulator();
      if (manipulator2) {
        const name2 = model.activeState.getName();
        const type = handleTypeFromName(name2);
        const index = name2.split("").map((l) => AXES.indexOf(l));
        const planes = model.widgetState.getCroppingPlanes().getPlanes();
        const indexToWorldT = model.widgetState.getIndexToWorldT();
        let worldCoords = [];
        let worldDelta = [];
        if (type === "corners") {
          ({
            worldCoords,
            worldDelta
          } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow));
        }
        if (type === "faces") {
          const worldCenter = calculateCropperCenter(planes, indexToWorldT);
          manipulator2.setHandleOrigin(worldCenter);
          manipulator2.setHandleNormal(calculateDirection(model.activeState.getOrigin(), worldCenter));
          ({
            worldCoords,
            worldDelta
          } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow));
        }
        if (type === "edges") {
          const edgeAxis = index.map((a2) => a2 === 1 ? a2 : 0);
          const faceName = edgeAxis.map((i) => AXES[i + 1]).join("");
          const handle = model.widgetState.getStatesWithLabel(faceName)[0];
          const worldCenter = calculateCropperCenter(planes, indexToWorldT);
          manipulator2.setHandleNormal(calculateDirection(handle.getOrigin(), worldCenter));
          ({
            worldCoords,
            worldDelta
          } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow));
        }
        if (worldCoords.length && worldDelta.length) {
          const worldToIndexT = model.widgetState.getWorldToIndexT();
          const indexCoords = transformVec3(worldCoords, worldToIndexT);
          for (let i = 0; i < 3; i++) {
            if (index[i] === 0) {
              planes[i * 2] = indexCoords[i];
            } else if (index[i] === 2) {
              planes[i * 2 + 1] = indexCoords[i];
            }
          }
          model.activeState.setOrigin(add(model.activeState.getOrigin(), worldDelta, []));
          model.widgetState.getCroppingPlanes().setPlanes(...planes);
          return macro.EVENT_ABORT;
        }
      }
    }
    return macro.VOID;
  };
  model._camera = model._renderer.getActiveCamera();
  model.classHierarchy.push("vtkImageCroppingWidgetProp");
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ImageCroppingWidget/state.js
function build2() {
  const builder = vtkStateBuilder.createBuilder();
  builder.addField({
    name: "indexToWorldT",
    initialValue: Array(16).fill(0)
  }).addField({
    name: "worldToIndexT",
    initialValue: Array(16).fill(0)
  });
  const croppingState = vtkStateBuilder.createBuilder().addField({
    name: "planes",
    // index space
    initialValue: [0, 1, 0, 1, 0, 1]
  }).build();
  builder.addStateFromInstance({
    labels: ["croppingPlanes"],
    name: "croppingPlanes",
    instance: croppingState
  });
  for (let i = -1; i < 2; i++) {
    for (let j = -1; j < 2; j++) {
      for (let k = -1; k < 2; k++) {
        if (i !== 0 || j !== 0 || k !== 0) {
          const name2 = AXES[i + 1] + AXES[j + 1] + AXES[k + 1];
          const type = handleTypeFromName(name2);
          builder.addStateFromMixin({
            labels: ["handles", name2, type],
            mixins: ["name", "origin", "color", "scale1", "visible", "manipulator"],
            name: name2,
            initialValues: {
              scale1: 30,
              origin: [i, j, k],
              visible: true,
              name: name2
            }
          });
        }
      }
    }
  }
  return builder.build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ImageCroppingWidget.js
function vtkImageCroppingWidget(publicAPI, model) {
  model.classHierarchy.push("vtkImageCroppingWidget");
  const superClass = {
    ...publicAPI
  };
  let stateSub = null;
  function setHandlesEnabled(label, flag) {
    model.widgetState.getStatesWithLabel(label).forEach((handle) => {
      handle.setVisible(flag);
    });
  }
  publicAPI.setFaceHandlesEnabled = (flag) => setHandlesEnabled("faces", flag);
  publicAPI.setEdgeHandlesEnabled = (flag) => setHandlesEnabled("edges", flag);
  publicAPI.setCornerHandlesEnabled = (flag) => setHandlesEnabled("corners", flag);
  publicAPI.copyImageDataDescription = (im) => {
    model.widgetState.setIndexToWorldT(...im.getIndexToWorld());
    model.widgetState.setWorldToIndexT(...im.getWorldToIndex());
    const dims = im.getDimensions();
    const planeState = model.widgetState.getCroppingPlanes();
    planeState.setPlanes([0, dims[0], 0, dims[1], 0, dims[2]]);
    publicAPI.modified();
  };
  publicAPI.updateHandles = () => {
    const planes = model.widgetState.getCroppingPlanes().getPlanes();
    const midpts = [(planes[0] + planes[1]) / 2, (planes[2] + planes[3]) / 2, (planes[4] + planes[5]) / 2];
    const iAxis = [planes[0], midpts[0], planes[1]];
    const jAxis = [planes[2], midpts[1], planes[3]];
    const kAxis = [planes[4], midpts[2], planes[5]];
    const indexToWorldT = model.widgetState.getIndexToWorldT();
    const getAxis = (a2) => AXES[a2];
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        for (let k = 0; k < 3; k++) {
          if (i !== 1 || j !== 1 || k !== 1) {
            const name2 = [i, j, k].map(getAxis).join("");
            const coord = transformVec3([iAxis[i], jAxis[j], kAxis[k]], indexToWorldT);
            const [handle] = model.widgetState.getStatesWithLabel(name2);
            handle.setOrigin(...coord);
          }
        }
      }
    }
  };
  publicAPI.delete = macro.chain(publicAPI.delete, () => {
    if (stateSub) {
      stateSub.unsubscribe();
    }
  });
  model.methodsToLink = ["scaleInPixels"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [
          // Describes constructing a vtkSphereHandleRepresentation, and every
          // time the widget state updates, we will give the representation
          // a list of all handle states (which have the label "handles").
          {
            builder: vtkSphereHandleRepresentation$1,
            labels: ["handles"]
          },
          {
            builder: vtkCroppingOutlineRepresentation$1,
            // outline is defined by corner points
            labels: ["corners"]
          }
        ];
    }
  };
  stateSub = model.widgetState.getCroppingPlanes().onModified(publicAPI.updateHandles);
  publicAPI.setCornerManipulator = (manipulator2) => {
    superClass.setCornerManipulator(manipulator2);
    model.widgetState.getStatesWithLabel("corners").forEach((handle) => handle.setManipulator(manipulator2));
  };
  publicAPI.setEdgeManipulator = (manipulator2) => {
    superClass.setEdgeManipulator(manipulator2);
    model.widgetState.getStatesWithLabel("edges").forEach((handle) => handle.setManipulator(manipulator2));
  };
  publicAPI.setFaceManipulator = (manipulator2) => {
    superClass.setFaceManipulator(manipulator2);
    model.widgetState.getStatesWithLabel("faces").forEach((handle) => handle.setManipulator(manipulator2));
  };
  publicAPI.setCornerManipulator(vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
  publicAPI.setEdgeManipulator(vtkPlaneManipulator$1.newInstance());
  publicAPI.setFaceManipulator(vtkLineManipulator$1.newInstance());
}
var defaultValues33 = (initialValues) => ({
  // cornerManipulator: null,
  // edgeManipulator: null,
  // faceManipulator: null,
  behavior: widgetBehavior4,
  widgetState: build2(),
  ...initialValues
});
function extend249(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues33(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["cornerManipulator", "edgeManipulator", "faceManipulator"]);
  vtkImageCroppingWidget(publicAPI, model);
}
var newInstance224 = macro.newInstance(extend249, "vtkImageCroppingWidget");
var vtkImageCroppingWidget$1 = {
  newInstance: newInstance224,
  extend: extend249
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ImplicitPlaneWidget.js
function widgetBehavior5(publicAPI, model) {
  model.classHierarchy.push("vtkPlaneWidget");
  model._isDragging = false;
  model._draggingWidgetOrigin = [0, 0, 0];
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  publicAPI.updateCursor = () => {
    switch (model.activeState.getUpdateMethodName()) {
      case "updateFromOrigin":
        model._apiSpecificRenderWindow.setCursor("crosshair");
        break;
      case "updateFromPlane":
        model._apiSpecificRenderWindow.setCursor("move");
        break;
      case "updateFromNormal":
        model._apiSpecificRenderWindow.setCursor("alias");
        break;
      default:
        model._apiSpecificRenderWindow.setCursor("grabbing");
        break;
    }
  };
  publicAPI.handleLeftButtonPress = (callData) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    model.lineManipulator.setWidgetOrigin(model.activeState.getOrigin());
    model.lineManipulator.setWidgetNormal(model.activeState.getNormal());
    model.planeManipulator.setWidgetOrigin(model.activeState.getOrigin());
    model.planeManipulator.setWidgetNormal(model.activeState.getNormal());
    model.trackballManipulator.reset(callData);
    model.trackballManipulator.setWidgetNormal(model.activeState.getNormal());
    let activeManipulator = null;
    switch (model.activeState.getUpdateMethodName()) {
      case "updateFromOrigin":
        activeManipulator = model.planeManipulator;
        break;
      case "updateFromPlane":
        activeManipulator = model.lineManipulator;
        break;
      case "updateFromNormal":
        activeManipulator = model.trackballManipulator;
        break;
    }
    if (activeManipulator) {
      activeManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    }
    if (model.dragable) {
      model._draggingWidgetOrigin = model.widgetState.getOrigin();
      model._isDragging = true;
      model._apiSpecificRenderWindow.setCursor("grabbing");
      model._interactor.requestAnimation(publicAPI);
    }
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => {
    if (model._isDragging) {
      return publicAPI.handleEvent(callData);
    }
    return macro.VOID;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    if (model._isDragging) {
      model._interactor.cancelAnimation(publicAPI);
      model._isDragging = false;
    }
    model.widgetState.deactivate();
    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleEvent = (callData) => {
    if (model.pickable && model.activeState && model.activeState.getActive()) {
      publicAPI[model.activeState.getUpdateMethodName()](callData);
      publicAPI.invokeInteractionEvent();
      return macro.EVENT_ABORT;
    }
    return macro.VOID;
  };
  publicAPI.updateFromOrigin = (callData) => {
    model.planeManipulator.setWidgetNormal(model.widgetState.getNormal());
    const {
      worldCoords,
      worldDelta
    } = model.planeManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    add(model._draggingWidgetOrigin, worldDelta, model._draggingWidgetOrigin);
    if (model.widgetState.containsPoint(...worldCoords)) {
      model.activeState.setOrigin(model._draggingWidgetOrigin);
    }
  };
  publicAPI.updateFromPlane = (callData) => {
    model.lineManipulator.setWidgetNormal(model.activeState.getNormal());
    const {
      worldDelta
    } = model.lineManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    add(model._draggingWidgetOrigin, worldDelta, model._draggingWidgetOrigin);
    if (model.widgetState.containsPoint(...model._draggingWidgetOrigin)) {
      model.activeState.setOrigin(model._draggingWidgetOrigin);
    }
  };
  publicAPI.updateFromNormal = (callData) => {
    model.trackballManipulator.setWidgetNormal(model.activeState.getNormal());
    const {
      worldCoords: newNormal
    } = model.trackballManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    model.activeState.setNormal(newNormal);
  };
  model.lineManipulator = vtkLineManipulator$1.newInstance();
  model.planeManipulator = vtkPlaneManipulator$1.newInstance();
  model.trackballManipulator = vtkTrackballManipulator$1.newInstance();
}
function vtkImplicitPlaneWidget(publicAPI, model) {
  model.classHierarchy.push("vtkPlaneWidget");
  model.methodsToLink = ["representationStyle", "sphereResolution", "handleSizeRatio", "axisScale", "normalVisible", "originVisible", "planeVisible", "outlineVisible"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkImplicitPlaneRepresentation$1
        }];
    }
  };
}
var defaultValues34 = (initialValues) => ({
  behavior: widgetBehavior5,
  widgetState: vtkImplicitPlaneRepresentation$1.generateState(),
  ...initialValues
});
function extend250(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues34(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  vtkImplicitPlaneWidget(publicAPI, model);
}
var newInstance225 = macro.newInstance(extend250, "vtkImplicitPlaneWidget");
var vtkImplicitPlaneWidget$1 = {
  newInstance: newInstance225,
  extend: extend250
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/InteractiveOrientationWidget/behavior.js
function widgetBehavior6(publicAPI, model) {
  model.classHierarchy.push("vtkInteractiveOrientationWidgetProp");
  macro.event(publicAPI, model, "OrientationChange");
  publicAPI.handleRightButtonPress = (e2) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    publicAPI.invokeOrientationChange({
      action: "rightPress",
      event: e2,
      ...model.activeState.get("up", "right", "direction")
    });
    return macro.EVENT_ABORT;
  };
  publicAPI.handleLeftButtonPress = (e2) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    publicAPI.invokeOrientationChange({
      action: "leftPress",
      event: e2,
      ...model.activeState.get("up", "right", "direction")
    });
    return macro.EVENT_ABORT;
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/InteractiveOrientationWidget/state.js
var INITIAL_POINTS = [
  [-1, -1, -1],
  // 0
  [-1, 1, -1],
  // 1
  [1, -1, -1],
  // 2
  [1, 1, -1],
  // 3
  [-1, -1, 1],
  // 4
  [-1, 1, 1],
  // 5
  [1, -1, 1],
  // 6
  [1, 1, 1]
  // 7
];
function generateState4() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["handles", "---"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[0]
    }
  }).addStateFromMixin({
    labels: ["handles", "-+-"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[1]
    }
  }).addStateFromMixin({
    labels: ["handles", "+--"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[2]
    }
  }).addStateFromMixin({
    labels: ["handles", "++-"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[3]
    }
  }).addStateFromMixin({
    labels: ["handles", "--+"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[4]
    }
  }).addStateFromMixin({
    labels: ["handles", "-++"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[5]
    }
  }).addStateFromMixin({
    labels: ["handles", "+-+"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[6]
    }
  }).addStateFromMixin({
    labels: ["handles", "+++"],
    mixins: ["origin"],
    name: "handle",
    initialValues: {
      origin: INITIAL_POINTS[7]
    }
  }).build("orientation", "name");
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/InteractiveOrientationWidget.js
function vtkInteractiveOrientationWidget(publicAPI, model) {
  model.classHierarchy.push("vtkInteractiveOrientationWidget");
  model.methodsToLink = ["closePolyLine", "activeScaleFactor", "activeColor", "useActiveColor", "glyphResolution", "defaultScale"];
  publicAPI.setBounds = (bounds2) => {
    const handles = model.widgetState.getStatesWithLabel("handles");
    for (let i = 0; i < handles.length; i++) {
      const xyz = INITIAL_POINTS[i];
      const x = xyz[0] > 0 ? bounds2[1] : bounds2[0];
      const y = xyz[1] > 0 ? bounds2[3] : bounds2[2];
      const z = xyz[2] > 0 ? bounds2[5] : bounds2[4];
      handles[i].setOrigin(x, y, z);
    }
  };
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkConvexFaceContextRepresentation$1,
          labels: ["---", "--+", "-++", "-+-"],
          initialValues: {
            behavior: Behavior.HANDLE,
            pickable: true,
            activeScaleFactor: 1.2,
            activeColor: 1,
            useActiveColor: true,
            name: "Face 1"
          }
        }, {
          builder: vtkConvexFaceContextRepresentation$1,
          labels: ["---", "+--", "+-+", "--+"],
          initialValues: {
            behavior: Behavior.HANDLE,
            pickable: true,
            activeScaleFactor: 1.2,
            activeColor: 1,
            useActiveColor: true,
            name: "Face 2"
          }
        }, {
          builder: vtkConvexFaceContextRepresentation$1,
          labels: ["+--", "++-", "+++", "+-+"],
          initialValues: {
            behavior: Behavior.HANDLE,
            pickable: true,
            activeScaleFactor: 1.2,
            activeColor: 1,
            useActiveColor: true,
            name: "Face 3"
          }
        }, {
          builder: vtkConvexFaceContextRepresentation$1,
          labels: ["++-", "-+-", "-++", "+++"],
          initialValues: {
            behavior: Behavior.HANDLE,
            pickable: true,
            activeScaleFactor: 1.2,
            activeColor: 1,
            useActiveColor: true,
            name: "Face 4"
          }
        }, {
          builder: vtkConvexFaceContextRepresentation$1,
          labels: ["-++", "--+", "+-+", "+++"],
          initialValues: {
            behavior: Behavior.HANDLE,
            pickable: true,
            activeScaleFactor: 1.2,
            activeColor: 1,
            useActiveColor: true,
            name: "Face 5"
          }
        }, {
          builder: vtkConvexFaceContextRepresentation$1,
          labels: ["-+-", "++-", "+--", "---"],
          initialValues: {
            behavior: Behavior.HANDLE,
            pickable: true,
            activeScaleFactor: 1.2,
            activeColor: 1,
            useActiveColor: true,
            name: "Face 6"
          }
        }];
    }
  };
}
var defaultValues35 = (initialValues) => ({
  behavior: widgetBehavior6,
  widgetState: generateState4(),
  ...initialValues
});
function extend251(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues35(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  vtkInteractiveOrientationWidget(publicAPI, model);
}
var newInstance226 = macro.newInstance(extend251, "vtkInteractiveOrientationWidget");
var vtkInteractiveOrientationWidget$1 = {
  newInstance: newInstance226,
  extend: extend251
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LabelWidget/behavior.js
function widgetBehavior7(publicAPI, model) {
  model.classHierarchy.push("vtkLabelWidgetProp");
  model._isDragging = false;
  publicAPI.setText = (text2) => {
    model.widgetState.getText().setText(text2);
    model._interactor.render();
  };
  publicAPI.getText = () => model.widgetState.getText().getText();
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  function ignoreKey(e2) {
    return e2.altKey || e2.controlKey || e2.shiftKey;
  }
  publicAPI.handleLeftButtonPress = (e2) => {
    var _a, _b;
    if (!model.activeState || !model.activeState.getActive() || !model.pickable || ignoreKey(e2)) {
      return macro.VOID;
    }
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    const {
      worldCoords
    } = manipulator2.handleEvent(e2, model._apiSpecificRenderWindow);
    if (model.activeState === model.widgetState.getMoveHandle() && manipulator2) {
      const moveHandle = model.widgetState.getMoveHandle();
      moveHandle.setOrigin(worldCoords);
      model.widgetState.getText().setOrigin(moveHandle.getOrigin());
      publicAPI.loseFocus();
    } else if (model.dragable) {
      model._isDragging = true;
      model._apiSpecificRenderWindow.setCursor("grabbing");
      model._interactor.requestAnimation(publicAPI);
    }
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    if (model._isDragging) {
      model._apiSpecificRenderWindow.setCursor("pointer");
      model.widgetState.deactivate();
      model._interactor.cancelAnimation(publicAPI);
      model._isDragging = false;
    } else if (model.activeState !== model.widgetState.getMoveHandle()) {
      model.widgetState.deactivate();
    }
    if (model.hasFocus && !model.activeState || model.activeState && !model.activeState.getActive()) {
      model._widgetManager.enablePicking();
      model._interactor.render();
    }
    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (manipulator2 && model.pickable && model.dragable && model.activeState && model.activeState.getActive() && !ignoreKey(callData)) {
      const {
        worldCoords,
        worldDelta
      } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
      const isHandleMoving = model.widgetState.getMoveHandle() === model.activeState || model._isDragging;
      if (!isHandleMoving || !worldCoords.length || !worldDelta.length) return macro.VOID;
      const curOrigin = model.activeState.getOrigin();
      const newOrigin = curOrigin ? add(curOrigin, worldDelta, []) : worldCoords;
      model.activeState.setOrigin(newOrigin);
      model.widgetState.getText().setOrigin(newOrigin);
      publicAPI.invokeInteractionEvent();
      return macro.EVENT_ABORT;
    }
    return macro.VOID;
  };
  publicAPI.reset = () => {
    model.widgetState.getMoveHandle().setOrigin(null);
    model.widgetState.getText().setOrigin(null);
    model.widgetState.getText().setText("");
  };
  publicAPI.grabFocus = () => {
    if (!model.hasFocus) {
      publicAPI.reset();
      model.activeState = model.widgetState.getMoveHandle();
      model.widgetState.getMoveHandle().activate();
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent();
    }
    model.hasFocus = true;
  };
  publicAPI.loseFocus = () => {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent();
    }
    model.widgetState.deactivate();
    model.widgetState.getMoveHandle().deactivate();
    model.activeState = null;
    model.hasFocus = false;
    model._widgetManager.enablePicking();
    model._interactor.render();
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LabelWidget/state.js
function generateState5() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "moveHandle",
    initialValues: {
      scale1: 10,
      visible: false
    }
  }).addStateFromMixin({
    labels: ["SVGtext"],
    mixins: ["origin", "color", "text", "visible", "manipulator"],
    name: "text",
    initialValues: {
      visible: true
    }
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LabelWidget.js
function vtkLabelWidget(publicAPI, model) {
  model.classHierarchy.push("vtkLabelWidget");
  const superClass = {
    ...publicAPI
  };
  model.methodsToLink = ["scaleInPixels"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation$1,
          labels: ["moveHandle"]
        }];
    }
  };
  publicAPI.setManipulator = (manipulator2) => {
    superClass.setManipulator(manipulator2);
    model.widgetState.getMoveHandle().setManipulator(manipulator2);
    model.widgetState.getText().setManipulator(manipulator2);
  };
  publicAPI.setManipulator(model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
}
function defaultValues36(initialValues) {
  return {
    behavior: widgetBehavior7,
    widgetState: generateState5(),
    ...initialValues
  };
}
function extend252(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues36(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["manipulator"]);
  vtkLabelWidget(publicAPI, model);
}
var newInstance227 = macro.newInstance(extend252, "vtkLabelWidget");
var vtkLabelWidget$1 = {
  newInstance: newInstance227,
  extend: extend252
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LineWidget/state.js
var linePosState = vtkStateBuilder.createBuilder().addField({
  name: "posOnLine",
  initialValue: 0.5
}).build();
function generateState6() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator", "shape"],
    name: "moveHandle",
    initialValues: {
      scale1: 30,
      visible: true
    }
  }).addStateFromMixin({
    labels: ["handle1"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator", "shape"],
    name: "handle1",
    initialValues: {
      scale1: 30
    }
  }).addStateFromMixin({
    labels: ["handle2"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator", "shape"],
    name: "handle2",
    initialValues: {
      scale1: 30
    }
  }).addStateFromMixin({
    labels: ["SVGtext"],
    mixins: ["origin", "color", "text", "visible"],
    name: "text",
    initialValues: {
      /* text is empty to set a text filed in the SVGLayer and to avoid
       * displaying text before positioning the handles */
      text: ""
    }
  }).addStateFromInstance({
    name: "positionOnLine",
    instance: linePosState
  }).addField({
    name: "lineThickness"
  }).build();
}

// node_modules/@kitware/vtk.js/Filters/Sources/Arrow2DSource/Constants.js
var ShapeType = {
  TRIANGLE: "triangle",
  STAR: "star",
  ARROW_4: "arrow4points",
  ARROW_6: "arrow6points"
};
var Constants21 = {
  ShapeType
};

// node_modules/@kitware/vtk.js/Filters/Sources/Arrow2DSource.js
var {
  ShapeType: ShapeType2
} = Constants21;
function vtkStarSource(publicAPI, model, dataset) {
  const points = macro.newTypedArray(model.pointType, 10 * 3);
  const edges = new Uint32Array(11);
  edges[0] = 10;
  for (let i = 0; i < 10; i++) {
    const radius = i % 2 === 1 ? model.height : model.height * 0.4;
    points[3 * i + 0] = radius * Math.cos((2 * i - 1) * Math.PI / 10);
    points[3 * i + 1] = radius * Math.sin((2 * i - 1) * Math.PI / 10);
    points[3 * i + 2] = 0;
    edges[1 + i] = i;
  }
  dataset.getPoints().setData(points, 3);
  dataset.getPolys().setData(edges, 1);
  return dataset;
}
function vtk6PointsArrow(publicAPI, model, dataset) {
  const points = macro.newTypedArray(model.pointType, 6 * 3);
  const thickOp = model.height * 0.5 * model.thickness;
  const offsetOp = model.height * 0.5 - thickOp;
  const baseOffsetOp = (model.height * 0.9 + thickOp - offsetOp - (model.height * 0.5 - thickOp - offsetOp)) * (1 - model.base);
  points[0] = model.width / 2 * -1 - thickOp;
  points[1] = model.height / 4 - offsetOp - baseOffsetOp;
  points[2] = 0;
  points[3] = 0;
  points[4] = model.height * 0.9 + thickOp - offsetOp - baseOffsetOp;
  points[5] = 0;
  points[6] = model.width / 2 + thickOp;
  points[7] = model.height / 4 - offsetOp - baseOffsetOp;
  points[8] = 0;
  points[9] = model.width / 3;
  points[10] = model.height * 0.1 - thickOp - offsetOp - baseOffsetOp;
  points[11] = 0;
  points[12] = 0;
  points[13] = model.height * 0.5 - thickOp - offsetOp - baseOffsetOp;
  points[14] = 0;
  points[15] = model.width / 3 * -1;
  points[16] = model.height * 0.1 - thickOp - offsetOp - baseOffsetOp;
  points[17] = 0;
  const cells = Uint8Array.from([3, 0, 1, 5, 3, 1, 4, 5, 3, 1, 4, 3, 3, 1, 2, 3]);
  dataset.getPoints().setData(points, 3);
  dataset.getPolys().setData(cells, 1);
  return dataset;
}
function vtk4PointsArrow(publicAPI, model, dataset) {
  const points = macro.newTypedArray(model.pointType, 4 * 3);
  const thickOp = model.height / 3 * model.thickness;
  const offsetOp = model.height / 3 - thickOp;
  const baseOffsetOp = (model.height - offsetOp - (model.height / 3 - thickOp - offsetOp)) * (1 - model.base);
  points[0] = model.width / 2 * -1;
  points[1] = 0 - offsetOp - baseOffsetOp;
  points[2] = 0;
  points[3] = 0;
  points[4] = model.height - offsetOp - baseOffsetOp;
  points[5] = 0;
  points[6] = model.width / 2;
  points[7] = 0 - offsetOp - baseOffsetOp;
  points[8] = 0;
  points[9] = 0;
  points[10] = model.height / 3 - thickOp - offsetOp - baseOffsetOp;
  points[11] = 0;
  const cells = Uint8Array.from([3, 0, 1, 3, 3, 1, 2, 3]);
  dataset.getPoints().setData(points, 3);
  dataset.getPolys().setData(cells, 1);
  return dataset;
}
function vtkTriangleSource(publicAPI, model, dataset) {
  const points = macro.newTypedArray(model.pointType, 3 * 3);
  const baseOffsetOp = model.height * (1 - model.base);
  points[0] = model.width / 2 * -1;
  points[1] = 0 - baseOffsetOp;
  points[2] = 0;
  points[3] = 0;
  points[4] = model.height - baseOffsetOp;
  points[5] = 0;
  points[6] = model.width / 2;
  points[7] = 0 - baseOffsetOp;
  points[8] = 0;
  const cells = Uint8Array.from([3, 0, 1, 2]);
  dataset.getPoints().setData(points, 3);
  dataset.getPolys().setData(cells, 1);
  return dataset;
}
function vtkArrow2DSource(publicAPI, model) {
  const shapeToSource = {
    [ShapeType2.TRIANGLE]: vtkTriangleSource,
    [ShapeType2.STAR]: vtkStarSource,
    [ShapeType2.ARROW_4]: vtk4PointsArrow,
    [ShapeType2.ARROW_6]: vtk6PointsArrow
  };
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    outData[0] = shapeToSource[model.shape](publicAPI, model, dataset);
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.direction).apply(outData[0].getPoints().getData());
  };
}
function defaultValues37(initialValues) {
  return {
    base: 0,
    center: [0, 0, 0],
    height: 1,
    direction: [1, 0, 0],
    pointType: "Float64Array",
    thickness: 0,
    width: 1,
    ...initialValues
  };
}
function extend253(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues37(initialValues));
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "width", "thickness", "base"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkArrow2DSource(publicAPI, model);
}
var newInstance228 = macro.newInstance(extend253, "vtkArrow2DSource");
var vtkArrow2DSource$1 = {
  newInstance: newInstance228,
  extend: extend253
};

// node_modules/@kitware/vtk.js/Filters/Sources/ViewFinderSource.js
function vtkViewFinderSource(publicAPI, model) {
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const dataset = ((_a = outData[0]) == null ? void 0 : _a.initialize()) || vtkPolyData$1.newInstance();
    const points = macro.newTypedArray(model.pointType, 3 * 16);
    points[0] = model.radius;
    points[1] = model.radius / model.width;
    points[2] = 0;
    points[3] = model.radius + model.spacing;
    points[4] = model.radius / model.width;
    points[5] = 0;
    points[6] = model.radius;
    points[7] = model.radius / model.width * -1;
    points[8] = 0;
    points[9] = model.radius + model.spacing;
    points[10] = model.radius / model.width * -1;
    points[11] = 0;
    points[12] = model.radius * -1;
    points[13] = model.radius / model.width;
    points[14] = 0;
    points[15] = (model.radius + model.spacing) * -1;
    points[16] = model.radius / model.width;
    points[17] = 0;
    points[18] = model.radius * -1;
    points[19] = model.radius / model.width * -1;
    points[20] = 0;
    points[21] = (model.radius + model.spacing) * -1;
    points[22] = model.radius / model.width * -1;
    points[23] = 0;
    points[24] = model.radius / model.width;
    points[25] = model.radius;
    points[26] = 0;
    points[27] = model.radius / model.width;
    points[28] = model.radius + model.spacing;
    points[29] = 0;
    points[30] = model.radius / model.width * -1;
    points[31] = model.radius;
    points[32] = 0;
    points[33] = model.radius / model.width * -1;
    points[34] = model.radius + model.spacing;
    points[35] = 0;
    points[36] = model.radius / model.width;
    points[37] = model.radius * -1;
    points[38] = 0;
    points[39] = model.radius / model.width;
    points[40] = (model.radius + model.spacing) * -1;
    points[41] = 0;
    points[42] = model.radius / model.width * -1;
    points[43] = model.radius * -1;
    points[44] = 0;
    points[45] = model.radius / model.width * -1;
    points[46] = (model.radius + model.spacing) * -1;
    points[47] = 0;
    const cells = Uint8Array.from([3, 0, 1, 2, 3, 2, 1, 3, 3, 4, 6, 5, 3, 6, 5, 7, 3, 8, 11, 9, 3, 8, 10, 11, 3, 12, 13, 15, 3, 12, 15, 14]);
    vtkMatrixBuilder.buildFromRadian().translate(...model.center).rotateFromDirections([1, 0, 0], model.orientation).apply(points);
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(cells, 1);
    outData[0] = dataset;
  };
}
var DEFAULT_VALUES214 = {
  radius: 1,
  spacing: 2,
  width: 4,
  pointType: "Float64Array"
};
function extend254(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  model.center = [0, 0, 0];
  model.orientation = [1, 0, 0];
  Object.assign(model, DEFAULT_VALUES214, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["radius", "spacing", "width"]);
  macro.setGetArray(publicAPI, model, ["center", "orientation"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkViewFinderSource(publicAPI, model);
}
var newInstance229 = macro.newInstance(extend254, "vtkArrow2DSource");
var vtkViewFinderSource$1 = {
  newInstance: newInstance229,
  extend: extend254
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LineWidget/Constants.js
var ShapeType3 = {
  // NONE is a sphere handle always invisible even on mouseover, which
  // prevents user from moving handle once it is placed
  NONE: "voidSphere",
  // 3D handles
  SPHERE: "sphere",
  CUBE: "cube",
  CONE: "cone",
  // 2D handles
  ARROWHEAD3: "triangle",
  ARROWHEAD4: "4pointsArrowHead",
  ARROWHEAD6: "6pointsArrowHead",
  STAR: "star",
  DISK: "disk",
  CIRCLE: "circle",
  VIEWFINDER: "viewFinder"
};
var Shapes2D = [ShapeType3.ARROWHEAD3, ShapeType3.ARROWHEAD4, ShapeType3.ARROWHEAD6, ShapeType3.STAR, ShapeType3.DISK, ShapeType3.CIRCLE, ShapeType3.VIEWFINDER];
var Shapes3D = [ShapeType3.SPHERE, ShapeType3.CUBE, ShapeType3.CONE];
var ShapesOrientable = [ShapeType3.CONE, ShapeType3.ARROWHEAD3, ShapeType3.ARROWHEAD4, ShapeType3.ARROWHEAD6];
var Constants22 = {
  ShapeType: ShapeType3,
  Shapes2D,
  Shapes3D,
  ShapesOrientable
};

// node_modules/@kitware/vtk.js/Widgets/Representations/ArrowHandleRepresentation.js
var {
  ShapeType: ShapeType4,
  Shapes2D: Shapes2D2,
  ShapesOrientable: ShapesOrientable2
} = Constants22;
function vtkArrowHandleRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkArrowHandleRepresentation");
  const superClass = {
    ...publicAPI
  };
  function createGlyph(shape2) {
    const representationToSource = {
      [ShapeType4.STAR]: {
        builder: vtkArrow2DSource$1,
        initialValues: {
          shape: "star",
          height: 0.6
        }
      },
      [ShapeType4.ARROWHEAD3]: {
        builder: vtkArrow2DSource$1,
        initialValues: {
          shape: "triangle"
        }
      },
      [ShapeType4.ARROWHEAD4]: {
        builder: vtkArrow2DSource$1,
        initialValues: {
          shape: "arrow4points"
        }
      },
      [ShapeType4.ARROWHEAD6]: {
        builder: vtkArrow2DSource$1,
        initialValues: {
          shape: "arrow6points"
        }
      },
      [ShapeType4.CONE]: {
        builder: vtkConeSource$1,
        initialValues: {
          direction: [0, 1, 0]
        }
      },
      [ShapeType4.SPHERE]: {
        builder: vtkSphereSource$1
      },
      [ShapeType4.CUBE]: {
        builder: vtkCubeSource$1,
        initialValues: {
          xLength: 0.8,
          yLength: 0.8,
          zLength: 0.8
        }
      },
      [ShapeType4.DISK]: {
        builder: vtkCircleSource$1,
        initialValues: {
          resolution: 30,
          radius: 0.5,
          direction: [0, 0, 1],
          lines: false,
          face: true
        }
      },
      [ShapeType4.CIRCLE]: {
        builder: vtkCircleSource$1,
        initialValues: {
          resolution: 30,
          radius: 0.5,
          direction: [0, 0, 1],
          lines: true,
          face: false
        }
      },
      [ShapeType4.VIEWFINDER]: {
        builder: vtkViewFinderSource$1,
        initialValues: {
          radius: 0.1,
          spacing: 0.3,
          width: 1.4
        }
      },
      [ShapeType4.NONE]: {
        builder: vtkSphereSource$1
      }
    };
    const rep = representationToSource[shape2];
    return rep.builder.newInstance(rep.initialValues);
  }
  model.displayMapper = vtkPixelSpaceCallbackMapper$1.newInstance();
  model.displayActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.displayActor.setMapper(model.displayMapper);
  model.displayMapper.setInputConnection(publicAPI.getOutputPort());
  publicAPI.addActor(model.displayActor);
  model.alwaysVisibleActors = [model.displayActor];
  publicAPI.setGlyphResolution = macro.chain(publicAPI.setGlyphResolution, (r) => model._pipeline.glyph.setPhiResolution(r), (r) => model._pipeline.glyph.setThetaResolution(r));
  function callbackProxy(coords) {
    if (model.displayCallback) {
      const filteredList = [];
      const states = publicAPI.getRepresentationStates();
      for (let i = 0; i < states.length; i++) {
        if (states[i].getActive()) {
          filteredList.push(coords[i]);
        }
      }
      if (filteredList.length) {
        model.displayCallback(filteredList);
        return;
      }
    }
    model.displayCallback();
  }
  publicAPI.setDisplayCallback = (callback) => {
    model.displayCallback = callback;
    model.displayMapper.setCallback(callback ? callbackProxy : null);
  };
  publicAPI.is2DShape = () => Shapes2D2.includes(model.shape);
  publicAPI.isOrientableShape = () => ShapesOrientable2.includes(model.shape);
  function getOrientationRotation(viewMatrixInv) {
    const displayOrientation = new Float64Array(3);
    const baseDir = [0, 1, 0];
    vec3_exports.transformMat3(displayOrientation, model.orientation, viewMatrixInv);
    displayOrientation[2] = 0;
    const displayMatrix = vtkMatrixBuilder.buildFromDegree().rotateFromDirections(baseDir, displayOrientation).getMatrix();
    const displayRotation = new Float64Array(9);
    mat3_exports.fromMat4(displayRotation, displayMatrix);
    return displayRotation;
  }
  function getCameraFacingRotation(scale33, displayRotation, viewMatrix) {
    const rotation = new Float64Array(9);
    mat3_exports.multiply(rotation, viewMatrix, displayRotation);
    vec3_exports.transformMat3(scale33, scale33, rotation);
    return rotation;
  }
  function getGlyphRotation(scale33) {
    const shouldFaceCamera = model.faceCamera === true || model.faceCamera == null && publicAPI.is2DShape();
    const viewMatrix = new Float64Array(9);
    mat3_exports.fromMat4(viewMatrix, model.viewMatrix);
    const viewMatrixInv = mat3_exports.identity(new Float64Array(9));
    if (shouldFaceCamera) {
      mat3_exports.invert(viewMatrixInv, viewMatrix);
    }
    let orientationRotation = null;
    if (publicAPI.isOrientableShape()) {
      orientationRotation = getOrientationRotation(viewMatrixInv);
    } else {
      orientationRotation = mat3_exports.identity(new Float64Array(9));
    }
    if (shouldFaceCamera) {
      orientationRotation = getCameraFacingRotation(scale33, orientationRotation, viewMatrix);
    }
    return orientationRotation;
  }
  function applyOrientation(polyData, states) {
    var _a, _b;
    model._pipeline.mapper.setOrientationArray("orientation");
    model._pipeline.mapper.setOrientationMode(OrientationModes.MATRIX);
    const orientation3 = allocateArray(polyData, "orientation", states.length, "Float32Array", 9).getData();
    const defaultScale3 = [1, 1, 1];
    for (let i = 0; i < states.length; ++i) {
      const scale33 = ((_b = (_a = states[i]).getScale3) == null ? void 0 : _b.call(_a)) ?? defaultScale3;
      const rotation = getGlyphRotation(scale33);
      orientation3.set(rotation, 9 * i);
    }
  }
  publicAPI.setDirection(applyOrientation);
  publicAPI.setNoOrientation(applyOrientation);
  publicAPI.requestData = (inData, outData) => {
    var _a;
    const shape2 = (_a = publicAPI.getRepresentationStates(inData[0])[0]) == null ? void 0 : _a.getShape();
    let shouldCreateGlyph = model._pipeline.glyph == null;
    if (model.shape !== shape2 && Object.values(ShapeType4).includes(shape2)) {
      model.shape = shape2;
      shouldCreateGlyph = true;
    }
    if (shouldCreateGlyph && model.shape) {
      model._pipeline.glyph = createGlyph(model.shape);
      model._pipeline.mapper.setInputConnection(model._pipeline.glyph.getOutputPort(), 1);
    }
    return superClass.requestData(inData, outData);
  };
  publicAPI.updateActorVisibility = function() {
    let renderingType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : RenderingTypes.FRONT_BUFFER;
    let ctxVisible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let handleVisible = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const hasValidState = publicAPI.getRepresentationStates().length > 0;
    superClass.updateActorVisibility(renderingType, ctxVisible, handleVisible && hasValidState);
  };
}
function defaultValues38(initialValues) {
  return {
    faceCamera: null,
    orientation: [1, 0, 0],
    shape: ShapeType4.SPHERE,
    viewMatrix: mat4_exports.identity(new Float64Array(16)),
    ...initialValues
  };
}
function extend255(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues38(initialValues));
  vtkGlyphRepresentation$1.extend(publicAPI, model, initialValues);
  macro.setGetArray(publicAPI, model, ["visibilityFlagArray"], 2);
  macro.setGetArray(publicAPI, model, ["orientation"], 3);
  macro.setGetArray(publicAPI, model, ["viewMatrix"], 16);
  macro.setGet(publicAPI, model, ["faceCamera"]);
  vtkArrowHandleRepresentation(publicAPI, model);
}
var newInstance230 = macro.newInstance(extend255, "vtkArrowHandleRepresentation");
var vtkArrowHandleRepresentation$1 = {
  newInstance: newInstance230,
  extend: extend255
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LineWidget/helpers.js
function calculateTextPosition(model) {
  const vector = [0, 0, 0];
  const handle1WorldPos = model.widgetState.getHandle1().getOrigin();
  const handle2WorldPos = model.widgetState.getHandle2().getOrigin();
  if (!handle1WorldPos || !handle2WorldPos) {
    return null;
  }
  let statePositionOnLine = model.widgetState.getPositionOnLine().getPosOnLine();
  statePositionOnLine = 1 - statePositionOnLine;
  subtract(handle1WorldPos, handle2WorldPos, vector);
  multiplyScalar(vector, statePositionOnLine);
  add(vector, handle2WorldPos, vector);
  return vector;
}
function updateTextPosition(model) {
  const SVGTextState = model.widgetState.getText();
  SVGTextState.setOrigin(calculateTextPosition(model));
}
function isHandlePlaced(handleIndex, widgetState) {
  if (handleIndex === 2) {
    return widgetState.getMoveHandle().getOrigin() != null;
  }
  const handle1Origin = widgetState.getHandle1().getOrigin();
  if (handleIndex === 0) {
    return handle1Origin != null;
  }
  const handle2Origin = widgetState.getHandle2().getOrigin();
  return handle1Origin && handle2Origin && !areEquals(handle1Origin, handle2Origin, 0);
}
function getPoint(handleIndex, widgetState) {
  let moveHandle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const handle = moveHandle && !isHandlePlaced(handleIndex, widgetState) ? widgetState.getMoveHandle() : widgetState[`getHandle${handleIndex + 1}`]();
  const origin3 = handle.getOrigin();
  return origin3 || null;
}
function getNumberOfPlacedHandles(widgetState) {
  let numberOfPlacedHandles = 0;
  if (isHandlePlaced(0, widgetState)) {
    numberOfPlacedHandles = 1 + isHandlePlaced(1, widgetState);
  }
  return numberOfPlacedHandles;
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LineWidget/behavior.js
var {
  ShapeType: ShapeType5
} = Constants22;
var MAX_POINTS2 = 2;
var handleGetters = ["getHandle1", "getHandle2", "getMoveHandle"];
function widgetBehavior8(publicAPI, model) {
  model.classHierarchy.push("vtkLineWidgetProp");
  model._isDragging = false;
  publicAPI.getHandle = (handleIndex) => model.widgetState[handleGetters[handleIndex]]();
  publicAPI.getHandleIndex = (handle) => {
    switch (handle) {
      case model.widgetState.getHandle1():
        return 0;
      case model.widgetState.getHandle2():
        return 1;
      case model.widgetState.getMoveHandle():
        return 2;
      default:
        return -1;
    }
  };
  publicAPI.isPlaced = () => getNumberOfPlacedHandles(model.widgetState) === MAX_POINTS2;
  function ignoreKey(e2) {
    return e2.altKey || e2.controlKey || e2.shiftKey;
  }
  function updateCursor(callData) {
    var _a, _b;
    model._isDragging = true;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
    model._apiSpecificRenderWindow.setCursor("grabbing");
    model._interactor.requestAnimation(publicAPI);
  }
  publicAPI.setText = (text2) => {
    model.widgetState.getText().setText(text2);
    model._interactor.render();
  };
  function getLineDirection(p1, p2) {
    const dir = subtract(p1, p2, []);
    normalize(dir);
    return dir;
  }
  function computeMousePosition(p1, callData) {
    const displayMousePos = publicAPI.computeWorldToDisplay(model._renderer, ...p1);
    const worldMousePos = publicAPI.computeDisplayToWorld(model._renderer, callData.position.x, callData.position.y, displayMousePos[2]);
    return worldMousePos;
  }
  function getHandleOrientation(handleIndex) {
    let callData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const point1 = getPoint(handleIndex, model.widgetState);
    const point2 = callData ? computeMousePosition(point1, callData) : getPoint(1 - handleIndex, model.widgetState);
    return point1 && point2 ? getLineDirection(point1, point2) : null;
  }
  function updateHandleOrientation(handleIndex) {
    const orientation3 = getHandleOrientation(Math.min(1, handleIndex));
    model.representations[handleIndex].setOrientation(orientation3);
  }
  publicAPI.updateHandleOrientations = () => {
    updateHandleOrientation(0);
    updateHandleOrientation(1);
    updateHandleOrientation(2);
  };
  publicAPI.rotateHandlesToFaceCamera = () => {
    model.representations[0].setViewMatrix(Array.from(model._camera.getViewMatrix()));
    model.representations[1].setViewMatrix(Array.from(model._camera.getViewMatrix()));
  };
  publicAPI.updateHandleVisibility = (handleIndex) => {
    const handle = publicAPI.getHandle(handleIndex);
    const visibility = handle.getVisible() && isHandlePlaced(handleIndex, model.widgetState);
    model.representations[handleIndex].setVisibilityFlagArray([visibility, visibility && handle.getShape() !== ShapeType5.NONE]);
    model.representations[handleIndex].updateActorVisibility();
    model._interactor.render();
  };
  publicAPI.placeHandle = (handleIndex) => {
    const handle = publicAPI.getHandle(handleIndex);
    handle.setOrigin(...model.widgetState.getMoveHandle().getOrigin());
    publicAPI.updateHandleOrientations();
    publicAPI.rotateHandlesToFaceCamera();
    model.widgetState.getText().setOrigin(calculateTextPosition(model));
    publicAPI.updateHandleVisibility(handleIndex);
    if (handleIndex === 0) {
      publicAPI.getHandle(1).setOrigin(...model.widgetState.getMoveHandle().getOrigin());
      publicAPI.updateHandleVisibility(1);
      model.widgetState.getMoveHandle().setShape(publicAPI.getHandle(1).getShape());
    }
    if (handleIndex === 1) {
      publicAPI.loseFocus();
    }
  };
  publicAPI.handleLeftButtonPress = (e2) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable || ignoreKey(e2)) {
      return macro.VOID;
    }
    if (model.activeState === model.widgetState.getMoveHandle() && getNumberOfPlacedHandles(model.widgetState) === 0) {
      publicAPI.placeHandle(0);
    } else if (model.widgetState.getMoveHandle().getActive() && getNumberOfPlacedHandles(model.widgetState) === 1) {
      publicAPI.placeHandle(1);
    } else if (model.dragable && !model.widgetState.getText().getActive()) {
      updateCursor(e2);
    }
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (manipulator2 && model.pickable && model.dragable && model.activeState && model.activeState.getActive() && !ignoreKey(callData)) {
      const {
        worldCoords,
        worldDelta
      } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
      const isHandleMoving = (
        // is placing first or second handle
        model.activeState === model.widgetState.getMoveHandle() || // is dragging already placed first or second handle
        model._isDragging
      );
      const isDraggingLine = !model.activeState.setOrigin;
      if (isHandleMoving) {
        if (!isDraggingLine) {
          const curOrigin = model.activeState.getOrigin();
          if (curOrigin) {
            model.activeState.setOrigin(add(model.activeState.getOrigin(), worldDelta, []));
          } else {
            model.activeState.setOrigin(worldCoords);
          }
          publicAPI.updateHandleVisibility(publicAPI.getHandleIndex(model.activeState));
        } else {
          for (let i = 0; i < 2; i++) {
            const handleOrigin = publicAPI.getHandle(i).getOrigin();
            publicAPI.getHandle(i).setOrigin(add(handleOrigin, worldDelta, []));
          }
        }
        publicAPI.updateHandleOrientations();
        updateTextPosition(model);
        publicAPI.invokeInteractionEvent();
        return macro.EVENT_ABORT;
      }
    }
    return macro.VOID;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      publicAPI.rotateHandlesToFaceCamera();
      return macro.VOID;
    }
    if (model.hasFocus && publicAPI.isPlaced()) {
      publicAPI.loseFocus();
      return macro.VOID;
    }
    if (model._isDragging && publicAPI.isPlaced()) {
      const wasTextActive = model.widgetState.getText().getActive();
      model.widgetState.deactivate();
      model.activeState = null;
      if (!wasTextActive) {
        model._interactor.cancelAnimation(publicAPI);
      }
      model._apiSpecificRenderWindow.setCursor("pointer");
      model.hasFocus = false;
      model._isDragging = false;
    } else if (model.activeState !== model.widgetState.getMoveHandle()) {
      model.widgetState.deactivate();
    }
    if (model.hasFocus && !model.activeState || model.activeState && !model.activeState.getActive()) {
      model._widgetManager.enablePicking();
      model._interactor.render();
    }
    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.grabFocus = () => {
    if (!model.hasFocus && !publicAPI.isPlaced()) {
      model.activeState = model.widgetState.getMoveHandle();
      model.activeState.setShape(publicAPI.getHandle(0).getShape());
      model.activeState.activate();
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent();
    }
    model.hasFocus = true;
  };
  publicAPI.loseFocus = () => {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent();
    }
    model.widgetState.deactivate();
    model.widgetState.getMoveHandle().deactivate();
    model.widgetState.getMoveHandle().setOrigin(null);
    model.activeState = null;
    model.hasFocus = false;
    model._widgetManager.enablePicking();
    model._interactor.render();
  };
  publicAPI.reset = () => {
    model.widgetState.deactivate();
    model.widgetState.getMoveHandle().deactivate();
    model.widgetState.getHandle1().setOrigin(null);
    model.widgetState.getHandle2().setOrigin(null);
    model.widgetState.getMoveHandle().setOrigin(null);
    model.widgetState.getText().setOrigin(null);
    model.widgetState.getText().setText("");
    model.activeState = null;
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/LineWidget.js
function vtkLineWidget(publicAPI, model) {
  model.classHierarchy.push("vtkLineWidget");
  const superClass = {
    ...publicAPI
  };
  model.methodsToLink = ["activeScaleFactor", "activeColor", "useActiveColor", "glyphResolution", "defaultScale", "scaleInPixels"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkArrowHandleRepresentation$1,
          labels: ["handle1"],
          initialValues: {
            /*
             * This table sets the visibility of the handles' actors
             * 1st actor is a displayActor, which hides a rendered object on the HTML layer.
             * operating on its value allows to hide a handle to the user while still being
             * able to detect its presence, so the user can move it. 2nd actor is a classic VTK
             * actor which renders the object on the VTK scene
             */
            visibilityFlagArray: [false, false],
            coincidentTopologyParameters: {
              Point: {
                factor: -1,
                offset: -1
              },
              Line: {
                factor: -1,
                offset: -1
              },
              Polygon: {
                factor: -3,
                offset: -3
              }
            }
          }
        }, {
          builder: vtkArrowHandleRepresentation$1,
          labels: ["handle2"],
          initialValues: {
            /*
             * This table sets the visibility of the handles' actors
             * 1st actor is a displayActor, which hides a rendered object on the HTML layer.
             * operating on its value allows to hide a handle to the user while still being
             * able to detect its presence, so the user can move it. 2nd actor is a classic VTK
             * actor which renders the object on the VTK scene
             */
            visibilityFlagArray: [false, false],
            coincidentTopologyParameters: {
              Point: {
                factor: -1,
                offset: -1
              },
              Line: {
                factor: -1,
                offset: -1
              },
              Polygon: {
                factor: -3,
                offset: -3
              }
            }
          }
        }, {
          builder: vtkArrowHandleRepresentation$1,
          labels: ["moveHandle"],
          initialValues: {
            visibilityFlagArray: [false, false],
            coincidentTopologyParameters: {
              Point: {
                factor: -1,
                offset: -1
              },
              Line: {
                factor: -1,
                offset: -1
              },
              Polygon: {
                factor: -3,
                offset: -3
              }
            }
          }
        }, {
          builder: vtkPolyLineRepresentation$1,
          labels: ["handle1", "handle2", "moveHandle"],
          initialValues: {
            behavior: Behavior.HANDLE,
            pickable: true
          }
        }];
    }
  };
  publicAPI.getDistance = () => {
    const p1 = getPoint(0, model.widgetState);
    const p2 = getPoint(1, model.widgetState);
    return p1 && p2 ? Math.sqrt(distance2BetweenPoints(p1, p2)) : 0;
  };
  publicAPI.setManipulator = (manipulator2) => {
    superClass.setManipulator(manipulator2);
    model.widgetState.getMoveHandle().setManipulator(manipulator2);
    model.widgetState.getHandle1().setManipulator(manipulator2);
    model.widgetState.getHandle2().setManipulator(manipulator2);
  };
  model.widgetState.onBoundsChange((bounds2) => {
    const center = [(bounds2[0] + bounds2[1]) * 0.5, (bounds2[2] + bounds2[3]) * 0.5, (bounds2[4] + bounds2[5]) * 0.5];
    model.widgetState.getMoveHandle().setOrigin(center);
  });
  let linePosSub = model.widgetState.getPositionOnLine().onModified(() => {
    updateTextPosition(model);
  });
  publicAPI.setManipulator(model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
  publicAPI.delete = macro.chain(publicAPI.delete, () => {
    linePosSub.unsubscribe();
    linePosSub = null;
  });
}
var defaultValues39 = (initialValues) => ({
  // manipulator: null,
  behavior: widgetBehavior8,
  widgetState: generateState6(),
  ...initialValues
});
function extend256(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues39(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["manipulator"]);
  vtkLineWidget(publicAPI, model);
}
var newInstance231 = macro.newInstance(extend256, "vtkLineWidget");
var vtkLineWidget$1 = {
  newInstance: newInstance231,
  extend: extend256
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/PaintWidget/behavior.js
function widgetBehavior9(publicAPI, model) {
  model.painting = model._factory.getPainting();
  publicAPI.handleLeftButtonPress = (callData) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (!(manipulator2 && model.activeState && model.activeState.getActive())) {
      model.painting = false;
      return macro.VOID;
    }
    const {
      worldCoords
    } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
    if (!(worldCoords == null ? void 0 : worldCoords.length)) {
      model.painting = false;
      return macro.VOID;
    }
    model.painting = true;
    const trailCircle = model.widgetState.addTrail();
    trailCircle.set(model.activeState.get("origin", "up", "right", "direction", "scale1"));
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => publicAPI.handleEvent(callData);
  publicAPI.handleLeftButtonRelease = () => {
    if (model.painting) {
      publicAPI.invokeEndInteractionEvent();
      model.widgetState.clearTrailList();
    }
    model.painting = false;
    return macro.VOID;
  };
  publicAPI.handleEvent = (callData) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (!(manipulator2 && model.activeState && model.activeState.getActive())) {
      model.painting = false;
      return macro.VOID;
    }
    const normal = model._camera.getDirectionOfProjection();
    const up = model._camera.getViewUp();
    const right = [];
    vec3_exports.cross(right, up, normal);
    model.activeState.setUp(...up);
    model.activeState.setRight(...right);
    model.activeState.setDirection(...normal);
    const {
      worldCoords
    } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
    if (!(worldCoords == null ? void 0 : worldCoords.length)) {
      return macro.VOID;
    }
    model.widgetState.setTrueOrigin(...worldCoords);
    model.activeState.setOrigin(...worldCoords);
    if (model.painting) {
      const trailCircle = model.widgetState.addTrail();
      trailCircle.set(model.activeState.get("origin", "up", "right", "direction", "scale1"));
    } else {
      return macro.VOID;
    }
    publicAPI.invokeInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.grabFocus = () => {
    if (!model.hasFocus) {
      model.activeState = model.widgetState.getHandle();
      model.activeState.activate();
      model._interactor.requestAnimation(publicAPI);
      const canvas = model._apiSpecificRenderWindow.getCanvas();
      canvas.onmouseenter = () => {
        if (model.hasFocus && model.activeState === model.widgetState.getHandle()) {
          model.activeState.setVisible(true);
        }
      };
      canvas.onmouseleave = () => {
        if (model.hasFocus && model.activeState === model.widgetState.getHandle()) {
          model.activeState.setVisible(false);
        }
      };
    }
    model.hasFocus = true;
  };
  publicAPI.loseFocus = () => {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);
    }
    model.widgetState.deactivate();
    model.widgetState.getHandle().deactivate();
    model.activeState = null;
    model.hasFocus = false;
  };
  macro.get(publicAPI, model, ["painting"]);
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/PaintWidget/state.js
function generateState7(radius) {
  return vtkStateBuilder.createBuilder().addField({
    name: "trueOrigin",
    initialValue: [0, 0, 0]
  }).addStateFromMixin({
    labels: ["handle"],
    mixins: ["origin", "color", "scale1", "orientation", "manipulator", "visible"],
    name: "handle",
    initialValues: {
      scale1: radius * 2,
      orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
  }).addDynamicMixinState({
    labels: ["trail"],
    mixins: ["origin", "color", "scale1", "orientation", "visible"],
    name: "trail",
    initialValues: {
      scale1: radius * 2,
      orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/PaintWidget.js
function vtkPaintWidget(publicAPI, model) {
  model.classHierarchy.push("vtkPaintWidget");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
        return [{
          builder: vtkCircleContextRepresentation$1,
          labels: ["handle", "trail"]
        }];
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation$1,
          labels: ["handle"]
        }];
    }
  };
  publicAPI.setManipulator = (manipulator2) => {
    superClass.setManipulator(manipulator2);
    model.widgetState.getHandle().setManipulator(manipulator2);
  };
  const superSetRadius = publicAPI.setRadius;
  publicAPI.setRadius = (r) => {
    if (superSetRadius(r)) {
      model.widgetState.getHandle().setScale1(r);
    }
  };
  publicAPI.setManipulator(model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
}
var defaultValues40 = (initialValues) => ({
  // manipulator: null,
  radius: 1,
  painting: false,
  color: [1],
  behavior: widgetBehavior9,
  widgetState: generateState7((initialValues == null ? void 0 : initialValues.radius) ?? 1),
  ...initialValues
});
function extend257(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues40(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["painting"]);
  macro.setGet(publicAPI, model, ["manipulator", "radius", "color"]);
  vtkPaintWidget(publicAPI, model);
}
var newInstance232 = macro.newInstance(extend257, "vtkPaintWidget");
var vtkPaintWidget$1 = {
  newInstance: newInstance232,
  extend: extend257
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/PolyLineWidget/behavior.js
function widgetBehavior10(publicAPI, model) {
  model.classHierarchy.push("vtkPolyLineWidgetProp");
  model._isDragging = false;
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  function ignoreKey(e2) {
    return e2.altKey || e2.controlKey || e2.shiftKey;
  }
  function updateMoveHandle(callData) {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (!manipulator2) {
      return macro.VOID;
    }
    const {
      worldCoords,
      worldDelta
    } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
    const isHandleMoving = model.activeState === model.widgetState.getMoveHandle() || model._isDragging;
    const isPickingLine = !model.activeState.setOrigin;
    if (worldCoords.length && isHandleMoving && !isPickingLine) {
      const curOrigin = model.activeState.getOrigin();
      if (curOrigin) {
        model.activeState.setOrigin(add(curOrigin, worldDelta, []));
      } else {
        model.activeState.setOrigin(worldCoords);
      }
      publicAPI.invokeInteractionEvent();
      return macro.EVENT_ABORT;
    }
    return macro.VOID;
  }
  publicAPI.handleRightButtonPress = (e2) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable || ignoreKey(e2)) {
      return macro.VOID;
    }
    if (model.activeState !== model.widgetState.getMoveHandle()) {
      model._interactor.requestAnimation(publicAPI);
      model.activeState.deactivate();
      model.widgetState.removeHandle(model.activeState);
      model.activeState = null;
      model._interactor.cancelAnimation(publicAPI);
    }
    publicAPI.invokeStartInteractionEvent();
    publicAPI.invokeInteractionEvent();
    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleLeftButtonPress = (e2) => {
    var _a, _b;
    if (!model.activeState || !model.activeState.getActive() || !model.pickable || ignoreKey(e2)) {
      return macro.VOID;
    }
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (model.activeState === model.widgetState.getMoveHandle() && manipulator2) {
      updateMoveHandle(e2);
      const moveHandle = model.widgetState.getMoveHandle();
      const newHandle = model.widgetState.addHandle();
      newHandle.setOrigin(moveHandle.getOrigin());
      newHandle.setColor(moveHandle.getColor());
      newHandle.setScale1(moveHandle.getScale1());
      newHandle.setManipulator(manipulator2);
    } else if (model.dragable) {
      manipulator2.handleEvent(e2, model._apiSpecificRenderWindow);
      model._isDragging = true;
      model._apiSpecificRenderWindow.setCursor("grabbing");
      model._interactor.requestAnimation(publicAPI);
    }
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => {
    if (model.pickable && model.dragable && model.activeState && model.activeState.getActive() && !ignoreKey(callData)) {
      if (updateMoveHandle(callData) === macro.EVENT_ABORT) {
        return macro.EVENT_ABORT;
      }
    }
    if (model.hasFocus) {
      model._widgetManager.disablePicking();
    }
    return macro.VOID;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    if (model._isDragging) {
      model._apiSpecificRenderWindow.setCursor("pointer");
      model.widgetState.deactivate();
      model._interactor.cancelAnimation(publicAPI);
      model._isDragging = false;
    } else if (model.activeState !== model.widgetState.getMoveHandle()) {
      model.widgetState.deactivate();
    }
    if (model.hasFocus && !model.activeState || model.activeState && !model.activeState.getActive()) {
      model._widgetManager.enablePicking();
      model._interactor.render();
    }
    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleKeyDown = (_ref) => {
    let {
      key
    } = _ref;
    if (key === "Escape") {
      publicAPI.loseFocus();
    }
  };
  publicAPI.grabFocus = () => {
    if (!model.hasFocus) {
      model.activeState = model.widgetState.getMoveHandle();
      model.activeState.activate();
      model.activeState.setVisible(true);
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent();
    }
    model.hasFocus = true;
  };
  publicAPI.loseFocus = () => {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent();
    }
    model.widgetState.deactivate();
    model.widgetState.getMoveHandle().deactivate();
    model.widgetState.getMoveHandle().setVisible(false);
    model.widgetState.getMoveHandle().setOrigin(null);
    model.activeState = null;
    model.hasFocus = false;
    model._widgetManager.enablePicking();
    model._interactor.render();
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/PolyLineWidget/state.js
function generateState8() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "moveHandle",
    initialValues: {
      // when scaleInPixels=true, the handles have 30px height
      scale1: 30,
      visible: false
    }
  }).addDynamicMixinState({
    labels: ["handles"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "handle",
    initialValues: {
      scale1: 30
    }
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/PolyLineWidget.js
function vtkPolyLineWidget(publicAPI, model) {
  model.classHierarchy.push("vtkPolyLineWidget");
  const superClass = {
    ...publicAPI
  };
  model.methodsToLink = ["activeColor", "activeScaleFactor", "closePolyLine", "defaultScale", "glyphResolution", "lineThickness", "useActiveColor", "scaleInPixels"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation$1,
          labels: ["handles"]
        }, {
          builder: vtkSphereHandleRepresentation$1,
          labels: ["moveHandle"]
        }, {
          builder: vtkPolyLineRepresentation$1,
          labels: ["handles", "moveHandle"]
        }];
    }
  };
  publicAPI.setManipulator = (manipulator2) => {
    superClass.setManipulator(manipulator2);
    model.widgetState.getMoveHandle().setManipulator(manipulator2);
    model.widgetState.getHandleList().forEach((handle) => {
      handle.setManipulator(manipulator2);
    });
  };
  publicAPI.setManipulator(model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraFocalPoint: true,
    useCameraNormal: true
  }));
}
var defaultValues41 = (initialValues) => ({
  manipulator: null,
  behavior: widgetBehavior10,
  widgetState: generateState8(),
  ...initialValues
});
function extend258(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues41(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["manipulator"]);
  vtkPolyLineWidget(publicAPI, model);
}
var newInstance233 = macro.newInstance(extend258, "vtkPolyLineWidget");
var vtkPolyLineWidget$1 = {
  newInstance: newInstance233,
  extend: extend258
};

// node_modules/@kitware/vtk.js/Widgets/Representations/RectangleContextRepresentation.js
function vtkRectangleContextRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkRectangleContextRepresentation");
  model.internalPolyData = vtkPolyData$1.newInstance({
    mtime: 0
  });
  model.mapper = vtkMapper$1.newInstance();
  model.actor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.mapper.setInputConnection(publicAPI.getOutputPort());
  model.actor.setMapper(model.mapper);
  model.actor.getProperty().setOpacity(0.2);
  model.actor.getProperty().setColor(0, 1, 0);
  publicAPI.addActor(model.actor);
  publicAPI.setOpacity = (opacity) => {
    model.actor.getProperty().setOpacity(opacity);
  };
  publicAPI.requestData = (inData, outData) => {
    const list = publicAPI.getRepresentationStates(inData[0]);
    const state = list[0];
    if ((state == null ? void 0 : state.getVisible()) && (state == null ? void 0 : state.getOrigin())) {
      const point1 = state.getOrigin();
      const point2 = state.getCorner();
      const diagonal = [0, 0, 0];
      vec3_exports.subtract(diagonal, point2, point1);
      const up = state.getUp();
      const upComponent = vec3_exports.dot(diagonal, up);
      const points = allocateArray(model.internalPolyData, "points", 4).getData();
      points[0] = point1[0];
      points[1] = point1[1];
      points[2] = point1[2];
      points[3] = point1[0] + upComponent * up[0];
      points[4] = point1[1] + upComponent * up[1];
      points[5] = point1[2] + upComponent * up[2];
      points[6] = point2[0];
      points[7] = point2[1];
      points[8] = point2[2];
      points[9] = point2[0] - upComponent * up[0];
      points[10] = point2[1] - upComponent * up[1];
      points[11] = point2[2] - upComponent * up[2];
      if (model.drawFace) {
        const polys = new Uint32Array([4, 0, 1, 2, 3]);
        model.internalPolyData.getPolys().setData(polys, 1);
      }
      if (model.drawBorder) {
        const line = new Uint32Array([5, 0, 1, 2, 3, 0]);
        model.internalPolyData.getLines().setData(line, 1);
      }
    } else {
      model.internalPolyData.getPoints().setData([], 0);
      model.internalPolyData.getPolys().setData([], 0);
      model.internalPolyData.getLines().setData([], 0);
    }
    model.internalPolyData.modified();
    outData[0] = model.internalPolyData;
  };
  publicAPI.getSelectedState = (prop, compositeID) => model.state;
}
var DEFAULT_VALUES215 = {
  drawBorder: false,
  drawFace: true
};
function extend259(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES215, initialValues);
  vtkContextRepresentation$1.extend(publicAPI, model, initialValues);
  macro.setGetArray(publicAPI, model, ["color"], 1);
  macro.setGet(publicAPI, model, ["drawBorder", "drawFace"]);
  macro.get(publicAPI, model, ["mapper", "actor"]);
  vtkRectangleContextRepresentation(publicAPI, model);
}
var newInstance234 = macro.newInstance(extend259, "vtkRectangleContextRepresentation");
var vtkRectangleContextRepresentation$1 = {
  newInstance: newInstance234,
  extend: extend259
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/RectangleWidget/behavior.js
function widgetBehavior11(publicAPI, model) {
  model.shapeHandle = model.widgetState.getRectangleHandle();
  model.point1Handle = model.widgetState.getPoint1Handle();
  model.point2Handle = model.widgetState.getPoint2Handle();
  model.point1Handle.setManipulator(model.manipulator);
  model.point2Handle.setManipulator(model.manipulator);
  widgetBehavior2(publicAPI, model);
  const superClass = {
    ...publicAPI
  };
  model.classHierarchy.push("vtkRectangleWidgetProp");
  publicAPI.setCorners = (point1, point2) => {
    if (superClass.setCorners) {
      superClass.setCorners(point1, point2);
    }
    model.shapeHandle.setOrigin(point1);
    model.shapeHandle.setCorner(point2);
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/RectangleWidget/state.js
function generateState9() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "point1Handle",
    initialValues: {
      scale1: 10,
      visible: false
    }
  }).addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "point2Handle",
    initialValues: {
      scale1: 10,
      visible: false
    }
  }).addStateFromMixin({
    labels: ["rectangleHandle"],
    mixins: ["origin", "corner", "color", "visible", "orientation"],
    name: "rectangleHandle",
    initialValues: {
      visible: false
    }
  }).addStateFromMixin({
    labels: ["SVGtext"],
    mixins: ["origin", "color", "text", "visible"],
    name: "text",
    initialValues: {
      /* text is empty to set a text filed in the SVGLayer and to avoid
       * displaying text before positioning the handles */
      text: ""
    }
  }).addField({
    name: "textPosition",
    initialValue: [TextPosition.CENTER, TextPosition.CENTER, TextPosition.CENTER]
  }).addField({
    name: "textWorldMargin",
    initialValue: 0
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/RectangleWidget.js
function vtkRectangleWidget(publicAPI, model) {
  model.classHierarchy.push("vtkRectangleWidget");
  model.methodsToLink = [...model.methodsToLink, "activeScaleFactor", "activeColor", "useActiveColor", "drawBorder", "drawFace", "opacity"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation$1,
          labels: ["moveHandle"]
        }, {
          builder: vtkRectangleContextRepresentation$1,
          labels: ["rectangleHandle"]
        }];
    }
  };
  model.manipulator = vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  });
}
function defaultValues42(initialValues) {
  return {
    behavior: widgetBehavior11,
    widgetState: generateState9(),
    modifierBehavior: {
      None: {
        [BehaviorCategory.PLACEMENT]: ShapeBehavior[BehaviorCategory.PLACEMENT].CLICK_AND_DRAG,
        [BehaviorCategory.POINTS]: ShapeBehavior[BehaviorCategory.POINTS].CORNER_TO_CORNER,
        [BehaviorCategory.RATIO]: ShapeBehavior[BehaviorCategory.RATIO].FREE
      },
      Shift: {
        [BehaviorCategory.RATIO]: ShapeBehavior[BehaviorCategory.RATIO].FIXED
      },
      Control: {
        [BehaviorCategory.POINTS]: ShapeBehavior[BehaviorCategory.POINTS].CENTER_TO_CORNER
      }
    },
    ...initialValues
  };
}
function extend260(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkShapeWidget$1.extend(publicAPI, model, defaultValues42(initialValues));
  macro.setGet(publicAPI, model, ["widgetState"]);
  vtkRectangleWidget(publicAPI, model);
}
var newInstance235 = macro.newInstance(extend260, "vtkRectangleWidget");
var vtkRectangleWidget$1 = {
  newInstance: newInstance235,
  extend: extend260
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ResliceCursorWidget/behavior.js
function widgetBehavior12(publicAPI, model) {
  model._isDragging = false;
  let isScrolling = false;
  let previousPosition;
  macro.setGet(publicAPI, model, ["keepOrthogonality", {
    type: "object",
    name: "cursorStyles"
  }]);
  publicAPI.setCursorStyles({
    [InteractionMethodsName.TranslateCenter]: "move",
    [InteractionMethodsName.RotateLine]: "alias",
    [InteractionMethodsName.TranslateAxis]: "pointer",
    default: "default"
  });
  publicAPI.setEnableTranslation = (enable) => {
    model.representations[0].setPickable(enable);
    model.representations[2].setPickable(enable);
  };
  publicAPI.setEnableRotation = (enable) => {
    model.representations[1].setPickable(enable);
  };
  publicAPI.getActiveInteraction = () => {
    if (model.widgetState.getStatesWithLabel("rotation").includes(model.activeState)) {
      return InteractionMethodsName.RotateLine;
    }
    if (model.widgetState.getStatesWithLabel("line").includes(model.activeState)) {
      return InteractionMethodsName.TranslateAxis;
    }
    if (model.widgetState.getStatesWithLabel("center").includes(model.activeState)) {
      return InteractionMethodsName.TranslateCenter;
    }
    return null;
  };
  publicAPI.getActiveLineName = () => getLineNames(model.widgetState).find((lineName) => model.widgetState.getStatesWithLabel(lineName).includes(model.activeState));
  publicAPI.getActiveLineHandle = () => {
    var _a, _b;
    return (_b = (_a = model.widgetState)[`getAxis${publicAPI.getActiveLineName()}`]) == null ? void 0 : _b.call(_a);
  };
  publicAPI.getOtherLineHandle = (lineName) => {
    var _a, _b;
    return (_b = (_a = model.widgetState)[`getAxis${getOtherLineName(model.widgetState, lineName)}`]) == null ? void 0 : _b.call(_a);
  };
  publicAPI.getActiveRotationPointName = () => {
    if (model.widgetState.getStatesWithLabel("point0").includes(model.activeState)) {
      return "point0";
    }
    if (model.widgetState.getStatesWithLabel("point1").includes(model.activeState)) {
      return "point1";
    }
    return null;
  };
  publicAPI.startScrolling = (newPosition) => {
    if (newPosition) {
      previousPosition = newPosition;
    }
    isScrolling = true;
    publicAPI.startInteraction();
  };
  publicAPI.endScrolling = () => {
    isScrolling = false;
    publicAPI.endInteraction();
  };
  publicAPI.updateCursor = () => {
    const cursorStyles = publicAPI.getCursorStyles();
    if (cursorStyles) {
      switch (publicAPI.getActiveInteraction()) {
        case InteractionMethodsName.TranslateCenter:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.translateCenter);
          break;
        case InteractionMethodsName.RotateLine:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.rotateLine);
          break;
        case InteractionMethodsName.TranslateAxis:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.translateAxis);
          break;
        default:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.default);
          break;
      }
    }
  };
  publicAPI.handleLeftButtonPress = (callData) => {
    var _a, _b;
    if (model.activeState && model.activeState.getActive()) {
      model._isDragging = true;
      const viewType = model.viewType;
      const currentPlaneNormal = model.widgetState.getPlanes()[viewType].normal;
      const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
      manipulator2.setWidgetOrigin(model.widgetState.getCenter());
      manipulator2.setWidgetNormal(currentPlaneNormal);
      const {
        worldCoords
      } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
      previousPosition = worldCoords;
      publicAPI.startInteraction();
    } else if (model.widgetState.getScrollingMethod() === ScrollingMethods.LEFT_MOUSE_BUTTON) {
      publicAPI.startScrolling(callData.position);
    } else {
      return macro.VOID;
    }
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (callData) => {
    if (model._isDragging) {
      return publicAPI.handleEvent(callData);
    }
    if (isScrolling) {
      if (previousPosition.y !== callData.position.y) {
        const step = previousPosition.y - callData.position.y;
        publicAPI.translateCenterOnPlaneDirection(step);
        previousPosition = callData.position;
        publicAPI.invokeInteractionEvent(publicAPI.getActiveInteraction());
      }
    }
    return macro.VOID;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (model._isDragging || isScrolling) {
      publicAPI.endScrolling();
    }
    model._isDragging = false;
    model.widgetState.deactivate();
  };
  publicAPI.handleRightButtonPress = (calldata) => {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.RIGHT_MOUSE_BUTTON) {
      publicAPI.startScrolling(calldata.position);
    }
  };
  publicAPI.handleRightButtonRelease = () => {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.RIGHT_MOUSE_BUTTON) {
      publicAPI.endScrolling();
    }
  };
  publicAPI.handleStartMouseWheel = () => {
    publicAPI.startInteraction();
  };
  publicAPI.handleMouseWheel = (calldata) => {
    const step = calldata.spinY;
    isScrolling = true;
    publicAPI.translateCenterOnPlaneDirection(step);
    publicAPI.invokeInteractionEvent(
      // Force interaction mode because mouse cursor could be above rotation handle
      InteractionMethodsName.TranslateCenter
    );
    isScrolling = false;
    return macro.EVENT_ABORT;
  };
  publicAPI.handleEndMouseWheel = () => {
    publicAPI.endScrolling();
  };
  publicAPI.handleMiddleButtonPress = (calldata) => {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.MIDDLE_MOUSE_BUTTON) {
      publicAPI.startScrolling(calldata.position);
    }
  };
  publicAPI.handleMiddleButtonRelease = () => {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.MIDDLE_MOUSE_BUTTON) {
      publicAPI.endScrolling();
    }
  };
  publicAPI.handleEvent = (callData) => {
    if (model.activeState.getActive()) {
      const methodName = publicAPI.getActiveInteraction();
      publicAPI[methodName](callData);
      publicAPI.invokeInteractionEvent(methodName);
      return macro.EVENT_ABORT;
    }
    return macro.VOID;
  };
  publicAPI.startInteraction = () => {
    publicAPI.invokeStartInteractionEvent();
    publicAPI.getViewWidgets().forEach((viewWidget) => {
      viewWidget.getInteractor().requestAnimation(publicAPI);
    });
  };
  publicAPI.endInteraction = () => {
    publicAPI.invokeEndInteractionEvent();
    publicAPI.getViewWidgets().forEach((viewWidget) => {
      viewWidget.getInteractor().cancelAnimation(publicAPI);
    });
  };
  publicAPI.translateCenterOnPlaneDirection = (nbSteps) => {
    const dirProj = model.widgetState.getPlanes()[model.viewType].normal;
    const oldCenter = model.widgetState.getCenter();
    const image = model.widgetState.getImage();
    const imageSpacing = image.getSpacing();
    const absDirProj = dirProj.map((value) => Math.abs(value));
    const index = absDirProj.indexOf(Math.max(...absDirProj));
    const movingFactor = nbSteps * imageSpacing[index] / Math.abs(dirProj[index]);
    let newCenter = [oldCenter[0] + movingFactor * dirProj[0], oldCenter[1] + movingFactor * dirProj[1], oldCenter[2] + movingFactor * dirProj[2]];
    newCenter = publicAPI.getBoundedCenter(newCenter);
    model.widgetState.setCenter(newCenter);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };
  publicAPI[InteractionMethodsName.TranslateAxis] = (calldata) => {
    var _a, _b, _c, _d;
    const lineHandle = publicAPI.getActiveLineHandle();
    const lineName = publicAPI.getActiveLineName();
    const pointOnLine = add(lineHandle.getOrigin(), lineHandle.getDirection(), []);
    const currentLineVector = lineHandle.getDirection();
    normalize(currentLineVector);
    const otherLineHandle = publicAPI.getOtherLineHandle(lineName);
    const center = model.widgetState.getCenter();
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    let worldCoords = null;
    let newOrigin = [];
    if ((_d = (_c = model.activeState) == null ? void 0 : _c.getManipulator) == null ? void 0 : _d.call(_c)) {
      worldCoords = manipulator2.handleEvent(calldata, model._apiSpecificRenderWindow).worldCoords;
      const translation = subtract(worldCoords, previousPosition, []);
      add(center, translation, newOrigin);
    } else if (otherLineHandle) {
      const otherLineVector = otherLineHandle.getDirection();
      normalize(otherLineVector);
      const axisTranslation = otherLineVector;
      const dot$1 = dot(currentLineVector, otherLineVector);
      if (dot$1 === 1 || dot$1 === -1) {
        cross(currentLineVector, manipulator2.getWidgetNormal(), axisTranslation);
      }
      const closestPoint = [];
      worldCoords = manipulator2.handleEvent(calldata, model._apiSpecificRenderWindow).worldCoords;
      vtkLine$1.distanceToLine(worldCoords, lineHandle.getOrigin(), pointOnLine, closestPoint);
      const translationVector = subtract(worldCoords, closestPoint, []);
      const translationDistance = dot(translationVector, axisTranslation);
      newOrigin = multiplyAccumulate(center, axisTranslation, translationDistance, newOrigin);
    }
    newOrigin = publicAPI.getBoundedCenter(newOrigin);
    model.widgetState.setCenter(newOrigin);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
    previousPosition = worldCoords;
  };
  publicAPI.getBoundedCenter = (newCenter) => {
    const oldCenter = model.widgetState.getCenter();
    const imageBounds = model.widgetState.getImage().getBounds();
    if (vtkBoundingBox.containsPoint(imageBounds, ...newCenter)) {
      return newCenter;
    }
    return boundPointOnPlane(newCenter, oldCenter, imageBounds);
  };
  publicAPI[InteractionMethodsName.TranslateCenter] = (calldata) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    const {
      worldCoords
    } = manipulator2.handleEvent(calldata, model._apiSpecificRenderWindow);
    const translation = subtract(worldCoords, previousPosition, []);
    previousPosition = worldCoords;
    let newCenter = add(model.widgetState.getCenter(), translation, []);
    newCenter = publicAPI.getBoundedCenter(newCenter);
    model.widgetState.setCenter(newCenter);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };
  publicAPI[InteractionMethodsName.RotateLine] = (calldata) => {
    var _a, _b;
    const activeLineHandle = publicAPI.getActiveLineHandle();
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    const planeNormal = manipulator2.getWidgetNormal();
    const {
      worldCoords
    } = manipulator2.handleEvent(calldata, model._apiSpecificRenderWindow);
    if (!worldCoords || !worldCoords.length) {
      return;
    }
    const center = model.widgetState.getCenter();
    const currentVectorToOrigin = [0, 0, 0];
    subtract(worldCoords, center, currentVectorToOrigin);
    normalize(currentVectorToOrigin);
    const previousLineDirection = activeLineHandle.getDirection();
    normalize(previousLineDirection);
    const activePointName = publicAPI.getActiveRotationPointName();
    if (activePointName === "point1" || !activePointName && dot(currentVectorToOrigin, previousLineDirection) < 0) {
      multiplyScalar(previousLineDirection, -1);
    }
    const radianAngle = signedAngleBetweenVectors(previousLineDirection, currentVectorToOrigin, planeNormal);
    publicAPI.rotateLineInView(publicAPI.getActiveLineName(), radianAngle);
  };
  publicAPI.rotateLineInView = (lineName, radianAngle) => {
    const viewType = planeNameToViewType[getLinePlaneName(lineName)];
    const inViewType = planeNameToViewType[getLineInPlaneName(lineName)];
    const planeNormal = model.widgetState.getPlanes()[inViewType].normal;
    publicAPI.rotatePlane(viewType, radianAngle, planeNormal);
    if (publicAPI.getKeepOrthogonality()) {
      const otherLineName = getOtherLineName(model.widgetState, lineName);
      const otherPlaneName = getLinePlaneName(otherLineName);
      publicAPI.rotatePlane(planeNameToViewType[otherPlaneName], radianAngle, planeNormal);
    }
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };
  publicAPI.rotatePlane = (viewType, radianAngle, planeNormal) => {
    const {
      normal,
      viewUp
    } = model.widgetState.getPlanes()[viewType];
    const newNormal = rotateVector(normal, planeNormal, radianAngle);
    const newViewUp = rotateVector(viewUp, planeNormal, radianAngle);
    model.widgetState.getPlanes()[viewType] = {
      normal: newNormal,
      viewUp: newViewUp
    };
  };
  publicAPI.setViewPlane = (viewType, normal, viewUp) => {
    let newViewUp = viewUp;
    if (newViewUp == null) {
      newViewUp = model.widgetState.getPlanes()[viewType].viewUp;
    }
    model.widgetState.getPlanes()[viewType] = {
      normal,
      viewUp: newViewUp
    };
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ResliceCursorWidget/state.js
var defaultPlanes = {
  X: {
    normal: [1, 0, 0],
    viewUp: [0, 0, 1],
    color3: [255, 0, 0]
  },
  Y: {
    normal: [0, -1, 0],
    viewUp: [0, 0, 1],
    color3: [0, 255, 0]
  },
  Z: {
    normal: [0, 0, -1],
    viewUp: [0, -1, 0],
    color3: [0, 0, 255]
  }
};
var viewsColor3 = {
  X: [255, 0, 0],
  // red
  Y: [0, 255, 0],
  // green
  Z: [0, 0, 255]
  // blue
};
function generateState10() {
  let planes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : planeNames;
  const state = vtkStateBuilder.createBuilder().addField({
    name: "center",
    initialValue: [0, 0, 0]
  }).addField({
    name: "image",
    initialValue: null
  }).addField({
    name: "activeViewType",
    initialValue: null
  }).addField({
    name: "planes",
    initialValue: planes.reduce((res, planeName) => ({
      ...res,
      [planeNameToViewType[planeName]]: {
        normal: defaultPlanes[planeName].normal,
        viewUp: defaultPlanes[planeName].viewUp
      }
    }), {})
  }).addField({
    name: "scrollingMethod",
    initialValue: ScrollingMethods.MIDDLE_MOUSE_BUTTON
  }).addField({
    name: "cameraOffsets",
    initialValue: {}
  }).addField({
    name: "viewUpFromViewType",
    initialValue: {}
  }).addStateFromMixin({
    labels: ["handles", "sphere", "center"],
    mixins: ["origin", "color3", "scale1", "visible", "manipulator"],
    name: "centerHandle",
    initialValues: {
      scale1: 30,
      color3: [255, 255, 255]
    }
  });
  planes.reduce((viewState, view) => planes.filter((v) => v !== view).reduce((axisState, axis) => {
    axisState.addStateFromMixin({
      labels: ["handles", "line", `lineIn${view}`, `${axis}in${view}`],
      mixins: ["origin", "color3", "scale3", "orientation", "visible", "manipulator"],
      name: `axis${axis}in${view}`,
      initialValues: {
        scale3: [4, 4, 4],
        color3: viewsColor3[axis]
      }
    });
    for (let rotationHandle = 0; rotationHandle < 2; ++rotationHandle) {
      axisState.addStateFromMixin({
        labels: ["handles", "sphere", "rotation", `rotationIn${view}`, `${axis}in${view}`, `point${rotationHandle}`],
        mixins: ["origin", "color3", "scale1", "visible", "manipulator"],
        name: `rotationHandle${axis}in${view}${rotationHandle}`,
        initialValues: {
          scale1: 30,
          color3: viewsColor3[axis]
        }
      });
    }
    return axisState;
  }, viewState), state);
  return state.build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/ResliceCursorWidget.js
var VTK_INT_MAX = 2147483647;
var {
  vtkErrorMacro: vtkErrorMacro81
} = macro;
function vtkResliceCursorWidget(publicAPI, model) {
  model.classHierarchy.push("vtkResliceCursorWidget");
  model.methodsToLink = [
    // For all representations
    "scaleInPixels",
    // For line representations
    "holeWidth",
    "infiniteLine"
  ];
  function computeReslicePlaneOrigin(viewType) {
    const bounds2 = model.widgetState.getImage().getBounds();
    const center = publicAPI.getWidgetState().getCenter();
    const imageCenter = model.widgetState.getImage().getCenter();
    const offset = [];
    for (let i = 0; i < 3; i++) {
      offset[i] = -Math.abs(center[i] - imageCenter[i]);
      offset[i] *= 2;
    }
    const planeSource = vtkPlaneSource$1.newInstance();
    if (viewType === ViewTypes.XZ_PLANE) {
      planeSource.setOrigin(bounds2[0] + offset[0], center[1], bounds2[4] + offset[2]);
      planeSource.setPoint1(bounds2[1] - offset[0], center[1], bounds2[4] + offset[2]);
      planeSource.setPoint2(bounds2[0] + offset[0], center[1], bounds2[5] - offset[2]);
    } else if (viewType === ViewTypes.XY_PLANE) {
      planeSource.setOrigin(bounds2[0] + offset[0], bounds2[2] + offset[1], center[2]);
      planeSource.setPoint1(bounds2[1] - offset[0], bounds2[2] + offset[1], center[2]);
      planeSource.setPoint2(bounds2[0] + offset[0], bounds2[3] - offset[1], center[2]);
    } else if (viewType === ViewTypes.YZ_PLANE) {
      planeSource.setOrigin(center[0], bounds2[2] + offset[1], bounds2[4] + offset[2]);
      planeSource.setPoint1(center[0], bounds2[3] - offset[1], bounds2[4] + offset[2]);
      planeSource.setPoint2(center[0], bounds2[2] + offset[1], bounds2[5] - offset[2]);
    }
    return planeSource;
  }
  function computeFocalPointOffsetFromResliceCursorCenter(viewType, renderer) {
    const worldFocalPoint = renderer.getActiveCamera().getFocalPoint();
    const worldResliceCenter = model.widgetState.getCenter();
    const view = renderer.getRenderWindow().getViews()[0];
    const dims = view.getViewportSize(renderer);
    const aspect = dims[0] / dims[1];
    const displayFocalPoint = renderer.worldToNormalizedDisplay(...worldFocalPoint, aspect);
    const displayResliceCenter = renderer.worldToNormalizedDisplay(...worldResliceCenter, aspect);
    const newOffset = subtract(displayFocalPoint, displayResliceCenter, [0, 0, 0]);
    const cameraOffsets = model.widgetState.getCameraOffsets();
    cameraOffsets[viewType] = newOffset;
    model.widgetState.setCameraOffsets(cameraOffsets);
  }
  function updateCamera(renderer, normal, viewType, resetFocalPoint, keepCenterFocalDistance) {
    const focalPoint = renderer.getActiveCamera().getFocalPoint();
    const distance = renderer.getActiveCamera().getDistance();
    const estimatedCameraPosition = multiplyAccumulate(focalPoint, normal, distance, [0, 0, 0]);
    let newFocalPoint = focalPoint;
    if (resetFocalPoint) {
      const intersection = vtkPlane$1.intersectWithLine(
        focalPoint,
        estimatedCameraPosition,
        model.widgetState.getCenter(),
        // reslice cursor center
        normal
      );
      newFocalPoint = intersection.x;
    }
    if (keepCenterFocalDistance) {
      const worldResliceCenter = model.widgetState.getCenter();
      const view = renderer.getRenderWindow().getViews()[0];
      const dims = view.getViewportSize(renderer);
      const aspect = dims[0] / dims[1];
      const displayResliceCenter = renderer.worldToNormalizedDisplay(...worldResliceCenter, aspect);
      const realOffset = model.widgetState.getCameraOffsets()[viewType];
      const displayFocal = add(displayResliceCenter, realOffset, [0, 0, 0]);
      const worldFocal = renderer.normalizedDisplayToWorld(...displayFocal, aspect);
      const intersection2 = vtkPlane$1.intersectWithLine(worldFocal, estimatedCameraPosition, worldResliceCenter, normal);
      newFocalPoint[0] = intersection2.x[0];
      newFocalPoint[1] = intersection2.x[1];
      newFocalPoint[2] = intersection2.x[2];
    }
    renderer.getActiveCamera().setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
    const newCameraPosition = multiplyAccumulate(newFocalPoint, normal, distance, [0, 0, 0]);
    renderer.getActiveCamera().setPosition(newCameraPosition[0], newCameraPosition[1], newCameraPosition[2]);
    const bounds2 = model.widgetState.getImage().getBounds();
    if (resetFocalPoint) {
      renderer.resetCamera(bounds2);
    }
    renderer.resetCameraClippingRange(bounds2);
  }
  function findWidgetForViewType(viewType) {
    return publicAPI.getViewIds().map((viewId) => publicAPI.getWidgetForView({
      viewId
    })).find((widget) => widget.getViewType() === viewType);
  }
  function findRepresentationsForViewType(viewType) {
    const widgetForViewType = findWidgetForViewType(viewType);
    return widgetForViewType ? widgetForViewType.getRepresentations() : [];
  }
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.XY_PLANE:
      case ViewTypes.XZ_PLANE:
      case ViewTypes.YZ_PLANE:
        return [{
          builder: vtkLineHandleRepresentation$1,
          labels: [`lineIn${viewTypeToPlaneName[viewType]}`],
          initialValues: {
            useActiveColor: false,
            scaleInPixels: model.scaleInPixels
          }
        }, {
          builder: vtkSphereHandleRepresentation$1,
          labels: [`rotationIn${viewTypeToPlaneName[viewType]}`],
          initialValues: {
            useActiveColor: false,
            scaleInPixels: model.scaleInPixels,
            lighting: false
          }
        }, {
          builder: vtkSphereHandleRepresentation$1,
          labels: ["center"],
          initialValues: {
            useActiveColor: false,
            scaleInPixels: model.scaleInPixels,
            lighting: false
          }
        }];
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [];
    }
  };
  publicAPI.setImage = (image) => {
    model.widgetState.setImage(image);
    const center = image.getCenter();
    publicAPI.setCenter(center);
  };
  publicAPI.setCenter = (center) => {
    model.widgetState.setCenter(center);
    updateState(model.widgetState, model.scaleInPixels, model.rotationHandlePosition);
    publicAPI.modified();
  };
  publicAPI.updateCameraPoints = (renderer, viewType, resetFocalPoint, computeFocalPointOffset) => {
    publicAPI.resetCamera(renderer, viewType, resetFocalPoint, !computeFocalPointOffset);
    if (computeFocalPointOffset) {
      computeFocalPointOffsetFromResliceCursorCenter(viewType, renderer);
    }
  };
  publicAPI.resetCamera = (renderer, viewType, resetFocalPoint, keepCenterFocalDistance) => {
    const center = model.widgetState.getImage().getCenter();
    const focalPoint = renderer.getActiveCamera().getFocalPoint();
    const position = renderer.getActiveCamera().getPosition();
    const distance = Math.sqrt(distance2BetweenPoints(position, focalPoint));
    const normal = publicAPI.getPlaneNormalFromViewType(viewType);
    const estimatedFocalPoint = resetFocalPoint ? center : focalPoint;
    const estimatedCameraPosition = multiplyAccumulate(estimatedFocalPoint, normal, distance, [0, 0, 0]);
    renderer.getActiveCamera().setFocalPoint(...estimatedFocalPoint);
    renderer.getActiveCamera().setPosition(...estimatedCameraPosition);
    renderer.getActiveCamera().setViewUp(model.widgetState.getPlanes()[viewType].viewUp);
    updateCamera(renderer, normal, viewType, resetFocalPoint, keepCenterFocalDistance);
  };
  publicAPI.getPlaneSource = (viewType) => {
    const planeSource = computeReslicePlaneOrigin(viewType);
    const {
      normal,
      viewUp
    } = model.widgetState.getPlanes()[viewType];
    transformPlane(planeSource, model.widgetState.getCenter(), normal, viewUp);
    const boundedOrigin = [...planeSource.getOrigin()];
    const boundedP1 = [...planeSource.getPoint1()];
    const boundedP2 = [...planeSource.getPoint2()];
    boundPlane(model.widgetState.getImage().getBounds(), boundedOrigin, boundedP1, boundedP2);
    planeSource.setOrigin(...boundedOrigin);
    planeSource.setPoint1(...boundedP1);
    planeSource.setPoint2(...boundedP2);
    return planeSource;
  };
  publicAPI.getResliceAxes = (viewType) => {
    const planeSource = publicAPI.getPlaneSource(viewType);
    const {
      normal
    } = model.widgetState.getPlanes()[viewType];
    const planeOrigin = planeSource.getOrigin();
    const p1 = planeSource.getPoint1();
    const planeAxis1 = [];
    subtract(p1, planeOrigin, planeAxis1);
    normalize(planeAxis1);
    const p2 = planeSource.getPoint2();
    const planeAxis2 = [];
    subtract(p2, planeOrigin, planeAxis2);
    normalize(planeAxis2);
    const newResliceAxes = mat4_exports.identity(new Float64Array(16));
    for (let i = 0; i < 3; i++) {
      newResliceAxes[i] = planeAxis1[i];
      newResliceAxes[4 + i] = planeAxis2[i];
      newResliceAxes[8 + i] = normal[i];
      newResliceAxes[12 + i] = planeOrigin[i];
    }
    return newResliceAxes;
  };
  publicAPI.updateReslicePlane = (imageReslice, viewType) => {
    const spacing = model.widgetState.getImage().getSpacing();
    const planeSource = publicAPI.getPlaneSource(viewType);
    const newResliceAxes = publicAPI.getResliceAxes(viewType);
    const planeOrigin = planeSource.getOrigin();
    const p1 = planeSource.getPoint1();
    const planeAxis1 = subtract(p1, planeOrigin, []);
    const planeSizeX = normalize(planeAxis1);
    const p2 = planeSource.getPoint2();
    const planeAxis2 = subtract(p2, planeOrigin, []);
    const planeSizeY = normalize(planeAxis2);
    const spacingX = Math.abs(planeAxis1[0] * spacing[0]) + Math.abs(planeAxis1[1] * spacing[1]) + Math.abs(planeAxis1[2] * spacing[2]);
    const spacingY = Math.abs(planeAxis2[0] * spacing[0]) + Math.abs(planeAxis2[1] * spacing[1]) + Math.abs(planeAxis2[2] * spacing[2]);
    let extentX = 0;
    let extentY = 0;
    const realExtentX = spacingX === 0 ? Number.MAX_SAFE_INTEGER : planeSizeX / spacingX;
    const value = VTK_INT_MAX >> 1;
    if (realExtentX > value) {
      vtkErrorMacro81("Invalid X extent: ", realExtentX, " on view type : ", viewType);
      extentX = 0;
    } else {
      extentX = 1;
      while (extentX < realExtentX) {
        extentX <<= 1;
      }
    }
    const realExtentY = spacingY === 0 ? Number.MAX_SAFE_INTEGER : planeSizeY / spacingY;
    if (realExtentY > value) {
      vtkErrorMacro81("Invalid Y extent:", realExtentY, " on view type : ", viewType);
      extentY = 0;
    } else {
      extentY = 1;
      while (extentY < realExtentY) {
        extentY <<= 1;
      }
    }
    const outputSpacingX = extentX === 0 ? 1 : planeSizeX / extentX;
    const outputSpacingY = extentY === 0 ? 1 : planeSizeY / extentY;
    let modified = imageReslice.setResliceAxes(newResliceAxes);
    modified = imageReslice.setOutputSpacing([outputSpacingX, outputSpacingY, 1]) || modified;
    modified = imageReslice.setOutputOrigin([0.5 * outputSpacingX, 0.5 * outputSpacingY, 0]) || modified;
    modified = imageReslice.setOutputExtent([0, extentX - 1, 0, extentY - 1, 0, 0]) || modified;
    return modified;
  };
  publicAPI.getPlaneSourceFromViewType = (type) => {
    const planeSource = vtkPlaneSource$1.newInstance();
    const origin3 = publicAPI.getWidgetState().getCenter();
    const planeNormal = publicAPI.getPlaneNormalFromViewType(type);
    planeSource.setNormal(planeNormal);
    planeSource.setOrigin(origin3);
    return planeSource;
  };
  publicAPI.getPlaneNormalFromViewType = (viewType) => publicAPI.getWidgetState().getPlanes()[viewType].normal;
  publicAPI.getOtherPlaneNormals = (viewType) => [ViewTypes.YZ_PLANE, ViewTypes.XZ_PLANE, ViewTypes.XY_PLANE].filter((vt) => vt !== viewType).map((vt) => publicAPI.getPlaneNormalFromViewType(vt));
  publicAPI.getResliceMatrix = () => {
    const resliceMatrix = mat4_exports.identity(new Float64Array(16));
    for (let i = 0; i < 3; i++) {
      resliceMatrix[4 * i + 0] = publicAPI.getPlaneNormalFromViewType(ViewTypes.YZ_PLANE)[i];
      resliceMatrix[4 * i + 1] = publicAPI.getPlaneNormalFromViewType(ViewTypes.XZ_PLANE)[i];
      resliceMatrix[4 * i + 2] = publicAPI.getPlaneNormalFromViewType(ViewTypes.XY_PLANE)[i];
    }
    const origin3 = publicAPI.getWidgetState().getCenter();
    const m = vtkMatrixBuilder.buildFromRadian().translate(...origin3).multiply(resliceMatrix).translate(...multiplyScalar([...origin3], -1)).getMatrix();
    return m;
  };
  publicAPI.getDisplayScaleParams = () => [ViewTypes.YZ_PLANE, ViewTypes.XZ_PLANE, ViewTypes.XY_PLANE].reduce((res, viewType) => {
    var _a, _b;
    res[viewType] = (_b = (_a = findRepresentationsForViewType(viewType)[0]) == null ? void 0 : _a.getDisplayScaleParams) == null ? void 0 : _b.call(_a);
    return res;
  }, {});
  publicAPI.setScaleInPixels = macro.chain(publicAPI.setScaleInPixels, (scale) => {
    publicAPI.getViewWidgets().forEach((w) => w.setScaleInPixels(scale));
    updateState(model.widgetState, model.scaleInPixels, model.rotationHandlePosition);
  });
  publicAPI.getPlaneExtremities = (viewType) => {
    const dirProj = publicAPI.getWidgetState().getPlanes()[viewType].normal;
    const length = vtkBoundingBox.getDiagonalLength(publicAPI.getWidgetState().getImage().getBounds());
    const p1 = multiplyAccumulate(publicAPI.getWidgetState().getCenter(), dirProj, -length, []);
    const p2 = multiplyAccumulate(publicAPI.getWidgetState().getCenter(), dirProj, length, []);
    const intersectionPoints = vtkBox$1.intersectWithLine(publicAPI.getWidgetState().getImage().getBounds(), p1, p2);
    return [intersectionPoints.x1, intersectionPoints.x2];
  };
}
var defaultValues43 = (initialValues) => ({
  behavior: widgetBehavior12,
  widgetState: generateState10(initialValues.planes),
  rotationHandlePosition: 0.5,
  scaleInPixels: true,
  manipulator: vtkPlaneManipulator$1.newInstance(),
  ...initialValues
});
function extend261(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues43(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["scaleInPixels", "rotationHandlePosition", "manipulator"]);
  vtkResliceCursorWidget(publicAPI, model);
}
var newInstance236 = macro.newInstance(extend261, "vtkResliceCursorWidget");
var vtkResliceCursorWidget$1 = {
  newInstance: newInstance236,
  extend: extend261
};

// node_modules/@kitware/vtk.js/Widgets/Representations/SphereContextRepresentation.js
function vtkSphereContextRepresentation(publicAPI, model) {
  model.classHierarchy.push("vtkSphereContextRepresentation");
  publicAPI.setGlyphResolution = macro.chain(publicAPI.setGlyphResolution, model._pipeline.glyph.setThetaResolution, model._pipeline.glyph.setPhiResolution);
  publicAPI.setDrawBorder = (draw) => {
    model._pipeline.glyph.setLines(draw);
  };
  publicAPI.setDrawFace = (draw) => {
    model._pipeline.glyph.setFace(draw);
  };
  publicAPI.setOpacity = (opacity) => {
    model._pipeline.actor.getProperty().setOpacity(opacity);
  };
  model._pipeline.actor.getProperty().setOpacity(0.2);
}
function defaultValues44(initialValues) {
  return {
    glyphResolution: 32,
    drawBorder: false,
    drawFace: true,
    behavior: Behavior.CONTEXT,
    _pipeline: {
      glyph: vtkSphereSource$1.newInstance({
        phiResolution: initialValues.glyphResolution ?? 32,
        thetaResolution: initialValues.glyphResolution ?? 32
      })
    },
    ...initialValues
  };
}
function extend262(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkGlyphRepresentation$1.extend(publicAPI, model, defaultValues44(initialValues));
  macro.setGet(publicAPI, model, ["glyphResolution"]);
  vtkSphereContextRepresentation(publicAPI, model);
}
var newInstance237 = macro.newInstance(extend262, "vtkSphereContextRepresentation");
var vtkSphereContextRepresentation$1 = {
  newInstance: newInstance237,
  extend: extend262
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/SphereWidget/behavior.js
function widgetBehavior13(publicAPI, model) {
  const state = model.widgetState;
  const moveHandle = state.getMoveHandle();
  const centerHandle = state.getCenterHandle();
  const borderHandle = state.getBorderHandle();
  const shapeHandle = state.getSphereHandle();
  model._isDragging = false;
  model.classHierarchy.push("vtkSphereWidgetProp");
  moveHandle.setVisible(true);
  centerHandle.setVisible(false);
  borderHandle.setVisible(false);
  shapeHandle.setVisible(true);
  function isValidHandle(handle) {
    return handle === centerHandle || handle === borderHandle || handle === moveHandle;
  }
  function isPlaced() {
    return !!centerHandle.getOrigin() && !!borderHandle.getOrigin();
  }
  function updateSphere() {
    const center = centerHandle.getOrigin();
    if (!center) return;
    centerHandle.setVisible(true);
    let border = borderHandle.getOrigin();
    if (border) {
      borderHandle.setVisible(true);
    } else {
      border = moveHandle.getOrigin();
      if (!border) return;
    }
    if (isPlaced()) {
      moveHandle.setVisible(false);
    }
    const radius = vec3_exports.distance(center, border);
    shapeHandle.setVisible(true);
    shapeHandle.setOrigin(center);
    shapeHandle.setScale1(radius * 2);
    model._interactor.render();
  }
  function currentWorldCoords(e2) {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    return manipulator2.handleEvent(e2, model._apiSpecificRenderWindow);
  }
  publicAPI.setCenterAndRadius = (newCenter, newRadius) => {
    const oldCenter = centerHandle.getOrigin();
    const oldBorder = borderHandle.getOrigin();
    let newBorder = [newCenter[0] + newRadius, newCenter[1], newCenter[2]];
    if (oldBorder) {
      const direction3 = vec3_exports.sub(vec3_exports.create(), oldBorder, oldCenter);
      const oldRadius = vec3_exports.length(direction3);
      if (oldRadius > 1e-10) {
        newBorder = vec3_exports.add(vec3_exports.create(), newCenter, vec3_exports.scale(vec3_exports.create(), direction3, newRadius / oldRadius));
      }
    }
    centerHandle.setOrigin(newCenter);
    borderHandle.setOrigin(newBorder);
    updateSphere();
    model._widgetManager.enablePicking();
  };
  publicAPI.handleLeftButtonPress = (e2) => {
    if (!isValidHandle(model.activeState)) {
      model.activeState = null;
      return macro.VOID;
    }
    const {
      worldCoords
    } = currentWorldCoords(e2);
    if (model.activeState === moveHandle) {
      if (!centerHandle.getOrigin()) {
        centerHandle.setOrigin(worldCoords);
      } else if (!borderHandle.getOrigin()) {
        borderHandle.setOrigin(worldCoords);
        publicAPI.loseFocus();
      }
      updateSphere();
      return macro.EVENT_ABORT;
    }
    model._isDragging = true;
    model._apiSpecificRenderWindow.setCursor("grabbing");
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleLeftButtonRelease = (e2) => {
    if (!model._isDragging) {
      model.activeState = null;
      return macro.VOID;
    }
    if (isPlaced()) {
      model._widgetManager.enablePicking();
      model._apiSpecificRenderWindow.setCursor("pointer");
      model._isDragging = false;
      model.activeState = null;
      state.deactivate();
    }
    publicAPI.invokeEndInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleMouseMove = (e2) => {
    if (!model.activeState) return macro.VOID;
    const {
      worldCoords,
      worldDelta
    } = currentWorldCoords(e2);
    if (model.hasFocus) {
      model.activeState.setOrigin(worldCoords);
    } else if (model._isDragging) {
      model.activeState.setOrigin(add(model.activeState.getOrigin(), worldDelta, []));
    }
    updateSphere();
    return macro.VOID;
  };
  const superGrabFocus = publicAPI.grabFocus;
  publicAPI.grabFocus = () => {
    superGrabFocus();
    moveHandle.setVisible(true);
    centerHandle.setVisible(false);
    borderHandle.setVisible(false);
    centerHandle.setOrigin(null);
    borderHandle.setOrigin(null);
    model.activeState = moveHandle;
    model._interactor.render();
  };
  const superLoseFocus = publicAPI.loseFocus;
  publicAPI.loseFocus = () => {
    superLoseFocus();
    model.activeState = null;
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/SphereWidget/state.js
function stateGenerator() {
  return vtkStateBuilder.createBuilder().addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "moveHandle",
    initialValues: {
      scale1: 20,
      visible: true
    }
  }).addStateFromMixin({
    labels: ["centerHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "centerHandle",
    initialValues: {
      scale1: 20,
      visible: true
    }
  }).addStateFromMixin({
    labels: ["borderHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "borderHandle",
    initialValues: {
      scale1: 20,
      visible: true
    }
  }).addStateFromMixin({
    labels: ["sphereHandle"],
    mixins: ["origin", "color", "scale1", "visible", "orientation"],
    name: "sphereHandle",
    initialValues: {
      visible: true,
      radius: 1
    }
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/SphereWidget.js
function vtkSphereWidget(publicAPI, model) {
  model.classHierarchy.push("vtkSphereWidget");
  const superClass = {
    ...publicAPI
  };
  model.methodsToLink = ["scaleInPixels"];
  publicAPI.getRepresentationsForViewType = (viewType) => [{
    builder: vtkSphereHandleRepresentation$1,
    labels: ["moveHandle"]
  }, {
    builder: vtkSphereHandleRepresentation$1,
    labels: ["centerHandle"]
  }, {
    builder: vtkSphereHandleRepresentation$1,
    labels: ["borderHandle"]
  }, {
    builder: vtkSphereContextRepresentation$1,
    labels: ["sphereHandle"]
  }];
  publicAPI.getRadius = () => {
    const h1 = model.widgetState.getCenterHandle();
    const h2 = model.widgetState.getBorderHandle();
    return Math.sqrt(distance2BetweenPoints(h1.getOrigin(), h2.getOrigin()));
  };
  publicAPI.setManipulator = (manipulator2) => {
    superClass.setManipulator(manipulator2);
    model.widgetState.getMoveHandle().setManipulator(manipulator2);
    model.widgetState.getCenterHandle().setManipulator(manipulator2);
    model.widgetState.getBorderHandle().setManipulator(manipulator2);
  };
  publicAPI.setManipulator(model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
}
var defaultValues45 = (initialValues) => ({
  behavior: widgetBehavior13,
  widgetState: stateGenerator(),
  ...initialValues
});
function extend263(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues45(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["manipulator", "widgetState"]);
  vtkSphereWidget(publicAPI, model);
}
var newInstance238 = macro.newInstance(extend263, "vtkSphereWidget");
var vtkSphereWidget$1 = {
  newInstance: newInstance238,
  extend: extend263
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/SplineWidget/behavior.js
function widgetBehavior14(publicAPI, model) {
  model.classHierarchy.push("vtkSplineWidgetProp");
  model._isDragging = false;
  model.keysDown = {};
  model.moveHandle = model.widgetState.getMoveHandle();
  const updateHandlesSize = () => {
    if (publicAPI.getHandleSizeInPixels() != null) {
      const scale = publicAPI.getHandleSizeInPixels();
      model.moveHandle.setScale1(scale);
      model.widgetState.getHandleList().forEach((handle) => {
        handle.setScale1(scale);
      });
    }
  };
  const addPoint = () => {
    if (!model.lastHandle || model.keysDown.Control || !model.freeHand || vec3_exports.squaredDistance(model.moveHandle.getOrigin(), model.lastHandle.getOrigin()) > publicAPI.getFreehandMinDistance() * publicAPI.getFreehandMinDistance()) {
      model.lastHandle = model.widgetState.addHandle();
      model.lastHandle.setVisible(false);
      model.lastHandle.setOrigin(...model.moveHandle.getOrigin());
      model.lastHandle.setColor(model.moveHandle.getColor());
      model.lastHandle.setScale1(model.moveHandle.getScale1());
      model.lastHandle.setManipulator(model.manipulator);
      if (!model.firstHandle) {
        model.firstHandle = model.lastHandle;
      }
      model._apiSpecificRenderWindow.setCursor("grabbing");
    }
  };
  const getHoveredHandle = () => {
    const handles = model.widgetState.getHandleList();
    const scale = model.moveHandle.getScale1() * vec3_exports.distance(model._apiSpecificRenderWindow.displayToWorld(0, 0, 0, model._renderer), model._apiSpecificRenderWindow.displayToWorld(1, 0, 0, model._renderer));
    return handles.reduce((_ref, handle) => {
      let {
        closestHandle,
        closestDistance
      } = _ref;
      if (handle !== model.moveHandle && model.moveHandle.getOrigin() && handle.getOrigin()) {
        const distance = vec3_exports.squaredDistance(model.moveHandle.getOrigin(), handle.getOrigin());
        if (distance < closestDistance) {
          return {
            closestHandle: handle,
            closestDistance: distance
          };
        }
      }
      return {
        closestHandle,
        closestDistance
      };
    }, {
      closestHandle: null,
      closestDistance: scale * scale
    }).closestHandle;
  };
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  publicAPI.setResetAfterPointPlacement = model._factory.setResetAfterPointPlacement;
  publicAPI.getResetAfterPointPlacement = model._factory.getResetAfterPointPlacement;
  publicAPI.setResetAfterPointPlacement(publicAPI.getResetAfterPointPlacement());
  publicAPI.setFreehandMinDistance = model._factory.setFreehandMinDistance;
  publicAPI.getFreehandMinDistance = model._factory.getFreehandMinDistance;
  publicAPI.setFreehandMinDistance(publicAPI.getFreehandMinDistance());
  publicAPI.setAllowFreehand = model._factory.setAllowFreehand;
  publicAPI.getAllowFreehand = model._factory.getAllowFreehand;
  publicAPI.setAllowFreehand(publicAPI.getAllowFreehand());
  publicAPI.setDefaultCursor = model._factory.setDefaultCursor;
  publicAPI.getDefaultCursor = model._factory.getDefaultCursor;
  publicAPI.setDefaultCursor(publicAPI.getDefaultCursor());
  publicAPI.setHandleSizeInPixels = (size) => {
    model._factory.setHandleSizeInPixels(size);
    updateHandlesSize();
  };
  publicAPI.getHandleSizeInPixels = model._factory.getHandleSizeInPixels;
  publicAPI.setHandleSizeInPixels(model._factory.getHandleSizeInPixels());
  publicAPI.setResolution = (resolution) => {
    model._factory.setResolution(resolution);
    model.representations[1].setResolution(resolution);
  };
  publicAPI.setResolution(model._factory.getResolution());
  publicAPI.getPoints = () => model.representations[1].getOutputData().getPoints().getData();
  publicAPI.reset = () => {
    model.widgetState.clearHandleList();
    model.lastHandle = null;
    model.firstHandle = null;
  };
  publicAPI.handleRightButtonPress = (e2) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    if (model.activeState !== model.moveHandle) {
      model._interactor.requestAnimation(publicAPI);
      model.activeState.deactivate();
      model.widgetState.removeHandle(model.activeState);
      model.activeState = null;
      model._interactor.cancelAnimation(publicAPI);
    } else {
      const handle = getHoveredHandle();
      if (handle) {
        model.widgetState.removeHandle(handle);
      } else if (model.lastHandle) {
        model.widgetState.removeHandle(model.lastHandle);
        const handles = model.widgetState.getHandleList();
        model.lastHandle = handles[handles.length - 1];
      }
    }
    publicAPI.invokeInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleLeftButtonPress = (e2) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (!manipulator2 || !model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    manipulator2.handleEvent(e2, model._apiSpecificRenderWindow);
    if (model.activeState === model.moveHandle) {
      if (model.widgetState.getHandleList().length === 0) {
        addPoint();
      } else {
        const hoveredHandle = getHoveredHandle();
        if (hoveredHandle && !model.keysDown.Control) {
          model.moveHandle.deactivate();
          model.moveHandle.setVisible(false);
          model.activeState = hoveredHandle;
          hoveredHandle.activate();
          model._isDragging = true;
          model.lastHandle.setVisible(true);
        } else {
          addPoint();
        }
      }
      model.freeHand = publicAPI.getAllowFreehand() && !model._isDragging;
    } else if (model.dragable) {
      model._isDragging = true;
      model._apiSpecificRenderWindow.setCursor("grabbing");
      model._interactor.requestAnimation(publicAPI);
    }
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };
  publicAPI.handleLeftButtonRelease = (e2) => {
    if (model._isDragging) {
      if (!model.hasFocus) {
        model._apiSpecificRenderWindow.setCursor(model.defaultCursor);
        model.widgetState.deactivate();
        model._interactor.cancelAnimation(publicAPI);
        publicAPI.invokeEndInteractionEvent();
      } else {
        model.moveHandle.setOrigin(...model.activeState.getOrigin());
        model.activeState.deactivate();
        model.moveHandle.activate();
        model.activeState = model.moveHandle;
        if (!model.draggedPoint) {
          if (vec3_exports.squaredDistance(model.moveHandle.getOrigin(), model.lastHandle.getOrigin()) < model.moveHandle.getScale1() * model.moveHandle.getScale1() || vec3_exports.squaredDistance(model.moveHandle.getOrigin(), model.firstHandle.getOrigin()) < model.moveHandle.getScale1() * model.moveHandle.getScale1()) {
            model.lastHandle.setVisible(true);
            publicAPI.invokeEndInteractionEvent();
            if (publicAPI.getResetAfterPointPlacement()) {
              publicAPI.reset();
            } else {
              publicAPI.loseFocus();
            }
          }
        }
        model._interactor.render();
      }
    } else if (model.activeState !== model.moveHandle) {
      model.widgetState.deactivate();
    }
    model.freeHand = false;
    model.draggedPoint = false;
    model._isDragging = false;
    return model.hasFocus ? macro.EVENT_ABORT : macro.VOID;
  };
  publicAPI.handleMouseMove = (callData) => {
    var _a, _b;
    const manipulator2 = ((_b = (_a = model.activeState) == null ? void 0 : _a.getManipulator) == null ? void 0 : _b.call(_a)) ?? model.manipulator;
    if (!manipulator2 || !model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    const {
      worldCoords,
      worldDelta
    } = manipulator2.handleEvent(callData, model._apiSpecificRenderWindow);
    const hoveredHandle = getHoveredHandle();
    if (hoveredHandle) {
      model.moveHandle.setVisible(false);
      if (hoveredHandle !== model.firstHandle) {
        model._apiSpecificRenderWindow.setCursor("grabbing");
      }
    } else if (!model._isDragging && model.hasFocus) {
      model.moveHandle.setVisible(true);
      model._apiSpecificRenderWindow.setCursor(model.defaultCursor);
    }
    if (model.lastHandle) {
      model.lastHandle.setVisible(true);
    }
    const isHandleMoving = model._isDragging || model.activeState === model.moveHandle;
    if (worldCoords.length && isHandleMoving) {
      const curOrigin = model.activeState.getOrigin();
      if (curOrigin) {
        model.activeState.setOrigin(add(curOrigin, worldDelta, []));
      } else {
        model.activeState.setOrigin(worldCoords);
      }
      if (model._isDragging) {
        model.draggedPoint = true;
      }
      if (model.freeHand && model.activeState === model.moveHandle) {
        addPoint();
      }
    }
    return model.hasFocus ? macro.EVENT_ABORT : macro.VOID;
  };
  publicAPI.handleKeyDown = (_ref2) => {
    let {
      key
    } = _ref2;
    model.keysDown[key] = true;
    if (!model.hasFocus) {
      return;
    }
    if (key === "Enter") {
      if (model.widgetState.getHandleList().length > 0) {
        publicAPI.invokeEndInteractionEvent();
        if (publicAPI.getResetAfterPointPlacement()) {
          publicAPI.reset();
        } else {
          publicAPI.loseFocus();
        }
      }
    } else if (key === "Escape") {
      publicAPI.reset();
      publicAPI.loseFocus();
      publicAPI.invokeEndInteractionEvent();
    } else if (key === "Delete" || key === "Backspace") {
      if (model.lastHandle) {
        model.widgetState.removeHandle(model.lastHandle);
        const handleList = model.widgetState.getHandleList();
        model.lastHandle = handleList[handleList.length - 1];
      }
    }
  };
  publicAPI.handleKeyUp = (_ref3) => {
    let {
      key
    } = _ref3;
    model.keysDown[key] = false;
  };
  publicAPI.grabFocus = () => {
    if (!model.hasFocus) {
      model.activeState = model.moveHandle;
      model.activeState.activate();
      model.activeState.setVisible(true);
      model._interactor.requestAnimation(publicAPI);
      updateHandlesSize();
    }
    model.hasFocus = true;
  };
  publicAPI.loseFocus = () => {
    if (model.hasFocus) {
      model._interactor.cancelAnimation(publicAPI);
    }
    model.widgetState.deactivate();
    model.moveHandle.deactivate();
    model.moveHandle.setVisible(false);
    model.activeState = null;
    model._interactor.render();
    model.hasFocus = false;
  };
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/SplineWidget/state.js
function generateState11() {
  return vtkStateBuilder.createBuilder().addField({
    name: "splineKind",
    initialValue: splineKind.KOCHANEK_SPLINE
  }).addField({
    name: "splineClosed",
    initialValue: true
  }).addField({
    name: "splineBoundaryCondition",
    initialValue: BoundaryCondition.DEFAULT
  }).addField({
    name: "splineBoundaryConditionValues",
    initialValue: [0, 0, 0]
  }).addField({
    name: "splineTension",
    initialValue: 0
  }).addField({
    name: "splineContinuity",
    initialValue: 0
  }).addField({
    name: "splineBias",
    initialValue: 0
  }).addStateFromMixin({
    labels: ["moveHandle"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "moveHandle",
    initialValues: {
      scale1: 10,
      visible: false
    }
  }).addDynamicMixinState({
    labels: ["handles"],
    mixins: ["origin", "color", "scale1", "visible", "manipulator"],
    name: "handle",
    initialValues: {
      scale1: 10
    }
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/SplineWidget.js
function vtkSplineWidget(publicAPI, model) {
  model.classHierarchy.push("vtkSplineWidget");
  const superClass = {
    ...publicAPI
  };
  model.methodsToLink = ["boundaryCondition", "close", "outputBorder", "fill", "borderColor", "errorBorderColor", "scaleInPixels"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation$1,
          labels: ["handles", "moveHandle"]
        }, {
          builder: vtkSplineContextRepresentation$1,
          labels: ["handles", "moveHandle"]
        }];
    }
  };
  publicAPI.setManipulator = (manipulator2) => {
    superClass.setManipulator(manipulator2);
    model.widgetState.getMoveHandle().setManipulator(manipulator2);
    model.widgetState.getHandleList().forEach((handle) => {
      handle.setManipulator(manipulator2);
    });
  };
  publicAPI.setManipulator(model.manipulator || model.manipulator || vtkPlaneManipulator$1.newInstance({
    useCameraNormal: true
  }));
}
var defaultValues46 = (initialValues) => ({
  // manipulator: null,
  freehandMinDistance: 0.1,
  allowFreehand: true,
  resolution: 32,
  // propagates to SplineContextRepresentation
  defaultCursor: "pointer",
  handleSizeInPixels: 10,
  // propagates to SplineContextRepresentation
  resetAfterPointPlacement: false,
  behavior: widgetBehavior14,
  widgetState: generateState11(),
  ...initialValues
});
function extend264(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues46(initialValues));
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["manipulator", "freehandMinDistance", "allowFreehand", "resolution", "defaultCursor", "handleSizeInPixels", "resetAfterPointPlacement"]);
  vtkSplineWidget(publicAPI, model);
}
var newInstance239 = macro.newInstance(extend264, "vtkSplineWidget");
var vtkSplineWidget$1 = {
  newInstance: newInstance239,
  extend: extend264
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/TransformControlsWidget/constants.js
var ROTATE_HANDLE_PIXEL_SCALE = 240;
var TRANSLATE_HANDLE_RADIUS = 3;
var SCALE_HANDLE_RADIUS = 3;
var SCALE_HANDLE_CUBE_SIDE_LENGTH = 20;
var SCALE_HANDLE_PIXEL_SCALE = 320;
var TransformMode = {
  TRANSLATE: "translate",
  SCALE: "scale",
  ROTATE: "rotate"
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/TransformControlsWidget/behavior.js
function widgetBehavior15(publicAPI, model) {
  let isDragging = false;
  model.rotationManipulator = vtkPlaneManipulator$1.newInstance();
  model.lineManipulator = vtkLineManipulator$1.newInstance();
  const rotateState = {
    startQuat: quat_exports.create(),
    dragStartVec: [0, 0, 0]
  };
  const scaleState = {
    startDistFromOrigin: 0,
    startScale: 1
  };
  const translateState = {
    startPos: 0,
    dragStartCoord: [0, 0, 0]
  };
  publicAPI.getBounds = () => [...vtkBoundingBox.INIT_BOUNDS];
  publicAPI.setDisplayCallback = (callback) => model.representations[0].setDisplayCallback(callback);
  publicAPI.handleLeftButtonPress = (callData) => {
    if (!model.activeState || !model.activeState.getActive() || !model.pickable) {
      return macro.VOID;
    }
    const [type, axis] = model.activeState.getName().split(":");
    const axisIndex = "XYZ".indexOf(axis);
    if (type === "translate") {
      publicAPI.handleTranslateStartEvent(callData, axis, axisIndex);
    } else if (type === "scale") {
      publicAPI.handleScaleStartEvent(callData, axis, axisIndex);
    } else if (type === "rotate") {
      publicAPI.handleRotateStartEvent(callData, axis, axisIndex);
    }
    model._interactor.requestAnimation(publicAPI);
    return macro.EVENT_ABORT;
  };
  publicAPI.handleTranslateStartEvent = (callData, axis, axisIndex) => {
    model.lineManipulator.setHandleOrigin(model.activeState.getOrigin());
    model.lineManipulator.setHandleNormal(model.activeState.getDirection());
    const {
      worldCoords
    } = model.lineManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    if (worldCoords.length) {
      isDragging = true;
      translateState.dragStartCoord = worldCoords;
      translateState.startPos = model.widgetState.getTransform().getTranslation()[axisIndex];
    }
  };
  publicAPI.handleScaleStartEvent = (callData, axis, axisIndex) => {
    model.lineManipulator.setHandleOrigin(model.activeState.getOrigin());
    model.lineManipulator.setHandleNormal(model.activeState.getDirection());
    const {
      worldCoords
    } = model.lineManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    if (worldCoords.length) {
      isDragging = true;
      scaleState.startScale = model.widgetState.getTransform().getScale()[axisIndex];
      scaleState.startDistFromOrigin = vec3_exports.dist(worldCoords, model.activeState.getOrigin()) || 1e-4;
    }
  };
  publicAPI.handleRotateStartEvent = (callData, axis) => {
    model.rotationManipulator.setHandleOrigin(model.activeState.getOrigin());
    model.rotationManipulator.setHandleNormal(model.activeState.getDirection());
    const {
      worldCoords
    } = model.rotationManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    if (worldCoords.length) {
      isDragging = true;
      vec3_exports.sub(rotateState.dragStartVec, worldCoords, model.activeState.getOrigin());
      vec3_exports.normalize(rotateState.dragStartVec, rotateState.dragStartVec);
      rotateState.startQuat = model.widgetState.getTransform().getRotation();
    }
  };
  publicAPI.handleMouseMove = (callData) => {
    if (isDragging && model.pickable) {
      return publicAPI.handleEvent(callData);
    }
    return macro.VOID;
  };
  publicAPI.handleLeftButtonRelease = () => {
    if (isDragging && model.pickable) {
      model._interactor.cancelAnimation(publicAPI);
    }
    isDragging = false;
    model.widgetState.deactivate();
  };
  publicAPI.handleEvent = (callData) => {
    if (model.pickable && model.activeState && model.activeState.getActive()) {
      const [type, axis] = model.activeState.getName().split(":");
      const axisIndex = "XYZ".indexOf(axis);
      if (type === "translate") {
        return publicAPI.handleTranslateEvent(callData, axis, axisIndex);
      }
      if (type === "scale") {
        return publicAPI.handleScaleEvent(callData, axis, axisIndex);
      }
      if (type === "rotate") {
        return publicAPI.handleRotateEvent(callData, axis, axisIndex);
      }
    }
    return macro.VOID;
  };
  publicAPI.handleTranslateEvent = (callData, axis, axisIndex) => {
    model.lineManipulator.setHandleOrigin(model.activeState.getOrigin());
    model.lineManipulator.setHandleNormal(model.activeState.getDirection());
    const {
      worldCoords
    } = model.lineManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    if (worldCoords.length) {
      const positiveDir = [0, 0, 0];
      positiveDir[axisIndex] = 1;
      const toWorldCoords = [0, 0, 0];
      vec3_exports.sub(toWorldCoords, worldCoords, translateState.dragStartCoord);
      const dir = Math.sign(vec3_exports.dot(positiveDir, toWorldCoords));
      const dist = vec3_exports.len(toWorldCoords);
      const delta = dir * dist;
      const translation = model.widgetState.getTransform().getTranslation();
      translation[axisIndex] = translateState.startPos + delta;
      model.widgetState.getTransform().setTranslation(translation);
    }
    return macro.EVENT_ABORT;
  };
  publicAPI.handleScaleEvent = (callData, axis, axisIndex) => {
    model.lineManipulator.setHandleOrigin(model.activeState.getOrigin());
    model.lineManipulator.setHandleNormal(model.activeState.getDirection());
    const {
      worldCoords
    } = model.lineManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    if (worldCoords.length) {
      const dist = vec3_exports.dist(model.activeState.getOrigin(), worldCoords);
      const scale = dist / scaleState.startDistFromOrigin * scaleState.startScale;
      const scales = model.widgetState.getTransform().getScale();
      scales[axisIndex] = scale;
      model.widgetState.getTransform().setScale(scales);
    }
    return macro.EVENT_ABORT;
  };
  publicAPI.handleRotateEvent = (callData) => {
    model.rotationManipulator.setHandleOrigin(model.activeState.getOrigin());
    model.rotationManipulator.setHandleNormal(model.activeState.getDirection());
    const {
      worldCoords
    } = model.rotationManipulator.handleEvent(callData, model._apiSpecificRenderWindow);
    const curPointerVec = [0, 0, 0];
    if (worldCoords.length) {
      vec3_exports.sub(curPointerVec, worldCoords, model.activeState.getOrigin());
      vec3_exports.normalize(curPointerVec, curPointerVec);
      const angle = vec3_exports.angle(rotateState.dragStartVec, curPointerVec);
      const signVec = [0, 0, 0];
      vec3_exports.cross(signVec, curPointerVec, rotateState.dragStartVec);
      vec3_exports.normalize(signVec, signVec);
      const sign = vec3_exports.dot(signVec, model.activeState.getDirection());
      const q = quat_exports.create();
      quat_exports.setAxisAngle(q, model.activeState.getDirection(), -sign * angle);
      quat_exports.mul(q, q, rotateState.startQuat);
      quat_exports.normalize(q, q);
      const direction3 = model.activeState.getDirection();
      model.widgetState.getTransform().setRotation(q);
      model.activeState.setDirection(direction3);
    }
    return macro.EVENT_ABORT;
  };
  model.camera = model._renderer.getActiveCamera();
  model.classHierarchy.push("vtkTransformControlsWidgetProp");
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/TransformControlsWidget/state.js
function stateGenerator2() {
  const transformState = vtkStateBuilder.createBuilder().addField({
    name: "translation",
    initialValue: [0, 0, 0]
  }).addField({
    name: "scale",
    initialValue: [1, 1, 1]
  }).addField({
    name: "rotation",
    initialValue: [0, 0, 0, 1]
  }).build();
  return vtkStateBuilder.createBuilder().addStateFromInstance({
    labels: [],
    name: "transform",
    instance: transformState
  }).addStateFromMixin({
    labels: ["handles", "translateHandles"],
    mixins: ["name", "origin", "color3", "scale3", "orientation", "visible"],
    name: "translateHandleZ",
    initialValues: {
      name: "translate:Z",
      scale3: [1, 1, SCALE_HANDLE_PIXEL_SCALE],
      origin: [0, 0, 0],
      color3: [0, 255, 0],
      // these are fixed to the world axes
      up: [0, 1, 0],
      right: [1, 0, 0],
      direction: [0, 0, 1]
    }
  }).addStateFromMixin({
    labels: ["handles", "translateHandles"],
    mixins: ["name", "origin", "color3", "scale3", "orientation", "visible"],
    name: "translateHandleX",
    initialValues: {
      name: "translate:X",
      scale3: [1, 1, SCALE_HANDLE_PIXEL_SCALE],
      origin: [0, 0, 0],
      color3: [0, 0, 255],
      // these are fixed to the world axes
      up: [0, 1, 0],
      right: [0, 0, -1],
      direction: [1, 0, 0]
    }
  }).addStateFromMixin({
    labels: ["handles", "translateHandles"],
    mixins: ["name", "origin", "color3", "scale3", "orientation", "visible"],
    name: "translateHandleY",
    initialValues: {
      name: "translate:Y",
      scale3: [1, 1, SCALE_HANDLE_PIXEL_SCALE],
      origin: [0, 0, 0],
      color3: [255, 0, 0],
      // these are fixed to the world axes
      up: [0, 0, 1],
      right: [1, 0, 0],
      direction: [0, 1, 0]
    }
  }).addStateFromMixin({
    labels: ["handles", "scaleHandles"],
    mixins: ["name", "origin", "color3", "scale3", "orientation", "visible"],
    name: "scaleHandleZ",
    initialValues: {
      name: "scale:Z",
      scale3: [1, 1, SCALE_HANDLE_PIXEL_SCALE],
      origin: [0, 0, 0],
      color3: [0, 255, 0],
      // these are set via setHandleOrientationsFromQuat
      up: [0, 0, 1],
      right: [0, 1, 0],
      direction: [1, 0, 0]
    }
  }).addStateFromMixin({
    labels: ["handles", "scaleHandles"],
    mixins: ["name", "origin", "color3", "scale3", "orientation", "visible"],
    name: "scaleHandleX",
    initialValues: {
      name: "scale:X",
      scale3: [1, 1, SCALE_HANDLE_PIXEL_SCALE],
      origin: [0, 0, 0],
      color3: [0, 0, 255],
      // these are set via setHandleOrientationsFromQuat
      up: [1, 0, 0],
      right: [0, -1, 0],
      direction: [0, 0, 1]
    }
  }).addStateFromMixin({
    labels: ["handles", "scaleHandles"],
    mixins: ["name", "origin", "color3", "scale3", "orientation", "visible"],
    name: "scaleHandleY",
    initialValues: {
      name: "scale:Y",
      scale3: [1, 1, SCALE_HANDLE_PIXEL_SCALE],
      origin: [0, 0, 0],
      color3: [255, 0, 0],
      // these are set via setHandleOrientationsFromQuat
      up: [0, 1, 0],
      right: [1, 0, 0],
      direction: [0, 0, 1]
    }
  }).addStateFromMixin({
    labels: ["handles", "rotateHandles"],
    mixins: ["name", "origin", "color3", "scale1", "orientation", "visible"],
    name: "rotateHandleZ",
    initialValues: {
      name: "rotate:Z",
      scale1: ROTATE_HANDLE_PIXEL_SCALE,
      origin: [0, 0, 0],
      color3: [0, 255, 0],
      // these are set via setHandleOrientationsFromQuat
      up: [0, 1, 0],
      right: [1, 0, 0],
      direction: [0, 0, 1]
    }
  }).addStateFromMixin({
    labels: ["handles", "rotateHandles"],
    mixins: ["name", "origin", "color3", "scale1", "orientation", "visible"],
    name: "rotateHandleX",
    initialValues: {
      name: "rotate:X",
      scale1: ROTATE_HANDLE_PIXEL_SCALE,
      origin: [0, 0, 0],
      color3: [0, 0, 255],
      // these are set via setHandleOrientationsFromQuat
      up: [0, 1, 0],
      right: [0, 0, -1],
      direction: [1, 0, 0]
    }
  }).addStateFromMixin({
    labels: ["handles", "rotateHandles"],
    mixins: ["name", "origin", "color3", "scale1", "orientation", "visible"],
    name: "rotateHandleY",
    initialValues: {
      name: "rotate:Y",
      scale1: ROTATE_HANDLE_PIXEL_SCALE,
      origin: [0, 0, 0],
      color3: [255, 0, 0],
      // these are set via setHandleOrientationsFromQuat
      up: [0, 0, 1],
      right: [1, 0, 0],
      direction: [0, 1, 0]
    }
  }).build();
}

// node_modules/@kitware/vtk.js/Widgets/Widgets3D/TransformControlsWidget.js
function updateHandleTransforms(widgetState) {
  const transformState = widgetState.getTransform();
  const sx = widgetState.getScaleHandleX();
  const sy = widgetState.getScaleHandleY();
  const sz = widgetState.getScaleHandleZ();
  const hx = widgetState.getRotateHandleX();
  const hy = widgetState.getRotateHandleY();
  const hz = widgetState.getRotateHandleZ();
  widgetState.getStatesWithLabel("handles").forEach((state) => {
    state.setOrigin(transformState.getTranslation());
  });
  const m3 = mat3_exports.create();
  mat3_exports.fromQuat(m3, transformState.getRotation());
  [sx, hx].forEach((state) => {
    state.setDirection(m3.slice(0, 3));
    state.setUp(m3.slice(3, 6).map((c2) => -c2));
    state.setRight(m3.slice(6, 9));
  });
  [sy, hy].forEach((state) => {
    state.setDirection(m3.slice(3, 6));
    state.setUp(m3.slice(6, 9));
    state.setRight(m3.slice(0, 3));
  });
  [sz, hz].forEach((state) => {
    state.setDirection(m3.slice(6, 9));
    state.setUp(m3.slice(3, 6));
    state.setRight(m3.slice(0, 3));
  });
}
function vtkTransformControlsWidget(publicAPI, model) {
  model.classHierarchy.push("vtkTransformControlsWidget");
  model.behavior = widgetBehavior15;
  model.widgetState = stateGenerator2();
  model.methodsToLink = ["scaleInPixels", "activeScaleFactor", "useActiveColor", "activeColor"];
  publicAPI.getRepresentationsForViewType = (viewType) => {
    switch (viewType) {
      default:
        return [{
          builder: vtkTranslateTransformHandleRepresentation$1,
          labels: ["translateHandles"],
          initialValues: {
            radius: TRANSLATE_HANDLE_RADIUS,
            glyphResolution: 12,
            coneSource: {
              radius: 8,
              height: 0.05,
              direction: [0, 1, 0]
            }
          }
        }, {
          builder: vtkScaleTransformHandleRepresentation$1,
          labels: ["scaleHandles"],
          initialValues: {
            radius: SCALE_HANDLE_RADIUS,
            glyphResolution: 12,
            cubeSource: {
              xLength: SCALE_HANDLE_CUBE_SIDE_LENGTH,
              yLength: SCALE_HANDLE_CUBE_SIDE_LENGTH / SCALE_HANDLE_PIXEL_SCALE,
              zLength: SCALE_HANDLE_CUBE_SIDE_LENGTH
            }
          }
        }, {
          builder: vtkRotateTransformHandleRepresentation$1,
          labels: ["rotateHandles"]
        }];
    }
  };
  publicAPI.updateHandleVisibility = () => {
    model.widgetState.getStatesWithLabel("translateHandles").forEach((state) => {
      state.setVisible(model.mode === "translate");
    });
    model.widgetState.getStatesWithLabel("scaleHandles").forEach((state) => {
      state.setVisible(model.mode === "scale");
    });
    model.widgetState.getStatesWithLabel("rotateHandles").forEach((state) => {
      state.setVisible(model.mode === "rotate");
    });
  };
  model._onModeChanged = () => {
    publicAPI.updateHandleVisibility();
  };
  const transformSubscription = model.widgetState.getTransform().onModified((state) => {
    updateHandleTransforms(model.widgetState);
  });
  publicAPI.delete = macro.chain(publicAPI.delete, () => {
    transformSubscription.unsubscribe();
  });
  updateHandleTransforms(model.widgetState);
  publicAPI.updateHandleVisibility();
}
var DEFAULT_VALUES216 = {
  mode: TransformMode.TRANSLATE
};
function extend265(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES216, initialValues);
  vtkAbstractWidgetFactory$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["mode"]);
  macro.get(publicAPI, model, ["lineManipulator", "rotateManipulator"]);
  vtkTransformControlsWidget(publicAPI, model);
}
var newInstance240 = macro.newInstance(extend265, "vtkTransformControlsWidget");
var vtkTransformControlsWidget$1 = {
  newInstance: newInstance240,
  extend: extend265,
  TransformMode
};

// node_modules/@kitware/vtk.js/Widgets/Widgets3D.js
var Widgets3D = {
  vtkAngleWidget: vtkAngleWidget$1,
  vtkEllipseWidget: vtkEllipseWidget$1,
  vtkImageCroppingWidget: vtkImageCroppingWidget$1,
  vtkImplicitPlaneWidget: vtkImplicitPlaneWidget$1,
  vtkInteractiveOrientationWidget: vtkInteractiveOrientationWidget$1,
  vtkLabelWidget: vtkLabelWidget$1,
  vtkLineWidget: vtkLineWidget$1,
  vtkPaintWidget: vtkPaintWidget$1,
  vtkPolyLineWidget: vtkPolyLineWidget$1,
  vtkRectangleWidget: vtkRectangleWidget$1,
  vtkResliceCursorWidget: vtkResliceCursorWidget$1,
  vtkShapeWidget: vtkShapeWidget$1,
  vtkSphereWidget: vtkSphereWidget$1,
  vtkSplineWidget: vtkSplineWidget$1,
  vtkTransformControlsWidget: vtkTransformControlsWidget$1
};

// node_modules/@kitware/vtk.js/Widgets/index.js
var Widgets2 = {
  Core: Core7,
  Manipulators: Manipulators2,
  Representations: Representations2,
  Widgets3D
};

// node_modules/@kitware/vtk.js/index.js
vtk.Common = Common;
vtk.Filters = Filters;
vtk.Imaging = Imaging;
vtk.Interaction = Interaction;
vtk.IO = IO;
vtk.Proxy = VTKProxy;
vtk.Rendering = Rendering;
vtk.Widgets = Widgets2;
vtk.mtime = macro.getCurrentGlobalMTime;
vtk.macro = macro;
window.vtk = vtk;
//# sourceMappingURL=@kitware_vtk__js.js.map
