import {
  Filter,
  HalfFloat,
  registerOverride,
  registerOverride2,
  vtkHelper,
  vtkOpenGLTexture$1,
  vtkShaderProgram$1,
  vtkVertexArrayObject,
  vtkViewNode$1,
  vtkViewNodeFactory,
  vtkWebGPUBuffer$1,
  vtkWebGPUBufferManager$1,
  vtkWebGPUFullScreenQuad$1,
  vtkWebGPUSampler$1,
  vtkWebGPUShaderCache$1,
  vtkWebGPUSimpleMapper$1,
  vtkWebGPUStorageBuffer$1,
  vtkWebGPUTexture$1,
  vtkWebGPUTextureView$1,
  vtkWebGPUTypes,
  vtkWebGPUUniformBuffer$1,
  vtkWebGPUViewNodeFactory$1
} from "./chunk-IC7NYLFI.js";
import {
  Constants2 as Constants
} from "./chunk-2MLCEZ25.js";
import {
  vtkProperty$1
} from "./chunk-KHTNCV3C.js";
import {
  vtkPolyData$1
} from "./chunk-3WRJRU3H.js";
import {
  VtkDataTypes,
  vtkDataArray$1,
  vtkDataSet$1
} from "./chunk-QTSXRC5W.js";
import {
  add,
  areBoundsInitialized,
  createUninitializedBounds,
  cross,
  degreesFromRadians,
  distance2BetweenPoints,
  dot,
  get,
  getArray,
  macro,
  macro$1,
  mat4_exports,
  moveToProtected,
  newInstance,
  normalize,
  normalize4D,
  obj,
  quat_exports,
  radiansFromDegrees,
  setGet,
  setGetArray,
  uninitializeBounds,
  vec3_exports,
  vec4_exports,
  vtkBoundingBox,
  vtkErrorMacro as vtkErrorMacro2
} from "./chunk-UJ7GCCMN.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS({
  "node_modules/spark-md5/spark-md5.js"(exports, module) {
    (function(factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        var glob;
        try {
          glob = window;
        } catch (e) {
          glob = self;
        }
        glob.SparkMD5 = factory();
      }
    })(function(undefined2) {
      "use strict";
      var add32 = function(a, b) {
        return a + b & 4294967295;
      }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32(a << s | a >>> 32 - s, b);
      }
      function md5cycle(x, k) {
        var a = x[0], b = x[1], c = x[2], d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      }
      function md5blk(s) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
      }
      function md51(s) {
        var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a) {
        var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }
        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= a[i] << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n) {
        var s = "", j;
        for (j = 0; j < 4; j += 1) {
          s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
        }
        return s;
      }
      function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
          x[i] = rhex(x[i]);
        }
        return x.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
        add32 = function(x, y) {
          var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
      }
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length, 0);
            }
            return Math.min(val, length);
          }
          ArrayBuffer.prototype.slice = function(from, to) {
            var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
            if (to !== undefined2) {
              end = clamp(to, length);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
          str = unescape(encodeURIComponent(str));
        }
        return str;
      }
      function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;
        for (i = 0; i < length; i += 1) {
          arr[i] = str.charCodeAt(i);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes = [], length = hex2.length, x;
        for (x = 0; x < length - 1; x += 2) {
          bytes.push(parseInt(hex2.substr(x, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes);
      }
      function SparkMD5() {
        this.reset();
      }
      SparkMD5.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this;
      };
      SparkMD5.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length, i;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }
        this._buff = this._buff.substring(i - 64);
        return this;
      };
      SparkMD5.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD5.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD5.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD5.prototype._finish = function(tail, length) {
        var i = length, tmp, lo, hi;
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(this._hash, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
      };
      SparkMD5.hash = function(str, raw) {
        return SparkMD5.hashBinary(toUtf8(str), raw);
      };
      SparkMD5.hashBinary = function(content, raw) {
        var hash = md51(content), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD5.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD5.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;
        this._length += arr.byteLength;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }
        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff[i] << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD5.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD5.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD5.prototype.setState.call(this, state);
      };
      SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
      SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
      SparkMD5.ArrayBuffer.hash = function(arr, raw) {
        var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD5;
    });
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var {
  vtkDebugMacro
} = macro;
function vtkCamera(publicAPI, model) {
  model.classHierarchy.push("vtkCamera");
  const origin = new Float64Array(3);
  const dopbasis = new Float64Array([0, 0, -1]);
  const upbasis = new Float64Array([0, 1, 0]);
  const tmpMatrix = mat4_exports.identity(new Float64Array(16));
  const tmpMatrix2 = mat4_exports.identity(new Float64Array(16));
  const tmpvec1 = new Float64Array(3);
  const tmpvec2 = new Float64Array(3);
  const tmpvec3 = new Float64Array(3);
  const rotateMatrix = mat4_exports.identity(new Float64Array(16));
  const trans = mat4_exports.identity(new Float64Array(16));
  const newPosition = new Float64Array(3);
  const newFocalPoint = new Float64Array(3);
  function computeViewPlaneNormal() {
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = () => {
    const vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = (x, y, z) => {
    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
      return;
    }
    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = (x, y, z) => {
    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = (d) => {
    if (model.distance === d) {
      return;
    }
    model.distance = d;
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro("Distance is set to minimum.");
    }
    const vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };
  publicAPI.computeDistance = () => {
    const dx = model.focalPoint[0] - model.position[0];
    const dy = model.focalPoint[1] - model.position[1];
    const dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro("Distance is set to minimum.");
      const vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.dolly = (amount) => {
    if (amount <= 0) {
      return;
    }
    const d = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
  };
  publicAPI.roll = (angle) => {
    const eye = model.position;
    const at = model.focalPoint;
    const up = model.viewUp;
    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0]);
    mat4_exports.identity(rotateMatrix);
    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    mat4_exports.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);
    vec4_exports.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = (angle) => {
    const fp = model.focalPoint;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = (angle) => {
    const position = model.position;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = (angle) => {
    const fp = model.focalPoint;
    const vt = publicAPI.getViewMatrix();
    const axis = [-vt[0], -vt[1], -vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), axis);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = (angle) => {
    const position = model.position;
    const vt = publicAPI.getViewMatrix();
    const axis = [vt[0], vt[1], vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), axis);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(...newFocalPoint);
  };
  publicAPI.zoom = (factor) => {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = (x, y, z) => {
    const offset = [x, y, z];
    add(model.position, offset, model.position);
    add(model.focalPoint, offset, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = (transformMat4) => {
    const vuOld = [...model.viewUp, 1];
    const posNew = [];
    const fpNew = [];
    const vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    vec4_exports.transformMat4(posNew, [...model.position, 1], transformMat4);
    vec4_exports.transformMat4(fpNew, [...model.focalPoint, 1], transformMat4);
    vec4_exports.transformMat4(vuNew, vuOld, transformMat4);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition(...posNew.slice(0, 3));
    publicAPI.setFocalPoint(...fpNew.slice(0, 3));
    publicAPI.setViewUp(...vuNew.slice(0, 3));
  };
  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];
  publicAPI.setThickness = (thickness) => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
  };
  publicAPI.setThicknessFromFocalPoint = (thickness) => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };
  publicAPI.setRoll = (angle) => {
  };
  publicAPI.getRoll = () => {
  };
  publicAPI.setObliqueAngles = (alpha, beta) => {
  };
  publicAPI.getOrientation = () => {
  };
  publicAPI.getOrientationWXYZ = () => {
  };
  publicAPI.getFrustumPlanes = function() {
    let aspect = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    let planes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Float64Array(24);
    const normals = [
      // Left
      [1, 0, 0, 1],
      // Right
      [-1, 0, 0, 1],
      // Bottom
      [0, 1, 0, 1],
      // Top
      [0, -1, 0, 1],
      // Near
      [0, 0, 1, 1],
      // Far
      [0, 0, -1, 1]
    ];
    const matrix = publicAPI.getCompositeProjectionMatrix(aspect, -1, 1);
    for (let i = 0; i < 6; i++) {
      vec4_exports.transformMat4(normals[i], normals[i], matrix);
      normalize4D(normals[i]);
      planes[4 * i + 0] = normals[i][0];
      planes[4 * i + 1] = normals[i][1];
      planes[4 * i + 2] = normals[i][2];
      planes[4 * i + 3] = normals[i][3];
    }
    return planes;
  };
  publicAPI.getCameraLightTransformMatrix = (matrix) => {
    mat4_exports.copy(matrix, model.cameraLightTransform);
    return matrix;
  };
  publicAPI.computeCameraLightTransform = () => {
    mat4_exports.copy(tmpMatrix, publicAPI.getViewMatrix());
    mat4_exports.invert(tmpMatrix, tmpMatrix);
    mat4_exports.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
    mat4_exports.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);
    mat4_exports.identity(model.cameraLightTransform);
    mat4_exports.translate(model.cameraLightTransform, tmpMatrix, [0, 0, -1]);
  };
  publicAPI.deepCopy = (sourceCamera) => {
  };
  publicAPI.physicalOrientationToWorldDirection = (ori) => {
    const oriq = quat_exports.fromValues(ori[0], ori[1], ori[2], ori[3]);
    const coriq = quat_exports.create();
    const qdir = quat_exports.fromValues(0, 0, 1, 0);
    quat_exports.conjugate(coriq, oriq);
    quat_exports.multiply(qdir, oriq, qdir);
    quat_exports.multiply(qdir, qdir, coriq);
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = (result) => {
    publicAPI.getWorldToPhysicalMatrix(result);
    mat4_exports.invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = (result) => {
    mat4_exports.identity(result);
    const physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    mat4_exports.transpose(result, result);
    vec3_exports.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    mat4_exports.scale(result, result, tmpvec1);
    mat4_exports.translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = (vmat) => {
    mat4_exports.invert(tmpMatrix, vmat);
    vec3_exports.transformMat4(tmpvec1, origin, tmpMatrix);
    publicAPI.computeDistance();
    const oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);
    vec3_exports.transformMat4(tmpvec2, dopbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec2, tmpvec2, tmpvec1);
    vec3_exports.normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    vec3_exports.transformMat4(tmpvec3, upbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec3, tmpvec3, tmpvec1);
    vec3_exports.normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };
  publicAPI.computeViewParametersFromPhysicalMatrix = (mat) => {
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);
    mat4_exports.multiply(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setModelTransformMatrix = (mat) => {
    model.modelTransformMatrix = mat;
  };
  publicAPI.getModelTransformMatrix = () => model.modelTransformMatrix;
  publicAPI.setViewMatrix = (mat) => {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      mat4_exports.copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      mat4_exports.transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = () => {
    if (model.viewMatrix) {
      if (model.modelTransformMatrix) {
        mat4_exports.multiply(tmpMatrix, model.viewMatrix, model.modelTransformMatrix);
        return tmpMatrix;
      }
      return model.viewMatrix;
    }
    mat4_exports.lookAt(
      tmpMatrix,
      model.position,
      // eye
      model.focalPoint,
      // at
      model.viewUp
      // up
    );
    mat4_exports.transpose(tmpMatrix, tmpMatrix);
    const result = new Float64Array(16);
    if (model.modelTransformMatrix) {
      mat4_exports.multiply(result, tmpMatrix, model.modelTransformMatrix);
    } else {
      mat4_exports.copy(result, tmpMatrix);
    }
    return result;
  };
  publicAPI.setProjectionMatrix = (mat) => {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = new Float64Array(16);
    mat4_exports.identity(result);
    if (model.projectionMatrix) {
      const scale = 1 / model.physicalScale;
      vec3_exports.set(tmpvec1, scale, scale, scale);
      mat4_exports.copy(result, model.projectionMatrix);
      mat4_exports.scale(result, result, tmpvec1);
      mat4_exports.transpose(result, result);
      return result;
    }
    mat4_exports.identity(tmpMatrix);
    const cWidth = model.clippingRange[1] - model.clippingRange[0];
    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2, model.clippingRange[0] + (farz + 1) * cWidth / 2];
    if (model.parallelProjection) {
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      mat4_exports.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      mat4_exports.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = model.clippingRange[0] * tmp;
        height = model.clippingRange[0] * tmp / aspect;
      } else {
        width = model.clippingRange[0] * tmp * aspect;
        height = model.clippingRange[0] * tmp;
      }
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      const znear = cRange[0];
      const zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (xmax - xmin);
      tmpMatrix[5] = 2 * znear / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    mat4_exports.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
    const vMat = publicAPI.getViewMatrix();
    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    mat4_exports.multiply(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = (x, y, z) => {
    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
      return;
    }
    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;
    const vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {
    const physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    const rotmat = mat4_exports.identity(new Float64Array(16));
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    const vup = new Float64Array(model.physicalViewNorth);
    vec3_exports.transformMat4(dop, dop, rotmat);
    vec3_exports.transformMat4(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {
    const quatMat = mat4_exports.identity(new Float64Array(16));
    if (degrees !== 0 && (x !== 0 || y !== 0 || z !== 0)) {
      const angle = radiansFromDegrees(degrees);
      const q = quat_exports.create();
      quat_exports.setAxisAngle(q, [x, y, z], angle);
      mat4_exports.fromQuat(quatMat, q);
    }
    const newdop = new Float64Array(3);
    vec3_exports.transformMat4(newdop, [0, 0, -1], quatMat);
    const newvup = new Float64Array(3);
    vec3_exports.transformMat4(newvup, [0, 1, 0], quatMat);
    publicAPI.setDirectionOfProjection(...newdop);
    publicAPI.setViewUp(...newvup);
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = (bounds) => {
    let vn = null;
    let position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    const a = -vn[0];
    const b = -vn[1];
    const c = -vn[2];
    const d = -(a * position[0] + b * position[1] + c * position[2]);
    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];
    for (let k = 0; k < 2; k++) {
      for (let j = 0; j < 2; j++) {
        for (let i = 0; i < 2; i++) {
          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist < range[0] ? dist : range[0];
          range[1] = dist > range[1] ? dist : range[1];
        }
      }
    }
    return range;
  };
}
var DEFAULT_VALUES = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,
  modelTransformMatrix: null,
  cameraLightTransform: mat4_exports.create(),
  // used for world to physical transformations
  physicalTranslation: [0, 0, 0],
  physicalScale: 1,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1]
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["distance"]);
  macro.setGet(publicAPI, model, ["parallelProjection", "useHorizontalViewAngle", "viewAngle", "parallelScale", "useOffAxisProjection", "freezeFocalPoint", "physicalScale"]);
  macro.getArray(publicAPI, model, ["directionOfProjection", "viewPlaneNormal", "position", "focalPoint"]);
  macro.setGetArray(publicAPI, model, ["clippingRange", "windowCenter"], 2);
  macro.setGetArray(publicAPI, model, ["viewUp", "screenBottomLeft", "screenBottomRight", "screenTopRight", "physicalTranslation", "physicalViewUp", "physicalViewNorth"], 3);
  vtkCamera(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkCamera");
var vtkCamera$1 = {
  newInstance: newInstance2,
  extend
};

// node_modules/@kitware/vtk.js/Rendering/Core/Light.js
var LIGHT_TYPES = ["HeadLight", "CameraLight", "SceneLight"];
function vtkLight(publicAPI, model) {
  model.classHierarchy.push("vtkLight");
  const tmpVec = new Float64Array(3);
  publicAPI.getTransformedPosition = () => {
    if (model.transformMatrix) {
      vec3_exports.transformMat4(tmpVec, model.position, model.transformMatrix);
    } else {
      vec3_exports.set(tmpVec, model.position[0], model.position[1], model.position[2]);
    }
    return tmpVec;
  };
  publicAPI.getTransformedFocalPoint = () => {
    if (model.transformMatrix) {
      vec3_exports.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);
    } else {
      vec3_exports.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
    }
    return tmpVec;
  };
  publicAPI.getDirection = () => {
    if (model.directionMTime < model.mtime) {
      vec3_exports.sub(model.direction, model.focalPoint, model.position);
      normalize(model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };
  publicAPI.setDirection = (directionVector) => {
    const newFocalPoint = new Float64Array(3);
    vec3_exports.sub(newFocalPoint, model.position, directionVector);
    model.focalPoint = newFocalPoint;
  };
  publicAPI.setDirectionAngle = (elevation, azimuth) => {
    const elevationRadians = radiansFromDegrees(elevation);
    const azimuthRadians = radiansFromDegrees(azimuth);
    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };
  publicAPI.setLightTypeToHeadLight = () => {
    publicAPI.setLightType("HeadLight");
  };
  publicAPI.setLightTypeToCameraLight = () => {
    publicAPI.setLightType("CameraLight");
  };
  publicAPI.setLightTypeToSceneLight = () => {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType("SceneLight");
  };
  publicAPI.lightTypeIsHeadLight = () => model.lightType === "HeadLight";
  publicAPI.lightTypeIsSceneLight = () => model.lightType === "SceneLight";
  publicAPI.lightTypeIsCameraLight = () => model.lightType === "CameraLight";
}
var DEFAULT_VALUES2 = {
  switch: true,
  intensity: 1,
  color: [1, 1, 1],
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  positional: false,
  exponent: 1,
  coneAngle: 30,
  coneFalloff: 5,
  attenuationValues: [1, 0, 0],
  transformMatrix: null,
  lightType: "SceneLight",
  shadowAttenuation: 1,
  direction: [0, 0, 0],
  directionMTime: 0
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["intensity", "switch", "positional", "exponent", "coneAngle", "coneFalloff", "transformMatrix", "lightType", "shadowAttenuation", "attenuationValues"]);
  macro.setGetArray(publicAPI, model, ["color", "position", "focalPoint", "attenuationValues"], 3);
  vtkLight(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkLight");
var vtkLight$1 = {
  newInstance: newInstance3,
  extend: extend2,
  LIGHT_TYPES
};

// node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js
var {
  vtkErrorMacro: vtkErrorMacro3
} = macro;
function notImplemented(method) {
  return () => vtkErrorMacro3(`vtkViewport::${method} - NOT IMPLEMENTED`);
}
function vtkViewport(publicAPI, model) {
  model.classHierarchy.push("vtkViewport");
  publicAPI.getViewProps = () => model.props;
  publicAPI.hasViewProp = (prop) => model.props.includes(prop);
  publicAPI.addViewProp = (prop) => {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props.push(prop);
    }
  };
  publicAPI.removeViewProp = (prop) => {
    const newPropList = model.props.filter((item) => item !== prop);
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };
  publicAPI.removeAllViewProps = () => {
    model.props = [];
  };
  function gatherProps(prop) {
    let allProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    allProps.push(prop);
    const children = prop.getNestedProps();
    if (children && children.length) {
      for (let i = 0; i < children.length; i++) {
        gatherProps(children[i], allProps);
      }
    }
    return allProps;
  }
  publicAPI.getViewPropsWithNestedProps = () => {
    let allPropsArray = [];
    model.actors2D = [];
    for (let i = 0; i < model.props.length; i++) {
      const isActor2D = model.props[i].getActors2D();
      if (isActor2D && (!Array.isArray(isActor2D) || isActor2D.length > 0)) {
        model.actors2D = model.actors2D.concat(isActor2D);
      } else {
        gatherProps(model.props[i], allPropsArray);
      }
    }
    model.actors2D.sort((a, b) => a.getLayerNumber() - b.getLayerNumber());
    allPropsArray = allPropsArray.concat(model.actors2D);
    return allPropsArray;
  };
  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = (prop) => {
    publicAPI.removeViewProp(prop);
  };
  publicAPI.getActors2D = () => {
    model.actors2D = [];
    model.props.forEach((prop) => {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };
  publicAPI.displayToView = () => vtkErrorMacro3("call displayToView on your view instead");
  publicAPI.viewToDisplay = () => vtkErrorMacro3("callviewtodisplay on your view instead");
  publicAPI.getSize = () => vtkErrorMacro3("call getSize on your View instead");
  publicAPI.normalizedDisplayToProjection = (x, y, z) => {
    const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {
    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [(x - model.viewport[0]) / scale[0], (y - model.viewport[1]) / scale[1], z];
  };
  publicAPI.normalizedViewportToProjection = (x, y, z) => [x * 2 - 1, y * 2 - 1, z * 2 - 1];
  publicAPI.projectionToNormalizedDisplay = (x, y, z) => {
    const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {
    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [x * scale[0] + model.viewport[0], y * scale[1] + model.viewport[1], z];
  };
  publicAPI.projectionToNormalizedViewport = (x, y, z) => [(x + 1) * 0.5, (y + 1) * 0.5, (z + 1) * 0.5];
  publicAPI.PickPropFrom = notImplemented("PickPropFrom");
}
var DEFAULT_VALUES3 = {
  // _vtkWindow: null,
  background: [0, 0, 0],
  background2: [0.2, 0.2, 0.2],
  gradientBackground: false,
  viewport: [0, 0, 1, 1],
  aspect: [1, 1],
  pixelAspect: [1, 1],
  props: [],
  actors2D: []
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  macro.setGetArray(publicAPI, model, ["viewport"], 4);
  macro.setGetArray(publicAPI, model, ["background", "background2"], 3);
  vtkViewport(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkViewport");
var vtkViewport$1 = {
  newInstance: newInstance4,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro2,
  vtkErrorMacro: vtkErrorMacro4,
  vtkWarningMacro
} = macro$1;
function notImplemented2(method) {
  return () => vtkErrorMacro4(`vtkRenderer::${method} - NOT IMPLEMENTED`);
}
function vtkRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkRenderer");
  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: "ComputeVisiblePropBoundsEvent",
    renderer: publicAPI
  };
  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: "ResetCameraClippingRangeEvent",
    renderer: publicAPI
  };
  const RESET_CAMERA_EVENT = {
    type: "ResetCameraEvent",
    renderer: publicAPI
  };
  publicAPI.updateCamera = () => {
    if (!model.activeCamera) {
      vtkDebugMacro2("No cameras are on, creating one.");
      publicAPI.getActiveCameraAndResetIfCreated();
    }
    model.activeCamera.render(publicAPI);
    return true;
  };
  publicAPI.updateLightsGeometryToFollowCamera = () => {
    const camera = publicAPI.getActiveCameraAndResetIfCreated();
    model.lights.forEach((light) => {
      if (light.lightTypeIsSceneLight()) ;
      else if (light.lightTypeIsHeadLight()) {
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else if (light.lightTypeIsCameraLight()) {
        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4_exports.create()));
      } else {
        vtkErrorMacro4("light has unknown light type", light.get());
      }
    });
  };
  publicAPI.updateLightGeometry = () => {
    if (model.lightFollowCamera) {
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };
  publicAPI.allocateTime = notImplemented2("allocateTime");
  publicAPI.updateGeometry = notImplemented2("updateGeometry");
  publicAPI.getVTKWindow = () => model._renderWindow;
  publicAPI.setLayer = (layer) => {
    vtkDebugMacro2(publicAPI.getClassName(), publicAPI, "setting Layer to ", layer);
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };
  publicAPI.setActiveCamera = (camera) => {
    if (model.activeCamera === camera) {
      return false;
    }
    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({
      type: "ActiveCameraEvent",
      camera
    });
    return true;
  };
  publicAPI.makeCamera = () => {
    const camera = vtkCamera$1.newInstance();
    publicAPI.invokeEvent({
      type: "CreateCameraEvent",
      camera
    });
    return camera;
  };
  publicAPI.getActiveCamera = () => {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActiveCameraAndResetIfCreated = () => {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActors = () => {
    model.actors = [];
    model.props.forEach((prop) => {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = (actor) => {
    model.actors = model.actors.filter((a) => a !== actor);
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = () => {
    const actors = publicAPI.getActors();
    actors.forEach((actor) => {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };
  publicAPI.getVolumes = () => {
    model.volumes = [];
    model.props.forEach((prop) => {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = (volume) => {
    model.volumes = model.volumes.filter((v) => v !== volume);
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = () => {
    const volumes = publicAPI.getVolumes();
    volumes.forEach((volume) => {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };
  publicAPI.hasLight = (light) => model.lights.includes(light);
  publicAPI.addLight = (light) => {
    if (light && !publicAPI.hasLight(light)) {
      model.lights.push(light);
      publicAPI.modified();
    }
  };
  publicAPI.removeLight = (light) => {
    model.lights = model.lights.filter((l) => l !== light);
    publicAPI.modified();
  };
  publicAPI.removeAllLights = () => {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = (lights) => {
    model.lights = lights;
    publicAPI.modified();
  };
  publicAPI.makeLight = vtkLight$1.newInstance;
  publicAPI.createLight = () => {
    if (!model.automaticLightCreation) {
      return;
    }
    if (model._createdLight) {
      publicAPI.removeLight(model._createdLight);
      model._createdLight.delete();
      model._createdLight = null;
    }
    model._createdLight = publicAPI.makeLight();
    publicAPI.addLight(model._createdLight);
    model._createdLight.setLightTypeToHeadLight();
    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
  };
  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {
    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {
    let vpd = publicAPI.worldToView(x, y, z);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.viewToWorld = (x, y, z) => {
    if (model.activeCamera === null) {
      vtkErrorMacro4("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getViewMatrix();
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.projectionToView = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro4("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.worldToView = (x, y, z) => {
    if (model.activeCamera === null) {
      vtkErrorMacro4("WorldToView: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getViewMatrix();
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.viewToProjection = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro4("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.computeVisiblePropBounds = () => {
    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
    let nothingVisible = true;
    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);
    for (let index = 0; index < model.props.length; ++index) {
      const prop = model.props[index];
      if (prop.getVisibility() && prop.getUseBounds()) {
        const bounds = prop.getBounds();
        if (bounds && areBoundsInitialized(bounds)) {
          nothingVisible = false;
          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }
    if (nothingVisible) {
      uninitializeBounds(model.allBounds);
      vtkDebugMacro2("Can't compute bounds, no 3D props are visible");
    }
    return model.allBounds;
  };
  publicAPI.resetCamera = function() {
    let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    const center = [0, 0, 0];
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro2("Cannot reset camera!");
      return false;
    }
    let vn = null;
    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      vtkErrorMacro4("Trying to reset non-existent camera");
      return false;
    }
    model.activeCamera.setViewAngle(30);
    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2;
    let w1 = boundsToUse[1] - boundsToUse[0];
    let w2 = boundsToUse[3] - boundsToUse[2];
    let w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    let radius = w1 + w2 + w3;
    radius = radius === 0 ? 1 : radius;
    radius = Math.sqrt(radius) * 0.5;
    const angle = radiansFromDegrees(model.activeCamera.getViewAngle());
    const parallelScale = radius;
    const distance = radius / Math.sin(angle * 0.5);
    const vup = model.activeCamera.getViewUp();
    if (Math.abs(dot(vup, vn)) > 0.999) {
      vtkWarningMacro("Resetting view-up since view plane normal is parallel");
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);
    publicAPI.resetCameraClippingRange(boundsToUse);
    model.activeCamera.setParallelScale(parallelScale);
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);
    return true;
  };
  publicAPI.resetCameraClippingRange = function() {
    let bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro2("Cannot reset camera clipping range!");
      return false;
    }
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      vtkErrorMacro4("Trying to reset clipping range of non-existent camera");
      return false;
    }
    const range = model.activeCamera.computeClippingRange(boundsToUse);
    let minGap = 0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.2 * model.activeCamera.getParallelScale();
    } else {
      const angle = radiansFromDegrees(model.activeCamera.getViewAngle());
      minGap = 0.2 * Math.tan(angle / 2) * range[1];
    }
    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2;
      range[0] -= minGap / 2;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };
  publicAPI.setRenderWindow = (renderWindow) => {
    if (renderWindow !== model._renderWindow) {
      model._vtkWindow = renderWindow;
      model._renderWindow = renderWindow;
    }
  };
  publicAPI.visibleActorCount = () => model.props.filter((prop) => prop.getVisibility()).length;
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m2 > m1) {
      m1 = m2;
    }
    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;
    if (m3 > m1) {
      m1 = m3;
    }
    return m1;
  };
  publicAPI.getTransparent = () => !!model.preserveColorBuffer;
  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
}
var DEFAULT_VALUES4 = {
  pickedProp: null,
  activeCamera: null,
  allBounds: [],
  ambient: [1, 1, 1],
  allocatedRenderTime: 100,
  timeFactor: 1,
  automaticLightCreation: true,
  twoSidedLighting: true,
  lastRenderTimeInSeconds: -1,
  renderWindow: null,
  lights: [],
  actors: [],
  volumes: [],
  lightFollowCamera: true,
  numberOfPropsRendered: 0,
  propArray: null,
  pathArray: null,
  layer: 0,
  preserveColorBuffer: false,
  preserveDepthBuffer: false,
  computeVisiblePropBounds: createUninitializedBounds(),
  interactive: true,
  nearClippingPlaneTolerance: 0,
  clippingRangeExpansion: 0.05,
  erase: true,
  draw: true,
  useShadows: false,
  useDepthPeeling: false,
  occlusionRatio: 0,
  maximumNumberOfPeels: 4,
  selector: null,
  delegate: null,
  texturedBackground: false,
  backgroundTexture: null,
  environmentTexture: null,
  environmentTextureDiffuseStrength: 1,
  environmentTextureSpecularStrength: 1,
  useEnvironmentTextureAsBackground: false,
  pass: 0
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkViewport$1.extend(publicAPI, model, initialValues);
  if (!model.background) model.background = [0, 0, 0, 1];
  while (model.background.length < 3) model.background.push(0);
  if (model.background.length === 3) model.background.push(1);
  get(publicAPI, model, ["_renderWindow", "allocatedRenderTime", "timeFactor", "lastRenderTimeInSeconds", "numberOfPropsRendered", "lastRenderingUsedDepthPeeling", "selector"]);
  setGet(publicAPI, model, ["twoSidedLighting", "lightFollowCamera", "automaticLightCreation", "erase", "draw", "nearClippingPlaneTolerance", "clippingRangeExpansion", "backingStore", "interactive", "layer", "preserveColorBuffer", "preserveDepthBuffer", "useDepthPeeling", "occlusionRatio", "maximumNumberOfPeels", "delegate", "backgroundTexture", "texturedBackground", "environmentTexture", "environmentTextureDiffuseStrength", "environmentTextureSpecularStrength", "useEnvironmentTextureAsBackground", "useShadows", "pass"]);
  getArray(publicAPI, model, ["actors", "volumes", "lights"]);
  setGetArray(publicAPI, model, ["background"], 4, 1);
  moveToProtected(publicAPI, model, ["renderWindow"]);
  vtkRenderer(publicAPI, model);
}
var newInstance5 = newInstance(extend4, "vtkRenderer");
var vtkRenderer$1 = {
  newInstance: newInstance5,
  extend: extend4
};

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js
var DEFAULT_VIEW_API = "WebGL";
var VIEW_CONSTRUCTORS = /* @__PURE__ */ Object.create(null);
function registerViewConstructor(name, constructor) {
  VIEW_CONSTRUCTORS[name] = constructor;
}
function listViewAPIs() {
  return Object.keys(VIEW_CONSTRUCTORS);
}
function newAPISpecificView(name) {
  let initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
}
function vtkRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindow");
  publicAPI.addRenderer = (renderer) => {
    if (publicAPI.hasRenderer(renderer)) {
      return;
    }
    renderer.setRenderWindow(publicAPI);
    model.renderers.push(renderer);
    publicAPI.modified();
  };
  publicAPI.removeRenderer = (renderer) => {
    model.renderers = model.renderers.filter((r) => r !== renderer);
    publicAPI.modified();
  };
  publicAPI.hasRenderer = (ren) => model.renderers.indexOf(ren) !== -1;
  publicAPI.newAPISpecificView = function(name) {
    let initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return newAPISpecificView(name || model.defaultViewAPI, initialValues);
  };
  publicAPI.addView = (view) => {
    if (publicAPI.hasView(view)) {
      return;
    }
    view.setRenderable(publicAPI);
    model._views.push(view);
    publicAPI.modified();
  };
  publicAPI.removeView = (view) => {
    model._views = model._views.filter((r) => r !== view);
    publicAPI.modified();
  };
  publicAPI.hasView = (view) => model._views.indexOf(view) !== -1;
  publicAPI.preRender = () => {
    model.renderers.forEach((ren) => {
      if (!ren.isActiveCameraCreated()) {
        ren.resetCamera();
      }
    });
  };
  publicAPI.render = () => {
    publicAPI.preRender();
    if (model.interactor) {
      model.interactor.render();
    } else {
      model._views.forEach((view) => view.traverseAllPasses());
    }
  };
  publicAPI.getStatistics = () => {
    const results = {
      propCount: 0,
      invisiblePropCount: 0,
      gpuMemoryMB: 0
    };
    model._views.forEach((v) => {
      if (v.getGraphicsMemoryInfo) results.gpuMemoryMB += v.getGraphicsMemoryInfo() / 1e6;
    });
    model.renderers.forEach((ren) => {
      const props = ren.getViewProps();
      const gren = model._views[0].getViewNodeFor(ren);
      props.forEach((prop) => {
        if (prop.getVisibility()) {
          results.propCount += 1;
          const mpr = prop.getMapper && prop.getMapper();
          if (mpr && mpr.getPrimitiveCount) {
            const gmpr = gren.getViewNodeFor(mpr);
            if (gmpr) {
              if (gmpr.getAllocatedGPUMemoryInBytes) {
                results.gpuMemoryMB += gmpr.getAllocatedGPUMemoryInBytes() / 1e6;
              }
              const pcount = mpr.getPrimitiveCount();
              Object.keys(pcount).forEach((keyName) => {
                if (!results[keyName]) {
                  results[keyName] = 0;
                }
                results[keyName] += pcount[keyName];
              });
            }
          }
        } else {
          results.invisiblePropCount += 1;
        }
      });
    });
    results.str = Object.keys(results).map((keyName) => `${keyName}: ${results[keyName]}`).join("\n");
    return results;
  };
  publicAPI.captureImages = function() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    macro.setImmediate(publicAPI.render);
    return model._views.map((view) => view.captureNextImage ? view.captureNextImage(format, opts) : void 0).filter((i) => !!i);
  };
  publicAPI.addRenderWindow = (child) => {
    if (model.childRenderWindows.includes(child)) {
      return false;
    }
    model.childRenderWindows.push(child);
    publicAPI.modified();
    return true;
  };
  publicAPI.removeRenderWindow = (child) => {
    const childIndex = model.childRenderWindows.findIndex((x) => x === child);
    if (childIndex < 0) {
      return false;
    }
    model.childRenderWindows.splice(childIndex, 1);
    publicAPI.modified();
    return true;
  };
}
var DEFAULT_VALUES5 = {
  defaultViewAPI: DEFAULT_VIEW_API,
  renderers: [],
  views: [],
  interactor: null,
  neverRendered: true,
  numberOfLayers: 1,
  childRenderWindows: []
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["interactor", "numberOfLayers", "_views", "defaultViewAPI"]);
  macro.get(publicAPI, model, ["neverRendered"]);
  macro.getArray(publicAPI, model, ["renderers", "childRenderWindows"]);
  macro.moveToProtected(publicAPI, model, ["views"]);
  macro.event(publicAPI, model, "completion");
  vtkRenderWindow(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend5, "vtkRenderWindow");
var vtkRenderWindow$1 = {
  newInstance: newInstance6,
  extend: extend5,
  registerViewConstructor,
  listViewAPIs,
  newAPISpecificView
};

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js
var Device = {
  Unknown: 0,
  LeftController: 1,
  RightController: 2
};
var Input = {
  Unknown: 0,
  Trigger: 1,
  TrackPad: 2,
  Grip: 3,
  Thumbstick: 4,
  A: 5,
  B: 6,
  ApplicationMenu: 7
  // Not exposed in WebXR API
};
var Axis = {
  Unknown: 0,
  TouchpadX: 1,
  TouchpadY: 2,
  ThumbstickX: 3,
  ThumbstickY: 4
};
var MouseButton = {
  LeftButton: 1,
  MiddleButton: 2,
  RightButton: 3
};
var Constants2 = {
  Device,
  Input,
  Axis,
  MouseButton
};

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js
var {
  Device: Device2,
  Input: Input2
} = Constants2;
var {
  vtkWarningMacro: vtkWarningMacro2,
  vtkErrorMacro: vtkErrorMacro5,
  normalizeWheel,
  vtkOnceErrorMacro
} = macro;
var EMPTY_MOUSE_EVENT = {
  ctrlKey: false,
  altKey: false,
  shiftKey: false
};
var deviceInputMap = {
  "xr-standard": [Input2.Trigger, Input2.Grip, Input2.TrackPad, Input2.Thumbstick, Input2.A, Input2.B]
};
var handledEvents = ["StartAnimation", "Animation", "EndAnimation", "PointerEnter", "PointerLeave", "MouseEnter", "MouseLeave", "StartMouseMove", "MouseMove", "EndMouseMove", "LeftButtonPress", "LeftButtonRelease", "MiddleButtonPress", "MiddleButtonRelease", "RightButtonPress", "RightButtonRelease", "KeyPress", "KeyDown", "KeyUp", "StartMouseWheel", "MouseWheel", "EndMouseWheel", "StartPinch", "Pinch", "EndPinch", "StartPan", "Pan", "EndPan", "StartRotate", "Rotate", "EndRotate", "Button3D", "Move3D", "StartPointerLock", "EndPointerLock", "StartInteraction", "Interaction", "EndInteraction", "AnimationFrameRateUpdate"];
function preventDefault(event) {
  if (event.cancelable) {
    event.preventDefault();
  }
}
function pointerCacheToPositions(cache) {
  const positions = /* @__PURE__ */ Object.create(null);
  cache.forEach((_ref) => {
    let {
      pointerId,
      position
    } = _ref;
    positions[pointerId] = position;
  });
  return positions;
}
function vtkRenderWindowInteractor(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowInteractor");
  const superClass = {
    ...publicAPI
  };
  const animationRequesters = /* @__PURE__ */ new Set();
  const pointerCache = /* @__PURE__ */ new Map();
  let wheelCoefficient = 1;
  publicAPI.start = () => {
    if (!model.initialized) {
      publicAPI.initialize();
      if (!model.initialized) {
        return;
      }
    }
    publicAPI.startEventLoop();
  };
  publicAPI.setRenderWindow = (aren) => {
    vtkErrorMacro5("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor");
  };
  publicAPI.setInteractorStyle = (style) => {
    if (model.interactorStyle !== style) {
      if (model.interactorStyle != null) {
        model.interactorStyle.setInteractor(null);
      }
      model.interactorStyle = style;
      if (model.interactorStyle != null) {
        if (model.interactorStyle.getInteractor() !== publicAPI) {
          model.interactorStyle.setInteractor(publicAPI);
        }
      }
    }
  };
  publicAPI.initialize = () => {
    model.initialized = true;
    publicAPI.enable();
    publicAPI.render();
  };
  publicAPI.enable = () => publicAPI.setEnabled(true);
  publicAPI.disable = () => publicAPI.setEnabled(false);
  publicAPI.startEventLoop = () => vtkWarningMacro2("empty event loop");
  function updateCurrentRenderer(x, y) {
    if (!model._forcedRenderer) {
      model.currentRenderer = publicAPI.findPokedRenderer(x, y);
    }
  }
  publicAPI.getCurrentRenderer = () => {
    if (model.currentRenderer) {
      return model.currentRenderer;
    }
    updateCurrentRenderer(0, 0);
    return model.currentRenderer;
  };
  function _getScreenEventPositionFor(source) {
    const canvas = model._view.getCanvas();
    const bounds = canvas.getBoundingClientRect();
    const scaleX = canvas.width / bounds.width;
    const scaleY = canvas.height / bounds.height;
    const position = {
      x: scaleX * (source.clientX - bounds.left),
      y: scaleY * (bounds.height - source.clientY + bounds.top),
      z: 0,
      movementX: scaleX * source.movementX,
      movementY: scaleY * source.movementY
    };
    if (pointerCache.size <= 1 || !model.currentRenderer) {
      updateCurrentRenderer(position.x, position.y);
    }
    return position;
  }
  const getScreenEventPositionFor = model._getScreenEventPositionFor || _getScreenEventPositionFor;
  function getModifierKeysFor(event) {
    return {
      controlKey: event.ctrlKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey
    };
  }
  function getKeysFor(event) {
    const modifierKeys = getModifierKeysFor(event);
    const keys = {
      key: event.key,
      keyCode: event.charCode,
      ...modifierKeys
    };
    return keys;
  }
  function getDeviceTypeFor(event) {
    return event.pointerType || "";
  }
  const _bindEvents = () => {
    if (model.container === null) {
      return;
    }
    const {
      container
    } = model;
    container.addEventListener("contextmenu", preventDefault);
    container.addEventListener("wheel", publicAPI.handleWheel);
    container.addEventListener("DOMMouseScroll", publicAPI.handleWheel);
    container.addEventListener("pointerenter", publicAPI.handlePointerEnter);
    container.addEventListener("pointerleave", publicAPI.handlePointerLeave);
    container.addEventListener("pointermove", publicAPI.handlePointerMove, {
      passive: false
    });
    container.addEventListener("pointerdown", publicAPI.handlePointerDown, {
      passive: false
    });
    container.addEventListener("pointerup", publicAPI.handlePointerUp);
    container.addEventListener("pointercancel", publicAPI.handlePointerCancel);
    container.addEventListener("keypress", publicAPI.handleKeyPress);
    container.addEventListener("keydown", publicAPI.handleKeyDown);
    document.addEventListener("keyup", publicAPI.handleKeyUp);
    document.addEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    container.tabIndex = 0;
    container.style.touchAction = "none";
    container.style.userSelect = "none";
    container.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
  };
  publicAPI.bindEvents = (container) => {
    if (container === null) {
      return;
    }
    const res = superClass.setContainer(container);
    if (res) {
      _bindEvents();
    }
  };
  const _unbindEvents = () => {
    clearTimeout(model.moveTimeoutID);
    clearTimeout(model.wheelTimeoutID);
    model.moveTimeoutID = 0;
    model.wheelTimeoutID = 0;
    wheelCoefficient = 1;
    const {
      container
    } = model;
    if (container) {
      container.removeEventListener("contextmenu", preventDefault);
      container.removeEventListener("wheel", publicAPI.handleWheel);
      container.removeEventListener("DOMMouseScroll", publicAPI.handleWheel);
      container.removeEventListener("pointerenter", publicAPI.handlePointerEnter);
      container.removeEventListener("pointerleave", publicAPI.handlePointerLeave);
      container.removeEventListener("pointermove", publicAPI.handlePointerMove, {
        passive: false
      });
      container.removeEventListener("pointerdown", publicAPI.handlePointerDown, {
        passive: false
      });
      container.removeEventListener("pointerup", publicAPI.handlePointerUp);
      container.removeEventListener("pointercancel", publicAPI.handlePointerCancel);
      container.removeEventListener("keypress", publicAPI.handleKeyPress);
      container.removeEventListener("keydown", publicAPI.handleKeyDown);
    }
    document.removeEventListener("keyup", publicAPI.handleKeyUp);
    document.removeEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    pointerCache.clear();
  };
  publicAPI.unbindEvents = () => {
    _unbindEvents();
    superClass.setContainer(null);
  };
  publicAPI.handleKeyPress = (event) => {
    const data = getKeysFor(event);
    publicAPI.keyPressEvent(data);
  };
  publicAPI.handleKeyDown = (event) => {
    const data = getKeysFor(event);
    publicAPI.keyDownEvent(data);
  };
  publicAPI.handleKeyUp = (event) => {
    const data = getKeysFor(event);
    publicAPI.keyUpEvent(data);
  };
  publicAPI.handlePointerEnter = (event) => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    publicAPI.pointerEnterEvent(callData);
    if (callData.deviceType === "mouse") {
      publicAPI.mouseEnterEvent(callData);
    }
  };
  publicAPI.handlePointerLeave = (event) => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    publicAPI.pointerLeaveEvent(callData);
    if (callData.deviceType === "mouse") {
      publicAPI.mouseLeaveEvent(callData);
    }
  };
  publicAPI.handlePointerDown = (event) => {
    if (event.button > 2 || publicAPI.isPointerLocked()) {
      return;
    }
    if (model.preventDefaultOnPointerDown) {
      preventDefault(event);
    }
    if (event.target.hasPointerCapture(event.pointerId)) {
      event.target.releasePointerCapture(event.pointerId);
    }
    model.container.setPointerCapture(event.pointerId);
    if (pointerCache.has(event.pointerId)) {
      vtkWarningMacro2("[RenderWindowInteractor] duplicate pointerId detected");
    }
    pointerCache.set(event.pointerId, {
      pointerId: event.pointerId,
      position: getScreenEventPositionFor(event)
    });
    switch (event.pointerType) {
      case "pen":
      case "touch":
        publicAPI.handleTouchStart(event);
        break;
      case "mouse":
      default:
        publicAPI.handleMouseDown(event);
        break;
    }
  };
  publicAPI.handlePointerUp = (event) => {
    if (pointerCache.has(event.pointerId)) {
      if (model.preventDefaultOnPointerUp) {
        preventDefault(event);
      }
      pointerCache.delete(event.pointerId);
      model.container.releasePointerCapture(event.pointerId);
      switch (event.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchEnd(event);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseUp(event);
          break;
      }
    }
  };
  publicAPI.handlePointerCancel = (event) => {
    if (pointerCache.has(event.pointerId)) {
      pointerCache.delete(event.pointerId);
      switch (event.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchEnd(event);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseUp(event);
          break;
      }
    }
  };
  publicAPI.handlePointerMove = (event) => {
    if (pointerCache.has(event.pointerId)) {
      const pointer = pointerCache.get(event.pointerId);
      pointer.position = getScreenEventPositionFor(event);
    }
    switch (event.pointerType) {
      case "pen":
      case "touch":
        publicAPI.handleTouchMove(event);
        break;
      case "mouse":
      default:
        publicAPI.handleMouseMove(event);
        break;
    }
  };
  publicAPI.handleMouseDown = (event) => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    switch (event.button) {
      case 0:
        publicAPI.leftButtonPressEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonPressEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonPressEvent(callData);
        break;
      default:
        vtkErrorMacro5(`Unknown mouse button pressed: ${event.button}`);
        break;
    }
  };
  publicAPI.requestPointerLock = () => {
    if (model.container) {
      model.container.requestPointerLock();
    }
  };
  publicAPI.exitPointerLock = () => {
    var _a;
    return (_a = document.exitPointerLock) == null ? void 0 : _a.call(document);
  };
  publicAPI.isPointerLocked = () => !!model.container && document.pointerLockElement === model.container;
  publicAPI.handlePointerLockChange = () => {
    if (publicAPI.isPointerLocked()) {
      publicAPI.startPointerLockEvent();
    } else {
      publicAPI.endPointerLockEvent();
    }
  };
  function forceRender() {
    if (model._view && model.enabled && model.enableRender) {
      model.inRender = true;
      model._view.traverseAllPasses();
      model.inRender = false;
    }
    publicAPI.invokeRenderEvent();
  }
  publicAPI.requestAnimation = (requestor) => {
    if (requestor === void 0) {
      vtkErrorMacro5(`undefined requester, can not start animating`);
      return;
    }
    if (animationRequesters.has(requestor)) {
      vtkWarningMacro2(`requester is already registered for animating`);
      return;
    }
    animationRequesters.add(requestor);
    if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.extendAnimation = (duration) => {
    const newEnd = Date.now() + duration;
    model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
    if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.isAnimating = () => model.xrAnimation || model.animationRequest !== null;
  publicAPI.cancelAnimation = function(requestor) {
    let skipWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!animationRequesters.has(requestor)) {
      if (!skipWarning) {
        const requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
        vtkWarningMacro2(`${requestStr} did not request an animation`);
      }
      return;
    }
    animationRequesters.delete(requestor);
    if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.switchToXRAnimation = () => {
    if (model.animationRequest) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
    }
    model.xrAnimation = true;
  };
  publicAPI.returnFromXRAnimation = () => {
    model.xrAnimation = false;
    if (animationRequesters.size !== 0) {
      model.recentAnimationFrameRate = 10;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    }
  };
  publicAPI.updateXRGamepads = (xrSession, xrFrame, xrRefSpace) => {
    xrSession.inputSources.forEach((inputSource) => {
      const gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
      const targetRayPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.targetRaySpace, xrRefSpace);
      const gamepad = inputSource.gamepad;
      const hand = inputSource.handedness;
      if (!gamepad) {
        return;
      }
      if (!(gamepad.index in model.lastGamepadValues)) {
        model.lastGamepadValues[gamepad.index] = {
          left: {
            buttons: {}
          },
          right: {
            buttons: {}
          },
          none: {
            buttons: {}
          }
        };
      }
      for (let buttonIdx = 0; buttonIdx < gamepad.buttons.length; ++buttonIdx) {
        if (!(buttonIdx in model.lastGamepadValues[gamepad.index][hand].buttons)) {
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = false;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] !== gamepad.buttons[buttonIdx].pressed && gripPose != null) {
          publicAPI.button3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            pressed: gamepad.buttons[buttonIdx].pressed,
            device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController,
            input: deviceInputMap[gamepad.mapping] && deviceInputMap[gamepad.mapping][buttonIdx] ? deviceInputMap[gamepad.mapping][buttonIdx] : Input2.Trigger
          });
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = gamepad.buttons[buttonIdx].pressed;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] && gripPose != null) {
          publicAPI.move3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController
          });
        }
      }
    });
  };
  publicAPI.handleMouseMove = (event) => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    if (model.moveTimeoutID === 0) {
      publicAPI.startMouseMoveEvent(callData);
    } else {
      publicAPI.mouseMoveEvent(callData);
      clearTimeout(model.moveTimeoutID);
    }
    model.moveTimeoutID = setTimeout(() => {
      publicAPI.endMouseMoveEvent();
      model.moveTimeoutID = 0;
    }, 200);
  };
  publicAPI.handleAnimation = () => {
    const currTime = Date.now();
    model._animationFrameCount++;
    if (currTime - model._animationStartTime > 1e3 && model._animationFrameCount > 1) {
      model.recentAnimationFrameRate = 1e3 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
      model.lastFrameTime = 1 / model.recentAnimationFrameRate;
      publicAPI.animationFrameRateUpdateEvent();
      model._animationStartTime = currTime;
      model._animationFrameCount = 1;
    }
    publicAPI.animationEvent();
    forceRender();
    if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    } else {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.handleWheel = (event) => {
    preventDefault(event);
    const callData = {
      ...normalizeWheel(event),
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    if (model.wheelTimeoutID === 0) {
      if (Math.abs(callData.spinY) >= 0.3) {
        wheelCoefficient = Math.abs(callData.spinY);
      } else {
        wheelCoefficient = 1;
      }
    }
    callData.spinY /= wheelCoefficient;
    if (model.wheelTimeoutID === 0) {
      publicAPI.startMouseWheelEvent(callData);
      publicAPI.mouseWheelEvent(callData);
    } else {
      publicAPI.mouseWheelEvent(callData);
      clearTimeout(model.wheelTimeoutID);
    }
    if (model.mouseScrollDebounceByPass) {
      publicAPI.extendAnimation(600);
      publicAPI.endMouseWheelEvent();
      model.wheelTimeoutID = 0;
    } else {
      model.wheelTimeoutID = setTimeout(() => {
        publicAPI.extendAnimation(600);
        publicAPI.endMouseWheelEvent();
        model.wheelTimeoutID = 0;
      }, 200);
    }
  };
  publicAPI.handleMouseUp = (event) => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    switch (event.button) {
      case 0:
        publicAPI.leftButtonReleaseEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonReleaseEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonReleaseEvent(callData);
        break;
      default:
        vtkErrorMacro5(`Unknown mouse button released: ${event.button}`);
        break;
    }
  };
  publicAPI.handleTouchStart = (event) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      if (pointers.length === 2) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
      publicAPI.recognizeGesture("TouchStart", positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.leftButtonPressEvent(callData);
    }
  };
  publicAPI.handleTouchMove = (event) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      publicAPI.recognizeGesture("TouchMove", positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.mouseMoveEvent(callData);
    }
  };
  publicAPI.handleTouchEnd = (event) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures) {
      if (pointers.length === 0) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: getScreenEventPositionFor(event),
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      } else if (pointers.length === 1) {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture("TouchEnd", positions);
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonPressEvent(callData);
      } else {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture("TouchMove", positions);
      }
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.leftButtonReleaseEvent(callData);
    }
  };
  publicAPI.setView = (val) => {
    if (model._view === val) {
      return;
    }
    model._view = val;
    model._view.getRenderable().setInteractor(publicAPI);
    publicAPI.modified();
  };
  publicAPI.getFirstRenderer = () => {
    var _a, _b, _c;
    return (_c = (_b = (_a = model._view) == null ? void 0 : _a.getRenderable()) == null ? void 0 : _b.getRenderersByReference()) == null ? void 0 : _c[0];
  };
  publicAPI.findPokedRenderer = function() {
    var _a, _b;
    let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!model._view) {
      return null;
    }
    const rc = (_b = (_a = model._view) == null ? void 0 : _a.getRenderable()) == null ? void 0 : _b.getRenderers();
    if (!rc || rc.length === 0) {
      return null;
    }
    rc.sort((a, b) => a.getLayer() - b.getLayer());
    let interactiveren = null;
    let viewportren = null;
    let currentRenderer = null;
    let count = rc.length;
    while (count--) {
      const aren = rc[count];
      if (model._view.isInViewport(x, y, aren) && aren.getInteractive()) {
        currentRenderer = aren;
        break;
      }
      if (interactiveren === null && aren.getInteractive()) {
        interactiveren = aren;
      }
      if (viewportren === null && model._view.isInViewport(x, y, aren)) {
        viewportren = aren;
      }
    }
    if (currentRenderer === null) {
      currentRenderer = interactiveren;
    }
    if (currentRenderer === null) {
      currentRenderer = viewportren;
    }
    if (currentRenderer == null) {
      currentRenderer = rc[0];
    }
    return currentRenderer;
  };
  publicAPI.render = () => {
    if (!publicAPI.isAnimating() && !model.inRender) {
      forceRender();
    }
  };
  handledEvents.forEach((eventName) => {
    const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    publicAPI[`${lowerFirst}Event`] = (arg) => {
      if (!model.enabled) {
        return;
      }
      const renderer = publicAPI.getCurrentRenderer();
      if (!renderer) {
        vtkOnceErrorMacro(`
          Can not forward events without a current renderer on the interactor.
        `);
        return;
      }
      const callData = {
        type: eventName,
        pokedRenderer: model.currentRenderer,
        firstRenderer: publicAPI.getFirstRenderer(),
        // Add the arguments to the call data
        ...arg
      };
      publicAPI[`invoke${eventName}`](callData);
    };
  });
  publicAPI.recognizeGesture = (event, positions) => {
    if (Object.keys(positions).length > 2) {
      return;
    }
    if (!model.startingEventPositions) {
      model.startingEventPositions = {};
    }
    if (event === "TouchStart") {
      Object.keys(positions).forEach((key) => {
        model.startingEventPositions[key] = positions[key];
      });
      model.currentGesture = "Start";
      return;
    }
    if (event === "TouchEnd") {
      if (model.currentGesture === "Pinch") {
        publicAPI.render();
        publicAPI.endPinchEvent();
      }
      if (model.currentGesture === "Rotate") {
        publicAPI.render();
        publicAPI.endRotateEvent();
      }
      if (model.currentGesture === "Pan") {
        publicAPI.render();
        publicAPI.endPanEvent();
      }
      model.currentGesture = "Start";
      model.startingEventPositions = {};
      return;
    }
    let count = 0;
    const posVals = [];
    const startVals = [];
    Object.keys(positions).forEach((key) => {
      posVals[count] = positions[key];
      startVals[count] = model.startingEventPositions[key];
      count++;
    });
    const originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
    const newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));
    let originalAngle = degreesFromRadians(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
    let newAngle = degreesFromRadians(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));
    let angleDeviation = newAngle - originalAngle;
    newAngle = newAngle + 180 >= 360 ? newAngle - 180 : newAngle + 180;
    originalAngle = originalAngle + 180 >= 360 ? originalAngle - 180 : originalAngle + 180;
    if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
      angleDeviation = newAngle - originalAngle;
    }
    const trans = [];
    trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2;
    trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2;
    if (event === "TouchMove") {
      if (model.currentGesture === "Start") {
        let thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
        if (thresh < 15) {
          thresh = 15;
        }
        const pinchDistance = Math.abs(newDistance - originalDistance);
        const rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360;
        const panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
        if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
          model.currentGesture = "Pinch";
          const callData = {
            scale: 1,
            touches: positions
          };
          publicAPI.startPinchEvent(callData);
        } else if (rotateDistance > thresh && rotateDistance > panDistance) {
          model.currentGesture = "Rotate";
          const callData = {
            rotation: 0,
            touches: positions
          };
          publicAPI.startRotateEvent(callData);
        } else if (panDistance > thresh) {
          model.currentGesture = "Pan";
          const callData = {
            translation: [0, 0],
            touches: positions
          };
          publicAPI.startPanEvent(callData);
        }
      } else {
        if (model.currentGesture === "Rotate") {
          const callData = {
            rotation: angleDeviation,
            touches: positions
          };
          publicAPI.rotateEvent(callData);
        }
        if (model.currentGesture === "Pinch") {
          const callData = {
            scale: newDistance / originalDistance,
            touches: positions
          };
          publicAPI.pinchEvent(callData);
        }
        if (model.currentGesture === "Pan") {
          const callData = {
            translation: trans,
            touches: positions
          };
          publicAPI.panEvent(callData);
        }
      }
    }
  };
  publicAPI.handleVisibilityChange = () => {
    model._animationStartTime = Date.now();
    model._animationFrameCount = 0;
  };
  publicAPI.setCurrentRenderer = (r) => {
    model._forcedRenderer = !!r;
    model.currentRenderer = r;
  };
  publicAPI.setContainer = (container) => {
    _unbindEvents();
    const res = superClass.setContainer(container ?? null);
    if (res) {
      _bindEvents();
    }
    return res;
  };
  publicAPI.delete = () => {
    while (animationRequesters.size) {
      publicAPI.cancelAnimation(animationRequesters.values().next().value);
    }
    if (typeof document.hidden !== "undefined") {
      document.removeEventListener("visibilitychange", publicAPI.handleVisibilityChange);
    }
    if (model.container) {
      publicAPI.setContainer(null);
    }
    superClass.delete();
  };
  if (typeof document.hidden !== "undefined") {
    document.addEventListener("visibilitychange", publicAPI.handleVisibilityChange, false);
  }
}
var DEFAULT_VALUES6 = {
  renderWindow: null,
  interactorStyle: null,
  picker: null,
  pickingManager: null,
  initialized: false,
  enabled: false,
  enableRender: true,
  currentRenderer: null,
  lightFollowCamera: true,
  desiredUpdateRate: 30,
  stillUpdateRate: 2,
  container: null,
  // _view: null,
  recognizeGestures: true,
  currentGesture: "Start",
  animationRequest: null,
  lastFrameTime: 0.1,
  recentAnimationFrameRate: 10,
  wheelTimeoutID: 0,
  moveTimeoutID: 0,
  lastGamepadValues: {},
  preventDefaultOnPointerDown: false,
  preventDefaultOnPointerUp: false,
  mouseScrollDebounceByPass: false
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  macro.obj(publicAPI, model);
  model._animationExtendedEnd = 0;
  macro.event(publicAPI, model, "RenderEvent");
  handledEvents.forEach((eventName) => macro.event(publicAPI, model, eventName));
  macro.get(publicAPI, model, ["initialized", "interactorStyle", "lastFrameTime", "recentAnimationFrameRate", "_view"]);
  macro.setGet(publicAPI, model, ["container", "lightFollowCamera", "enabled", "enableRender", "recognizeGestures", "desiredUpdateRate", "stillUpdateRate", "picker", "preventDefaultOnPointerDown", "preventDefaultOnPointerUp", "mouseScrollDebounceByPass"]);
  macro.moveToProtected(publicAPI, model, ["view"]);
  vtkRenderWindowInteractor(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend6, "vtkRenderWindowInteractor");
var vtkRenderWindowInteractor$1 = {
  newInstance: newInstance7,
  extend: extend6,
  handledEvents,
  ...Constants2
};

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorObserver.js
var {
  vtkErrorMacro: vtkErrorMacro6,
  VOID
} = macro;
function computeWorldToDisplay(renderer, x, y, z) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.worldToDisplay(x, y, z, renderer);
}
function computeDisplayToWorld(renderer, x, y, z) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.displayToWorld(x, y, z, renderer);
}
var STATIC = {
  computeWorldToDisplay,
  computeDisplayToWorld
};
function vtkInteractorObserver(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorObserver");
  const superClass = {
    ...publicAPI
  };
  function unsubscribeFromEvents() {
    while (model.subscribedEvents.length) {
      model.subscribedEvents.pop().unsubscribe();
    }
  }
  function subscribeToEvents() {
    vtkRenderWindowInteractor$1.handledEvents.forEach((eventName) => {
      if (publicAPI[`handle${eventName}`]) {
        model.subscribedEvents.push(model._interactor[`on${eventName}`]((callData) => {
          if (model.processEvents) {
            return publicAPI[`handle${eventName}`](callData);
          }
          return VOID;
        }, model.priority));
      }
    });
  }
  publicAPI.setInteractor = (i) => {
    if (i === model._interactor) {
      return;
    }
    unsubscribeFromEvents();
    model._interactor = i;
    if (i && model.enabled) {
      subscribeToEvents();
    }
    publicAPI.modified();
  };
  publicAPI.setEnabled = (enable) => {
    if (enable === model.enabled) {
      return;
    }
    unsubscribeFromEvents();
    if (enable) {
      if (model._interactor) {
        subscribeToEvents();
      } else {
        vtkErrorMacro6(`
          The interactor must be set before subscribing to events
        `);
      }
    }
    model.enabled = enable;
    publicAPI.modified();
  };
  publicAPI.computeDisplayToWorld = (renderer, x, y, z) => {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().displayToWorld(x, y, z, renderer);
  };
  publicAPI.computeWorldToDisplay = (renderer, x, y, z) => {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().worldToDisplay(x, y, z, renderer);
  };
  publicAPI.setPriority = (priority) => {
    const modified = superClass.setPriority(priority);
    if (modified && model._interactor) {
      unsubscribeFromEvents();
      subscribeToEvents();
    }
  };
}
var DEFAULT_VALUES7 = {
  enabled: true,
  // _interactor: null,
  priority: 0,
  processEvents: true,
  subscribedEvents: []
};
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "InteractionEvent");
  macro.event(publicAPI, model, "StartInteractionEvent");
  macro.event(publicAPI, model, "EndInteractionEvent");
  macro.get(publicAPI, model, ["_interactor", "enabled"]);
  macro.setGet(publicAPI, model, ["priority", "processEvents"]);
  macro.moveToProtected(publicAPI, model, ["interactor"]);
  vtkInteractorObserver(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend7, "vtkInteractorObserver");
var vtkInteractorObserver$1 = {
  newInstance: newInstance8,
  extend: extend7,
  ...STATIC
};

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle/Constants.js
var States = {
  IS_START: 0,
  IS_NONE: 0,
  IS_ROTATE: 1,
  IS_PAN: 2,
  IS_SPIN: 3,
  IS_DOLLY: 4,
  IS_CAMERA_POSE: 11,
  IS_WINDOW_LEVEL: 1024,
  IS_SLICE: 1025
};
var vtkInteractorStyleConstants = {
  States
};

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle.js
var {
  States: States2
} = vtkInteractorStyleConstants;
var stateNames = {
  Rotate: States2.IS_ROTATE,
  Pan: States2.IS_PAN,
  Spin: States2.IS_SPIN,
  Dolly: States2.IS_DOLLY,
  CameraPose: States2.IS_CAMERA_POSE,
  WindowLevel: States2.IS_WINDOW_LEVEL,
  Slice: States2.IS_SLICE
};
function vtkInteractorStyle(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyle");
  Object.keys(stateNames).forEach((key) => {
    macro.event(publicAPI, model, `Start${key}Event`);
    publicAPI[`start${key}`] = () => {
      if (model.state !== States2.IS_NONE) {
        return;
      }
      model.state = stateNames[key];
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent({
        type: "StartInteractionEvent"
      });
      publicAPI[`invokeStart${key}Event`]({
        type: `Start${key}Event`
      });
    };
    macro.event(publicAPI, model, `End${key}Event`);
    publicAPI[`end${key}`] = () => {
      if (model.state !== stateNames[key]) {
        return;
      }
      model.state = States2.IS_NONE;
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent({
        type: "EndInteractionEvent"
      });
      publicAPI[`invokeEnd${key}Event`]({
        type: `End${key}Event`
      });
      model._interactor.render();
    };
  });
  model.getRenderer = (callData) => model.focusedRenderer || callData.pokedRenderer;
  publicAPI.handleKeyPress = (callData) => {
    const rwi = model._interactor;
    let ac = null;
    switch (callData.key) {
      case "r":
      case "R":
        model.getRenderer(callData).resetCamera();
        rwi.render();
        break;
      case "w":
      case "W":
        ac = model.getRenderer(callData).getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToWireframe) {
            prop.setRepresentationToWireframe();
          }
        });
        rwi.render();
        break;
      case "s":
      case "S":
        ac = model.getRenderer(callData).getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToSurface) {
            prop.setRepresentationToSurface();
          }
        });
        rwi.render();
        break;
      case "v":
      case "V":
        ac = model.getRenderer(callData).getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToPoints) {
            prop.setRepresentationToPoints();
          }
        });
        rwi.render();
        break;
    }
  };
}
var DEFAULT_VALUES8 = {
  state: States2.IS_NONE,
  handleObservers: 1,
  autoAdjustCameraClippingRange: 1
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  vtkInteractorObserver$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["focusedRenderer"]);
  vtkInteractorStyle(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend8, "vtkInteractorStyle");
var vtkInteractorStyle$1 = {
  newInstance: newInstance9,
  extend: extend8,
  ...vtkInteractorStyleConstants
};

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleTrackballCamera.js
var {
  States: States3
} = vtkInteractorStyleConstants;
function vtkInteractorStyleTrackballCamera(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleTrackballCamera");
  publicAPI.handleMouseMove = (callData) => {
    const pos = callData.position;
    const renderer = model.getRenderer(callData);
    switch (model.state) {
      case States3.IS_ROTATE:
        publicAPI.handleMouseRotate(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_PAN:
        publicAPI.handleMousePan(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_DOLLY:
        publicAPI.handleMouseDolly(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_SPIN:
        publicAPI.handleMouseSpin(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
    }
    model.previousPosition = pos;
  };
  publicAPI.handleButton3D = (ed) => {
    if (ed && ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad)) {
      publicAPI.startCameraPose();
      return;
    }
    if (ed && !ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad) && model.state === States3.IS_CAMERA_POSE) {
      publicAPI.endCameraPose();
    }
  };
  publicAPI.handleMove3D = (ed) => {
    switch (model.state) {
      case States3.IS_CAMERA_POSE:
        publicAPI.updateCameraPose(ed);
        break;
    }
  };
  publicAPI.updateCameraPose = (ed) => {
    const camera = model.getRenderer(ed).getActiveCamera();
    const oldTrans = camera.getPhysicalTranslation();
    const speed = 0.5;
    const pscale = speed * 0.05 * camera.getPhysicalScale();
    const dir = camera.physicalOrientationToWorldDirection([ed.orientation.x, ed.orientation.y, ed.orientation.z, ed.orientation.w]);
    camera.setPhysicalTranslation(oldTrans[0] + dir[0] * pscale, oldTrans[1] + dir[1] * pscale, oldTrans[2] + dir[2] * pscale);
  };
  publicAPI.handleLeftButtonPress = (callData) => {
    const pos = callData.position;
    model.previousPosition = pos;
    if (callData.shiftKey) {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startDolly();
      } else {
        publicAPI.startPan();
      }
    } else {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startSpin();
      } else {
        publicAPI.startRotate();
      }
    }
  };
  publicAPI.handleLeftButtonRelease = () => {
    switch (model.state) {
      case States3.IS_DOLLY:
        publicAPI.endDolly();
        break;
      case States3.IS_PAN:
        publicAPI.endPan();
        break;
      case States3.IS_SPIN:
        publicAPI.endSpin();
        break;
      case States3.IS_ROTATE:
        publicAPI.endRotate();
        break;
    }
  };
  publicAPI.handleStartMouseWheel = () => {
    publicAPI.startDolly();
  };
  publicAPI.handleEndMouseWheel = () => {
    publicAPI.endDolly();
  };
  publicAPI.handleStartPinch = (callData) => {
    model.previousScale = callData.scale;
    publicAPI.startDolly();
  };
  publicAPI.handleEndPinch = () => {
    publicAPI.endDolly();
  };
  publicAPI.handleStartRotate = (callData) => {
    model.previousRotation = callData.rotation;
    publicAPI.startRotate();
  };
  publicAPI.handleEndRotate = () => {
    publicAPI.endRotate();
  };
  publicAPI.handleStartPan = (callData) => {
    model.previousTranslation = callData.translation;
    publicAPI.startPan();
  };
  publicAPI.handleEndPan = () => {
    publicAPI.endPan();
  };
  publicAPI.handlePinch = (callData) => {
    publicAPI.dollyByFactor(model.getRenderer(callData), callData.scale / model.previousScale);
    model.previousScale = callData.scale;
  };
  publicAPI.handlePan = (callData) => {
    const camera = model.getRenderer(callData).getActiveCamera();
    let viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(model.getRenderer(callData), viewFocus[0], viewFocus[1], viewFocus[2]);
    const focalDepth = viewFocus[2];
    const trans = callData.translation;
    const lastTrans = model.previousTranslation;
    const newPickPoint = publicAPI.computeDisplayToWorld(model.getRenderer(callData), viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);
    const oldPickPoint = publicAPI.computeDisplayToWorld(model.getRenderer(callData), viewFocus[0], viewFocus[1], focalDepth);
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      model.getRenderer(callData).updateLightsGeometryToFollowCamera();
    }
    camera.orthogonalizeViewUp();
    model.previousTranslation = callData.translation;
  };
  publicAPI.handleRotate = (callData) => {
    const camera = model.getRenderer(callData).getActiveCamera();
    camera.roll(callData.rotation - model.previousRotation);
    camera.orthogonalizeViewUp();
    model.previousRotation = callData.rotation;
  };
  publicAPI.handleMouseRotate = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const rwi = model._interactor;
    const dx = position.x - model.previousPosition.x;
    const dy = position.y - model.previousPosition.y;
    const size = rwi.getView().getViewportSize(renderer);
    let deltaElevation = -0.1;
    let deltaAzimuth = -0.1;
    if (size[0] && size[1]) {
      deltaElevation = -20 / size[1];
      deltaAzimuth = -20 / size[0];
    }
    const rxf = dx * deltaAzimuth * model.motionFactor;
    const ryf = dy * deltaElevation * model.motionFactor;
    const camera = renderer.getActiveCamera();
    if (!Number.isNaN(rxf) && !Number.isNaN(ryf)) {
      camera.azimuth(rxf);
      camera.elevation(ryf);
      camera.orthogonalizeViewUp();
    }
    if (model.autoAdjustCameraClippingRange) {
      renderer.resetCameraClippingRange();
    }
    if (rwi.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseSpin = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const rwi = model._interactor;
    const camera = renderer.getActiveCamera();
    const center = rwi.getView().getViewportCenter(renderer);
    const oldAngle = degreesFromRadians(Math.atan2(model.previousPosition.y - center[1], model.previousPosition.x - center[0]));
    const newAngle = degreesFromRadians(Math.atan2(position.y - center[1], position.x - center[0])) - oldAngle;
    if (!Number.isNaN(newAngle)) {
      camera.roll(newAngle);
      camera.orthogonalizeViewUp();
    }
  };
  publicAPI.handleMousePan = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const camera = renderer.getActiveCamera();
    let viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    const focalDepth = viewFocus[2];
    const newPickPoint = publicAPI.computeDisplayToWorld(renderer, position.x, position.y, focalDepth);
    const oldPickPoint = publicAPI.computeDisplayToWorld(renderer, model.previousPosition.x, model.previousPosition.y, focalDepth);
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseDolly = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const dy = position.y - model.previousPosition.y;
    const rwi = model._interactor;
    const center = rwi.getView().getViewportCenter(renderer);
    const dyf = model.motionFactor * dy / center[1];
    publicAPI.dollyByFactor(renderer, 1.1 ** dyf);
  };
  publicAPI.handleMouseWheel = (callData) => {
    const dyf = 1 - callData.spinY / model.zoomFactor;
    publicAPI.dollyByFactor(model.getRenderer(callData), dyf);
  };
  publicAPI.dollyByFactor = (renderer, factor) => {
    if (Number.isNaN(factor)) {
      return;
    }
    const camera = renderer.getActiveCamera();
    if (camera.getParallelProjection()) {
      camera.setParallelScale(camera.getParallelScale() / factor);
    } else {
      camera.dolly(factor);
      if (model.autoAdjustCameraClippingRange) {
        renderer.resetCameraClippingRange();
      }
    }
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}
var DEFAULT_VALUES9 = {
  motionFactor: 10,
  zoomFactor: 10
};
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  vtkInteractorStyle$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["motionFactor", "zoomFactor"]);
  vtkInteractorStyleTrackballCamera(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend9, "vtkInteractorStyleTrackballCamera");
var vtkInteractorStyleTrackballCamera$1 = {
  newInstance: newInstance10,
  extend: extend9
};

// node_modules/@kitware/vtk.js/Common/Core/URLExtract.js
function identity(i) {
  return i;
}
function toNativeType(str) {
  if (str === null || str === "null") {
    return null;
  }
  if (str === "true") {
    return true;
  }
  if (str === "false") {
    return false;
  }
  if (str === void 0 || str === "undefined") {
    return void 0;
  }
  if (str[0] === "[" && str[str.length - 1] === "]") {
    return str.substring(1, str.length - 1).split(",").map((s) => toNativeType(s.trim()));
  }
  if (str === "" || Number.isNaN(Number(str))) {
    return str;
  }
  return Number(str);
}
function extractURLParameters() {
  let castToNativeType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  let query = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window.location.search;
  const summary = {};
  const convert3 = castToNativeType ? toNativeType : identity;
  const params = new URLSearchParams(query);
  params.forEach((value, key) => {
    if (key) {
      summary[key] = value ? convert3(value) : true;
    }
  });
  return summary;
}
var vtkURLExtract = {
  toNativeType,
  extractURLParameters
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
function vtkFramebuffer(publicAPI, model) {
  model.classHierarchy.push("vtkFramebuffer");
  publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
  publicAPI.saveCurrentBindingsAndBuffers = (modeIn) => {
    const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };
  publicAPI.saveCurrentBindings = (modeIn) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
      return;
    }
    const gl = model.context;
    model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
    model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
  };
  publicAPI.saveCurrentBuffers = (modeIn) => {
  };
  publicAPI.restorePreviousBindingsAndBuffers = (modeIn) => {
    const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };
  publicAPI.restorePreviousBindings = (modeIn) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
      return;
    }
    const gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
  };
  publicAPI.restorePreviousBuffers = (modeIn) => {
  };
  publicAPI.bind = function() {
    let modeArg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let mode = modeArg;
    if (mode === null) {
      mode = model.context.FRAMEBUFFER;
    }
    model.context.bindFramebuffer(mode, model.glFramebuffer);
    for (let i = 0; i < model.colorBuffers.length; i++) {
      model.colorBuffers[i].bind();
    }
    model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };
  publicAPI.create = (width, height) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling create");
      return;
    }
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };
  publicAPI.setColorBuffer = function(texture) {
    let attachment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const gl = model.context;
    if (!gl) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling setColorBuffer");
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro2("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    model.colorBuffers[attachment] = texture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
  };
  publicAPI.removeColorBuffer = function() {
    let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    const gl = model.context;
    if (!gl) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling removeColorBuffer");
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro2("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
    model.colorBuffers = model.colorBuffers.splice(attachment, 1);
  };
  publicAPI.setDepthBuffer = (texture) => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling setDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
    } else {
      vtkErrorMacro2("Attaching depth buffer textures to fbo requires WebGL 2");
    }
  };
  publicAPI.removeDepthBuffer = () => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    } else {
      vtkErrorMacro2("Attaching depth buffer textures to framebuffers requires WebGL 2");
    }
  };
  publicAPI.getGLFramebuffer = () => model.glFramebuffer;
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
  };
  publicAPI.getSize = () => {
    if (model.glFramebuffer == null) return null;
    return [model.glFramebuffer.width, model.glFramebuffer.height];
  };
  publicAPI.populateFramebuffer = () => {
    if (!model.context) {
      vtkErrorMacro2("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
      return;
    }
    publicAPI.bind();
    const gl = model.context;
    const texture = vtkOpenGLTexture$1.newInstance();
    texture.setOpenGLRenderWindow(model._openGLRenderWindow);
    texture.setMinificationFilter(Filter.LINEAR);
    texture.setMagnificationFilter(Filter.LINEAR);
    texture.create2DFromRaw({
      width: model.glFramebuffer.width,
      height: model.glFramebuffer.height,
      numComps: 4,
      dataType: VtkDataTypes.UNSIGNED_CHAR,
      data: null
    });
    publicAPI.setColorBuffer(texture);
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
  };
  publicAPI.getColorTexture = () => model.colorBuffers[0];
}
var DEFAULT_VALUES10 = {
  // _openGLRenderWindow: null,
  glFramebuffer: null,
  colorBuffers: null,
  depthTexture: null,
  previousDrawBinding: 0,
  previousReadBinding: 0,
  previousDrawBuffer: 0,
  previousReadBuffer: 0,
  previousActiveFramebuffer: null
};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  obj(publicAPI, model);
  if (model.colorBuffers) {
    vtkErrorMacro2("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.");
  }
  model.colorBuffers = [];
  getArray(publicAPI, model, ["colorBuffers"]);
  vtkFramebuffer(publicAPI, model);
}
var newInstance11 = newInstance(extend10, "vtkFramebuffer");
var vtkOpenGLFramebuffer = {
  newInstance: newInstance11,
  extend: extend10
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js
function vtkRenderPass(publicAPI, model) {
  model.classHierarchy.push("vtkRenderPass");
  publicAPI.getOperation = () => model.currentOperation;
  publicAPI.setCurrentOperation = (val) => {
    model.currentOperation = val;
    model.currentTraverseOperation = `traverse${macro.capitalize(model.currentOperation)}`;
  };
  publicAPI.getTraverseOperation = () => model.currentTraverseOperation;
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    model.preDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach((val) => {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}
var DEFAULT_VALUES11 = {
  delegates: [],
  currentOperation: null,
  preDelegateOperations: [],
  postDelegateOperations: [],
  currentParent: null
};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["currentOperation"]);
  macro.setGet(publicAPI, model, ["delegates", "_currentParent", "preDelegateOperations", "postDelegateOperations"]);
  macro.moveToProtected(publicAPI, model, ["currentParent"]);
  vtkRenderPass(publicAPI, model);
}
var newInstance12 = macro.newInstance(extend11, "vtkRenderPass");
var vtkRenderPass$1 = {
  newInstance: newInstance12,
  extend: extend11
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js
var {
  Representation
} = vtkProperty$1;
var {
  vtkErrorMacro: vtkErrorMacro7
} = macro;
function translucentShaderReplacement(shaders) {
  const substituteRes = vtkShaderProgram$1.substitute(shaders.Fragment, "//VTK::RenderPassFragmentShader::Impl", `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
  shaders.Fragment = substituteRes.result;
}
var oitpFragTemplate = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass");
  publicAPI.createVertexBuffer = () => {
    const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);
    const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    const points = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName("points");
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName("tcoords");
    const cells = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
  publicAPI.createFramebuffer = (viewNode) => {
    const size = viewNode.getSize();
    const gl = viewNode.getContext();
    model.framebuffer = vtkOpenGLFramebuffer.newInstance();
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    model.framebuffer.create(...size);
    model.framebuffer.saveCurrentBindingsAndBuffers();
    model.framebuffer.bind();
    model.translucentRGBATexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
    model.translucentRGBATexture.setFormat(gl.RGBA);
    model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
    model.translucentRGBATexture.create2DFromRaw({
      width: size[0],
      height: size[1],
      numComps: 4,
      dataType: "Float32Array",
      data: null
    });
    model.translucentRTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRTexture.setInternalFormat(gl.R16F);
    model.translucentRTexture.setFormat(gl.RED);
    model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRTexture.setOpenGLRenderWindow(viewNode);
    model.translucentRTexture.create2DFromRaw({
      width: size[0],
      height: size[1],
      numComps: 1,
      dataType: "Float32Array",
      data: null
    });
    model.translucentZTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentZTexture.setOpenGLRenderWindow(viewNode);
    model.translucentZTexture.createDepthFromRaw({
      width: size[0],
      height: size[1],
      dataType: "Float32Array",
      data: null
    });
    model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
    model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
    model.framebuffer.setDepthBuffer(model.translucentZTexture);
  };
  publicAPI.createCopyShader = (viewNode) => {
    model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "attribute vec2 tcoordTC;", "varying vec2 tcoord;", "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"), oitpFragTemplate, "");
  };
  publicAPI.createVBO = (viewNode) => {
    const gl = viewNode.getContext();
    model.tris.setOpenGLRenderWindow(viewNode);
    publicAPI.createVertexBuffer();
    const program = model.copyShader;
    model.tris.getCABO().bind();
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
      vtkErrorMacro7("Error setting vertexDC in copy shader VAO.");
    }
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "tcoordTC", model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
      vtkErrorMacro7("Error setting vertexDC in copy shader VAO.");
    }
  };
  publicAPI.traverse = (viewNode, renNode, forwardPass) => {
    if (model.deleted) {
      return;
    }
    const size = viewNode.getSize();
    const gl = viewNode.getContext();
    model._supported = false;
    if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension("EXT_color_buffer_half_float") && !gl.getExtension("EXT_color_buffer_float")) {
      publicAPI.setCurrentOperation("translucentPass");
      renNode.traverse(publicAPI);
      return;
    }
    model._supported = true;
    if (model.framebuffer === null) {
      publicAPI.createFramebuffer(viewNode);
    } else {
      const fbSize = model.framebuffer.getSize();
      if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.releaseGraphicsResources();
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        publicAPI.createFramebuffer(viewNode);
      } else {
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.bind();
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 0]);
    gl.clearBufferfv(gl.DEPTH, 0, [1]);
    gl.colorMask(false, false, false, false);
    if (forwardPass.getOpaqueActorCount() > 0) {
      forwardPass.setCurrentOperation("opaqueZBufferPass");
      renNode.traverse(forwardPass);
    }
    gl.colorMask(true, true, true, true);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
    gl.clearBufferfv(gl.COLOR, 1, [0, 0, 0, 0]);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
    publicAPI.setCurrentOperation("translucentPass");
    renNode.traverse(publicAPI);
    gl.drawBuffers([gl.NONE]);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    if (model.copyShader === null) {
      publicAPI.createCopyShader(viewNode);
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.copyShader);
    }
    if (!model.copyVAO) {
      model.copyVAO = vtkVertexArrayObject.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
    }
    model.copyVAO.bind();
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      publicAPI.createVBO(viewNode);
    }
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    gl.depthFunc(gl.ALWAYS);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    model.translucentRGBATexture.activate();
    model.copyShader.setUniformi("translucentRGBATexture", model.translucentRGBATexture.getTextureUnit());
    model.translucentRTexture.activate();
    model.copyShader.setUniformi("translucentRTexture", model.translucentRTexture.getTextureUnit());
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    model.translucentRGBATexture.deactivate();
    model.translucentRTexture.deactivate();
    const ts = renNode.getTiledSizeAndOrigin();
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
  };
  publicAPI.getShaderReplacement = () => {
    if (model._supported) {
      return translucentShaderReplacement;
    }
    return null;
  };
  publicAPI.releaseGraphicsResources = (viewNode) => {
    if (model.framebuffer) {
      model.framebuffer.releaseGraphicsResources(viewNode);
      model.framebuffer = null;
    }
    if (model.translucentRGBATexture) {
      model.translucentRGBATexture.releaseGraphicsResources(viewNode);
      model.translucentRGBATexture = null;
    }
    if (model.translucentRTexture) {
      model.translucentRTexture.releaseGraphicsResources(viewNode);
      model.translucentRTexture = null;
    }
    if (model.translucentZTexture) {
      model.translucentZTexture.releaseGraphicsResources(viewNode);
      model.translucentZTexture = null;
    }
    if (model.copyVAO) {
      model.copyVAO.releaseGraphicsResources(viewNode);
      model.copyVAO = null;
    }
    if (model.copyShader) {
      model.copyShader.releaseGraphicsResources(viewNode);
      model.copyShader = null;
    }
    if (model.tris) {
      model.tris.releaseGraphicsResources(viewNode);
      model.tris = null;
    }
    publicAPI.modified();
  };
}
var DEFAULT_VALUES12 = {
  framebuffer: null,
  copyShader: null,
  tris: null
};
function extend12(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  macro.get(publicAPI, model, ["framebuffer"]);
  vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend12, "vtkOpenGLOrderIndependentTranslucentPass");
var vtkOpenGLOrderIndependentTranslucentPass$1 = {
  newInstance: newInstance13,
  extend: extend12
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js
function vtkForwardPass(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    const numlayers = viewNode.getRenderable().getNumberOfLayers();
    const renderers = viewNode.getRenderable().getRenderersByReference();
    for (let i = 0; i < numlayers; i++) {
      for (let index = 0; index < renderers.length; index++) {
        const ren = renderers[index];
        const renNode = viewNode.getViewNodeFor(ren);
        if (ren.getDraw() && ren.getLayer() === i) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          model.overlayActorCount = 0;
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {
            const size = viewNode.getFramebufferSize();
            if (model.framebuffer === null) {
              model.framebuffer = vtkOpenGLFramebuffer.newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            const fbSize = model.framebuffer.getSize();
            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
              model.framebuffer.create(size[0], size[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            publicAPI.setCurrentOperation("zBufferPass");
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();
            model.depthRequested = false;
          }
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation("opaquePass");
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
            }
            model.translucentPass.traverse(viewNode, renNode, publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation("volumePass");
            renNode.traverse(publicAPI);
          }
          if (model.overlayActorCount > 0) {
            publicAPI.setCurrentOperation("overlayPass");
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };
  publicAPI.getZBufferTexture = () => {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };
  publicAPI.requestDepth = () => {
    model.depthRequested = true;
  };
  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
  publicAPI.incrementVolumeCount = () => model.volumeCount++;
  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;
}
var DEFAULT_VALUES13 = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumeCount: 0,
  overlayActorCount: 0,
  framebuffer: null,
  depthRequested: false
};
function extend13(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["framebuffer", "opaqueActorCount", "translucentActorCount", "volumeCount"]);
  vtkForwardPass(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend13, "vtkForwardPass");
var vtkForwardPass$1 = {
  newInstance: newInstance14,
  extend: extend13
};

// node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js
var {
  FieldAssociations
} = vtkDataSet$1;
function vtkHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkHardwareSelector");
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
  };
  publicAPI.selectAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    const srcData = await publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
    if (srcData) {
      return srcData.generateSelection(fx1, fy1, fx2, fy2);
    }
    return [];
  };
}
var DEFAULT_VALUES14 = {
  fieldAssociation: FieldAssociations.FIELD_ASSOCIATION_CELLS,
  captureZValues: false
};
function extend14(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["fieldAssociation", "captureZValues"]);
  vtkHardwareSelector(publicAPI, model);
}
var newInstance15 = macro.newInstance(extend14, "vtkHardwareSelector");
var vtkHardwareSelector$1 = {
  newInstance: newInstance15,
  extend: extend14
};

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
var SelectionContent = {
  GLOBALIDS: 0,
  PEDIGREEIDS: 1,
  VALUES: 2,
  INDICES: 3,
  FRUSTUM: 4,
  LOCATIONS: 5,
  THRESHOLDS: 6,
  BLOCKS: 7,
  QUERY: 8
};
var SelectionField = {
  CELL: 0,
  POINT: 1,
  FIELD: 2,
  VERTEX: 3,
  EDGE: 4,
  ROW: 5
};
var Constants3 = {
  SelectionContent,
  SelectionField
};

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js
function vtkSelectionNode(publicAPI, model) {
  model.classHierarchy.push("vtkSelectionNode");
  publicAPI.getBounds = () => model.points.getBounds();
}
var DEFAULT_VALUES15 = {
  contentType: -1,
  fieldType: -1,
  properties: null,
  selectionList: []
};
function extend15(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  macro.obj(publicAPI, model);
  model.properties = {};
  macro.setGet(publicAPI, model, ["contentType", "fieldType", "properties", "selectionList"]);
  vtkSelectionNode(publicAPI, model);
}
var newInstance16 = macro.newInstance(extend15, "vtkSelectionNode");
var vtkSelectionNode$1 = {
  newInstance: newInstance16,
  extend: extend15,
  ...Constants3
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js
var {
  PassTypes
} = Constants;
var {
  SelectionContent: SelectionContent2,
  SelectionField: SelectionField2
} = vtkSelectionNode$1;
var {
  FieldAssociations: FieldAssociations2
} = vtkDataSet$1;
var {
  vtkErrorMacro: vtkErrorMacro8
} = macro;
var idOffset = 1;
function getInfoHash(info) {
  return `${info.propID} ${info.compositeID}`;
}
function getAlpha(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  return pb[offset + 3];
}
function convert(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  const r = pb[offset];
  const g = pb[offset + 1];
  const b = pb[offset + 2];
  return (b * 256 + g) * 256 + r;
}
function getID(low24, high8) {
  let val = high8;
  val <<= 24;
  val |= low24;
  return val;
}
function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  const maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
      return null;
    }
    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);
    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
      return null;
    }
    const info2 = {};
    info2.valid = true;
    info2.propID = actorid - idOffset;
    info2.prop = buffdata.props[info2.propID];
    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    info2.compositeID = compositeID - idOffset;
    if (buffdata.captureZValues) {
      const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
      info2.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535;
      info2.displayPosition = inDisplayPosition;
    }
    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {
      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0) {
        return info2;
      }
    }
    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);
    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);
    info2.attributeID = getID(low24, high24);
    return info2;
  }
  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  const curPos = [0, 0];
  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info && info.valid) {
    return info;
  }
  for (let dist = 1; dist < maxDist; ++dist) {
    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist) {
        curPos[0] = dispPos[0] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist) {
        curPos[1] = dispPos[1] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
  const sel = [];
  let count = 0;
  dataMap.forEach((value, key) => {
    const child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent2.INDICES);
    switch (fieldassociation) {
      case FieldAssociations2.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField2.CELL);
        break;
      case FieldAssociations2.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField2.POINT);
        break;
      default:
        vtkErrorMacro8("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    child.getProperties().prop = value.info.prop;
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().attributeID = value.info.attributeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
  const x1 = Math.floor(fx1);
  const y1 = Math.floor(fy1);
  const x2 = Math.floor(fx2);
  const y2 = Math.floor(fy2);
  const dataMap = /* @__PURE__ */ new Map();
  const outSelectedPosition = [0, 0];
  for (let yy = y1; yy <= y2; yy++) {
    for (let xx = x1; xx <= x2; xx++) {
      const pos = [xx, yy];
      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
      if (info && info.valid) {
        const hash = getInfoHash(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          const dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
}
function vtkOpenGLHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHardwareSelector");
  publicAPI.releasePixBuffers = () => {
    model.rawPixBuffer = [];
    model.pixBuffer = [];
    model.zBuffer = null;
  };
  publicAPI.beginSelection = () => {
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer, model._openGLRenderer);
    model.maxAttributeId = 0;
    const size = model._openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size[0], size[1]);
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      const fbSize = model.framebuffer.getSize();
      if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }
    model._openGLRenderer.clear();
    model._openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.propPixels = {};
    model.props = [];
    publicAPI.releasePixBuffers();
    if (model.fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_POINTS) {
      const gl = model._openGLRenderWindow.getContext();
      const originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
      model._openGLRenderWindow.traverseAllPasses();
      if (originalBlending) {
        gl.enable(gl.BLEND);
      }
    }
  };
  publicAPI.endSelection = () => {
    model.hitProps = {};
    model._openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
  };
  publicAPI.preCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    model.originalBlending = gl.isEnabled(gl.BLEND);
    gl.disable(gl.BLEND);
  };
  publicAPI.postCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    if (model.originalBlending) {
      gl.enable(gl.BLEND);
    }
  };
  publicAPI.select = () => {
    let sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
      publicAPI.releasePixBuffers();
    }
    return sel;
  };
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    model._renderer = renderer;
    if (fx1 === void 0) {
      const size = model._openGLRenderWindow.getSize();
      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
    } else {
      publicAPI.setArea(fx1, fy1, fx2, fy2);
    }
    if (!publicAPI.captureBuffers()) {
      return false;
    }
    const result = {
      area: [...model.area],
      pixBuffer: [...model.pixBuffer],
      captureZValues: model.captureZValues,
      zBuffer: model.zBuffer,
      props: [...model.props],
      fieldAssociation: model.fieldAssociation,
      renderer,
      openGLRenderWindow: model._openGLRenderWindow
    };
    result.generateSelection = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return generateSelectionWithData(result, ...args);
    };
    return result;
  };
  publicAPI.captureBuffers = () => {
    if (!model._renderer || !model._openGLRenderWindow) {
      vtkErrorMacro8("Renderer and view must be set before calling Select.");
      return false;
    }
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer, model._openGLRenderer);
    model._openGLRenderWindow.getRenderable().preRender();
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.originalBackground = model._renderer.getBackgroundByReference();
    model._renderer.setBackground(0, 0, 0, 0);
    const rpasses = model._openGLRenderWindow.getRenderPasses();
    publicAPI.beginSelection();
    const pixelBufferSavedPasses = [];
    for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          rpasses[0].requestDepth();
          model._openGLRenderWindow.traverseAllPasses();
        } else {
          model._openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);
        publicAPI.savePixelBuffer(model.currentPass);
        pixelBufferSavedPasses.push(model.currentPass);
      }
    }
    pixelBufferSavedPasses.forEach((pass) => {
      model.currentPass = pass;
      publicAPI.processPixelBuffers();
    });
    model.currentPass = PassTypes.MAX_KNOWN_PASS;
    publicAPI.endSelection();
    model._renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    return true;
  };
  publicAPI.processPixelBuffers = () => {
    model.props.forEach((prop, index) => {
      if (publicAPI.isPropHit(index)) {
        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);
      }
    });
  };
  publicAPI.passRequired = (pass) => {
    if (pass === PassTypes.ID_HIGH24) {
      if (model.fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_POINTS) {
        return model.maximumPointId > 16777215;
      }
      if (model.fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_CELLS) {
        return model.maximumCellId > 16777215;
      }
    }
    return true;
  };
  publicAPI.savePixelBuffer = (passNo) => {
    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
    if (!model.rawPixBuffer[passNo]) {
      const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
      model.rawPixBuffer[passNo] = new Uint8Array(size);
      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
    }
    if (passNo === PassTypes.ACTOR_PASS) {
      if (model.captureZValues) {
        const rpasses = model._openGLRenderWindow.getRenderPasses();
        if (typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          const fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
    }
  };
  publicAPI.buildPropHitList = (pixelbuffer) => {
    let offset = 0;
    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
        let val = convert(xx, yy, pixelbuffer, model.area);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
            model.propPixels[val] = [];
          }
          model.propPixels[val].push(offset * 4);
        }
        ++offset;
      }
    }
  };
  publicAPI.renderProp = (prop) => {
    if (model.currentPass === PassTypes.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
      model.props.push(prop);
    }
  };
  publicAPI.renderCompositeIndex = (index) => {
    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index + idOffset);
    }
  };
  publicAPI.renderAttributeId = (attribid) => {
    if (attribid < 0) {
      return;
    }
    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;
  };
  publicAPI.passTypeToString = (type) => macro.enumToString(PassTypes, type);
  publicAPI.isPropHit = (id) => Boolean(model.hitProps[id]);
  publicAPI.setPropColorValueFromInt = (val) => {
    model.propColorValue[0] = val % 256 / 255;
    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255;
    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255;
  };
  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    console.log("getPixelInformation called", maxDist);
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
        return null;
      }
      console.log(inDisplayPosition);
      console.log(model.area);
      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
      console.log("adjusted displayPosition", displayPosition);
      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);
      console.log("actorid", actorid);
      if (actorid <= 0 || actorid - idOffset >= model.props.length) {
        return null;
      }
      const info2 = {};
      info2.valid = true;
      info2.propID = actorid - idOffset;
      info2.prop = model.props[info2.propID];
      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);
      if (compositeID < 0 || compositeID > 16777215) {
        compositeID = 0;
      }
      info2.compositeID = compositeID - idOffset;
      if (model.captureZValues) {
        const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
        info2.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535;
        info2.displayPosition = inDisplayPosition;
      }
      if (model.pixBuffer[PassTypes.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0) {
          return info2;
        }
      }
      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);
      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);
      info2.attributeID = getID(low24, high24);
      return info2;
    }
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (let dist = 1; dist < maxDist; ++dist) {
      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };
  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);
    const dataMap = /* @__PURE__ */ new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
  };
  publicAPI.getRawPixelBuffer = (passNo) => model.rawPixBuffer[passNo];
  publicAPI.getPixelBuffer = (passNo) => model.pixBuffer[passNo];
  publicAPI.attach = (openGLRenderWindow, renderer) => {
    model._openGLRenderWindow = openGLRenderWindow;
    model._renderer = renderer;
  };
  const superSetArea = publicAPI.setArea;
  publicAPI.setArea = function() {
    if (superSetArea(...arguments)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES16 = {
  area: void 0,
  // _renderer: null,
  // _openGLRenderWindow: null,
  // _openGLRenderer: null,
  currentPass: -1,
  propColorValue: null,
  props: null,
  maximumPointId: 0,
  maximumCellId: 0,
  idOffset: 1
};
function extend16(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model.propColorValue = [0, 0, 0];
  model.props = [];
  if (!model.area) {
    model.area = [0, 0, 0, 0];
  }
  macro.setGetArray(publicAPI, model, ["area"], 4);
  macro.setGet(publicAPI, model, ["_renderer", "currentPass", "_openGLRenderWindow", "maximumPointId", "maximumCellId"]);
  macro.setGetArray(publicAPI, model, ["propColorValue"], 3);
  macro.moveToProtected(publicAPI, model, ["renderer", "openGLRenderWindow"]);
  macro.event(publicAPI, model, "event");
  vtkOpenGLHardwareSelector(publicAPI, model);
}
var newInstance17 = macro.newInstance(extend16, "vtkOpenGLHardwareSelector");
var vtkHardwareSelector2 = {
  newInstance: newInstance17,
  extend: extend16,
  ...Constants
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js
var import_spark_md5 = __toESM(require_spark_md5(), 1);
var SET_GET_FIELDS = ["lastShaderProgramBound", "context", "_openGLRenderWindow"];
function vtkShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkShaderCache");
  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
    let nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "VSOut", "GSOut").result;
    }
    const gl2 = model._openGLRenderWindow.getWebgl2();
    let fragDepthString = "\n";
    let version = "#version 100\n";
    if (gl2) {
      version = "#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n";
    } else {
      model.context.getExtension("OES_standard_derivatives");
      if (model.context.getExtension("EXT_frag_depth")) {
        fragDepthString = "#extension GL_EXT_frag_depth : enable\n";
      }
      if (model.context.getExtension("EXT_shader_texture_lod")) {
        fragDepthString += "#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT";
      }
    }
    nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::System::Dec", [`${version}
`, gl2 ? "" : "#extension GL_OES_standard_derivatives : enable\n", fragDepthString, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    let nVSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::System::Dec", [`${version}
`, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    if (gl2) {
      nVSSource = vtkShaderProgram$1.substitute(nVSSource, "varying", "out").result;
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "varying", "in").result;
      let shaderOutputs = "";
      let outputCount = 0;
      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, `gl_FragData\\[${outputCount}\\]`, `fragOutput${outputCount}`).result;
        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};
`;
        outputCount++;
      }
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::Output::Dec", shaderOutputs).result;
    }
    const nGSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::System::Dec", version).result;
    return {
      VSSource: nVSSource,
      FSSource: nFSSource,
      GSSource: nGSSource
    };
  };
  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {
    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
    const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
    return publicAPI.readyShaderProgram(shaderProgram);
  };
  publicAPI.readyShaderProgram = (program) => {
    if (!program) {
      return null;
    }
    if (!program.getCompiled() && !program.compileShader()) {
      return null;
    }
    if (!publicAPI.bindShaderProgram(program)) {
      return null;
    }
    return program;
  };
  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
    const result = import_spark_md5.default.hash(hashInput);
    if (!(result in model.shaderPrograms)) {
      const sps = vtkShaderProgram$1.newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }
    return model.shaderPrograms[result];
  };
  publicAPI.releaseGraphicsResources = (win) => {
    publicAPI.releaseCurrentShaderProgram();
    Object.keys(model.shaderPrograms).map((key) => model.shaderPrograms[key]).forEach((sp) => sp.cleanup());
    model.shaderPrograms = {};
  };
  publicAPI.releaseCurrentShaderProgram = () => {
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.cleanup();
      model.lastShaderProgramBound = null;
    }
  };
  publicAPI.bindShaderProgram = (program) => {
    if (model.lastShaderProgramBound === program) {
      return 1;
    }
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.release();
    }
    program.bind();
    model.lastShaderProgramBound = program;
    return 1;
  };
}
var DEFAULT_VALUES17 = {
  lastShaderProgramBound: null,
  shaderPrograms: null,
  context: null
  // _openGLRenderWindow: null,
};
function extend17(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  model.shaderPrograms = {};
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, SET_GET_FIELDS);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkShaderCache(publicAPI, model);
}
var newInstance18 = macro.newInstance(extend17, "vtkShaderCache");
var vtkShaderCache$1 = {
  newInstance: newInstance18,
  extend: extend17
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js
var {
  vtkErrorMacro: vtkErrorMacro9
} = macro;
function vtkOpenGLTextureUnitManager(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTextureUnitManager");
  publicAPI.deleteTable = () => {
    for (let i = 0; i < model.numberOfTextureUnits; ++i) {
      if (model.textureUnits[i] === true) {
        vtkErrorMacro9("some texture units  were not properly released");
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };
  publicAPI.setContext = (ctx) => {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (let i = 0; i < model.numberOfTextureUnits; ++i) {
          model.textureUnits[i] = false;
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.allocate = () => {
    for (let i = 0; i < model.numberOfTextureUnits; i++) {
      if (!publicAPI.isAllocated(i)) {
        model.textureUnits[i] = true;
        return i;
      }
    }
    return -1;
  };
  publicAPI.allocateUnit = (unit) => {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }
    model.textureUnits[unit] = true;
    return unit;
  };
  publicAPI.isAllocated = (textureUnitId) => model.textureUnits[textureUnitId];
  publicAPI.free = (val) => {
    model.textureUnits[val] = false;
  };
  publicAPI.freeAll = () => {
    for (let i = 0; i < model.numberOfTextureUnits; ++i) {
      model.textureUnits[i] = false;
    }
  };
}
var DEFAULT_VALUES18 = {
  context: null,
  numberOfTextureUnits: 0,
  textureUnits: 0
};
function extend18(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  macro.obj(publicAPI, model);
  model.textureUnits = [];
  macro.get(publicAPI, model, ["numberOfTextureUnits"]);
  macro.setGet(publicAPI, model, ["context"]);
  vtkOpenGLTextureUnitManager(publicAPI, model);
}
var newInstance19 = macro.newInstance(extend18, "vtkOpenGLTextureUnitManager");
var vtkTextureUnitManager = {
  newInstance: newInstance19,
  extend: extend18
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js
function vtkRenderWindowViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowViewNode");
  publicAPI.getViewNodeFactory = () => null;
  publicAPI.getAspectRatio = () => model.size[0] / model.size[1];
  publicAPI.getAspectRatioForRenderer = (renderer) => {
    const viewport = renderer.getViewportByReference();
    return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
  };
  publicAPI.isInViewport = (x, y, viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
      return true;
    }
    return false;
  };
  publicAPI.getViewportSize = (viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
  };
  publicAPI.getViewportCenter = (viewport) => {
    const size = publicAPI.getViewportSize(viewport);
    return [size[0] * 0.5, size[1] * 0.5];
  };
  publicAPI.displayToNormalizedDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x / size[0], y / size[1], z];
  };
  publicAPI.normalizedDisplayToDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x * size[0], y * size[1], z];
  };
  publicAPI.worldToView = (x, y, z, renderer) => renderer.worldToView(x, y, z);
  publicAPI.viewToWorld = (x, y, z, renderer) => renderer.viewToWorld(x, y, z);
  publicAPI.worldToDisplay = (x, y, z, renderer) => {
    const val = renderer.worldToView(x, y, z);
    const dims = publicAPI.getViewportSize(renderer);
    const val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
    const val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };
  publicAPI.displayToWorld = (x, y, z, renderer) => {
    const val = publicAPI.displayToNormalizedDisplay(x, y, z);
    const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    const dims = publicAPI.getViewportSize(renderer);
    const val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };
  publicAPI.normalizedDisplayToViewport = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    const coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
  };
  publicAPI.viewportToNormalizedViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    if (size && size[0] !== 0 && size[1] !== 0) {
      return [x / (size[0] - 1), y / (size[1] - 1), z];
    }
    return [x, y, z];
  };
  publicAPI.normalizedViewportToViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    return [x * (size[0] - 1), y * (size[1] - 1), z];
  };
  publicAPI.displayToLocalDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x, size[1] - y - 1, z];
  };
  publicAPI.viewportToNormalizedDisplay = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    const x2 = x + vCoords[0] + 0.5;
    const y2 = y + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x2, y2, z);
  };
  publicAPI.getComputedDevicePixelRatio = () => model.size[0] / publicAPI.getContainerSize()[0];
  publicAPI.getContainerSize = () => {
    macro.vtkErrorMacro("not implemented");
  };
  publicAPI.getPixelData = (x1, y1, x2, y2) => {
    macro.vtkErrorMacro("not implemented");
  };
  publicAPI.createSelector = () => {
    macro.vtkErrorMacro("not implemented");
  };
}
var DEFAULT_VALUES19 = {
  size: void 0,
  selector: void 0
};
function extend19(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  if (!model.size) {
    model.size = [300, 300];
  }
  macro.getArray(publicAPI, model, ["size"], 2);
  macro.get(publicAPI, model, ["selector"]);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkRenderWindowViewNode(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend19, "vtkRenderWindowViewNode");
var vtkRenderWindowViewNode$1 = {
  newInstance: newInstance20,
  extend: extend19
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/ContextProxy.js
var GET_UNDERLYING_CONTEXT = "__getUnderlyingContext";
function createContextProxyHandler() {
  const cache = /* @__PURE__ */ new Map();
  const getParameterHandler = {
    apply(target, gl, args) {
      if (cache.has(args[0])) {
        return cache.get(args[0]);
      }
      return target.apply(gl, args);
    }
  };
  function cachedSetterHandler(key) {
    return {
      apply(target, gl, args) {
        cache.set(key, args[0]);
        return target.apply(gl, args);
      }
    };
  }
  const propHandlers = /* @__PURE__ */ Object.create(null);
  propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler);
  propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
  return {
    get(gl, prop, receiver) {
      if (prop === GET_UNDERLYING_CONTEXT) return () => gl;
      let value = Reflect.get(gl, prop, gl);
      if (value instanceof Function) {
        value = value.bind(gl);
      }
      const propHandler = propHandlers[prop];
      if (propHandler) {
        return propHandler(gl, prop, receiver, value);
      }
      return value;
    }
  };
}

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js
var {
  vtkDebugMacro: vtkDebugMacro3,
  vtkErrorMacro: vtkErrorMacro10
} = macro;
var SCREENSHOT_PLACEHOLDER = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%"
};
var parentMethodsToProxy = ["activateTexture", "deactivateTexture", "disableCullFace", "enableCullFace", "get3DContext", "getActiveFramebuffer", "getContext", "getDefaultTextureByteSize", "getDefaultTextureInternalFormat", "getDefaultToWebgl2", "getGLInformations", "getGraphicsMemoryInfo", "getGraphicsResourceForObject", "getHardwareMaximumLineWidth", "getPixelData", "getShaderCache", "getTextureUnitForTexture", "getTextureUnitManager", "getWebgl2", "makeCurrent", "releaseGraphicsResources", "registerGraphicsResourceUser", "unregisterGraphicsResourceUser", "restoreContext", "setActiveFramebuffer", "setContext", "setDefaultToWebgl2", "setGraphicsResourceForObject"];
function checkRenderTargetSupport(gl, format, type) {
  const framebuffer = gl.createFramebuffer();
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return status === gl.FRAMEBUFFER_COMPLETE;
}
var GL_CONTEXT_COUNT = 0;
var GL_CONTEXT_LISTENERS = [];
function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}
function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}
function pushMonitorGLContextCount(cb) {
  GL_CONTEXT_LISTENERS.push(cb);
}
function popMonitorGLContextCount(cb) {
  return GL_CONTEXT_LISTENERS.pop();
}
function _preventDefault(e) {
  e.preventDefault();
}
function vtkOpenGLRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderWindow");
  let cachingContextHandler;
  function getCachingContextHandler() {
    if (!cachingContextHandler) {
      cachingContextHandler = createContextProxyHandler();
    }
    return cachingContextHandler;
  }
  publicAPI.getViewNodeFactory = () => model.myFactory;
  model.canvas.addEventListener("webglcontextlost", _preventDefault, false);
  model.canvas.addEventListener("webglcontextrestored", publicAPI.restoreContext, false);
  const previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.addMissingNodes(model.renderable.getChildRenderWindowsByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
      model.children.forEach((child) => {
        var _a;
        (_a = child.setOpenGLRenderWindow) == null ? void 0 : _a.call(child, publicAPI);
      });
    }
  };
  publicAPI.initialize = () => {
    if (!model.initialized) {
      model.rootOpenGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (model.rootOpenGLRenderWindow) {
        model.context2D = publicAPI.get2DContext();
      } else {
        model.context = publicAPI.get3DContext();
        publicAPI.resizeFromChildRenderWindows();
        if (model.context) {
          createGLContext();
        }
        model.textureUnitManager = vtkTextureUnitManager.newInstance();
        model.textureUnitManager.setContext(model.context);
        model.shaderCache.setContext(model.context);
        const gl = model.context;
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.BLEND);
      }
      model.initialized = true;
    }
  };
  publicAPI.makeCurrent = () => {
    model.context.makeCurrent();
  };
  publicAPI.setContainer = (el) => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro10("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = () => model.el;
  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const {
        width,
        height
      } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = () => {
    var _a;
    const fbSize = (_a = model.activeFramebuffer) == null ? void 0 : _a.getSize();
    return fbSize || model.size;
  };
  publicAPI.getPixelData = (x1, y1, x2, y2) => {
    const pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
    model.context.readPixels(x1, y1, x2 - x1 + 1, y2 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
    return pixels;
  };
  publicAPI.get3DContext = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      preserveDrawingBuffer: false,
      depth: true,
      alpha: true,
      powerPreference: "high-performance"
    };
    let result = null;
    const webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext("webgl2", options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro3("using webgl2");
      }
    }
    if (!result) {
      vtkDebugMacro3("using webgl1");
      result = model.canvas.getContext("webgl", options) || model.canvas.getContext("experimental-webgl", options);
    }
    if (!result) {
      vtkErrorMacro10("no webgl context");
    }
    return new Proxy(result, getCachingContextHandler());
  };
  publicAPI.get2DContext = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return model.canvas.getContext("2d", options);
  };
  publicAPI.restoreContext = () => {
    const rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
  };
  publicAPI.activateTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }
    const activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      vtkErrorMacro10("Hardware does not support the number of textures defined.");
      return;
    }
    model._textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };
  publicAPI.deactivateTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      publicAPI.getTextureUnitManager().free(result);
      model._textureResourceIds.delete(texture);
    }
  };
  publicAPI.getTextureUnitForTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      return result;
    }
    return -1;
  };
  publicAPI.getDefaultTextureByteSize = function(vtkType) {
    let oglNorm16Ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let useHalfFloat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (model.webgl2) {
      switch (vtkType) {
        case VtkDataTypes.CHAR:
        case VtkDataTypes.SIGNED_CHAR:
        case VtkDataTypes.UNSIGNED_CHAR:
          return 1;
        case oglNorm16Ext:
        case useHalfFloat:
        case VtkDataTypes.UNSIGNED_SHORT:
        case VtkDataTypes.SHORT:
        case VtkDataTypes.VOID:
          return 2;
        default:
          return 4;
      }
    }
    return 1;
  };
  publicAPI.getDefaultTextureInternalFormat = function(vtktype, numComps) {
    let oglNorm16Ext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    let useHalfFloat = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (model.webgl2) {
      switch (vtktype) {
        case VtkDataTypes.UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT):
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_EXT;
            case 2:
              return oglNorm16Ext.RG16_EXT;
            case 3:
              return oglNorm16Ext.RGB16_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_EXT;
          }
        case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.SHORT):
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_SNORM_EXT;
            case 2:
              return oglNorm16Ext.RG16_SNORM_EXT;
            case 3:
              return oglNorm16Ext.RGB16_SNORM_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_SNORM_EXT;
          }
        case VtkDataTypes.UNSIGNED_SHORT:
        case VtkDataTypes.SHORT:
        case VtkDataTypes.FLOAT:
        default:
          switch (numComps) {
            case 1:
              return useHalfFloat ? model.context.R16F : model.context.R32F;
            case 2:
              return useHalfFloat ? model.context.RG16F : model.context.RG32F;
            case 3:
              return useHalfFloat ? model.context.RGB16F : model.context.RGB32F;
            case 4:
            default:
              return useHalfFloat ? model.context.RGBA16F : model.context.RGBA32F;
          }
      }
    }
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };
  publicAPI.setBackgroundImage = (img) => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = (value) => {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
    const temporaryCanvas = document.createElement("canvas");
    const temporaryContext = temporaryCanvas.getContext("2d");
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);
    const mainBoundingClientRect = model.canvas.getBoundingClientRect();
    const renderWindow = model.renderable;
    const renderers = renderWindow.getRenderers();
    renderers.forEach((renderer) => {
      const viewProps = renderer.getViewProps();
      viewProps.forEach((viewProp) => {
        if (viewProp.getContainer) {
          const container = viewProp.getContainer();
          const canvasList = container.getElementsByTagName("canvas");
          for (let i = 0; i < canvasList.length; i++) {
            const currentCanvas = canvasList[i];
            const boundingClientRect = currentCanvas.getBoundingClientRect();
            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    const screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    let {
      resetCamera = false,
      size = null,
      scale = 1
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale !== 1 ? size || model.size.map((val) => val * scale) : null
    };
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady((imageURL) => {
        var _a;
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach((_ref) => {
                let {
                  restoreParamsFn,
                  arg
                } = _ref;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          const tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          (_a = model.rootOpenGLRenderWindow) == null ? void 0 : _a.resizeFromChildRenderWindows();
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            const isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map((renderer) => {
              const camera = renderer.getActiveCamera();
              const params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : void 0,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                // "clone" the params so we don't keep refs to properties
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach((_ref2) => {
              let {
                resetCameraFn,
                resetCameraArgs
              } = _ref2;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  let hardwareMaximumLineWidth;
  publicAPI.getHardwareMaximumLineWidth = () => {
    if (hardwareMaximumLineWidth != null) {
      return hardwareMaximumLineWidth;
    }
    const gl = publicAPI.get3DContext();
    const lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    hardwareMaximumLineWidth = lineWidthRange[1];
    return lineWidthRange[1];
  };
  publicAPI.getGLInformations = () => {
    if (model._glInformation) {
      return model._glInformation;
    }
    const gl = publicAPI.get3DContext();
    const glTextureFloat = gl.getExtension("OES_texture_float");
    const glTextureHalfFloat = gl.getExtension("OES_texture_half_float");
    const glDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const glDrawBuffers = gl.getExtension("WEBGL_draw_buffers");
    const glAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
    const params = [["Max Vertex Attributes", "MAX_VERTEX_ATTRIBS", gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ["Max Varying Vectors", "MAX_VARYING_VECTORS", gl.getParameter(gl.MAX_VARYING_VECTORS)], ["Max Vertex Uniform Vectors", "MAX_VERTEX_UNIFORM_VECTORS", gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ["Max Fragment Uniform Vectors", "MAX_FRAGMENT_UNIFORM_VECTORS", gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ["Max Fragment Texture Image Units", "MAX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ["Max Vertex Texture Image Units", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ["Max Combined Texture Image Units", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ["Max 2D Texture Size", "MAX_TEXTURE_SIZE", gl.getParameter(gl.MAX_TEXTURE_SIZE)], ["Max Cube Texture Size", "MAX_CUBE_MAP_TEXTURE_SIZE", gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ["Max Texture Anisotropy", "MAX_TEXTURE_MAX_ANISOTROPY_EXT", glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ["Point Size Range", "ALIASED_POINT_SIZE_RANGE", gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(" - ")], ["Line Width Range", "ALIASED_LINE_WIDTH_RANGE", gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(" - ")], ["Max Viewport Dimensions", "MAX_VIEWPORT_DIMS", gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(" - ")], ["Max Renderbuffer Size", "MAX_RENDERBUFFER_SIZE", gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ["Framebuffer Red Bits", "RED_BITS", gl.getParameter(gl.RED_BITS)], ["Framebuffer Green Bits", "GREEN_BITS", gl.getParameter(gl.GREEN_BITS)], ["Framebuffer Blue Bits", "BLUE_BITS", gl.getParameter(gl.BLUE_BITS)], ["Framebuffer Alpha Bits", "ALPHA_BITS", gl.getParameter(gl.ALPHA_BITS)], ["Framebuffer Depth Bits", "DEPTH_BITS", gl.getParameter(gl.DEPTH_BITS)], ["Framebuffer Stencil Bits", "STENCIL_BITS", gl.getParameter(gl.STENCIL_BITS)], ["Framebuffer Subpixel Bits", "SUBPIXEL_BITS", gl.getParameter(gl.SUBPIXEL_BITS)], ["MSAA Samples", "SAMPLES", gl.getParameter(gl.SAMPLES)], ["MSAA Sample Buffers", "SAMPLE_BUFFERS", gl.getParameter(gl.SAMPLE_BUFFERS)], ["Supported Formats for UByte Render Targets     ", "UNSIGNED_BYTE RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Half Float Render Targets", "HALF FLOAT RENDER TARGET FORMATS", [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGBA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGB" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "ALPHA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Full Float Render Targets", "FLOAT RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Max Multiple Render Targets Buffers", "MAX_DRAW_BUFFERS_WEBGL", glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ["High Float Precision in Vertex Shader", "HIGH_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Vertex Shader", "MEDIUM_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Vertex Shader", "LOW_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Float Precision in Fragment Shader", "HIGH_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Fragment Shader", "MEDIUM_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Fragment Shader", "LOW_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Vertex Shader", "HIGH_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Vertex Shader", "MEDIUM_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Vertex Shader", "LOW_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Fragment Shader", "HIGH_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Fragment Shader", "MEDIUM_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Fragment Shader", "LOW_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["Supported Extensions", "EXTENSIONS", gl.getSupportedExtensions().join("<br/>					    ")], ["WebGL Renderer", "RENDERER", gl.getParameter(gl.RENDERER)], ["WebGL Vendor", "VENDOR", gl.getParameter(gl.VENDOR)], ["WebGL Version", "VERSION", gl.getParameter(gl.VERSION)], ["Shading Language Version", "SHADING_LANGUAGE_VERSION", gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ["Unmasked Renderer", "UNMASKED_RENDERER", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ["Unmasked Vendor", "UNMASKED_VENDOR", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ["WebGL Version", "WEBGL_VERSION", model.webgl2 ? 2 : 1]];
    const result = {};
    while (params.length) {
      const [label, key, value] = params.pop();
      if (key) {
        result[key] = {
          label,
          value
        };
      }
    }
    model._glInformation = result;
    return result;
  };
  publicAPI.traverseAllPasses = () => {
    var _a;
    if (model.renderPasses) {
      for (let index = 0; index < model.renderPasses.length; ++index) {
        model.renderPasses[index].traverse(publicAPI, null);
      }
    }
    publicAPI.copyParentContent();
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    for (let i = 0; i < childrenRW.length; ++i) {
      (_a = publicAPI.getViewNodeFor(childrenRW[i])) == null ? void 0 : _a.traverseAllPasses();
    }
  };
  publicAPI.copyParentContent = () => {
    const rootParent = model.rootOpenGLRenderWindow;
    if (!rootParent || !model.context2D || model.children.some((oglRenderer) => {
      var _a;
      return !!((_a = oglRenderer.getSelector) == null ? void 0 : _a.call(oglRenderer));
    })) {
      return;
    }
    const parentCanvas = rootParent.getCanvas();
    const selfCanvas = model.canvas;
    model.context2D.drawImage(
      parentCanvas,
      0,
      parentCanvas.height - selfCanvas.height,
      // source y axis is inverted
      selfCanvas.width,
      selfCanvas.height,
      0,
      0,
      selfCanvas.width,
      selfCanvas.height
    );
  };
  publicAPI.resizeFromChildRenderWindows = () => {
    var _a;
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    if (childrenRW.length > 0) {
      const maxSize = [0, 0];
      for (let i = 0; i < childrenRW.length; ++i) {
        const childSize = (_a = publicAPI.getViewNodeFor(childrenRW[i])) == null ? void 0 : _a.getSize();
        if (childSize) {
          maxSize[0] = childSize[0] > maxSize[0] ? childSize[0] : maxSize[0];
          maxSize[1] = childSize[1] > maxSize[1] ? childSize[1] : maxSize[1];
        }
      }
      publicAPI.setSize(...maxSize);
    }
  };
  publicAPI.disableCullFace = () => {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };
  publicAPI.enableCullFace = () => {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };
  publicAPI.setViewStream = (stream) => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady((e) => publicAPI.setBackgroundImage(e.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.createSelector = () => {
    const ret = vtkHardwareSelector2.newInstance();
    ret.setOpenGLRenderWindow(publicAPI);
    return ret;
  };
  function clearEvents() {
    model.canvas.removeEventListener("webglcontextlost", _preventDefault);
    model.canvas.removeEventListener("webglcontextrestored", publicAPI.restoreContext);
  }
  publicAPI.delete = macro.chain(() => {
    if (model.context) {
      deleteGLContext();
    }
    publicAPI.setContainer();
    publicAPI.setViewStream();
  }, clearEvents, publicAPI.delete);
  publicAPI.setActiveFramebuffer = (newActiveFramebuffer) => {
    model.activeFramebuffer = newActiveFramebuffer;
  };
  const superSetSize = publicAPI.setSize;
  publicAPI.setSize = (width, height) => {
    const modified = superSetSize(width, height);
    if (modified) {
      publicAPI.invokeWindowResizeEvent({
        width,
        height
      });
    }
    return modified;
  };
  publicAPI.registerGraphicsResourceUser = (coreObject, newUser) => {
    if (!model._graphicsResources.has(coreObject)) {
      publicAPI.setGraphicsResourceForObject(coreObject, null, null);
    }
    const sharedResource = model._graphicsResources.get(coreObject);
    sharedResource == null ? void 0 : sharedResource.users.add(newUser);
  };
  publicAPI.unregisterGraphicsResourceUser = (coreObject, oldUser) => {
    var _a;
    const sharedResource = model._graphicsResources.get(coreObject);
    if (!sharedResource) {
      return;
    }
    sharedResource.users.delete(oldUser);
    if (!sharedResource.users.size) {
      (_a = sharedResource.oglObject) == null ? void 0 : _a.releaseGraphicsResources(publicAPI);
      model._graphicsResources.delete(coreObject);
    }
  };
  publicAPI.getGraphicsResourceForObject = (coreObject) => model._graphicsResources.get(coreObject);
  publicAPI.setGraphicsResourceForObject = (coreObject, oglObject, hash) => {
    var _a;
    if (!coreObject) {
      return;
    }
    const sharedResource = model._graphicsResources.get(coreObject);
    (_a = sharedResource == null ? void 0 : sharedResource.oglObject) == null ? void 0 : _a.releaseGraphicsResources(publicAPI);
    model._graphicsResources.set(coreObject, {
      coreObject,
      oglObject,
      hash,
      users: (sharedResource == null ? void 0 : sharedResource.users) ?? /* @__PURE__ */ new Set()
    });
  };
  publicAPI.getGraphicsMemoryInfo = () => {
    let memUsed = 0;
    model._graphicsResources.forEach((_ref3) => {
      let {
        oglObject
      } = _ref3;
      memUsed += oglObject.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.shaderCache !== null) {
      model.shaderCache.releaseGraphicsResources(publicAPI);
    }
    model._graphicsResources.forEach((_ref4) => {
      let {
        oglObject
      } = _ref4;
      oglObject.releaseGraphicsResources(publicAPI);
    });
    model._graphicsResources.clear();
    if (model.textureUnitManager !== null) {
      model.textureUnitManager.freeAll();
    }
    model.renderable.getRenderersByReference().forEach((ren) => {
      const glRen = publicAPI.getViewNodeFor(ren);
      glRen == null ? void 0 : glRen.releaseGraphicsResources();
    });
  };
  const publicAPIBeforeProxy = {
    ...publicAPI
  };
  parentMethodsToProxy.forEach((methodName) => {
    publicAPI[methodName] = function() {
      if (model.rootOpenGLRenderWindow) {
        return model.rootOpenGLRenderWindow[methodName](...arguments);
      }
      return publicAPIBeforeProxy[methodName](...arguments);
    };
  });
}
var DEFAULT_VALUES20 = {
  cullFaceEnabled: false,
  shaderCache: null,
  initialized: false,
  context: null,
  context2D: null,
  canvas: null,
  cursorVisibility: true,
  cursor: "pointer",
  textureUnitManager: null,
  textureResourceIds: null,
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  webgl2: false,
  defaultToWebgl2: true,
  // attempt webgl2 on by default
  activeFramebuffer: null,
  imageFormat: "image/png",
  useOffScreen: false,
  useBackgroundImage: false
};
function extend20(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  if (!model.canvas) {
    model.canvas = document.createElement("canvas");
    model.canvas.style.width = "100%";
  }
  if (!model.selector) {
    model.selector = vtkHardwareSelector2.newInstance();
    model.selector.setOpenGLRenderWindow(publicAPI);
  }
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  model._textureResourceIds = /* @__PURE__ */ new Map();
  model._graphicsResources = /* @__PURE__ */ new Map();
  model._glInformation = null;
  model.myFactory = vtkViewNodeFactory.newInstance();
  model.shaderCache = vtkShaderCache$1.newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);
  model.renderPasses[0] = vtkForwardPass$1.newInstance();
  macro.get(publicAPI, model, ["shaderCache", "textureUnitManager", "webgl2", "useBackgroundImage", "activeFramebuffer", "rootOpenGLRenderWindow"]);
  macro.setGet(publicAPI, model, ["initialized", "context", "context2D", "canvas", "renderPasses", "notifyStartCaptureImage", "defaultToWebgl2", "cursor", "useOffScreen"]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "windowResizeEvent");
  vtkOpenGLRenderWindow(publicAPI, model);
}
var newInstance21 = macro.newInstance(extend20, "vtkOpenGLRenderWindow");
registerViewConstructor("WebGL", newInstance21);
var vtkRenderWindow2 = {
  newInstance: newInstance21,
  extend: extend20,
  pushMonitorGLContextCount,
  popMonitorGLContextCount
};
registerOverride("vtkRenderWindow", newInstance21);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderEncoder.js
var forwarded = ["setBindGroup", "setIndexBuffer", "setVertexBuffer", "draw", "drawIndexed"];
function vtkWebGPURenderEncoder(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderEncoder");
  publicAPI.begin = (encoder) => {
    model.drawCallbacks = [];
    model.handle = encoder.beginRenderPass(model.description);
    if (model.label) {
      model.handle.pushDebugGroup(model.label);
    }
  };
  publicAPI.end = () => {
    for (let i = 0; i < model.drawCallbacks.length; i++) {
      const pStruct = model.drawCallbacks[i];
      const pl = pStruct.pipeline;
      publicAPI.setPipeline(pl);
      for (let cb = 0; cb < pStruct.callbacks.length; cb++) {
        pStruct.callbacks[cb](publicAPI);
      }
    }
    if (model.label) {
      model.handle.popDebugGroup();
    }
    model.handle.end();
    model.boundPipeline = null;
  };
  publicAPI.setPipeline = (pl) => {
    var _a, _b;
    if (model.boundPipeline === pl) {
      return;
    }
    model.handle.setPipeline(pl.getHandle());
    const pd = pl.getPipelineDescription();
    if (model.colorTextureViews.length !== pd.fragment.targets.length) {
      console.log(`mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`);
      console.trace();
    } else {
      for (let i = 0; i < model.colorTextureViews.length; i++) {
        const fmt = (_a = model.colorTextureViews[i].getTexture()) == null ? void 0 : _a.getFormat();
        if (fmt && fmt !== pd.fragment.targets[i].format) {
          console.log(`mismatched attachments for attachment ${i} on pipeline ${pd.fragment.targets[i].format} while encoder has ${fmt}`);
          console.trace();
        }
      }
    }
    if (!model.depthTextureView !== !("depthStencil" in pd)) {
      console.log("mismatched depth attachments");
      console.trace();
    } else if (model.depthTextureView) {
      const dfmt = (_b = model.depthTextureView.getTexture()) == null ? void 0 : _b.getFormat();
      if (dfmt && dfmt !== pd.depthStencil.format) {
        console.log(`mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`);
        console.trace();
      }
    }
    model.boundPipeline = pl;
  };
  publicAPI.replaceShaderCode = (pipeline) => {
    model.replaceShaderCodeFunction(pipeline);
  };
  publicAPI.setColorTextureView = (idx, view) => {
    if (model.colorTextureViews[idx] === view) {
      return;
    }
    model.colorTextureViews[idx] = view;
  };
  publicAPI.activateBindGroup = (bg) => {
    const device = model.boundPipeline.getDevice();
    const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());
    model.handle.setBindGroup(midx, bg.getBindGroup(device));
    const bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));
    const bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));
    if (bgl1 !== bgl2) {
      console.log(`renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has
${bgl1}
 versus pipeline
${bgl2}
`);
      console.trace();
    }
  };
  publicAPI.attachTextureViews = () => {
    for (let i = 0; i < model.colorTextureViews.length; i++) {
      if (!model.description.colorAttachments[i]) {
        model.description.colorAttachments[i] = {
          view: model.colorTextureViews[i].getHandle()
        };
      } else {
        model.description.colorAttachments[i].view = model.colorTextureViews[i].getHandle();
      }
    }
    if (model.depthTextureView) {
      model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();
    }
  };
  publicAPI.registerDrawCallback = (pipeline, cb) => {
    for (let i = 0; i < model.drawCallbacks.length; i++) {
      if (model.drawCallbacks[i].pipeline === pipeline) {
        model.drawCallbacks[i].callbacks.push(cb);
        return;
      }
    }
    model.drawCallbacks.push({
      pipeline,
      callbacks: [cb]
    });
  };
  for (let i = 0; i < forwarded.length; i++) {
    publicAPI[forwarded[i]] = function() {
      return model.handle[forwarded[i]](...arguments);
    };
  }
}
var DEFAULT_VALUES21 = {
  description: null,
  handle: null,
  boundPipeline: null,
  pipelineHash: null,
  pipelineSettings: null,
  replaceShaderCodeFunction: null,
  depthTextureView: null,
  label: null
};
function extend21(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  obj(publicAPI, model);
  model.description = {
    colorAttachments: [{
      view: void 0,
      loadOp: "load",
      storeOp: "store"
    }],
    depthStencilAttachment: {
      view: void 0,
      depthLoadOp: "clear",
      depthClearValue: 0,
      depthStoreOp: "store"
    }
  };
  model.replaceShaderCodeFunction = (pipeline) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addOutput("vec4<f32>", "outColor");
    let code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = computedColor;"]).result;
    fDesc.setCode(code);
  };
  model.pipelineSettings = {
    primitive: {
      cullMode: "none"
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: "greater-equal",
      format: "depth32float"
    },
    fragment: {
      targets: [{
        format: "rgba16float",
        blend: {
          color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha"
          },
          alpha: {
            srcFactor: "one",
            dstFactor: "one-minus-src-alpha"
          }
        }
      }]
    }
  };
  model.colorTextureViews = [];
  get(publicAPI, model, ["boundPipeline", "colorTextureViews"]);
  setGet(publicAPI, model, ["depthTextureView", "description", "handle", "label", "pipelineHash", "pipelineSettings", "replaceShaderCodeFunction"]);
  vtkWebGPURenderEncoder(publicAPI, model);
}
var newInstance22 = newInstance(extend21, "vtkWebGPURenderEncoder");
var vtkWebGPURenderEncoder$1 = {
  newInstance: newInstance22,
  extend: extend21
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/OpaquePass.js
function vtkWebGPUOpaquePass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUOpaquePass");
  publicAPI.traverse = (renNode, viewNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = viewNode;
    const device = viewNode.getDevice();
    if (!model.renderEncoder) {
      publicAPI.createRenderEncoder();
      model.colorTexture = vtkWebGPUTexture$1.newInstance({
        label: "opaquePassColor"
      });
      model.colorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba16float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      const ctView = model.colorTexture.createView("opaquePassColorTexture");
      model.renderEncoder.setColorTextureView(0, ctView);
      model.depthFormat = "depth32float";
      model.depthTexture = vtkWebGPUTexture$1.newInstance({
        label: "opaquePassDepth"
      });
      model.depthTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: model.depthFormat,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      const dView = model.depthTexture.createView("opaquePassDepthTexture");
      model.renderEncoder.setDepthTextureView(dView);
    } else {
      model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      model.depthTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
    }
    model.renderEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("opaquePass");
    renNode.setRenderEncoder(model.renderEncoder);
    renNode.traverse(publicAPI);
  };
  publicAPI.getColorTextureView = () => model.renderEncoder.getColorTextureViews()[0];
  publicAPI.getDepthTextureView = () => model.renderEncoder.getDepthTextureView();
  publicAPI.createRenderEncoder = () => {
    model.renderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "OpaquePass"
    });
    model.renderEncoder.setPipelineHash("op");
  };
}
var DEFAULT_VALUES22 = {
  renderEncoder: null,
  colorTexture: null,
  depthTexture: null
};
function extend22(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES22, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
  vtkWebGPUOpaquePass(publicAPI, model);
}
var newInstance23 = macro.newInstance(extend22, "vtkWebGPUOpaquePass");
var vtkWebGPUOpaquePass$1 = {
  newInstance: newInstance23,
  extend: extend22
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/OrderIndependentTranslucentPass.js
var oitpFragTemplate2 = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));
  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;
  if (reveal == 1.0) { discard; }
  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);
  var total: f32 = max(tcolor.a, 0.01);
  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass");
  publicAPI.traverse = (renNode, viewNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = viewNode;
    const device = viewNode.getDevice();
    if (!model.translucentRenderEncoder) {
      publicAPI.createRenderEncoder();
      publicAPI.createFinalEncoder();
      model.translucentColorTexture = vtkWebGPUTexture$1.newInstance({
        label: "translucentPassColor"
      });
      model.translucentColorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba16float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const v1 = model.translucentColorTexture.createView("oitpColorTexture");
      model.translucentRenderEncoder.setColorTextureView(0, v1);
      model.translucentAccumulateTexture = vtkWebGPUTexture$1.newInstance({
        label: "translucentPassAccumulate"
      });
      model.translucentAccumulateTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "r16float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const v2 = model.translucentAccumulateTexture.createView("oitpAccumTexture");
      model.translucentRenderEncoder.setColorTextureView(1, v2);
      model.fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model.fullScreenQuad.setDevice(viewNode.getDevice());
      model.fullScreenQuad.setPipelineHash("oitpfsq");
      model.fullScreenQuad.setTextureViews(model.translucentRenderEncoder.getColorTextureViews());
      model.fullScreenQuad.setFragmentShaderTemplate(oitpFragTemplate2);
    } else {
      model.translucentColorTexture.resizeToMatch(model.colorTextureView.getTexture());
      model.translucentAccumulateTexture.resizeToMatch(model.colorTextureView.getTexture());
    }
    model.translucentRenderEncoder.setDepthTextureView(model.depthTextureView);
    model.translucentRenderEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("translucentPass");
    renNode.setRenderEncoder(model.translucentRenderEncoder);
    renNode.traverse(publicAPI);
    publicAPI.finalPass(viewNode, renNode);
  };
  publicAPI.finalPass = (viewNode, renNode) => {
    model.translucentFinalEncoder.setColorTextureView(0, model.colorTextureView);
    model.translucentFinalEncoder.attachTextureViews();
    model.translucentFinalEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model.translucentFinalEncoder);
    model.fullScreenQuad.prepareAndDraw(model.translucentFinalEncoder);
    model.translucentFinalEncoder.end();
  };
  publicAPI.getTextures = () => [model.translucentColorTexture, model.translucentAccumulateTexture];
  publicAPI.createRenderEncoder = () => {
    model.translucentRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "translucentRender"
    });
    const rDesc = model.translucentRenderEncoder.getDescription();
    rDesc.colorAttachments = [{
      view: void 0,
      clearValue: [0, 0, 0, 0],
      loadOp: "clear",
      storeOp: "store"
    }, {
      view: void 0,
      clearValue: [1, 0, 0, 0],
      loadOp: "clear",
      storeOp: "store"
    }];
    rDesc.depthStencilAttachment = {
      view: void 0,
      depthLoadOp: "load",
      depthStoreOp: "store"
    };
    model.translucentRenderEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      fDesc.addOutput("f32", "outAccum");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", [
        // very simple depth weighting in w z ranges from 1.0 near to 0.0
        "var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);",
        "output.outColor = vec4<f32>(computedColor.rgb*w, w);",
        "output.outAccum = computedColor.a;"
      ]).result;
      fDesc.setCode(code);
    });
    model.translucentRenderEncoder.setPipelineHash("oitpr");
    model.translucentRenderEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "greater",
        format: "depth32float"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one"
            }
          }
        }, {
          format: "r16float",
          blend: {
            color: {
              srcFactor: "zero",
              dstFactor: "one-minus-src"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createFinalEncoder = () => {
    model.translucentFinalEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "translucentFinal"
    });
    model.translucentFinalEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model.translucentFinalEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
      fDesc.setCode(code);
    });
    model.translucentFinalEncoder.setPipelineHash("oitpf");
    model.translucentFinalEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
}
var DEFAULT_VALUES23 = {
  colorTextureView: null,
  depthTextureView: null
};
function extend23(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES23, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
  vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model);
}
var newInstance24 = macro.newInstance(extend23, "vtkWebGPUOrderIndependentTranslucentPass");
var vtkWebGPUOrderIndepenentTranslucentPass = {
  newInstance: newInstance24,
  extend: extend23
};

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
var BlendMode = {
  COMPOSITE_BLEND: 0,
  MAXIMUM_INTENSITY_BLEND: 1,
  MINIMUM_INTENSITY_BLEND: 2,
  AVERAGE_INTENSITY_BLEND: 3,
  ADDITIVE_INTENSITY_BLEND: 4,
  RADON_TRANSFORM_BLEND: 5,
  LABELMAP_EDGE_PROJECTION_BLEND: 6
};
var Constants4 = {
  BlendMode
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePassFSQ.js
var volFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Volume::TraverseDec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

fn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32
{
  // todo multicomponent support
  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;
}

fn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>
{
  var result: vec4<f32>;

  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;
  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;
  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;
  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;
  result.w = 0.0;

  // divide by spacing as that is our delta
  result = result / volumeSSBO.values[vNum].spacing;
  // now we have a gradient in unit tcoords

  var grad: f32 = length(result.xyz);
  if (grad > 0.0)
  {
    // rotate to View Coords, needed for lighting and shading
    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;
    result = nMat * result;
    result = result / length(result);
  }

  // store gradient magnitude in .w
  result.w = grad;

  return result;
}

fn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>
{
  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);

  // convert to tcoords and reject if outside the volume
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;
  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||
      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }

  var scalar: f32 = getTextureValue(vTex, tpos);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);

  var gofactor: f32 = 1.0;
  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);
  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    normal = getGradient(vTex, tpos, vNum, scalar);
    if (componentSSBO.values[cNum].gomin <  1.0)
    {
      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,
      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);
    }
  }

  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;

  if (volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    color = color*abs(normal.z);
  }

  outColor = vec4<f32>(color.rgb, gofactor * opacity);

  return outColor;
}

// adjust the start and end point of a raycast such that it intersects the unit cube.
// This function is used to take a raycast starting point and step vector
// and numSteps and return the startijng and ending steps for intersecting the
// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates
// that have valid values. So this funtion can be used to take a ray in texture coordinates
// and bound it to intersecting the texture.
//
fn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>
{
  var result: vec2<f32> = vec2<f32>(0.0, numSteps);
  var tpos2: vec4<f32> = tpos + tstep*numSteps;

  // move tpos to the start of the volume
  var adjust: f32 =
    min(
      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),
      min(
        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),
        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));
  if (adjust < 0.0)
  {
    result.x = result.x - adjust;
  }

  // adjust length to the end
  adjust =
    max(
      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),
      max(
        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),
        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));
  if (adjust > 0.0)
  {
    result.y = result.y - adjust;
  }

  return result;
}

fn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>
{
  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);
  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;
  return vec4<f32>(color.rgb, opacity);
}

fn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var maxVal: f32 = -1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar > maxVal)
    {
      maxVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);
}

fn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var minVal: f32 = 1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar < minVal)
    {
      minVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);
}

fn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var avgVal: f32 = 0.0;
  var sampleCount: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      avgVal = avgVal + sample;
      sampleCount = sampleCount + 1.0;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  if (sampleCount <= 0.0)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);
}

fn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var sumVal: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      sumVal = sumVal + sample;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);
}

fn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>
{
  // initial ray position is at the beginning
  var rayPosSC: vec4<f32> = minPosSC;

  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var curDist: f32 = 0.0;
  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
  var sampleColor: vec4<f32>;
//VTK::Volume::TraverseCalls

  loop
  {
    // for each volume, sample and accumulate color
//VTK::Volume::CompositeCalls

    // increment position
    curDist = curDist + mapperUBO.SampleDistance;
    rayPosSC = rayPosSC + rayStepSC;

    // check if we have reached a terminating condition
    if (curDist > rayLengthSC) { break; }
    if (computedColor.a > 0.98) { break; }
  }
  return computedColor;
}

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;
  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;

  // discard empty rays
  if (rayMax <= rayMin) { discard; }
  else
  {
    // compute start and end ray positions in view coordinates
    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);
    minPosSC = minPosSC * (1.0 / minPosSC.w);
    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);
    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);

    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);
    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);
    rayStepSC.w = 0.0;

    var computedColor: vec4<f32>;

//VTK::Volume::Loop

//VTK::RenderEncoder::Impl
  }

  return output;
}
`;
var tmpMat4 = new Float64Array(16);
var tmp2Mat4 = new Float64Array(16);
function vtkWebGPUVolumePassFSQ(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolumePassFSQ");
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    const compositeCalls = [];
    const traverseCalls = [];
    for (let i = 0; i < model.volumes.length; i++) {
      const blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();
      if (blendMode === BlendMode.COMPOSITE_BLEND) {
        compositeCalls.push(`    sampleColor = processVolume(volTexture${i}, ${i}, ${model.rowStarts[i]}, rayPosSC, tfunRows);`);
        compositeCalls.push(`    computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
      } else {
        traverseCalls.push(`  sampleColor = traverseVals[${i}];`);
        traverseCalls.push(`  computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
      }
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::CompositeCalls", compositeCalls).result;
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseCalls", traverseCalls).result;
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseDec", [`var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`]).result;
    let compositeWhileTraversing = false;
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
      if (blendMode === BlendMode.COMPOSITE_BLEND) {
        compositeWhileTraversing = true;
      } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", [`    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, "//VTK::Volume::Loop"]).result;
      }
    }
    if (compositeWhileTraversing) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result;
    }
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderVolume", publicAPI.replaceShaderVolume);
  publicAPI.updateLUTImage = (device) => {
    let mtime = publicAPI.getMTime();
    for (let i = 0; i < model.volumes.length; i++) {
      const vol = model.volumes[i].getRenderable();
      const image = vol.getMapper().getInputData();
      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());
    }
    if (mtime < model.lutBuildTime.getMTime()) {
      return;
    }
    model.numRows = 0;
    model.rowStarts = [];
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      model.rowStarts.push(model.numRows);
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const vprop = actor.getProperty();
      const image = volMapr.getInputData();
      const scalars = image.getPointData() && image.getPointData().getScalars();
      const numComp = scalars.getNumberOfComponents();
      const iComps = vprop.getIndependentComponents();
      const numIComps = iComps ? numComp : 1;
      model.numRows += numIComps;
    }
    const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
    const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);
    let imgRow = 0;
    const tmpTable = new Float32Array(model.rowLength * 3);
    const rowLength = model.rowLength;
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const vprop = actor.getProperty();
      const image = volMapr.getInputData();
      const scalars = image.getPointData() && image.getPointData().getScalars();
      const numComp = scalars.getNumberOfComponents();
      const iComps = vprop.getIndependentComponents();
      const numIComps = iComps ? numComp : 1;
      for (let c = 0; c < numIComps; ++c) {
        const cfun = vprop.getRGBTransferFunction(c);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);
        let ioffset = imgRow * rowLength * 4;
        for (let i = 0; i < rowLength; ++i) {
          colorArray[ioffset + i * 4] = 255 * tmpTable[i * 3];
          colorArray[ioffset + i * 4 + 1] = 255 * tmpTable[i * 3 + 1];
          colorArray[ioffset + i * 4 + 2] = 255 * tmpTable[i * 3 + 2];
          colorArray[ioffset + i * 4 + 3] = 255;
          for (let co = 0; co < 4; co++) {
            colorArray[ioffset + (rowLength + i) * 4 + co] = colorArray[ioffset + i * 4 + co];
          }
        }
        const ofun = vprop.getScalarOpacity(c);
        const opacityFactor = model.sampleDist / vprop.getScalarOpacityUnitDistance(c);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);
        ioffset = imgRow * rowLength;
        for (let i = 0; i < rowLength; ++i) {
          opacityArray[ioffset + i] = 1 - (1 - tmpTable[i]) ** opacityFactor;
          opacityArray[ioffset + i + rowLength] = opacityArray[ioffset + i];
        }
        imgRow += 2;
      }
    }
    {
      const treq = {
        nativeArray: colorArray,
        width: model.rowLength,
        height: model.numRows * 2,
        depth: 1,
        format: "rgba8unorm"
      };
      const newTex = device.getTextureManager().getTexture(treq);
      const tview = newTex.createView("tfunTexture");
      model.textureViews[2] = tview;
    }
    {
      const treq = {
        nativeArray: opacityArray,
        width: model.rowLength,
        height: model.numRows * 2,
        depth: 1,
        format: "r16float"
      };
      const newTex = device.getTextureManager().getTexture(treq);
      const tview = newTex.createView("ofunTexture");
      model.textureViews[3] = tview;
    }
    model.lutBuildTime.modified();
  };
  publicAPI.updateSSBO = (device) => {
    let mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());
    for (let i = 0; i < model.volumes.length; i++) {
      const vol = model.volumes[i].getRenderable();
      const volMapr = vol.getMapper();
      const image = volMapr.getInputData();
      mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());
    }
    if (mtime < model.SSBO.getSendTime()) {
      return;
    }
    const center = model.WebGPURenderer.getStabilizedCenterByReference();
    model.SSBO.clearData();
    model.SSBO.setNumberOfInstances(model.volumes.length);
    const marray = new Float64Array(model.volumes.length * 16);
    const vPlaneArray = new Float64Array(model.volumes.length * 16);
    const tstepArray = new Float64Array(model.volumes.length * 4);
    const shadeArray = new Float64Array(model.volumes.length * 4);
    const spacingArray = new Float64Array(model.volumes.length * 4);
    const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const image = volMapr.getInputData();
      mat4_exports.identity(tmpMat4);
      mat4_exports.translate(tmpMat4, tmpMat4, center);
      const mcwcmat = actor.getMatrix();
      mat4_exports.transpose(tmp2Mat4, mcwcmat);
      mat4_exports.invert(tmp2Mat4, tmp2Mat4);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const modelToIndex = image.getWorldToIndex();
      mat4_exports.multiply(tmpMat4, modelToIndex, tmpMat4);
      const dims = image.getDimensions();
      mat4_exports.identity(tmp2Mat4);
      mat4_exports.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      for (let j = 0; j < 16; j++) {
        marray[vidx * 16 + j] = tmpMat4[j];
      }
      mat4_exports.invert(tmpMat4, tmpMat4);
      for (let j = 0; j < 4; j++) {
        vPlaneArray[vidx * 16 + j * 4] = tmpMat4[j * 4];
        vPlaneArray[vidx * 16 + j * 4 + 1] = tmpMat4[j * 4 + 1];
        vPlaneArray[vidx * 16 + j * 4 + 2] = tmpMat4[j * 4 + 2];
        vPlaneArray[vidx * 16 + j * 4 + 3] = 0;
      }
      tstepArray[vidx * 4] = 1 / dims[0];
      tstepArray[vidx * 4 + 1] = 1 / dims[1];
      tstepArray[vidx * 4 + 2] = 1 / dims[2];
      tstepArray[vidx * 4 + 3] = 1;
      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1 : 0;
      const spacing = image.getSpacing();
      spacingArray[vidx * 4] = spacing[0];
      spacingArray[vidx * 4 + 1] = spacing[1];
      spacingArray[vidx * 4 + 2] = spacing[2];
      spacingArray[vidx * 4 + 3] = 1;
      const tScale = model.textureViews[vidx + 4].getTexture().getScale();
      const ipScalarRange = actor.getProperty().getIpScalarRange();
      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;
      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;
      ipScalarRangeArray[vidx * 4 + 2] = actor.getProperty().getFilterMode();
    }
    model.SSBO.addEntry("SCTCMatrix", "mat4x4<f32>");
    model.SSBO.addEntry("planeNormals", "mat4x4<f32>");
    model.SSBO.addEntry("shade", "vec4<f32>");
    model.SSBO.addEntry("tstep", "vec4<f32>");
    model.SSBO.addEntry("spacing", "vec4<f32>");
    model.SSBO.addEntry("ipScalarRange", "vec4<f32>");
    model.SSBO.setAllInstancesFromArray("SCTCMatrix", marray);
    model.SSBO.setAllInstancesFromArray("planeNormals", vPlaneArray);
    model.SSBO.setAllInstancesFromArray("shade", shadeArray);
    model.SSBO.setAllInstancesFromArray("tstep", tstepArray);
    model.SSBO.setAllInstancesFromArray("spacing", spacingArray);
    model.SSBO.setAllInstancesFromArray("ipScalarRange", ipScalarRangeArray);
    model.SSBO.send(device);
    model.componentSSBO.clearData();
    model.componentSSBO.setNumberOfInstances(model.numRows);
    const cScaleArray = new Float64Array(model.numRows);
    const cShiftArray = new Float64Array(model.numRows);
    const oScaleArray = new Float64Array(model.numRows);
    const oShiftArray = new Float64Array(model.numRows);
    const gominArray = new Float64Array(model.numRows);
    const gomaxArray = new Float64Array(model.numRows);
    const goshiftArray = new Float64Array(model.numRows);
    const goscaleArray = new Float64Array(model.numRows);
    let rowIdx = 0;
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const vprop = actor.getProperty();
      const image = volMapr.getInputData();
      const scalars = image.getPointData() && image.getPointData().getScalars();
      const numComp = scalars.getNumberOfComponents();
      const iComps = vprop.getIndependentComponents();
      const tformat = model.textureViews[vidx + 4].getTexture().getFormat();
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      const volInfo = {
        scale: [255],
        offset: [0]
      };
      if (halfFloat) {
        volInfo.scale[0] = 1;
      }
      for (let compIdx = 0; compIdx < numComp; compIdx++) {
        const target = iComps ? compIdx : 0;
        const sscale = volInfo.scale[compIdx];
        const ofun = vprop.getScalarOpacity(target);
        const oRange = ofun.getRange();
        const oscale = sscale / (oRange[1] - oRange[0]);
        const oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);
        oShiftArray[rowIdx] = oshift;
        oScaleArray[rowIdx] = oscale;
        const cfun = vprop.getRGBTransferFunction(target);
        const cRange = cfun.getRange();
        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);
        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);
        const useGO = vprop.getUseGradientOpacity(target);
        if (useGO) {
          const gomin = vprop.getGradientOpacityMinimumOpacity(target);
          const gomax = vprop.getGradientOpacityMaximumOpacity(target);
          gominArray[rowIdx] = gomin;
          gomaxArray[rowIdx] = gomax;
          const goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];
          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);
          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;
        } else {
          gominArray[rowIdx] = 1;
          gomaxArray[rowIdx] = 1;
          goscaleArray[rowIdx] = 0;
          goshiftArray[rowIdx] = 1;
        }
        rowIdx++;
      }
    }
    model.componentSSBO.addEntry("cScale", "f32");
    model.componentSSBO.addEntry("cShift", "f32");
    model.componentSSBO.addEntry("oScale", "f32");
    model.componentSSBO.addEntry("oShift", "f32");
    model.componentSSBO.addEntry("goShift", "f32");
    model.componentSSBO.addEntry("goScale", "f32");
    model.componentSSBO.addEntry("gomin", "f32");
    model.componentSSBO.addEntry("gomax", "f32");
    model.componentSSBO.setAllInstancesFromArray("cScale", cScaleArray);
    model.componentSSBO.setAllInstancesFromArray("cShift", cShiftArray);
    model.componentSSBO.setAllInstancesFromArray("oScale", oScaleArray);
    model.componentSSBO.setAllInstancesFromArray("oShift", oShiftArray);
    model.componentSSBO.setAllInstancesFromArray("goScale", goscaleArray);
    model.componentSSBO.setAllInstancesFromArray("goShift", goshiftArray);
    model.componentSSBO.setAllInstancesFromArray("gomin", gominArray);
    model.componentSSBO.setAllInstancesFromArray("gomax", gomaxArray);
    model.componentSSBO.send(device);
  };
  const superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = () => {
    superClassUpdateBuffers();
    let sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();
    for (let i = 0; i < model.volumes.length; i++) {
      const vol = model.volumes[i];
      const volMapr = vol.getRenderable().getMapper();
      const sd = volMapr.getSampleDistance();
      if (sd < sampleDist) {
        sampleDist = sd;
      }
    }
    if (model.sampleDist !== sampleDist) {
      model.sampleDist = sampleDist;
      model.UBO.setValue("SampleDistance", sampleDist);
      model.UBO.sendIfNeeded(model.device);
    }
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const webgpuvol = model.volumes[vidx];
      const actor = webgpuvol.getRenderable();
      const volMapr = actor.getMapper();
      const image = volMapr.getInputData();
      const newTex = model.device.getTextureManager().getTextureForImageData(image);
      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {
        const tview = newTex.createView(`volTexture${vidx}`);
        model.textureViews[vidx + 4] = tview;
      }
    }
    if (model.volumes.length < model.lastVolumeLength) {
      for (let i = model.volumes.length; i < model.lastVolumeLength; i++) {
        model.textureViews.pop();
      }
    }
    model.lastVolumeLength = model.volumes.length;
    publicAPI.updateLUTImage(model.device);
    publicAPI.updateSSBO(model.device);
    if (!model.clampSampler) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: "linear",
        magFilter: "linear"
      });
    }
  };
  publicAPI.computePipelineHash = () => {
    model.pipelineHash = "volfsq";
    for (let vidx = 0; vidx < model.volumes.length; vidx++) {
      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
      model.pipelineHash += `${blendMode}`;
    }
  };
  publicAPI.setVolumes = (val) => {
    if (!model.volumes || model.volumes.length !== val.length) {
      model.volumes = [...val];
      publicAPI.modified();
      return;
    }
    for (let i = 0; i < val.length; i++) {
      if (val[i] !== model.volumes[i]) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
    }
  };
  const superclassGetBindables = publicAPI.getBindables;
  publicAPI.getBindables = () => {
    const bindables = superclassGetBindables();
    bindables.push(model.componentSSBO);
    bindables.push(model.clampSampler);
    return bindables;
  };
}
var DEFAULT_VALUES24 = {
  volumes: null,
  rowLength: 1024,
  lastVolumeLength: 0
};
function extend24(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES24, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  model.fragmentShaderTemplate = volFragTemplate;
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SampleDistance", "f32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "volumeSSBO"
  });
  model.componentSSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "componentSSBO"
  });
  model.lutBuildTime = {};
  macro.obj(model.lutBuildTime, {
    mtime: 0
  });
  vtkWebGPUVolumePassFSQ(publicAPI, model);
}
var newInstance25 = macro.newInstance(extend24, "vtkWebGPUVolumePassFSQ");
var vtkWebGPUVolumePassFSQ$1 = {
  newInstance: newInstance25,
  extend: extend24
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePass.js
var {
  Representation: Representation2
} = vtkProperty$1;
var {
  BufferUsage,
  PrimitiveTypes
} = vtkWebGPUBufferManager$1;
var cubeFaceTriangles = [[0, 4, 6], [0, 6, 2], [1, 3, 7], [1, 7, 5], [0, 5, 4], [0, 1, 5], [2, 6, 7], [2, 7, 3], [0, 3, 1], [0, 2, 3], [4, 5, 7], [4, 7, 6]];
var DepthBoundsFS = `
//VTK::Renderer::Dec

//VTK::Select::Dec

//VTK::VolumePass::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Select::Impl

  //VTK::TCoord::Impl

  //VTK::VolumePass::Impl

  // use the maximum (closest) of the current value and the zbuffer
  // the blend func will then take the min to find the farthest stop value
  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var volumeCopyFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,
    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkWebGPUVolumePass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolumePass");
  publicAPI.initialize = (viewNode) => {
    if (!model._clearEncoder) {
      publicAPI.createClearEncoder(viewNode);
    }
    if (!model._mergeEncoder) {
      publicAPI.createMergeEncoder(viewNode);
    }
    if (!model._copyEncoder) {
      publicAPI.createCopyEncoder(viewNode);
    }
    if (!model._depthRangeEncoder) {
      publicAPI.createDepthRangeEncoder(viewNode);
    }
    if (!model.fullScreenQuad) {
      model.fullScreenQuad = vtkWebGPUVolumePassFSQ$1.newInstance();
      model.fullScreenQuad.setDevice(viewNode.getDevice());
      model.fullScreenQuad.setTextureViews([...model._depthRangeEncoder.getColorTextureViews()]);
    }
    if (!model._volumeCopyQuad) {
      model._volumeCopyQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model._volumeCopyQuad.setPipelineHash("volpassfsq");
      model._volumeCopyQuad.setDevice(viewNode.getDevice());
      model._volumeCopyQuad.setFragmentShaderTemplate(volumeCopyFragTemplate);
      model._copyUBO = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      model._copyUBO.addEntry("tscale", "vec2<f32>");
      model._volumeCopyQuad.setUBO(model._copyUBO);
      model._volumeCopyQuad.setTextureViews([model._colorTextureView]);
    }
  };
  publicAPI.traverse = (renNode, viewNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = viewNode;
    publicAPI.initialize(viewNode);
    publicAPI.computeTiming(viewNode);
    publicAPI.renderDepthBounds(renNode, viewNode);
    model._firstGroup = true;
    const device = viewNode.getDevice();
    const maxVolumes = device.getHandle().limits.maxSampledTexturesPerShaderStage - 4;
    if (model.volumes.length > maxVolumes) {
      const cameraPos = renNode.getRenderable().getActiveCamera().getPosition();
      const distances = [];
      for (let v = 0; v < model.volumes.length; v++) {
        const bounds = model.volumes[v].getRenderable().getBounds();
        const centroid = [0.5 * (bounds[1] + bounds[0]), 0.5 * (bounds[3] + bounds[2]), 0.5 * (bounds[5] + bounds[4])];
        distances[v] = distance2BetweenPoints(centroid, cameraPos);
      }
      const volumeOrder = [...Array(model.volumes.length).keys()];
      volumeOrder.sort((a, b) => distances[b] - distances[a]);
      let volumesToRender = [];
      let chunkSize = volumeOrder.length % maxVolumes;
      for (let v = 0; v < volumeOrder.length; v++) {
        volumesToRender.push(model.volumes[volumeOrder[v]]);
        if (volumesToRender.length >= chunkSize) {
          publicAPI.rayCastPass(viewNode, renNode, volumesToRender);
          volumesToRender = [];
          chunkSize = maxVolumes;
          model._firstGroup = false;
        }
      }
    } else {
      publicAPI.rayCastPass(viewNode, renNode, model.volumes);
    }
    model._volumeCopyQuad.setWebGPURenderer(renNode);
    if (model._useSmallViewport) {
      const width = model._colorTextureView.getTexture().getWidth();
      const height = model._colorTextureView.getTexture().getHeight();
      model._copyUBO.setArray("tscale", [model._smallViewportWidth / width, model._smallViewportHeight / height]);
    } else {
      model._copyUBO.setArray("tscale", [1, 1]);
    }
    model._copyUBO.sendIfNeeded(device);
    model._copyEncoder.setColorTextureView(0, model.colorTextureView);
    model._copyEncoder.attachTextureViews();
    model._copyEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model._copyEncoder);
    model._volumeCopyQuad.prepareAndDraw(model._copyEncoder);
    model._copyEncoder.end();
  };
  publicAPI.delete = macro.chain(() => {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, publicAPI.delete);
  publicAPI.computeTiming = (viewNode) => {
    const rwi = viewNode.getRenderable().getInteractor();
    if (model._lastScale == null) {
      const firstMapper = model.volumes[0].getRenderable().getMapper();
      model._lastScale = firstMapper.getInitialInteractionScale() || 1;
    }
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    model._colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
        const firstMapper = model.volumes[0].getRenderable().getMapper();
        if (firstMapper.getAutoAdjustSampleDistances()) {
          const frate = rwi.getRecentAnimationFrameRate();
          const targetScale = model._lastScale * rwi.getDesiredUpdateRate() / frate;
          model._lastScale = targetScale;
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
        } else {
          model._lastScale = firstMapper.getImageSampleDistance() * firstMapper.getImageSampleDistance();
        }
        if (model._lastScale < 1.5) {
          model._lastScale = 1.5;
        }
      });
    }
  };
  publicAPI.rayCastPass = (viewNode, renNode, volumes) => {
    const encoder = model._firstGroup ? model._clearEncoder : model._mergeEncoder;
    encoder.attachTextureViews();
    encoder.begin(viewNode.getCommandEncoder());
    let width = model._colorTextureView.getTexture().getWidth();
    let height = model._colorTextureView.getTexture().getHeight();
    if (model._useSmallViewport) {
      const canvas = viewNode.getCanvas();
      const scaleFactor = 1 / Math.sqrt(model._lastScale);
      model._smallViewportWidth = Math.ceil(scaleFactor * canvas.width);
      model._smallViewportHeight = Math.ceil(scaleFactor * canvas.height);
      width = model._smallViewportWidth;
      height = model._smallViewportHeight;
    }
    encoder.getHandle().setViewport(0, 0, width, height, 0, 1);
    encoder.getHandle().setScissorRect(0, 0, width, height);
    model.fullScreenQuad.setWebGPURenderer(renNode);
    model.fullScreenQuad.setVolumes(volumes);
    model.fullScreenQuad.prepareAndDraw(encoder);
    encoder.end();
  };
  publicAPI.renderDepthBounds = (renNode, viewNode) => {
    publicAPI.updateDepthPolyData(renNode);
    const pd = model._boundsPoly;
    const points = pd.getPoints();
    const cells = pd.getPolys();
    let buffRequest = {
      hash: `vp${cells.getMTime()}`,
      usage: BufferUsage.Index,
      cells,
      numberOfPoints: points.getNumberOfPoints(),
      primitiveType: PrimitiveTypes.Triangles,
      representation: Representation2.SURFACE
    };
    const indexBuffer = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
    model._mapper.getVertexInput().setIndexBuffer(indexBuffer);
    buffRequest = {
      usage: BufferUsage.PointArray,
      format: "float32x4",
      hash: `vp${points.getMTime()}${cells.getMTime()}`,
      dataArray: points,
      indexBuffer,
      packExtra: true
    };
    const buff = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
    model._mapper.getVertexInput().addBuffer(buff, ["vertexBC"]);
    model._mapper.setNumberOfVertices(buff.getSizeInBytes() / buff.getStrideInBytes());
    publicAPI.drawDepthRange(renNode, viewNode);
  };
  publicAPI.updateDepthPolyData = (renNode) => {
    let update = false;
    for (let i = 0; i < model.volumes.length; i++) {
      const mtime = model.volumes[i].getMTime();
      if (!model._lastMTimes[i] || mtime !== model._lastMTimes[i]) {
        update = true;
        model._lastMTimes[i] = mtime;
      }
    }
    const stime = renNode.getStabilizedTime();
    if (model._lastMTimes.length <= model.volumes.length || stime !== model._lastMTimes[model.volumes.length]) {
      update = true;
      model._lastMTimes[model.volumes.length] = stime;
    }
    if (!update) {
      return;
    }
    const center = renNode.getStabilizedCenterByReference();
    const numPts = model.volumes.length * 8;
    const points = new Float64Array(numPts * 3);
    const numTris = model.volumes.length * 12;
    const polys = new Uint16Array(numTris * 4);
    for (let i = 0; i < model.volumes.length; i++) {
      model.volumes[i].getBoundingCubePoints(points, i * 24);
      let cellIdx = i * 12 * 4;
      const offset = i * 8;
      for (let t = 0; t < 12; t++) {
        polys[cellIdx++] = 3;
        polys[cellIdx++] = offset + cubeFaceTriangles[t][0];
        polys[cellIdx++] = offset + cubeFaceTriangles[t][1];
        polys[cellIdx++] = offset + cubeFaceTriangles[t][2];
      }
    }
    for (let p = 0; p < points.length; p += 3) {
      points[p] -= center[0];
      points[p + 1] -= center[1];
      points[p + 2] -= center[2];
    }
    model._boundsPoly.getPoints().setData(points, 3);
    model._boundsPoly.getPoints().modified();
    model._boundsPoly.getPolys().setData(polys, 1);
    model._boundsPoly.getPolys().modified();
    model._boundsPoly.modified();
  };
  publicAPI.drawDepthRange = (renNode, viewNode) => {
    model._depthRangeTexture.resizeToMatch(model.colorTextureView.getTexture());
    model._depthRangeTexture2.resizeToMatch(model.colorTextureView.getTexture());
    model._depthRangeEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("volumeDepthRangePass");
    renNode.setRenderEncoder(model._depthRangeEncoder);
    renNode.volumeDepthRangePass(true);
    model._mapper.setWebGPURenderer(renNode);
    model._mapper.prepareToDraw(model._depthRangeEncoder);
    model._mapper.registerDrawCallback(model._depthRangeEncoder);
    renNode.volumeDepthRangePass(false);
  };
  publicAPI.createDepthRangeEncoder = (viewNode) => {
    const device = viewNode.getDevice();
    model._depthRangeEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "VolumePass DepthRange"
    });
    model._depthRangeEncoder.setPipelineHash("volr");
    model._depthRangeEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor1");
      fDesc.addOutput("vec4<f32>", "outColor2");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);", "output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result;
      fDesc.setCode(code);
    });
    model._depthRangeEncoder.setDescription({
      colorAttachments: [{
        view: null,
        clearValue: [0, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }, {
        view: null,
        clearValue: [1, 1, 1, 1],
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    model._depthRangeEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "r16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "max"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "max"
            }
          }
        }, {
          format: "r16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "min"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "min"
            }
          }
        }]
      }
    });
    model._depthRangeTexture = vtkWebGPUTexture$1.newInstance({
      label: "volumePassMaxDepth"
    });
    model._depthRangeTexture.create(device, {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "r16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const maxView = model._depthRangeTexture.createView("maxTexture");
    model._depthRangeEncoder.setColorTextureView(0, maxView);
    model._depthRangeTexture2 = vtkWebGPUTexture$1.newInstance({
      label: "volumePassDepthMin"
    });
    model._depthRangeTexture2.create(device, {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "r16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const minView = model._depthRangeTexture2.createView("minTexture");
    model._depthRangeEncoder.setColorTextureView(1, minView);
    model._mapper.setDevice(viewNode.getDevice());
    model._mapper.setTextureViews([model.depthTextureView]);
  };
  publicAPI.createClearEncoder = (viewNode) => {
    model._colorTexture = vtkWebGPUTexture$1.newInstance({
      label: "volumePassColor"
    });
    model._colorTexture.create(viewNode.getDevice(), {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "bgra8unorm",
      /* eslint-disable no-undef */
      /* eslint-disable no-bitwise */
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    model._colorTextureView = model._colorTexture.createView("volumePassColorTexture");
    model._colorTextureView.addSampler(viewNode.getDevice(), {
      minFilter: "linear",
      magFilter: "linear"
    });
    model._clearEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "VolumePass Clear"
    });
    model._clearEncoder.setColorTextureView(0, model._colorTextureView);
    model._clearEncoder.setDescription({
      colorAttachments: [{
        view: null,
        clearValue: [0, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    model._clearEncoder.setPipelineHash("volpf");
    model._clearEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "bgra8unorm",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createCopyEncoder = (viewNode) => {
    model._copyEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "volumePassCopy"
    });
    model._copyEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._copyEncoder.setPipelineHash("volcopypf");
    model._copyEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createMergeEncoder = (viewNode) => {
    model._mergeEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "volumePassMerge"
    });
    model._mergeEncoder.setColorTextureView(0, model._colorTextureView);
    model._mergeEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._mergeEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
      fDesc.setCode(code);
    });
    model._mergeEncoder.setPipelineHash("volpf");
    model._mergeEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "bgra8unorm",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.setVolumes = (val) => {
    if (!model.volumes || model.volumes.length !== val.length) {
      model.volumes = [...val];
      publicAPI.modified();
      return;
    }
    for (let i = 0; i < val.length; i++) {
      if (val[i] !== model.volumes[i]) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
    }
  };
}
var DEFAULT_VALUES25 = {
  colorTextureView: null,
  depthTextureView: null,
  volumes: null
};
function extend25(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES25, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model._mapper = vtkWebGPUSimpleMapper$1.newInstance();
  model._mapper.setFragmentShaderTemplate(DepthBoundsFS);
  model._mapper.getShaderReplacements().set("replaceShaderVolumePass", (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
  });
  model._boundsPoly = vtkPolyData$1.newInstance();
  model._lastMTimes = [];
  macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
  vtkWebGPUVolumePass(publicAPI, model);
}
var newInstance26 = macro.newInstance(extend25, "vtkWebGPUVolumePass");
var vtkWebGPUVolumePass$1 = {
  newInstance: newInstance26,
  extend: extend25
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ForwardPass.js
var finalBlitFragTemplate = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkForwardPass2(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    if (!model.opaquePass) {
      model.opaquePass = vtkWebGPUOpaquePass$1.newInstance();
    }
    const numlayers = viewNode.getRenderable().getNumberOfLayers();
    const renderers = viewNode.getChildren();
    for (let i = 0; i < numlayers; i++) {
      for (let index = 0; index < renderers.length; index++) {
        const renNode = renderers[index];
        const ren = viewNode.getRenderable().getRenderers()[index];
        if (ren.getDraw() && ren.getLayer() === i) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumes = [];
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          model.opaquePass.traverse(renNode, viewNode);
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkWebGPUOrderIndepenentTranslucentPass.newInstance();
            }
            model.translucentPass.setColorTextureView(model.opaquePass.getColorTextureView());
            model.translucentPass.setDepthTextureView(model.opaquePass.getDepthTextureView());
            model.translucentPass.traverse(renNode, viewNode);
          }
          if (model.volumes.length > 0) {
            if (!model.volumePass) {
              model.volumePass = vtkWebGPUVolumePass$1.newInstance();
            }
            model.volumePass.setColorTextureView(model.opaquePass.getColorTextureView());
            model.volumePass.setDepthTextureView(model.opaquePass.getDepthTextureView());
            model.volumePass.setVolumes(model.volumes);
            model.volumePass.traverse(renNode, viewNode);
          }
          publicAPI.finalPass(viewNode, renNode);
        }
      }
    }
  };
  publicAPI.finalPass = (viewNode, renNode) => {
    if (!model._finalBlitEncoder) {
      publicAPI.createFinalBlitEncoder(viewNode);
    }
    model._finalBlitOutputTextureView.createFromTextureHandle(viewNode.getCurrentTexture(), {
      depth: 1,
      format: viewNode.getPresentationFormat()
    });
    model._finalBlitEncoder.attachTextureViews();
    model._finalBlitEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model._finalBlitEncoder);
    model._fullScreenQuad.prepareAndDraw(model._finalBlitEncoder);
    model._finalBlitEncoder.end();
  };
  publicAPI.createFinalBlitEncoder = (viewNode) => {
    model._finalBlitEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "forwardPassBlit"
    });
    model._finalBlitEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._finalBlitEncoder.setPipelineHash("fpf");
    model._finalBlitEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: viewNode.getPresentationFormat(),
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
    model._fsqSampler = vtkWebGPUSampler$1.newInstance({
      label: "finalPassSampler"
    });
    model._fsqSampler.create(viewNode.getDevice(), {
      minFilter: "linear",
      magFilter: "linear"
    });
    model._fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
    model._fullScreenQuad.setDevice(viewNode.getDevice());
    model._fullScreenQuad.setPipelineHash("fpfsq");
    model._fullScreenQuad.setTextureViews([model.opaquePass.getColorTextureView()]);
    model._fullScreenQuad.setAdditionalBindables([model._fsqSampler]);
    model._fullScreenQuad.setFragmentShaderTemplate(finalBlitFragTemplate);
    model._finalBlitOutputTextureView = vtkWebGPUTextureView$1.newInstance();
    model._finalBlitEncoder.setColorTextureView(0, model._finalBlitOutputTextureView);
  };
  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
  publicAPI.addVolume = (volume) => {
    model.volumes.push(volume);
  };
}
var DEFAULT_VALUES26 = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumes: null,
  opaqueRenderEncoder: null,
  translucentPass: null,
  volumePass: null
};
function extend26(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES26, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["opaquePass", "translucentPass", "volumePass"]);
  vtkForwardPass2(publicAPI, model);
}
var newInstance27 = macro.newInstance(extend26, "vtkForwardPass");
var vtkForwardPass$12 = {
  newInstance: newInstance27,
  extend: extend26
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureManager.js
var {
  VtkDataTypes: VtkDataTypes2
} = vtkDataArray$1;
function vtkWebGPUTextureManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTextureManager");
  function _fillRequest(req) {
    if (req.imageData) {
      req.dataArray = req.imageData.getPointData().getScalars();
      req.time = req.dataArray.getMTime();
      req.nativeArray = req.dataArray.getData();
      const dims = req.imageData.getDimensions();
      req.width = dims[0];
      req.height = dims[1];
      req.depth = dims[2];
      const numComp = req.dataArray.getNumberOfComponents();
      switch (numComp) {
        case 1:
          req.format = "r";
          break;
        case 2:
          req.format = "rg";
          break;
        case 3:
        case 4:
        default:
          req.format = "rgba";
          break;
      }
      const dataType = req.dataArray.getDataType();
      switch (dataType) {
        case VtkDataTypes2.UNSIGNED_CHAR:
          req.format += "8unorm";
          break;
        case VtkDataTypes2.FLOAT:
        case VtkDataTypes2.UNSIGNED_INT:
        case VtkDataTypes2.INT:
        case VtkDataTypes2.DOUBLE:
        case VtkDataTypes2.UNSIGNED_SHORT:
        case VtkDataTypes2.SHORT:
        default:
          req.format += "16float";
          break;
      }
    }
    if (req.image) {
      req.width = req.image.width;
      req.height = req.image.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
    }
    if (req.jsImageData) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
      req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
    }
    if (req.imageBitmap) {
      req.width = req.imageBitmap.width;
      req.height = req.imageBitmap.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
    }
    if (req.canvas) {
      req.width = req.canvas.width;
      req.height = req.canvas.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.usage = GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT;
    }
  }
  function _createTexture(req) {
    const newTex = vtkWebGPUTexture$1.newInstance({
      label: req.label
    });
    newTex.create(model.device, {
      width: req.width,
      height: req.height,
      depth: req.depth,
      format: req.format,
      usage: req.usage,
      mipLevel: req.mipLevel
    });
    if (req.nativeArray || req.image || req.canvas || req.imageBitmap) {
      newTex.writeImageData(req);
    }
    return newTex;
  }
  publicAPI.getTexture = (req) => {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createTexture, req);
    }
    return _createTexture(req);
  };
  publicAPI.getTextureForImageData = (imgData) => {
    const treq = {
      time: imgData.getMTime()
    };
    treq.imageData = imgData;
    _fillRequest(treq);
    treq.hash = treq.time + treq.format + treq.mipLevel;
    return model.device.getTextureManager().getTexture(treq);
  };
  publicAPI.getTextureForVTKTexture = function(srcTexture) {
    let label = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    const treq = {
      time: srcTexture.getMTime(),
      label
    };
    if (srcTexture.getInputData()) {
      treq.imageData = srcTexture.getInputData();
    } else if (srcTexture.getImage()) {
      treq.image = srcTexture.getImage();
    } else if (srcTexture.getJsImageData()) {
      treq.jsImageData = srcTexture.getJsImageData();
    } else if (srcTexture.getImageBitmap()) {
      treq.imageBitmap = srcTexture.getImageBitmap();
    } else if (srcTexture.getCanvas()) {
      treq.canvas = srcTexture.getCanvas();
    }
    _fillRequest(treq);
    treq.mipLevel = srcTexture.getMipLevel();
    treq.hash = treq.time + treq.format + treq.mipLevel;
    return model.device.getTextureManager().getTexture(treq);
  };
}
var DEFAULT_VALUES27 = {
  handle: null,
  device: null
};
function extend27(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES27, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device"]);
  vtkWebGPUTextureManager(publicAPI, model);
}
var newInstance28 = macro.newInstance(extend27);
var vtkWebGPUTextureManager$1 = {
  newInstance: newInstance28,
  extend: extend27
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Device.js
var WeakRefMap = class extends Map {
  constructor() {
    super();
    this.registry = new FinalizationRegistry((key) => {
      const entry = super.get(key);
      if (entry && entry.deref && entry.deref() === void 0) super.delete(key);
    });
  }
  getValue(key) {
    const entry = super.get(key);
    if (entry) {
      const value = entry.deref();
      if (value !== void 0) return value;
      super.delete(key);
    }
    return void 0;
  }
  setValue(key, value) {
    let entry;
    if (value && typeof value === "object") {
      entry = new WeakRef(value);
      this.registry.register(value, key);
      super.set(key, entry);
    }
    return entry;
  }
};
function vtkWebGPUDevice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUDevice");
  publicAPI.initialize = (handle) => {
    model.handle = handle;
  };
  publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();
  publicAPI.submitCommandEncoder = (commandEncoder) => {
    model.handle.queue.submit([commandEncoder.finish()]);
  };
  publicAPI.getShaderModule = (sd) => model.shaderCache.getShaderModule(sd);
  publicAPI.getBindGroupLayout = (val) => {
    if (!val.entries) {
      return null;
    }
    for (let i = 0; i < val.entries.length; i++) {
      const ent = val.entries[i];
      ent.binding = ent.binding || 0;
      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
    }
    const sval = JSON.stringify(val);
    for (let i = 0; i < model.bindGroupLayouts.length; i++) {
      if (model.bindGroupLayouts[i].sval === sval) {
        return model.bindGroupLayouts[i].layout;
      }
    }
    const layout = model.handle.createBindGroupLayout(val);
    model.bindGroupLayouts.push({
      sval,
      layout
    });
    return layout;
  };
  publicAPI.getBindGroupLayoutDescription = (layout) => {
    for (let i = 0; i < model.bindGroupLayouts.length; i++) {
      if (model.bindGroupLayouts[i].layout === layout) {
        return model.bindGroupLayouts[i].sval;
      }
    }
    vtkErrorMacro("layout not found");
    console.trace();
    return null;
  };
  publicAPI.getPipeline = (hash) => {
    if (hash in model.pipelines) {
      return model.pipelines[hash];
    }
    return null;
  };
  publicAPI.createPipeline = (hash, pipeline) => {
    pipeline.initialize(publicAPI, hash);
    model.pipelines[hash] = pipeline;
  };
  publicAPI.onSubmittedWorkDone = () => model.handle.queue.onSubmittedWorkDone();
  publicAPI.hasCachedObject = (hash) => model.objectCache.getValue(hash);
  publicAPI.getCachedObject = function(hash, creator) {
    if (!hash) {
      vtkErrorMacro("attempt to cache an object without a hash");
      return null;
    }
    const existingValue = model.objectCache.getValue(hash);
    if (existingValue) {
      return existingValue;
    }
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    const createdObject = creator(...args);
    model.objectCache.setValue(hash, createdObject);
    return createdObject;
  };
}
var DEFAULT_VALUES28 = {
  handle: null,
  pipelines: null,
  shaderCache: null,
  bindGroupLayouts: null,
  bufferManager: null,
  textureManager: null
};
function extend28(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES28, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["handle"]);
  get(publicAPI, model, ["bufferManager", "shaderCache", "textureManager"]);
  model.objectCache = new WeakRefMap();
  model.shaderCache = vtkWebGPUShaderCache$1.newInstance();
  model.shaderCache.setDevice(publicAPI);
  model.bindGroupLayouts = [];
  model.bufferManager = vtkWebGPUBufferManager$1.newInstance();
  model.bufferManager.setDevice(publicAPI);
  model.textureManager = vtkWebGPUTextureManager$1.newInstance();
  model.textureManager.setDevice(publicAPI);
  model.pipelines = {};
  vtkWebGPUDevice(publicAPI, model);
}
var newInstance29 = newInstance(extend28, "vtkWebGPUDevice");
var vtkWebGPUDevice$1 = {
  newInstance: newInstance29,
  extend: extend28
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelectionPass.js
function vtkWebGPUHardwareSelectionPass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUHardwareSelectionPass");
  publicAPI.traverse = (viewNode, renNode) => {
    if (model.deleted) {
      return;
    }
    model._currentParent = null;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    const device = viewNode.getDevice();
    if (!model.selectionRenderEncoder) {
      publicAPI.createRenderEncoder();
      model.colorTexture = vtkWebGPUTexture$1.newInstance({
        label: "hardwareSelectorColor"
      });
      model.colorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba32uint",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
      const v1 = model.colorTexture.createView("hardwareSelectColorTexture");
      model.selectionRenderEncoder.setColorTextureView(0, v1);
      model.depthTexture = vtkWebGPUTexture$1.newInstance({
        label: "hardwareSelectorDepth"
      });
      model.depthTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "depth32float",
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
      const v2 = model.depthTexture.createView("hardwareSelectDepthTexture");
      model.selectionRenderEncoder.setDepthTextureView(v2);
    } else {
      model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      model.depthTexture.resizeToMatch(model.colorTexture);
    }
    model.selectionRenderEncoder.attachTextureViews();
    renNode.setRenderEncoder(model.selectionRenderEncoder);
    publicAPI.setCurrentOperation("cameraPass");
    renNode.traverse(publicAPI);
    publicAPI.setCurrentOperation("opaquePass");
    renNode.traverse(publicAPI);
  };
  publicAPI.createRenderEncoder = () => {
    model.selectionRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "HardwareSelectionPass"
    });
    model.selectionRenderEncoder.setPipelineHash("sel");
    model.selectionRenderEncoder.setReplaceShaderCodeFunction((pipeline) => {
      const fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<u32>", "outColor");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result;
      fDesc.setCode(code);
    });
    const renDesc = model.selectionRenderEncoder.getDescription();
    renDesc.colorAttachments[0].clearValue = [0, 0, 0, 0];
    model.selectionRenderEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "greater",
        format: "depth32float"
      },
      fragment: {
        targets: [{
          format: "rgba32uint",
          blend: void 0
        }]
      }
    });
  };
}
var DEFAULT_VALUES29 = {
  selectionRenderEncoder: null,
  colorTexture: null,
  depthTexture: null
};
function extend29(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES29, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
  vtkWebGPUHardwareSelectionPass(publicAPI, model);
}
var newInstance30 = macro.newInstance(extend29, "vtkWebGPUHardwareSelectionPass");
var vtkWebGPUHardwareSelectionPass$1 = {
  newInstance: newInstance30,
  extend: extend29
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelector.js
var {
  SelectionContent: SelectionContent3,
  SelectionField: SelectionField3
} = vtkSelectionNode$1;
var {
  FieldAssociations: FieldAssociations3
} = vtkDataSet$1;
var {
  vtkErrorMacro: vtkErrorMacro11
} = macro;
function getInfoHash2(info) {
  return `${info.propID} ${info.compositeID}`;
}
function convert2(xx, yy, buffdata, channel) {
  const offset = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;
  return buffdata.colorValues[offset];
}
function getPixelInformationWithData2(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  const maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {
      return null;
    }
    const actorid = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);
    if (actorid <= 0) {
      return null;
    }
    const info2 = {};
    info2.propID = actorid;
    let compositeID = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    info2.compositeID = compositeID;
    if (buffdata.captureZValues) {
      const offset = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];
      info2.zValue = buffdata.depthValues[offset];
      info2.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info2.zValue);
      info2.displayPosition = inDisplayPosition;
    }
    return info2;
  }
  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  const curPos = [0, 0];
  let info = getPixelInformationWithData2(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info) {
    return info;
  }
  for (let dist = 1; dist < maxDist; ++dist) {
    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist) {
        curPos[0] = dispPos[0] - dist;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist;
      info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
      if (info) {
        return info;
      }
    }
    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist) {
        curPos[1] = dispPos[1] - dist;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist;
      info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
      if (info) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection2(fieldassociation, dataMap, buffdata) {
  const sel = [];
  let count = 0;
  dataMap.forEach((value, key) => {
    const child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent3.INDICES);
    switch (fieldassociation) {
      case FieldAssociations3.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField3.CELL);
        break;
      case FieldAssociations3.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField3.POINT);
        break;
      default:
        vtkErrorMacro11("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);
    child.getProperties().prop = wprop.getRenderable();
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (buffdata.captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData2(buffdata, fx1, fy1, fx2, fy2) {
  const x1 = Math.floor(fx1);
  const y1 = Math.floor(fy1);
  const x2 = Math.floor(fx2);
  const y2 = Math.floor(fy2);
  const dataMap = /* @__PURE__ */ new Map();
  const outSelectedPosition = [0, 0];
  for (let yy = y1; yy <= y2; yy++) {
    for (let xx = x1; xx <= x2; xx++) {
      const pos = [xx, yy];
      const info = getPixelInformationWithData2(buffdata, pos, 0, outSelectedPosition);
      if (info) {
        const hash = getInfoHash2(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          const dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection2(buffdata.fieldAssociation, dataMap, buffdata);
}
function vtkWebGPUHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUHardwareSelector");
  publicAPI.endSelection = () => {
    model.WebGPURenderer.setSelector(null);
  };
  publicAPI.getSourceDataAsync = async (renderer) => {
    if (!renderer || !model._WebGPURenderWindow) {
      vtkErrorMacro11("Renderer and view must be set before calling Select.");
      return false;
    }
    model._WebGPURenderWindow.getRenderable().preRender();
    if (!model._WebGPURenderWindow.getInitialized()) {
      model._WebGPURenderWindow.initialize();
      await new Promise((resolve) => {
        model._WebGPURenderWindow.onInitialized(resolve);
      });
    }
    const webGPURenderer = model._WebGPURenderWindow.getViewNodeFor(renderer);
    if (!webGPURenderer) {
      return false;
    }
    const originalSuppress = webGPURenderer.getSuppressClear();
    webGPURenderer.setSuppressClear(true);
    model._selectionPass.traverse(model._WebGPURenderWindow, webGPURenderer);
    webGPURenderer.setSuppressClear(originalSuppress);
    const device = model._WebGPURenderWindow.getDevice();
    const texture = model._selectionPass.getColorTexture();
    const depthTexture = model._selectionPass.getDepthTexture();
    const result = {
      area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],
      captureZValues: model.captureZValues,
      fieldAssociation: model.fieldAssociation,
      renderer,
      webGPURenderer,
      webGPURenderWindow: model._WebGPURenderWindow,
      width: texture.getWidth(),
      height: texture.getHeight()
    };
    result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);
    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;
    const colorBuffer = vtkWebGPUBuffer$1.newInstance({
      label: "hardwareSelectColorBuffer"
    });
    colorBuffer.setDevice(device);
    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    const cmdEnc = model._WebGPURenderWindow.getCommandEncoder();
    cmdEnc.copyTextureToBuffer({
      texture: texture.getHandle()
    }, {
      buffer: colorBuffer.getHandle(),
      bytesPerRow: 16 * result.colorBufferWidth,
      rowsPerImage: result.height
    }, {
      width: result.width,
      height: result.height,
      depthOrArrayLayers: 1
    });
    let zbuffer;
    if (model.captureZValues) {
      result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);
      zbuffer = vtkWebGPUBuffer$1.newInstance({
        label: "hardwareSelectDepthBuffer"
      });
      zbuffer.setDevice(device);
      result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;
      zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      cmdEnc.copyTextureToBuffer({
        texture: depthTexture.getHandle(),
        aspect: "depth-only"
      }, {
        buffer: zbuffer.getHandle(),
        bytesPerRow: 4 * result.zbufferBufferWidth,
        rowsPerImage: result.height
      }, {
        width: result.width,
        height: result.height,
        depthOrArrayLayers: 1
      });
    }
    device.submitCommandEncoder(cmdEnc);
    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
    if (model.captureZValues) {
      const zLoad = zbuffer.mapAsync(GPUMapMode.READ);
      await Promise.all([cLoad, zLoad]);
      result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());
      zbuffer.unmap();
    } else {
      await cLoad;
    }
    result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());
    colorBuffer.unmap();
    result.generateSelection = (fx1, fy1, fx2, fy2) => generateSelectionWithData2(result, fx1, fy1, fx2, fy2);
    return result;
  };
}
var DEFAULT_VALUES30 = {
  // WebGPURenderWindow: null,
};
function extend30(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES30, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model._selectionPass = vtkWebGPUHardwareSelectionPass$1.newInstance();
  macro.setGet(publicAPI, model, ["_WebGPURenderWindow"]);
  macro.moveToProtected(publicAPI, model, ["WebGPURenderWindow"]);
  vtkWebGPUHardwareSelector(publicAPI, model);
}
var newInstance31 = macro.newInstance(extend30, "vtkWebGPUHardwareSelector");
var vtkWebGPUHardwareSelector$1 = {
  newInstance: newInstance31,
  extend: extend30
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderWindow.js
var {
  vtkErrorMacro: vtkErrorMacro12
} = macro;
var SCREENSHOT_PLACEHOLDER2 = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%"
};
function vtkWebGPURenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderWindow");
  publicAPI.getViewNodeFactory = () => model.myFactory;
  const previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
        publicAPI.recreateSwapChain();
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.recreateSwapChain = () => {
    if (model.context) {
      model.context.unconfigure();
      model.presentationFormat = navigator.gpu.getPreferredCanvasFormat(model.adapter);
      model.context.configure({
        device: model.device.getHandle(),
        format: model.presentationFormat,
        alphaMode: "premultiplied",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
        width: model.size[0],
        height: model.size[1]
      });
      model._configured = true;
    }
  };
  publicAPI.getCurrentTexture = () => model.context.getCurrentTexture();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
    } else if (model.initialized) {
      if (!model._configured) {
        publicAPI.recreateSwapChain();
      }
      model.commandEncoder = model.device.createCommandEncoder();
    }
  };
  publicAPI.initialize = () => {
    if (!model.initializing) {
      model.initializing = true;
      if (!navigator.gpu) {
        vtkErrorMacro12("WebGPU is not enabled.");
        return;
      }
      publicAPI.create3DContextAsync().then(() => {
        model.initialized = true;
        if (model.deleted) {
          return;
        }
        publicAPI.invokeInitialized();
      });
    }
  };
  publicAPI.setContainer = (el) => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro12("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = () => model.el;
  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const {
        width,
        height
      } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = () => model.size;
  publicAPI.create3DContextAsync = async () => {
    model.adapter = await navigator.gpu.requestAdapter({
      powerPreference: "high-performance"
    });
    if (model.deleted) {
      return;
    }
    model.device = vtkWebGPUDevice$1.newInstance();
    model.device.initialize(await model.adapter.requestDevice());
    if (model.deleted) {
      model.device = null;
      return;
    }
    model.context = model.canvas.getContext("webgpu");
  };
  publicAPI.releaseGraphicsResources = () => {
    const rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
    model.adapter = null;
    model.device = null;
    model.context = null;
    model.initialized = false;
    model.initializing = false;
  };
  publicAPI.setBackgroundImage = (img) => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = (value) => {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  async function getCanvasDataURL() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
    const temporaryCanvas = document.createElement("canvas");
    const temporaryContext = temporaryCanvas.getContext("2d");
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    const result = await publicAPI.getPixelsAsync();
    const imageData = new ImageData(result.colorValues, result.width, result.height);
    temporaryContext.putImageData(imageData, 0, 0);
    const mainBoundingClientRect = model.canvas.getBoundingClientRect();
    const renderWindow = model.renderable;
    const renderers = renderWindow.getRenderers();
    renderers.forEach((renderer) => {
      const viewProps = renderer.getViewProps();
      viewProps.forEach((viewProp) => {
        if (viewProp.getContainer) {
          const container = viewProp.getContainer();
          const canvasList = container.getElementsByTagName("canvas");
          for (let i = 0; i < canvasList.length; i++) {
            const currentCanvas = canvasList[i];
            const boundingClientRect = currentCanvas.getBoundingClientRect();
            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    const screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function() {
    let format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    let {
      resetCamera = false,
      size = null,
      scale = 1
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale !== 1 ? size || model.size.map((val) => val * scale) : null
    };
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady((imageURL) => {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach((_ref) => {
                let {
                  restoreParamsFn,
                  arg
                } = _ref;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          const tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER2;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            const isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map((renderer) => {
              const camera = renderer.getActiveCamera();
              const params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : void 0,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                // "clone" the params so we don't keep refs to properties
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach((_ref2) => {
              let {
                resetCameraFn,
                resetCameraArgs
              } = _ref2;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  publicAPI.traverseAllPasses = () => {
    if (model.deleted) {
      return;
    }
    if (!model.initialized) {
      publicAPI.initialize();
      const subscription = publicAPI.onInitialized(() => {
        subscription.unsubscribe();
        publicAPI.traverseAllPasses();
      });
    } else {
      if (model.renderPasses) {
        for (let index = 0; index < model.renderPasses.length; ++index) {
          model.renderPasses[index].traverse(publicAPI, null);
        }
      }
      if (model.commandEncoder) {
        model.device.submitCommandEncoder(model.commandEncoder);
        model.commandEncoder = null;
        if (model.notifyStartCaptureImage) {
          model.device.onSubmittedWorkDone().then(() => {
            getCanvasDataURL();
          });
        }
      }
    }
  };
  publicAPI.setViewStream = (stream) => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady((e) => publicAPI.setBackgroundImage(e.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.getUniquePropID = () => model.nextPropID++;
  publicAPI.getPropFromID = (id) => {
    for (let i = 0; i < model.children.length; i++) {
      const res = model.children[i].getPropFromID(id);
      if (res !== null) {
        return res;
      }
    }
    return null;
  };
  publicAPI.getPixelsAsync = async () => {
    const device = model.device;
    const texture = model.renderPasses[0].getOpaquePass().getColorTexture();
    const result = {
      width: texture.getWidth(),
      height: texture.getHeight()
    };
    result.colorBufferWidth = 32 * Math.floor((result.width + 31) / 32);
    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 8;
    const colorBuffer = vtkWebGPUBuffer$1.newInstance();
    colorBuffer.setDevice(device);
    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    const cmdEnc = model.device.createCommandEncoder();
    cmdEnc.copyTextureToBuffer({
      texture: texture.getHandle()
    }, {
      buffer: colorBuffer.getHandle(),
      bytesPerRow: 8 * result.colorBufferWidth,
      rowsPerImage: result.height
    }, {
      width: result.width,
      height: result.height,
      depthOrArrayLayers: 1
    });
    device.submitCommandEncoder(cmdEnc);
    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
    await cLoad;
    result.colorValues = new Uint16Array(colorBuffer.getMappedRange().slice());
    colorBuffer.unmap();
    const tmparray = new Uint8ClampedArray(result.height * result.width * 4);
    for (let y = 0; y < result.height; y++) {
      for (let x = 0; x < result.width; x++) {
        const doffset = (y * result.width + x) * 4;
        const soffset = (y * result.colorBufferWidth + x) * 4;
        tmparray[doffset] = 255 * HalfFloat.fromHalf(result.colorValues[soffset]);
        tmparray[doffset + 1] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 1]);
        tmparray[doffset + 2] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 2]);
        tmparray[doffset + 3] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 3]);
      }
    }
    result.colorValues = tmparray;
    return result;
  };
  publicAPI.createSelector = () => {
    const ret = vtkWebGPUHardwareSelector$1.newInstance();
    ret.setWebGPURenderWindow(publicAPI);
    return ret;
  };
  const superSetSize = publicAPI.setSize;
  publicAPI.setSize = (width, height) => {
    const modified = superSetSize(width, height);
    if (modified) {
      publicAPI.invokeWindowResizeEvent({
        width,
        height
      });
    }
    return modified;
  };
  publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream);
}
var DEFAULT_VALUES31 = {
  initialized: false,
  context: null,
  adapter: null,
  device: null,
  canvas: null,
  cursorVisibility: true,
  cursor: "pointer",
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  imageFormat: "image/png",
  useOffScreen: false,
  useBackgroundImage: false,
  nextPropID: 1,
  xrSupported: false,
  presentationFormat: null
};
function extend31(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES31, initialValues);
  model.canvas = document.createElement("canvas");
  model.canvas.style.width = "100%";
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  model.myFactory = vtkWebGPUViewNodeFactory$1.newInstance();
  model.renderPasses[0] = vtkForwardPass$12.newInstance();
  if (!model.selector) {
    model.selector = vtkWebGPUHardwareSelector$1.newInstance();
    model.selector.setWebGPURenderWindow(publicAPI);
  }
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "initialized");
  macro.get(publicAPI, model, ["commandEncoder", "device", "presentationFormat", "useBackgroundImage", "xrSupported"]);
  macro.setGet(publicAPI, model, ["initialized", "context", "canvas", "device", "renderPasses", "notifyStartCaptureImage", "cursor", "useOffScreen"]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  macro.event(publicAPI, model, "windowResizeEvent");
  vtkWebGPURenderWindow(publicAPI, model);
}
var newInstance32 = macro.newInstance(extend31, "vtkWebGPURenderWindow");
registerViewConstructor("WebGPU", newInstance32);
var vtkRenderWindow3 = {
  newInstance: newInstance32,
  extend: extend31
};
registerOverride2("vtkRenderWindow", newInstance32);

// node_modules/@kitware/vtk.js/Rendering/Misc/GenericRenderWindow.js
var userParams = vtkURLExtract.extractURLParameters();
function vtkGenericRenderWindow(publicAPI, model) {
  const invokeResize = publicAPI.invokeResize;
  delete publicAPI.invokeResize;
  model.renderWindow = vtkRenderWindow$1.newInstance();
  model.renderer = vtkRenderer$1.newInstance();
  model.renderWindow.addRenderer(model.renderer);
  model._apiSpecificRenderWindow = model.renderWindow.newAPISpecificView(userParams.viewAPI ?? model.defaultViewAPI);
  model.renderWindow.addView(model._apiSpecificRenderWindow);
  model.interactor = vtkRenderWindowInteractor$1.newInstance();
  model.interactor.setInteractorStyle(vtkInteractorStyleTrackballCamera$1.newInstance());
  model.interactor.setView(model._apiSpecificRenderWindow);
  model.interactor.initialize();
  publicAPI.setBackground = model.renderer.setBackground;
  publicAPI.setBackground(...model.background);
  publicAPI.resize = () => {
    if (model.container) {
      const dims = model.container.getBoundingClientRect();
      const devicePixelRatio = window.devicePixelRatio || 1;
      model._apiSpecificRenderWindow.setSize(Math.floor(dims.width * devicePixelRatio), Math.floor(dims.height * devicePixelRatio));
      invokeResize();
      model.renderWindow.render();
    }
  };
  publicAPI.setContainer = (el) => {
    if (model.container) {
      model.interactor.unbindEvents(model.container);
    }
    model.container = el;
    model._apiSpecificRenderWindow.setContainer(model.container);
    if (model.container) {
      model.interactor.bindEvents(model.container);
    }
  };
  publicAPI.delete = macro.chain(publicAPI.setContainer, model._apiSpecificRenderWindow.delete, () => {
    window.removeEventListener("resize", publicAPI.resize);
  }, publicAPI.delete);
  if (model.listenWindowResize) {
    window.addEventListener("resize", publicAPI.resize);
  }
  publicAPI.resize();
}
var DEFAULT_VALUES32 = {
  background: [0.32, 0.34, 0.43],
  listenWindowResize: true,
  container: null
};
function extend32(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES32, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["renderWindow", "renderer", "_apiSpecificRenderWindow", "interactor", "container"]);
  macro.moveToProtected(publicAPI, model, ["_apiSpecificRenderWindow"]);
  macro.event(publicAPI, model, "resize");
  vtkGenericRenderWindow(publicAPI, model);
}
var newInstance33 = macro.newInstance(extend32);
var vtkGenericRenderWindow$1 = {
  newInstance: newInstance33,
  extend: extend32
};

export {
  vtkURLExtract,
  vtkSelectionNode$1,
  Device,
  Input,
  MouseButton,
  vtkRenderWindowInteractor$1,
  vtkInteractorObserver$1,
  States,
  vtkInteractorStyleConstants,
  vtkInteractorStyle$1,
  vtkInteractorStyleTrackballCamera$1,
  vtkCamera$1,
  vtkLight$1,
  vtkViewport$1,
  vtkRenderer$1,
  BlendMode,
  Constants4 as Constants,
  vtkHardwareSelector$1,
  vtkRenderWindow$1,
  vtkOpenGLFramebuffer,
  vtkRenderPass$1,
  vtkForwardPass$1,
  vtkHardwareSelector2 as vtkHardwareSelector,
  vtkShaderCache$1,
  vtkTextureUnitManager,
  vtkRenderWindowViewNode$1,
  GET_UNDERLYING_CONTEXT,
  vtkRenderWindow2 as vtkRenderWindow,
  vtkRenderWindow3 as vtkRenderWindow2,
  extend32 as extend,
  newInstance33 as newInstance,
  vtkGenericRenderWindow$1
};
//# sourceMappingURL=chunk-4PMBHKM2.js.map
