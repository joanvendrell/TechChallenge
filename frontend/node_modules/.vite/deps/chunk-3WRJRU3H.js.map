{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/Core/Points.js", "../../@kitware/vtk.js/Common/Core/CellArray.js", "../../@kitware/vtk.js/Common/DataModel/Cell.js", "../../@kitware/vtk.js/Common/DataModel/CellLinks.js", "../../@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js", "../../@kitware/vtk.js/Common/DataModel/CellTypes.js", "../../@kitware/vtk.js/Common/DataModel/Line/Constants.js", "../../@kitware/vtk.js/Common/DataModel/Line.js", "../../@kitware/vtk.js/Common/DataModel/PointSet.js", "../../@kitware/vtk.js/Common/DataModel/PolyLine.js", "../../@kitware/vtk.js/Common/Core/PriorityQueue.js", "../../@kitware/vtk.js/Common/DataModel/Polygon/Constants.js", "../../@kitware/vtk.js/Common/DataModel/Polygon.js", "../../@kitware/vtk.js/Common/DataModel/Triangle.js", "../../@kitware/vtk.js/Common/DataModel/Quad.js", "../../@kitware/vtk.js/Common/DataModel/TriangleStrip.js", "../../@kitware/vtk.js/Common/DataModel/PolyData/Constants.js", "../../@kitware/vtk.js/Common/DataModel/PolyData.js"],
  "sourcesContent": ["import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\nimport { u as uninitializeBounds } from './Math/index.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n// ----------------------------------------------------------------------------\n// vtkPoints methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPoints(publicAPI, model) {\n  // Keep track of modified time for bounds computation\n  let boundMTime = 0;\n\n  // Set our className\n  model.classHierarchy.push('vtkPoints');\n\n  // Forwarding methods\n  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;\n  publicAPI.setNumberOfPoints = function (nbPoints) {\n    let dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    if (publicAPI.getNumberOfPoints() !== nbPoints) {\n      model.size = nbPoints * dimension;\n      model.values = macro.newTypedArray(model.dataType, model.size);\n      publicAPI.setNumberOfComponents(dimension);\n      publicAPI.modified();\n    }\n  };\n  publicAPI.setPoint = function (idx) {\n    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      xyz[_key - 1] = arguments[_key];\n    }\n    publicAPI.setTuple(idx, xyz);\n  };\n  publicAPI.getPoint = publicAPI.getTuple;\n  publicAPI.findPoint = publicAPI.findTuple;\n  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);\n  publicAPI.insertPoint = (ptId, point) => publicAPI.insertTuple(ptId, point);\n  const superGetBounds = publicAPI.getBounds;\n  publicAPI.getBounds = () => {\n    if (boundMTime < model.mtime) {\n      publicAPI.computeBounds();\n    }\n    return superGetBounds();\n  };\n  const superGetBoundsByReference = publicAPI.getBoundsByReference;\n  publicAPI.getBoundsByReference = () => {\n    if (boundMTime < model.mtime) {\n      publicAPI.computeBounds();\n    }\n    return superGetBoundsByReference();\n  };\n\n  // Trigger the computation of bounds\n  publicAPI.computeBounds = () => {\n    if (publicAPI.getNumberOfComponents() === 3) {\n      const xRange = publicAPI.getRange(0);\n      model.bounds[0] = xRange[0];\n      model.bounds[1] = xRange[1];\n      const yRange = publicAPI.getRange(1);\n      model.bounds[2] = yRange[0];\n      model.bounds[3] = yRange[1];\n      const zRange = publicAPI.getRange(2);\n      model.bounds[4] = zRange[0];\n      model.bounds[5] = zRange[1];\n    } else if (publicAPI.getNumberOfComponents() === 2) {\n      const xRange = publicAPI.getRange(0);\n      model.bounds[0] = xRange[0];\n      model.bounds[1] = xRange[1];\n      const yRange = publicAPI.getRange(1);\n      model.bounds[2] = yRange[0];\n      model.bounds[3] = yRange[1];\n      model.bounds[4] = 0;\n      model.bounds[5] = 0;\n    } else {\n      vtkErrorMacro(`getBounds called on an array with components of ${publicAPI.getNumberOfComponents()}`);\n      uninitializeBounds(model.bounds);\n    }\n    boundMTime = macro.getCurrentGlobalMTime();\n  };\n\n  // Initialize\n  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  empty: true,\n  numberOfComponents: 3,\n  dataType: VtkDataTypes.FLOAT,\n  bounds: [1, -1, 1, -1, 1, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkDataArray.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n  vtkPoints(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPoints');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPoints$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPoints$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\nconst {\n  isVtkObject\n} = macro;\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n    return false;\n  });\n}\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n  return cellId;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  extractCellSizes,\n  getNumberOfCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getNumberOfCells = recompute => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n    return model.numberOfCells;\n  };\n  publicAPI.getCellSizes = recompute => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  /**\n   * When `resize()` is being used, you then MUST use `insertNextCell()`.\n   * @see vtkCellArray#insertNextCell\n   * @see vtkDataArray#allocate\n   */\n  publicAPI.resize = requestedNumTuples => {\n    const oldNumTuples = publicAPI.getNumberOfTuples();\n    superClass.resize(requestedNumTuples);\n    const newNumTuples = publicAPI.getNumberOfTuples();\n    if (newNumTuples < oldNumTuples) {\n      if (newNumTuples === 0) {\n        model.numberOfCells = 0;\n        model.cellSizes = [];\n      } else {\n        // We do not know how many cells are left.\n        // Set to undefined to ensure insertNextCell works correctly.\n        model.numberOfCells = undefined;\n        model.cellSizes = undefined;\n      }\n    }\n  };\n  publicAPI.setData = typedArray => {\n    superClass.setData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n  publicAPI.getCell = loc => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n  publicAPI.insertNextCell = cell => {\n    let cellPointIds;\n    if (isVtkObject(cell)) {\n      cellPointIds = cell.getPointsIds();\n    } else {\n      cellPointIds = cell;\n    }\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);\n    // By computing the number of cells earlier, we made sure that numberOfCells is defined\n    ++model.numberOfCells;\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n    return cellId;\n  };\n  publicAPI.getMaxCellSize = () => publicAPI.getCellSizes().reduce((a, b) => Math.max(a, b), 0);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellArray$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkPoints from '../Core/Points.js';\n\n// ----------------------------------------------------------------------------\n// vtkCell methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCell(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCell');\n  publicAPI.initialize = function (points) {\n    let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!pointIdsList) {\n      model.points = points;\n      model.pointsIds = new Array(points.getNumberOfPoints());\n      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {\n        model.pointsIds[i] = i;\n      }\n    } else {\n      model.pointsIds = pointIdsList;\n      let triangleData = model.points.getData();\n      if (triangleData.length !== 3 * model.pointsIds.length) {\n        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);\n      }\n      const pointsData = points.getData();\n      model.pointsIds.forEach((pointId, index) => {\n        // const start = 3 * pointId;\n        // pointsData.set(p.subarray(start, start + 3), 3 * index);\n        let pointOffset = 3 * pointId;\n        let trianglePointOffset = 3 * index;\n        triangleData[trianglePointOffset] = pointsData[pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n      });\n      model.points.setData(triangleData);\n    }\n  };\n  publicAPI.getBounds = () => model.points.getBounds();\n  publicAPI.getLength2 = () => {\n    const lengths = vtkBoundingBox.getLengths(publicAPI.getBounds());\n    return lengths[0] * lengths[0] + lengths[1] * lengths[1] + lengths[2] * lengths[2];\n  };\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    for (let i = 0; i < 3; i++) {\n      if (pcoords[i] < 0.0) {\n        pDist = -pcoords[i];\n      } else if (pcoords[i] > 1.0) {\n        pDist = pcoords[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n  publicAPI.deepCopy = cell => {\n    cell.initialize(model.points, model.pointsIds);\n  };\n  publicAPI.getCellDimension = () => {}; // virtual\n  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual\n  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {\n    macro.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');\n  }; // virtual\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bounds: [-1, -1, -1, -1, -1, -1],\n  pointsIds: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  }\n  macro.get(publicAPI, model, ['points', 'pointsIds']);\n  vtkCell(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCell');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCell$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkCell$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst InitLink = {\n  ncells: 0,\n  cells: null\n};\nfunction resize(model, sz) {\n  let newSize = sz;\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n  while (newSize > model.array.length) model.array.push({\n    ncells: 0,\n    cells: null\n  });\n  model.array.length = newSize;\n}\n\n// ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n  publicAPI.buildLinks = data => {\n    const numPts = data.getPoints().getNumberOfPoints();\n    const numCells = data.getNumberOfCells();\n\n    // fill out lists with number of references to cells\n    const linkLoc = new Uint32Array(numPts);\n\n    // Use fast path if polydata\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; cellId++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // end else\n  };\n\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n  publicAPI.allocate = function (numLinks) {\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.array = Array(numLinks).fill().map(() => ({\n      ncells: 0,\n      cells: null\n    }));\n    model.extend = ext;\n    model.maxId = -1;\n  };\n  publicAPI.initialize = () => {\n    model.array = null;\n  };\n\n  /**\n   * Get a link structure given a point id.\n   */\n  publicAPI.getLink = ptId => model.array[ptId];\n\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n  publicAPI.getNcells = ptId => model.array[ptId].ncells;\n\n  /**\n   * Return a list of cell ids using the point.\n   */\n  publicAPI.getCells = ptId => model.array[ptId].cells;\n\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n  publicAPI.insertNextPoint = numLinks => {\n    model.array.push({\n      ncells: numLinks,\n      cells: Array(numLinks)\n    });\n    ++model.maxId;\n  };\n\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n  publicAPI.insertNextCellReference = (ptId, cellId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n  publicAPI.deletePoint = ptId => {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n  publicAPI.removeCellReference = (cellId, ptId) => {\n    model.array[ptId].cells = model.array[ptId].cells.filter(cell => cell !== cellId);\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n  publicAPI.addCellReference = (cellId, ptId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n  publicAPI.resizeCellList = (ptId, size) => {\n    model.array[ptId].cells.length = size;\n  };\n\n  /**\n   * Reclaim any unused memory.\n   */\n  publicAPI.squeeze = () => {\n    resize(model, model.maxId + 1);\n  };\n\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    model.array = [...src.array];\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n  publicAPI.incrementLinkCount = ptId => {\n    ++model.array[ptId].ncells;\n  };\n  publicAPI.allocateLinks = n => {\n    for (let i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n  publicAPI.insertCellReference = (ptId, pos, cellId) => {\n    model.array[ptId].cells[pos] = cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  array: null,\n  // pointer to data\n  maxId: 0,\n  // maximum index inserted thus far\n  extend: 0 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkCellLinks(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellLinks');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellLinks$1 = {\n  newInstance,\n  extend\n};\n\nexport { InitLink, vtkCellLinks$1 as default, extend, newInstance };\n", "const CellType = {\n  // Linear cells\n  VTK_EMPTY_CELL: 0,\n  VTK_VERTEX: 1,\n  VTK_POLY_VERTEX: 2,\n  VTK_LINE: 3,\n  VTK_POLY_LINE: 4,\n  VTK_TRIANGLE: 5,\n  VTK_TRIANGLE_STRIP: 6,\n  VTK_POLYGON: 7,\n  VTK_PIXEL: 8,\n  VTK_QUAD: 9,\n  VTK_TETRA: 10,\n  VTK_VOXEL: 11,\n  VTK_HEXAHEDRON: 12,\n  VTK_WEDGE: 13,\n  VTK_PYRAMID: 14,\n  VTK_PENTAGONAL_PRISM: 15,\n  VTK_HEXAGONAL_PRISM: 16,\n  // Quadratic, isoparametric cells\n  VTK_QUADRATIC_EDGE: 21,\n  VTK_QUADRATIC_TRIANGLE: 22,\n  VTK_QUADRATIC_QUAD: 23,\n  VTK_QUADRATIC_POLYGON: 36,\n  VTK_QUADRATIC_TETRA: 24,\n  VTK_QUADRATIC_HEXAHEDRON: 25,\n  VTK_QUADRATIC_WEDGE: 26,\n  VTK_QUADRATIC_PYRAMID: 27,\n  VTK_BIQUADRATIC_QUAD: 28,\n  VTK_TRIQUADRATIC_HEXAHEDRON: 29,\n  VTK_QUADRATIC_LINEAR_QUAD: 30,\n  VTK_QUADRATIC_LINEAR_WEDGE: 31,\n  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,\n  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,\n  VTK_BIQUADRATIC_TRIANGLE: 34,\n  // Cubic, isoparametric cell\n  VTK_CUBIC_LINE: 35,\n  // Special class of cells formed by convex group of points\n  VTK_CONVEX_POINT_SET: 41,\n  // Polyhedron cell (consisting of polygonal faces)\n  VTK_POLYHEDRON: 42,\n  // Higher order cells in parametric form\n  VTK_PARAMETRIC_CURVE: 51,\n  VTK_PARAMETRIC_SURFACE: 52,\n  VTK_PARAMETRIC_TRI_SURFACE: 53,\n  VTK_PARAMETRIC_QUAD_SURFACE: 54,\n  VTK_PARAMETRIC_TETRA_REGION: 55,\n  VTK_PARAMETRIC_HEX_REGION: 56,\n  // Higher order cells\n  VTK_HIGHER_ORDER_EDGE: 60,\n  VTK_HIGHER_ORDER_TRIANGLE: 61,\n  VTK_HIGHER_ORDER_QUAD: 62,\n  VTK_HIGHER_ORDER_POLYGON: 63,\n  VTK_HIGHER_ORDER_TETRAHEDRON: 64,\n  VTK_HIGHER_ORDER_WEDGE: 65,\n  VTK_HIGHER_ORDER_PYRAMID: 66,\n  VTK_HIGHER_ORDER_HEXAHEDRON: 67,\n  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)\n  VTK_LAGRANGE_CURVE: 68,\n  VTK_LAGRANGE_TRIANGLE: 69,\n  VTK_LAGRANGE_QUADRILATERAL: 70,\n  VTK_LAGRANGE_TETRAHEDRON: 71,\n  VTK_LAGRANGE_HEXAHEDRON: 72,\n  VTK_LAGRANGE_WEDGE: 73,\n  VTK_LAGRANGE_PYRAMID: 74,\n  VTK_NUMBER_OF_CELL_TYPES: 75\n};\n\n// This list should contain the cell class names in\n// the same order as in CellType.\nconst CellTypesStrings = ['vtkEmptyCell', 'vtkVertex', 'vtkPolyVertex', 'vtkLine', 'vtkPolyLine', 'vtkTriangle', 'vtkTriangleStrip', 'vtkPolygon', 'vtkPixel', 'vtkQuad', 'vtkTetra', 'vtkVoxel', 'vtkHexahedron', 'vtkWedge', 'vtkPyramid', 'vtkPentagonalPrism', 'vtkHexagonalPrism', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkQuadraticEdge', 'vtkQuadraticTriangle', 'vtkQuadraticQuad', 'vtkQuadraticTetra', 'vtkQuadraticHexahedron', 'vtkQuadraticWedge', 'vtkQuadraticPyramid', 'vtkBiQuadraticQuad', 'vtkTriQuadraticHexahedron', 'vtkQuadraticLinearQuad', 'vtkQuadraticLinearWedge', 'vtkBiQuadraticQuadraticWedge', 'vtkBiQuadraticQuadraticHexahedron', 'vtkBiQuadraticTriangle', 'vtkCubicLine', 'vtkQuadraticPolygon', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkConvexPointSet', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkParametricCurve', 'vtkParametricSurface', 'vtkParametricTriSurface', 'vtkParametricQuadSurface', 'vtkParametricTetraRegion', 'vtkParametricHexRegion', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkHigherOrderEdge', 'vtkHigherOrderTriangle', 'vtkHigherOrderQuad', 'vtkHigherOrderPolygon', 'vtkHigherOrderTetrahedron', 'vtkHigherOrderWedge', 'vtkHigherOrderPyramid', 'vtkHigherOrderHexahedron'];\nvar Constants = {\n  CellType,\n  CellTypesStrings\n};\n\nexport { CellType, CellTypesStrings, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport { CellTypesStrings, CellType } from './CellTypes/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';\n}\n\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\nfunction isLinear(type) {\n  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;\n}\nfunction hasSubCells(cellType) {\n  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  getClassNameFromTypeId,\n  getTypeIdFromClassName,\n  isLinear,\n  hasSubCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n  publicAPI.allocate = function () {\n    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n\n  /**\n   * Add a cell at specified id.\n   */\n  publicAPI.insertCell = (cellId, type, loc) => {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n  publicAPI.insertNextCell = (type, loc) => {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {\n    model.size = ncells;\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n    model.maxId = ncells - 1;\n  };\n\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n  publicAPI.getCellLocation = cellId => model.locationArray[cellId];\n\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n  publicAPI.deleteCell = cellId => {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n\n  /**\n   * Return the number of types in the list.\n   */\n  publicAPI.getNumberOfTypes = () => model.maxId + 1;\n\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n  publicAPI.isType = type => {\n    const numTypes = publicAPI.getNumberOfTypes();\n    for (let i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);\n\n  /**\n   * Return the type of cell.\n   */\n  publicAPI.getCellType = cellId => model.typeArray[cellId];\n\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0,\n  // allocated size of data\n  maxId: -1,\n  // maximum index inserted thus far\n  extend: 1000 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n  vtkCellTypes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellTypes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellTypes$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellTypes$1 as default, extend, newInstance };\n", "const IntersectionState = {\n  NO_INTERSECTION: 0,\n  YES_INTERSECTION: 1,\n  ON_LINE: 2\n};\nvar Constants = {\n  IntersectionState\n};\n\nexport { IntersectionState, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, f as distance2BetweenPoints, s as subtract, g as solveLinearSystem } from '../Core/Math/index.js';\nimport { quat } from 'gl-matrix';\n\nconst {\n  IntersectionState\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nfunction distanceToLine(x, p1, p2) {\n  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  const p21 = [];\n  let closest;\n  // Determine appropriate vector\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2];\n\n  // Get parametric location\n  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  const denom = dot(p21, p21);\n\n  // trying to avoid an expensive fabs\n  let tolerance = 1e-5 * num;\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\nfunction intersection(a1, a2, b1, b2, u, v) {\n  const a21 = [];\n  const b21 = [];\n  const b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0;\n\n  // Determine line vectors.\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1);\n\n  // Compute the system (least squares) matrix.\n  const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];\n\n  // Compute the least squares system constant term.\n  const c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1);\n  // Solve the system of equations\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    let minDist = Number.MAX_VALUE;\n    const p = [a1, a2, b1, b2];\n    const l1 = [b1, b1, a1, a1];\n    const l2 = [b2, b2, a2, a2];\n    [v[0], v[0], u[0], u[0]];\n    [u[0], u[0], v[0], v[0]];\n    let obj;\n    for (let i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n        obj.t;\n      }\n    }\n    return IntersectionState.ON_LINE;\n  }\n  u[0] = c[0];\n  v[0] = c[1];\n\n  // Check parametric coordinates for intersection.\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n  return IntersectionState.NO_INTERSECTION;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  distanceToLine,\n  intersection\n};\n\n// ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    const projXYZ = [];\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    const u = [];\n    const v = [];\n    const intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (let i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      let outDistance;\n      // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n          return outObj;\n        }\n        return outObj;\n      }\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    for (let i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n  publicAPI.evaluateOrientation = (pcoords, q, weights) => {\n    if (model.orientations) {\n      quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);\n      weights[0] = 1.0 - pcoords[0];\n      weights[1] = pcoords[0];\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null // an array of two quat or null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations']);\n  vtkLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkLine$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkLine$1 as default, extend, newInstance };\n", "import vtk from '../../vtk.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkPoints from '../Core/Points.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkPointSet methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointSet(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointSet');\n\n  // Create empty points\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  } else {\n    model.points = vtk(model.points);\n  }\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n  publicAPI.getBounds = () => model.points.getBounds();\n  publicAPI.computeBounds = () => {\n    publicAPI.getBounds();\n  };\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    model.points = vtkPoints.newInstance();\n    model.points.shallowCopy(other.getPoints());\n  };\n  const superGetMTime = publicAPI.getMTime;\n  publicAPI.getMTime = () => {\n    const mTime = superGetMTime();\n    return Math.max(mTime, model.points?.getMTime() ?? mTime);\n  };\n  const superInitialize = publicAPI.initialize;\n  publicAPI.initialize = () => {\n    model.points?.initialize();\n    return superInitialize();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // points: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['points']);\n\n  // Object specific methods\n  vtkPointSet(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPointSet');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPointSet$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPointSet$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport vtkLine from './Line.js';\nimport { vec3 } from 'gl-matrix';\n\nfunction vtkPolyLine(publicAPI, model) {\n  model.classHierarchy.push('vtkPolyLine');\n  const line = vtkLine.newInstance();\n  line.getPoints().setNumberOfPoints(2);\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (t1, t2, p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    const numLines = publicAPI.getNumberOfPoints() - 1;\n    let pDistMin = Number.MAX_VALUE;\n    for (let subId = 0; subId < numLines; subId++) {\n      const pCoords = [0, 0, 0];\n      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n      const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);\n      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {\n        outObj.intersect = 1;\n        const pDist = line.getParametricDistance(pCoords);\n        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {\n          outObj.subId = subId;\n          outObj.t = lineIntersected.t;\n          pDistMin = pDist;\n          for (let k = 0; k < 3; k++) {\n            x[k];\n            pCoords[k];\n          }\n        }\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {\n    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n    return line.evaluateLocation(pcoords, x, weights);\n  };\n  publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {\n    if (model.orientations) {\n      line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);\n    } else {\n      line.setOrientations(null);\n    }\n    return line.evaluateOrientation(pcoords, q, weights);\n  };\n  publicAPI.getDistancesToFirstPoint = () => {\n    const dTime = model.distancesTime.getMTime();\n    if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {\n      const numPoints = publicAPI.getNumberOfPoints();\n      if (!model.distances) {\n        model.distances = new Array(numPoints);\n      } else {\n        model.distances.length = numPoints;\n      }\n      if (numPoints > 0) {\n        const previousPoint = new Array(3);\n        const currentPoint = new Array(3);\n        let totalDistance = 0;\n        model.distances[0] = totalDistance;\n        model.points.getPoint(0, previousPoint);\n        for (let i = 1; i < numPoints; ++i) {\n          model.points.getPoint(i, currentPoint);\n          totalDistance += model.distanceFunction(previousPoint, currentPoint);\n          model.distances[i] = totalDistance;\n          vec3.copy(previousPoint, currentPoint);\n        }\n      }\n      model.distancesTime.modified();\n    }\n    return model.distances;\n  };\n  publicAPI.findPointIdAtDistanceFromFirstPoint = distance => {\n    const distances = publicAPI.getDistancesToFirstPoint();\n    // At least two points to return an ID\n    if (distances.length < 2) {\n      return -1;\n    }\n    // Binary search in the distance array\n    let minId = 0;\n    let maxId = distances.length - 1;\n    if (distance < distances[minId] || distance > distances[maxId] || distances[maxId] === 0) {\n      return -1;\n    }\n    while (maxId - minId > 1) {\n      const midId = Math.floor((minId + maxId) / 2);\n      if (distances[midId] <= distance) {\n        minId = midId;\n      } else {\n        maxId = midId;\n      }\n    }\n    return minId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null,\n  // an array of quat or null\n  distanceFunction: vec3.dist\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations', 'distanceFunction']);\n  model.distancesTime = {};\n  macro.obj(model.distancesTime, {\n    mtime: 0\n  });\n  vtkPolyLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyLine$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPolyLine$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkPriorityQueue methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPriorityQueue(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkPriorityQueue');\n  publicAPI.push = (priority, element) => {\n    // naive algo\n    const i = model.elements.findIndex(e => e.priority > priority);\n    model.elements.splice(i, 0, {\n      priority,\n      element\n    });\n  };\n  publicAPI.pop = () => {\n    if (model.elements.length > 0) {\n      return model.elements.shift().element;\n    }\n    return null;\n  };\n  publicAPI.deleteById = id => {\n    model.elements = model.elements.filter(_ref => {\n      let {\n        element\n      } = _ref;\n      return element.id !== id;\n    });\n  };\n  publicAPI.length = () => model.elements.length;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elements: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  vtkPriorityQueue(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPriorityQueue');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPriorityQueue$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPriorityQueue$1 as default, extend, newInstance };\n", "const EPSILON = 1e-6;\nconst FLOAT_EPSILON = 1.1920929e-7;\nconst TOLERANCE = 1e-8;\nconst PolygonWithPointIntersectionState = {\n  FAILURE: -1,\n  OUTSIDE: 0,\n  INSIDE: 1,\n  INTERSECTION: 2,\n  ON_LINE: 3\n};\n\nexport { EPSILON, FLOAT_EPSILON, PolygonWithPointIntersectionState, TOLERANCE };\n", "import { m as macro } from '../../macros2.js';\nimport { d as dot, s as subtract, j as cross, k as add, l as normalize, f as distance2BetweenPoints, n as norm } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\nimport vtkPriorityQueue from '../Core/PriorityQueue.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport { IntersectionState } from './Line/Constants.js';\nimport { PolygonWithPointIntersectionState, FLOAT_EPSILON, TOLERANCE, EPSILON } from './Polygon/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Given the line (p0,p1), determine if the given point is located to the left\n// of, on, or to the right of a line (with the function returning >0, ==0, or\n// <0 respectively). The points are assumed 3D points, but projected into\n// one of x-y-z planes; hence the indices axis0 and axis1 specify which plane\n// the computation is to be performed on.\nfunction pointLocation(axis0, axis1, p0, p1, point) {\n  return (p1[axis0] - p0[axis0]) * (point[axis1] - p0[axis1]) - (point[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);\n}\n\n//------------------------------------------------------------------------------\n\nfunction pointInPolygon(point, vertices, bounds, normal) {\n  // Do a quick bounds check to throw out trivial cases.\n  // winding plane.\n  if (point[0] < bounds[0] || point[0] > bounds[1] || point[1] < bounds[2] || point[1] > bounds[3] || point[2] < bounds[4] || point[2] > bounds[5]) {\n    return PolygonWithPointIntersectionState.OUTSIDE;\n  }\n\n  //  Check that the normal is non-zero.\n  if (normalize(normal) <= FLOAT_EPSILON) {\n    return PolygonWithPointIntersectionState.FAILURE;\n  }\n\n  // Assess whether the point lies on the boundary of the polygon. Points on\n  // the boundary are considered inside the polygon. Need to define a small\n  // tolerance relative to the bounding box diagonal length of the polygon.\n  let tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));\n  tol2 *= tol2;\n  tol2 = tol2 === 0.0 ? FLOAT_EPSILON : tol2;\n  const p0 = [];\n  const p1 = [];\n  for (let i = 0; i < vertices.length;) {\n    // Check coincidence to polygon vertices\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n    if (distance2BetweenPoints(point, p0) <= tol2) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n\n    // Check coincidence to polygon edges\n    const {\n      distance,\n      t\n    } = vtkLine.distanceToLine(point, p0, p1);\n    if (distance <= tol2 && t > 0.0 && t < 1.0) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n  }\n\n  // If here, begin computation of the winding number. This method works for\n  // points/polygons arbitrarily oriented in 3D space.  Hence a projection\n  // onto one of the x-y-z coordinate planes using the maximum normal\n  // component. The computation will be performed in the (axis0, axis1) plane.\n  let axis0;\n  let axis1;\n  if (Math.abs(normal[0]) > Math.abs(normal[1])) {\n    if (Math.abs(normal[0]) > Math.abs(normal[2])) {\n      axis0 = 1;\n      axis1 = 2;\n    } else {\n      axis0 = 0;\n      axis1 = 1;\n    }\n  } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {\n    axis0 = 0;\n    axis1 = 2;\n  } else {\n    axis0 = 0;\n    axis1 = 1;\n  }\n\n  // Compute the winding number wn. If after processing all polygon edges\n  // wn == 0, then the point is outside.  Otherwise, the point is inside the\n  // polygon. Process all polygon edges determining if there are ascending or\n  // descending crossings of the line axis1=constant.\n  let wn = 0;\n  for (let i = 0; i < vertices.length;) {\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n    if (i < vertices.length) {\n      p1[0] = vertices[i];\n      p1[1] = vertices[i + 1];\n      p1[2] = vertices[i + 2];\n    } else {\n      p1[0] = vertices[0];\n      p1[1] = vertices[1];\n      p1[2] = vertices[2];\n    }\n    if (p0[axis1] <= point[axis1]) {\n      if (p1[axis1] > point[axis1]) {\n        // if an upward crossing\n        if (pointLocation(axis0, axis1, p0, p1, point) > 0) {\n          // if x left of edge\n          ++wn; // a valid up intersect, increment the winding number\n        }\n      }\n    } else if (p1[axis1] <= point[axis1]) {\n      // if a downward crossing\n      if (pointLocation(axis0, axis1, p0, p1, point) < 0) {\n        // if x right of edge\n        --wn; // a valid down intersect, decrement the winding number\n      }\n    }\n  } // Over all polygon edges\n\n  // A winding number == 0 is outside the polygon\n  return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;\n}\n\n// ---------------------------------------------------\n/**\n * Simple utility method for computing polygon bounds.\n * Returns the sum of the squares of the dimensions.\n * Requires a poly with at least one point.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Bound} bounds\n */\nfunction getBounds(poly, points, bounds) {\n  const n = poly.length;\n  const p = [];\n  points.getPoint(poly[0], p);\n  bounds[0] = p[0];\n  bounds[1] = p[0];\n  bounds[2] = p[1];\n  bounds[3] = p[1];\n  bounds[4] = p[2];\n  bounds[5] = p[2];\n  for (let j = 1; j < n; j++) {\n    points.getPoint(poly[j], p);\n    vtkBoundingBox.addPoint(bounds, ...p);\n  }\n  const length = vtkBoundingBox.getLengths(bounds);\n  return dot(length, length);\n}\n\n// ---------------------------------------------------\n/**\n * Compute the normal of a polygon and return its norm.\n *\n * TBD: This does the same thing as vtkPolygon.computeNormal,\n * but in a more generic way. Maybe we can keep the public\n * static method somehow and have the private method use it instead.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @returns {Number}\n */\nfunction getNormal(poly, points, normal) {\n  normal.length = 3;\n  normal[0] = 0.0;\n  normal[1] = 0.0;\n  normal[2] = 0.0;\n  const p0 = [];\n  let p1 = [];\n  let p2 = [];\n  const v1 = [];\n  const v2 = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  for (let j = 2; j < poly.length; j++) {\n    points.getPoint(poly[j], p2);\n    subtract(p2, p1, v1);\n    subtract(p0, p1, v2);\n    const n = [0, 0, 0];\n    cross(v1, v2, n);\n    add(normal, n, normal);\n    [p1, p2] = [p2, p1];\n  }\n  return normalize(normal);\n}\n\n/**\n * Compute the centroid of a polygon.\n * @param {Array<number>} poly - Array of point indices for the polygon\n * @param {vtkPoints} points - vtkPoints instance\n * @param {Vector3} [centroid] - Optional output array (length 3)\n * @returns {Vector3} The centroid as [x, y, z]\n */\nfunction computeCentroid(poly, points) {\n  let centroid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0];\n  centroid[0] = 0;\n  centroid[1] = 0;\n  centroid[2] = 0;\n  const n = poly.length;\n  const p = [];\n  for (let i = 0; i < n; i++) {\n    points.getPoint(poly[i], p);\n    centroid[0] += p[0];\n    centroid[1] += p[1];\n    centroid[2] += p[2];\n  }\n  centroid[0] /= n;\n  centroid[1] /= n;\n  centroid[2] /= n;\n  return centroid;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  PolygonWithPointIntersectionState,\n  pointInPolygon,\n  getBounds,\n  getNormal,\n  computeCentroid\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolygon methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolygon(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkPolygon');\n  function computeNormal() {\n    const v1 = [0, 0, 0];\n    const v2 = [0, 0, 0];\n    model.normal = [0, 0, 0];\n    const anchor = [...model.firstPoint.point];\n    let point = model.firstPoint;\n    for (let i = 0; i < model.pointCount; i++) {\n      subtract(point.point, anchor, v1);\n      subtract(point.next.point, anchor, v2);\n      const n = [0, 0, 0];\n      cross(v1, v2, n);\n      add(model.normal, n, model.normal);\n      point = point.next;\n    }\n    return normalize(model.normal);\n  }\n  function computeMeasure(point) {\n    const v1 = [0, 0, 0];\n    const v2 = [0, 0, 0];\n    const v3 = [0, 0, 0];\n    const v4 = [0, 0, 0];\n    subtract(point.point, point.previous.point, v1);\n    subtract(point.next.point, point.point, v2);\n    subtract(point.previous.point, point.next.point, v3);\n    cross(v1, v2, v4);\n    const area = dot(v4, model.normal);\n    if (area <= 0) {\n      return -1;\n    }\n    const perimeter = norm(v1) + norm(v2) + norm(v3);\n    return perimeter * perimeter / area;\n  }\n  function canRemoveVertex(point) {\n    if (model.pointCount <= 3) {\n      return true;\n    }\n    const previous = point.previous;\n    const next = point.next;\n    const v = [0, 0, 0];\n    subtract(next.point, previous.point, v);\n    const sN = [0, 0, 0];\n    cross(v, model.normal, sN);\n    normalize(sN);\n    if (norm(sN) === 0) {\n      return false;\n    }\n    let val = vtkPlane.evaluate(sN, previous.point, next.next.point);\n    // eslint-disable-next-line no-nested-ternary\n    let currentSign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n    let oneNegative = currentSign < 0 ? 1 : 0;\n    for (let vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {\n      const previousVertex = vertex.previous;\n      val = vtkPlane.evaluate(sN, previous.point, vertex.point);\n      // eslint-disable-next-line no-nested-ternary\n      const sign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n      if (sign !== currentSign) {\n        if (!oneNegative) {\n          oneNegative = sign <= 0 ? 1 : 0;\n        }\n        if (vtkLine.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {\n          return false;\n        }\n        currentSign = sign;\n      }\n    }\n    return oneNegative === 1;\n  }\n  function removePoint(point, queue) {\n    model.pointCount -= 1;\n    const previous = point.previous;\n    const next = point.next;\n    model.tris = model.tris.concat(point.point);\n    model.tris = model.tris.concat(next.point);\n    model.tris = model.tris.concat(previous.point);\n    previous.next = next;\n    next.previous = previous;\n    queue.deleteById(previous.id);\n    queue.deleteById(next.id);\n    const previousMeasure = computeMeasure(previous);\n    if (previousMeasure > 0) {\n      queue.push(previousMeasure, previous);\n    }\n    const nextMeasure = computeMeasure(next);\n    if (nextMeasure > 0) {\n      queue.push(nextMeasure, next);\n    }\n    if (point.id === model.firstPoint.id) {\n      model.firstPoint = next;\n    }\n  }\n  function earCutTriangulation() {\n    computeNormal();\n    const vertexQueue = vtkPriorityQueue.newInstance();\n    let point = model.firstPoint;\n    for (let i = 0; i < model.pointCount; i++) {\n      const measure = computeMeasure(point);\n      if (measure > 0) {\n        vertexQueue.push(measure, point);\n      }\n      point = point.next;\n    }\n    while (model.pointCount > 2 && vertexQueue.length() > 0) {\n      if (model.pointCount === vertexQueue.length()) {\n        // convex\n        const pointToRemove = vertexQueue.pop();\n        removePoint(pointToRemove, vertexQueue);\n      } else {\n        // concave\n        const pointToRemove = vertexQueue.pop();\n        if (canRemoveVertex(pointToRemove)) {\n          removePoint(pointToRemove, vertexQueue);\n        }\n      }\n    }\n    return model.pointCount <= 2;\n  }\n  publicAPI.triangulate = () => {\n    if (!model.firstPoint) {\n      return null;\n    }\n    return earCutTriangulation();\n  };\n  publicAPI.setPoints = points => {\n    model.pointCount = points.length;\n    model.firstPoint = {\n      id: 0,\n      point: points[0],\n      next: null,\n      previous: null\n    };\n    let currentPoint = model.firstPoint;\n    for (let i = 1; i < model.pointCount; i++) {\n      currentPoint.next = {\n        id: i,\n        point: points[i],\n        next: null,\n        previous: currentPoint\n      };\n      currentPoint = currentPoint.next;\n    }\n    model.firstPoint.previous = currentPoint;\n    currentPoint.next = model.firstPoint;\n  };\n  publicAPI.getPointArray = () => model.tris;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  firstPoint: null,\n  pointCount: 0,\n  tris: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  vtkPolygon(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolygon');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolygon$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { computeCentroid, vtkPolygon$1 as default, extend, getBounds, getNormal, newInstance };\n", "import { m as macro, T as TYPED_ARRAYS } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, j as cross, l as normalize, m as multiplyAccumulate, f as distance2BetweenPoints, o as determinant2x2, s as subtract, p as invertMatrix } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  const ax = v3[0] - v2[0];\n  const ay = v3[1] - v2[1];\n  const az = v3[2] - v2[2];\n  const bx = v1[0] - v2[0];\n  const by = v1[1] - v2[1];\n  const bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\nfunction interpolationDerivs(derivs) {\n  // Order: [dN1/dr, dN2/dr, dN3/dr, dN1/ds, dN2/ds, dN3/ds]\n  // r-derivatives\n  derivs[0] = -1.0;\n  derivs[1] = 1.0;\n  derivs[2] = 0.0;\n\n  // s-derivatives\n  derivs[3] = -1.0;\n  derivs[4] = 0.0;\n  derivs[5] = 1.0;\n}\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  let coplanar = false;\n  const pt1 = [];\n  const pt2 = [];\n  const surfaceId = [];\n  const n1 = [];\n  const n2 = [];\n\n  // Compute supporting plane normals.\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  const s1 = -dot(n1, p1);\n  const s2 = -dot(n2, p2);\n\n  // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n  const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n  const dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Check for coplanarity of the supporting planes.\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true;\n    // vtkDebugMacro(<<\"Coplanar!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n  const pts1 = [p1, q1, r1];\n  const pts2 = [p2, q2, r2];\n\n  // Find line of intersection (L = p + t*v) between two planes.\n  const n1n2 = dot(n1, n2);\n  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  const v = cross(n1, n2, []);\n  normalize(v);\n  let index1 = 0;\n  let index2 = 0;\n  const t1 = [];\n  const t2 = [];\n  let ts1 = 50;\n  let ts2 = 50;\n  for (let i = 0; i < 3; i++) {\n    const id1 = i;\n    const id2 = (i + 1) % 3;\n\n    // Find t coordinate on line of intersection between two planes.\n    const val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n    const val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  }\n\n  // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n  if (index1 > 2) {\n    index1--;\n    // swap\n    const t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n  if (index2 > 2) {\n    index2--;\n    const t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  }\n  // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // Check for NaNs\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  if (t1[0] > t1[1]) {\n    // swap\n    const t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n  if (t2[0] > t2[1]) {\n    // swap\n    const t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  }\n  // Handle the different interval configuration cases.\n  let tt1;\n  let tt2;\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  }\n\n  // Create actual intersection points.\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar,\n    pt1,\n    pt2,\n    surfaceId\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeNormalDirection,\n  computeNormal,\n  interpolationDerivs,\n  intersectWithTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    const closestPoint = [];\n    const tol2 = tol * tol;\n\n    // Get normal for triangle\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    const n = [];\n    const weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      const plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      }\n\n      // Evaluate position\n      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    }\n\n    // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n    if (intersectLine.intersect) {\n      const pt3Pt1 = [];\n      const pt3Pt2 = [];\n      const pt3X = [];\n      // Compute r and s manually, using dot and norm.\n      for (let i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n\n  /**\n   * Evaluates whether the specified point is inside (1), outside (0), or\n   * indeterminate (-1) for the cell; computes parametric coordinates, sub-cell\n   * ID (if applicable), squared distance to the cell (and closest point if\n   * requested), and interpolation weights for the cell.\n   *\n   * @param {Vector3} x The x point coordinate.\n   * @param {Vector3} closestPoint The closest point coordinate.\n   * @param {Vector3} pcoords The parametric coordinates.\n   * @param {Number[]} weights The number of weights.\n   */\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {\n    // will return obj\n    const outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    let i;\n    let j;\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    const n = [];\n    let fabsn;\n    const rhs = [];\n    const c1 = [];\n    const c2 = [];\n    let det = 0;\n    let idx = 0;\n    const indices = [];\n    let dist2Point;\n    let dist2Line1;\n    let dist2Line2;\n    let closest = [];\n    const closestPoint1 = [];\n    const closestPoint2 = [];\n    const cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0;\n\n    // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n);\n\n    // Project point to plane\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp);\n\n    // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n    let maxComponent = 0.0;\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n    det = determinant2x2(c1, c2);\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det;\n\n    // Okay, now find closest point to element\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n      outObj.evaluation = 1;\n    } else {\n      let t;\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        }\n      }\n      outObj.evaluation = 0;\n    }\n    return outObj;\n  };\n\n  /**\n   * Determine global coordinates (x) from the given subId and parametric\n   * coordinates.\n   * @param {Vector3} pcoords The parametric coordinates.\n   * @param {Vector3} x The x point coordinate.\n   * @param {Number[]} weights The number of weights.\n   */\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const p0 = [];\n    const p1 = [];\n    const p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n\n  /**\n   * Get the distance of the parametric coordinate provided to the cell.\n   * @param {Vector3} pcoords The parametric coordinates.\n   */\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    const pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n\n  /**\n   * Get the derivatives of the triangle strip.\n   * @param {Number} subId - The sub-id of the triangle.\n   * @param {Vector3} pcoords - The parametric coordinates.\n   * @param {Number[]} values - The values at the points.\n   * @param {Number} dim - The dimension.\n   * @param {Number[]} derivs - The derivatives.\n   */\n  publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {\n    const x0 = model.points.getPoint(0);\n    const x1 = model.points.getPoint(1);\n    const x2 = model.points.getPoint(2);\n    const n = [];\n    const v10 = [];\n    const v20 = [];\n    const v = [];\n    computeNormal(x0, x1, x2, n);\n    subtract(x1, x0, v10);\n    subtract(x2, x0, v);\n    cross(n, v10, v20);\n    const lenX = normalize(v10); // check for degenerate triangle\n\n    if (lenX <= 0.0 || normalize(v20) <= 0.0) {\n      // degenerate\n      for (let j = 0; j < dim; j++) {\n        for (let i = 0; i < 3; i++) {\n          derivs[j * dim + i] = 0.0;\n        }\n      }\n      return;\n    }\n\n    // 2D coordinates\n    const v0 = [0, 0];\n    const v1 = [lenX, 0];\n    const v2 = [dot(v, v10), dot(v, v20)];\n    const functionDerivs = new Array(6);\n    interpolationDerivs(functionDerivs);\n\n    // Compute Jacobian: Jacobian is constant for a triangle.\n    const J = [v1[0] - v0[0], v1[1] - v0[1], v2[0] - v0[0], v2[1] - v0[1]];\n\n    // Compute inverse Jacobian (expects flat array)\n    const JI = macro.newTypedArray(TYPED_ARRAYS.Float64Array, 4);\n    invertMatrix(J, JI, 2); // returns flat array [JI00, JI01, JI10, JI11]\n\n    // Compute derivatives\n    for (let j = 0; j < dim; j++) {\n      let sum0 = 0.0;\n      let sum1 = 0.0;\n      for (let i = 0; i < 3; i++) {\n        sum0 += functionDerivs[i] * values[dim * i + j];\n        sum1 += functionDerivs[3 + i] * values[dim * i + j];\n      }\n      const dBydx = sum0 * JI[0] + sum1 * JI[1];\n      const dBydy = sum0 * JI[2] + sum1 * JI[3];\n\n      // Transform into global system (dot product with global axes)\n      derivs[3 * j] = dBydx * v10[0] + dBydy * v20[0];\n      derivs[3 * j + 1] = dBydx * v10[1] + dBydy * v20[1];\n      derivs[3 * j + 2] = dBydx * v10[2] + dBydy * v20[2];\n    }\n  };\n\n  /**\n   * Get the nearest cell boundary to the specified parametric\n   * coordinates and whether the point is inside or outside the cell.\n   * @param {Number} subId The sub-id of the cell.\n   * @param {Vector3} pcoords The parametric coordinates.\n   * @param {Vector2} pts The points of the cell.\n   */\n  publicAPI.cellBoundary = (subId, pcoords, pts) => {\n    const t1 = pcoords[0] - pcoords[1];\n    const t2 = 0.5 * (1.0 - pcoords[0]) - pcoords[1];\n    const t3 = 2.0 * pcoords[0] + pcoords[1] - 1.0;\n\n    // compare against three lines in parametric space that divide element\n    // into three pieces\n    if (t1 >= 0.0 && t2 >= 0.0) {\n      pts[0] = model.pointsIds[0];\n      pts[1] = model.pointsIds[1];\n    } else if (t2 < 0.0 && t3 >= 0.0) {\n      pts[0] = model.pointsIds[1];\n      pts[1] = model.pointsIds[2];\n    } // ( t1 < 0.0 && t3 < 0.0 )\n    else {\n      pts[0] = model.pointsIds[2];\n      pts[1] = model.pointsIds[0];\n    }\n    if (pcoords[0] < 0.0 || pcoords[1] < 0.0 || pcoords[0] > 1.0 || pcoords[1] > 1.0 || 1.0 - pcoords[0] - pcoords[1] < 0.0) {\n      return false; // outside of triangle\n    }\n\n    return true; // inside triangle\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTriangle');\n\n// ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { f as distance2BetweenPoints } from '../Core/Math/index.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport vtkTriangle from './Triangle.js';\nimport vtkPoints from '../Core/Points.js';\n\nfunction intersectionStruct() {\n  return {\n    intersected: false,\n    subId: -1,\n    x: [0.0, 0.0, 0.0],\n    pCoords: [0.0, 0.0, 0.0],\n    t: -1\n  };\n}\nfunction vtkQuad(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkQuad');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.getCellType = () => CellType.VTK_QUAD;\n  publicAPI.getNumberOfEdges = () => 4;\n  publicAPI.getNumberOfFaces = () => 0;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    let outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    let diagonalCase;\n    const point0 = model.points.getPoint(0, []);\n    const point1 = model.points.getPoint(1, []);\n    const point2 = model.points.getPoint(2, []);\n    const point3 = model.points.getPoint(3, []);\n    const d1 = distance2BetweenPoints(point0, point2);\n    const d2 = distance2BetweenPoints(point1, point3);\n\n    /* Figure out how to uniquely tessellate the quad. Watch out for\n     * equivalent triangulations (i.e., the triangulation is equivalent\n     * no matter where the diagonal). In this case use the point ids as\n     * a tie breaker to ensure unique triangulation across the quad.\n     */\n\n    // rare case; discriminate based on point id\n    if (d1 === d2) {\n      // find the maximum id\n      let id;\n      let maxId = 0;\n      let maxIdx = 0;\n      for (let i = 0; i < 4; i++) {\n        id = model.pointsIds[i];\n        if (id > maxId) {\n          maxId = id;\n          maxIdx = i;\n        }\n      }\n      if (maxIdx === 0 || maxIdx === 2) {\n        diagonalCase = 0;\n      } else {\n        diagonalCase = 1;\n      }\n    } else if (d1 < d2) {\n      diagonalCase = 0;\n    } else {\n      diagonalCase = 1;\n    }\n    let points = null;\n    if (!model.triangle) {\n      model.triangle = vtkTriangle.newInstance();\n      points = vtkPoints.newInstance();\n      points.setNumberOfPoints(3);\n      model.triangle.initialize(points);\n    } else {\n      points = model.triangle.getPoints();\n    }\n    let firstIntersect;\n    const firstIntersectTmpObj = intersectionStruct();\n    let secondIntersect;\n    const secondIntersectTmpObj = intersectionStruct();\n    let useFirstIntersection;\n    let useSecondIntersection;\n    switch (diagonalCase) {\n      case 0:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point2);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point0);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1.0 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n      case 1:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point3);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point1);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n    }\n    return outObj;\n  };\n  publicAPI.interpolationFunctions = (pcoords, weights) => {\n    const rm = 1 - pcoords[0];\n    const sm = 1 - pcoords[1];\n    weights[0] = rm * sm;\n    weights[1] = pcoords[0] * sm;\n    weights[2] = pcoords[0] * pcoords[1];\n    weights[3] = rm * pcoords[1];\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const point = [];\n\n    // Calculate the weights\n    publicAPI.interpolationFunctions(pcoords, weights);\n    x[0] = 0.0;\n    x[1] = 0.0;\n    x[2] = 0.0;\n    for (let i = 0; i < 4; i++) {\n      model.points.getPoint(i, point);\n      for (let j = 0; j < 3; j++) {\n        x[j] += point[j] * weights[i];\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkQuad(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkQuad');\n\n// ----------------------------------------------------------------------------\n\nvar vtkQuad$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkQuad$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport vtkLine from './Line.js';\nimport vtkTriangle from './Triangle.js';\nimport { CellType } from './CellTypes/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkTriangleStrip.${method} - NOT IMPLEMENTED`);\n}\n\n/**\n * Decomposes a triangle strip into individual triangles.\n * @param {*} pts Points of the triangle strip\n * @param {*} polys Cell array to store the resulting triangles\n */\nfunction decomposeStrip(pts, polys) {\n  if (!Array.isArray(pts) || pts.length < 3) {\n    vtkErrorMacro('decomposeStrip - Invalid points array');\n    return;\n  }\n  let p1 = pts[0];\n  let p2 = pts[1];\n  for (let i = 0; i < pts.length - 2; i++) {\n    const p3 = pts[i + 2];\n    if (i % 2) {\n      // Flip ordering to preserve consistency\n      polys.insertNextCell([p2, p1, p3]);\n    } else {\n      polys.insertNextCell([p1, p2, p3]);\n    }\n    p1 = p2;\n    p2 = p3;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  decomposeStrip\n};\n\n// ----------------------------------------------------------------------------\n// vtkTriangleStrip methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangleStrip(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangleStrip');\n  const superInitialize = publicAPI.initialize;\n  publicAPI.initialize = (points, pointsIds) => {\n    model.triangle.initialize(points, pointsIds);\n    superInitialize(points, pointsIds);\n  };\n\n  /**\n   * Get the cell type.\n   * @returns {number} Cell type\n   */\n  publicAPI.getCellType = () => CellType.VTK_TRIANGLE_STRIP;\n\n  /**\n   * Get the cell dimension.\n   * The dimension of a triangle strip is always 2.\n   * @returns {number} Cell dimension\n   */\n  publicAPI.getCellDimension = () => 2;\n\n  /**\n   * Get the number of edges.\n   * @returns {number} Number of edges\n   */\n  publicAPI.getNumberOfEdges = () => model.pointsIds.length;\n\n  /**\n   * Get the number of faces.\n   * @returns {number} Number of faces\n   */\n  publicAPI.getNumberOfFaces = () => 0;\n\n  /**\n   * Evaluate the position within the triangle strip.\n   * @param {*} x Intersection point\n   * @param {*} closestPoint Closest point on the triangle\n   * @param {*} pcoords Parametric coordinates\n   * @param {*} dist2 Squared distance to the closest point\n   * @param {*} weights Weights for interpolation\n   * @returns {number} Evaluation status\n   */\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, dist2, weights) => {\n    const pc = [0, 0, 0];\n    let minDist2 = Number.MAX_VALUE;\n    let returnStatus = 0;\n    const tempWeights = [];\n    const activeWeights = [];\n    const closest = [];\n    pcoords[2] = 0.0;\n    activeWeights[0] = 0.0;\n    activeWeights[1] = 0.0;\n    activeWeights[2] = 0.0;\n    const points = model.triangle.getPoints();\n    points.setNumberOfPoints(3);\n    const pointsIds = model.triangle.getPointsIds();\n    const numPoints = pointsIds.length;\n\n    // Initialize weights\n    for (let i = 0; i < numPoints; i++) {\n      weights[i] = 0.0;\n    }\n\n    // Iterate through triangles in the strip\n    for (let i = 0; i < numPoints - 2; i++) {\n      // Set triangle points\n      const pt0 = [];\n      points.getPoint(i, pt0);\n      const pt1 = [];\n      points.getPoint(i + 1, pt1);\n      const pt2 = [];\n      points.getPoint(i + 2, pt2);\n      points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);\n\n      // Use dist2 from triangle's evaluatePosition return value\n      const status = model.triangle.evaluatePosition(x, closest, pc, tempWeights);\n      const currentDist2 = status.dist2;\n      if (status.evaluation >= 0 && (currentDist2 < minDist2 || currentDist2 === minDist2 && returnStatus === 0)) {\n        returnStatus = status;\n        if (closestPoint) {\n          closestPoint[0] = closest[0];\n          closestPoint[1] = closest[1];\n          closestPoint[2] = closest[2];\n        }\n        pcoords[0] = pc[0];\n        pcoords[1] = pc[1];\n        minDist2 = currentDist2;\n        activeWeights[0] = tempWeights[0];\n        activeWeights[1] = tempWeights[1];\n        activeWeights[2] = tempWeights[2];\n      }\n    }\n    dist2[0] = minDist2;\n    weights[0] = activeWeights[0];\n    weights[1] = activeWeights[1];\n    weights[2] = activeWeights[2];\n    return returnStatus;\n  };\n\n  /**\n   * Evaluate the location within the triangle strip.\n   * @param {*} subId Sub-Id of the triangle\n   * @param {*} pcoords Parametric coordinates\n   * @param {*} x Intersection point\n   * @param {*} weights Weights for interpolation\n   */\n  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {\n    const idx = [[0, 1, 2], [1, 0, 2]];\n    const order = subId % 2;\n    const numPoints = model.pointsIds.length;\n\n    // Initialize weights\n    for (let i = 0; i < numPoints; i++) {\n      weights[i] = 0.0;\n    }\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n    weights[subId] = u3;\n    weights[subId + 1] = pcoords[0];\n    weights[subId + 2] = pcoords[1];\n\n    // Get points\n    const pt1 = [];\n    model.points.getPoint(subId + idx[order][0], pt1);\n    const pt2 = [];\n    model.points.getPoint(subId + idx[order][1], pt2);\n    const pt3 = [];\n    model.points.getPoint(subId + idx[order][2], pt3);\n\n    // Interpolate position\n    for (let i = 0; i < 3; i++) {\n      x[i] = pt1[i] * weights[subId] + pt2[i] * weights[subId + 1] + pt3[i] * weights[subId + 2];\n    }\n  };\n\n  /**\n   * Get the cell boundary of the triangle strip.\n   * @param {Number} subId The sub-id of the cell.\n   * @param {Vector3} pcoords The parametric coordinates.\n   * @param {Vector2} pts The points of the cell.\n   */\n  publicAPI.cellBoundary = (subId, pcoords, pts) => {\n    const idx = [[0, 1, 2], [1, 0, 2]];\n    const order = subId % 2;\n    const pointsIds = model.triangle.getPointsIds();\n    pointsIds[0] = model.pointsIds[idx[order][0]];\n    pointsIds[1] = model.pointsIds[idx[order][1]];\n    pointsIds[2] = model.pointsIds[idx[order][2]];\n    return model.triangle.cellBoundary(0, pcoords, pts);\n  };\n\n  /**\n   * Get the edge of the triangle strip.\n   * @param {Number} edgeId Edge index (0 to n-1)\n   * @returns {vtkLine} The edge as a vtkLine instance\n   */\n  publicAPI.getEdge = edgeId => {\n    let id1;\n    let id2;\n    const numPoints = model.pointsIds.length;\n    if (edgeId === 0) {\n      id1 = 0;\n      id2 = 1;\n    } else if (edgeId === numPoints - 1) {\n      id1 = edgeId - 1;\n      id2 = edgeId;\n    } else {\n      id1 = edgeId - 1;\n      id2 = edgeId + 1;\n    }\n    model.line.getPointsIds()[0] = model.pointsIds[id1];\n    model.line.getPointsIds()[1] = model.pointsIds[id2];\n    model.line.getPoints().setPoint(0, model.points.getPoint(id1));\n    model.line.getPoints().setPoint(1, model.points.getPoint(id2));\n    return model.line;\n  };\n\n  /**\n   * Intersects a line with the triangle strip.\n   * @param {Vector3} p1 Start point of the line\n   * @param {Vector3} p2 End point of the line\n   * @param {number} tol Tolerance for intersection\n   * @param {Vector3} x Intersection point\n   * @param {Vector3} pcoords Parametric coordinates of the intersection\n   * @returns {Boolean} True if the line intersects the triangle strip\n   */\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const numTris = model.pointsIds.length - 2;\n    const points = model.triangle.getPoints();\n    points.setNumberOfPoints(3);\n    for (let i = 0; i < numTris; i++) {\n      const pt0 = [];\n      model.points.getPoint(model.pointsIds[i], pt0);\n      const pt1 = [];\n      model.points.getPoint(model.pointsIds[i + 1], pt1);\n      const pt2 = [];\n      model.points.getPoint(model.pointsIds[i + 2], pt2);\n      points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);\n      const ret = model.triangle.intersectWithLine(p1, p2, tol, x, pcoords);\n      if (ret.intersect) {\n        return ret;\n      }\n    }\n    return false;\n  };\n\n  // Triangulate\n  /**\n   * Triangulate the triangle strip.\n   * @returns {Boolean} True if the triangulation is successful.\n   */\n  publicAPI.triangulate = () => {\n    const numTris = model.points.getNumberOfPoints() - 2;\n    model.tris = new Array(3 * numTris);\n    const idx = [[0, 1, 2], [1, 0, 2]];\n    for (let subId = 0; subId < numTris; subId++) {\n      const order = subId % 2;\n      for (let i = 0; i < 3; i++) {\n        model.tris[subId * 3 + i] = subId + idx[order][i];\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Get the point array of the triangle strip.\n   * @returns {Array} The point array.\n   */\n  publicAPI.getPointArray = () => model.tris;\n\n  // Derivatives\n  /**\n   * Get the derivatives of the triangle strip.\n   * @param {Number} subId - The sub-id of the triangle.\n   * @param {Vector3} pcoords - The parametric coordinates.\n   * @param {Number[]} values - The values at the points.\n   * @param {Number} dim - The dimension.\n   * @param {Number[]} derivs - The derivatives.\n   */\n  publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {\n    const pt0 = [];\n    model.points.getPoint(subId, pt0);\n    const pt1 = [];\n    model.points.getPoint(subId + 1, pt1);\n    const pt2 = [];\n    model.points.getPoint(subId + 2, pt2);\n    const points = model.triangle.getPoints();\n    points.setPoint(0, ...pt0);\n    points.setPoint(1, ...pt1);\n    points.setPoint(2, ...pt2);\n    model.triangle.derivatives(0, pcoords, values, dim, derivs);\n  };\n\n  /**\n   * Get the parametric center of the triangle strip.\n   * @param {Vector3} pcoords - The parametric coordinates.\n   * @returns {Number} The parametric center.\n   */\n  publicAPI.getParametricCenter = pcoords => {\n    pcoords[0] = 0.333333;\n    pcoords[1] = 0.333333;\n    pcoords[2] = 0.0;\n    return Math.floor((model.pointsIds.length - 2) / 2);\n  };\n\n  /**\n   * Contour the triangle strip.\n   * @param {*} value\n   * @param {*} cellScalars\n   * @param {*} locator\n   * @param {*} verts\n   * @param {*} lines\n   * @param {*} polys\n   * @param {*} inPd\n   * @param {*} outPd\n   * @param {*} inCd\n   * @param {*} cellId\n   * @param {*} outCd\n   * @returns\n   */\n  publicAPI.contour = (value, cellScalars, locator, verts, lines, polys, inPd, outPd, inCd, cellId, outCd) => notImplemented('contour')();\n\n  /**\n   * Clip the triangle strip.\n   * @param {*} value Clipping value\n   * @param {*} cellScalars Cell scalars\n   * @param {*} locator Locator\n   * @param {*} tris Triangle indices\n   * @param {*} inPd Input point data\n   * @param {*} outPd Output point data\n   * @param {*} inCd\n   * @param {*} cellId\n   * @param {*} outCd\n   * @param {*} insideOut\n   * @returns\n   */\n  publicAPI.clip = (value, cellScalars, locator, tris, inPd, outPd, inCd, cellId, outCd, insideOut) => notImplemented('clip')();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  line: null,\n  triangle: null,\n  tris: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkCell.extend(publicAPI, model, initialValues);\n  if (!model.line) {\n    model.line = vtkLine.newInstance();\n  }\n  if (!model.triangle) {\n    model.triangle = vtkTriangle.newInstance();\n  }\n\n  // Build VTK API\n  vtkTriangleStrip(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTriangleStrip');\n\n// ----------------------------------------------------------------------------\n\nvar vtkTriangleStrip$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkTriangleStrip$1 as default, extend, newInstance };\n", "const POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];\nvar Constants = {\n  POLYDATA_FIELDS\n};\n\nexport { POLYDATA_FIELDS, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtk from '../../vtk.js';\nimport vtkCellArray from '../Core/CellArray.js';\nimport vtkCellLinks from './CellLinks.js';\nimport vtkCellTypes from './CellTypes.js';\nimport vtkLine from './Line.js';\nimport vtkPointSet from './PointSet.js';\nimport vtkPolyLine from './PolyLine.js';\nimport vtkPolygon from './Polygon.js';\nimport vtkQuad from './Quad.js';\nimport vtkTriangle from './Triangle.js';\nimport vtkTriangleStrip from './TriangleStrip.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport { POLYDATA_FIELDS } from './PolyData/Constants.js';\n\nconst {\n  vtkWarningMacro\n} = macro;\nconst CELL_FACTORY = {\n  [CellType.VTK_LINE]: vtkLine,\n  [CellType.VTK_QUAD]: vtkQuad,\n  [CellType.VTK_POLY_LINE]: vtkLine,\n  [CellType.VTK_TRIANGLE]: vtkTriangle,\n  [CellType.VTK_TRIANGLE_STRIP]: vtkTriangleStrip,\n  [CellType.VTK_POLY_LINE]: vtkPolyLine,\n  [CellType.VTK_POLYGON]: vtkPolygon\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolyData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPolyData');\n  function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, letter => letter.toUpperCase()).replace(/\\s+/g, '');\n  }\n  function clearCells() {\n    model.cells = undefined;\n    model.links = undefined;\n  }\n\n  // build empty cell arrays and set methods\n  POLYDATA_FIELDS.forEach(type => {\n    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();\n    if (!model[type]) {\n      model[type] = vtkCellArray.newInstance();\n    } else {\n      model[type] = vtk(model[type]);\n    }\n    model[`_on${camelize(type)}Changed`] = clearCells;\n  });\n  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    POLYDATA_FIELDS.forEach(type => {\n      model[type] = vtkCellArray.newInstance();\n      model[type].shallowCopy(other.getReferenceByName(type));\n    });\n  };\n  const superGetMTime = publicAPI.getMTime;\n  publicAPI.getMTime = () => POLYDATA_FIELDS.reduce((mTime, type) => Math.max(mTime, model[type]?.getMTime() ?? mTime), superGetMTime());\n  const superInitialize = publicAPI.initialize;\n  publicAPI.initialize = () => {\n    POLYDATA_FIELDS.forEach(type => model[type]?.initialize());\n    clearCells();\n    return superInitialize();\n  };\n  publicAPI.buildCells = () => {\n    // here are the number of cells we have\n    const nVerts = publicAPI.getNumberOfVerts();\n    const nLines = publicAPI.getNumberOfLines();\n    const nPolys = publicAPI.getNumberOfPolys();\n    const nStrips = publicAPI.getNumberOfStrips();\n\n    // pre-allocate the space we need\n    const nCells = nVerts + nLines + nPolys + nStrips;\n    const types = new Uint8Array(nCells);\n    let pTypes = types;\n    const locs = new Uint32Array(nCells);\n    let pLocs = locs;\n\n    // record locations and type of each cell.\n    // verts\n    if (nVerts) {\n      let nextCellPts = 0;\n      model.verts.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nVerts);\n      pTypes = pTypes.subarray(nVerts);\n    }\n\n    // lines\n    if (nLines) {\n      let nextCellPts = 0;\n      model.lines.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;\n        if (numCellPts === 1) {\n          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nLines);\n      pTypes = pTypes.subarray(nLines);\n    }\n\n    // polys\n    if (nPolys) {\n      let nextCellPts = 0;\n      model.polys.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        switch (numCellPts) {\n          case 3:\n            pTypes[index] = CellType.VTK_TRIANGLE;\n            break;\n          case 4:\n            pTypes[index] = CellType.VTK_QUAD;\n            break;\n          default:\n            pTypes[index] = CellType.VTK_POLYGON;\n            break;\n        }\n        if (numCellPts < 3) {\n          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs += pLocs.subarray(nPolys);\n      pTypes += pTypes.subarray(nPolys);\n    }\n\n    // strips\n    if (nStrips) {\n      let nextCellPts = 0;\n      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);\n      model.strips.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        nextCellPts += numCellPts + 1;\n      });\n    }\n\n    // set up the cell types data structure\n    model.cells = vtkCellTypes.newInstance();\n    model.cells.setCellTypes(nCells, types, locs);\n  };\n\n  /**\n   * Create upward links from points to cells that use each point. Enables\n   * topologically complex queries.\n   */\n  publicAPI.buildLinks = function () {\n    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (model.cells == null) {\n      publicAPI.buildCells();\n    }\n    model.links = vtkCellLinks.newInstance();\n    if (initialSize > 0) {\n      model.links.allocate(initialSize);\n    } else {\n      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());\n    }\n    model.links.buildLinks(publicAPI);\n  };\n  publicAPI.getCellType = cellId => model.cells.getCellType(cellId);\n  publicAPI.getCellPoints = cellId => {\n    const cellType = publicAPI.getCellType(cellId);\n    let cells = null;\n    switch (cellType) {\n      case CellType.VTK_VERTEX:\n      case CellType.VTK_POLY_VERTEX:\n        cells = model.verts;\n        break;\n      case CellType.VTK_LINE:\n      case CellType.VTK_POLY_LINE:\n        cells = model.lines;\n        break;\n      case CellType.VTK_TRIANGLE:\n      case CellType.VTK_QUAD:\n      case CellType.VTK_POLYGON:\n        cells = model.polys;\n        break;\n      case CellType.VTK_TRIANGLE_STRIP:\n        cells = model.strips;\n        break;\n      default:\n        cells = null;\n        return {\n          type: 0,\n          cellPointIds: null\n        };\n    }\n    const loc = model.cells.getCellLocation(cellId);\n    const cellPointIds = cells.getCell(loc);\n    return {\n      cellType,\n      cellPointIds\n    };\n  };\n  publicAPI.getPointCells = ptId => model.links.getCells(ptId);\n  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {\n    const link1 = model.links.getLink(point1);\n    const link2 = model.links.getLink(point2);\n    return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);\n  };\n\n  /**\n   * If you know the type of cell, you may provide it to improve performances.\n   */\n  publicAPI.getCell = function (cellId) {\n    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const cellInfo = publicAPI.getCellPoints(cellId);\n    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();\n    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);\n    return cell;\n  };\n  publicAPI.getMaxCellSize = () => POLYDATA_FIELDS.reduce((max, type) => Math.max(max, model[type]?.getMaxCellSize?.() ?? 0), 0);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // verts: null,\n  // lines: null,\n  // polys: null,\n  // strips: null,\n  // cells: null,\n  // links: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPointSet.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['cells', 'links']);\n  macro.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);\n\n  // Object specific methods\n  vtkPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyData$1 = {\n  newInstance,\n  extend\n};\n\nexport { CELL_FACTORY, vtkPolyData$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "IntersectionState", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "STATIC", "computeNormal", "DEFAULT_VALUES", "extend", "newInstance", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance"]
}
