import {
  VtkDataTypes,
  vtkDataArray$1,
  vtkDataSet$1
} from "./chunk-QTSXRC5W.js";
import {
  TYPED_ARRAYS,
  add,
  cross,
  determinant2x2,
  distance2BetweenPoints,
  dot,
  invertMatrix,
  macro,
  multiplyAccumulate,
  norm,
  normalize,
  quat_exports,
  solveLinearSystem,
  subtract,
  uninitializeBounds,
  vec3_exports,
  vtk,
  vtkBoundingBox,
  vtkPlane$1
} from "./chunk-UJ7GCCMN.js";

// node_modules/@kitware/vtk.js/Common/Core/Points.js
var {
  vtkErrorMacro
} = macro;
function vtkPoints(publicAPI, model) {
  let boundMTime = 0;
  model.classHierarchy.push("vtkPoints");
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function(nbPoints) {
    let dimension = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = macro.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function(idx) {
    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      xyz[_key - 1] = arguments[_key];
    }
    publicAPI.setTuple(idx, xyz);
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.findPoint = publicAPI.findTuple;
  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);
  publicAPI.insertPoint = (ptId, point) => publicAPI.insertTuple(ptId, point);
  const superGetBounds = publicAPI.getBounds;
  publicAPI.getBounds = () => {
    if (boundMTime < model.mtime) {
      publicAPI.computeBounds();
    }
    return superGetBounds();
  };
  const superGetBoundsByReference = publicAPI.getBoundsByReference;
  publicAPI.getBoundsByReference = () => {
    if (boundMTime < model.mtime) {
      publicAPI.computeBounds();
    }
    return superGetBoundsByReference();
  };
  publicAPI.computeBounds = () => {
    if (publicAPI.getNumberOfComponents() === 3) {
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      const zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
    } else if (publicAPI.getNumberOfComponents() === 2) {
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      model.bounds[4] = 0;
      model.bounds[5] = 0;
    } else {
      vtkErrorMacro(`getBounds called on an array with components of ${publicAPI.getNumberOfComponents()}`);
      uninitializeBounds(model.bounds);
    }
    boundMTime = macro.getCurrentGlobalMTime();
  };
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}
var DEFAULT_VALUES = {
  empty: true,
  numberOfComponents: 3,
  dataType: VtkDataTypes.FLOAT,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkDataArray$1.extend(publicAPI, model, initialValues);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkPoints(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkPoints");
var vtkPoints$1 = {
  newInstance,
  extend
};

// node_modules/@kitware/vtk.js/Common/Core/CellArray.js
var {
  isVtkObject
} = macro;
function extractCellSizes(cellArray) {
  let currentIdx = 0;
  return cellArray.filter((value, index) => {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  let cellId = 0;
  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length; ) {
    cellArrayIndex += cellArray[cellArrayIndex] + 1;
    cellId++;
  }
  return cellId;
}
var STATIC = {
  extractCellSizes,
  getNumberOfCells
};
function vtkCellArray(publicAPI, model) {
  model.classHierarchy.push("vtkCellArray");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getNumberOfCells = (recompute) => {
    if (model.numberOfCells !== void 0 && !recompute) {
      return model.numberOfCells;
    }
    if (model.cellSizes) {
      model.numberOfCells = model.cellSizes.length;
    } else {
      model.numberOfCells = getNumberOfCells(publicAPI.getData());
    }
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = (recompute) => {
    if (model.cellSizes !== void 0 && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(publicAPI.getData());
    return model.cellSizes;
  };
  publicAPI.resize = (requestedNumTuples) => {
    const oldNumTuples = publicAPI.getNumberOfTuples();
    superClass.resize(requestedNumTuples);
    const newNumTuples = publicAPI.getNumberOfTuples();
    if (newNumTuples < oldNumTuples) {
      if (newNumTuples === 0) {
        model.numberOfCells = 0;
        model.cellSizes = [];
      } else {
        model.numberOfCells = void 0;
        model.cellSizes = void 0;
      }
    }
  };
  publicAPI.setData = (typedArray) => {
    superClass.setData(typedArray, 1);
    model.numberOfCells = void 0;
    model.cellSizes = void 0;
  };
  publicAPI.getCell = (loc) => {
    let cellLoc = loc;
    const numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
  publicAPI.insertNextCell = (cell) => {
    let cellPointIds;
    if (isVtkObject(cell)) {
      cellPointIds = cell.getPointsIds();
    } else {
      cellPointIds = cell;
    }
    const cellId = publicAPI.getNumberOfCells();
    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
    ++model.numberOfCells;
    if (model.cellSizes != null) {
      model.cellSizes.push(cellPointIds.length);
    }
    return cellId;
  };
  publicAPI.getMaxCellSize = () => publicAPI.getCellSizes().reduce((a, b) => Math.max(a, b), 0);
}
function defaultValues(initialValues) {
  return {
    empty: true,
    numberOfComponents: 1,
    dataType: VtkDataTypes.UNSIGNED_INT,
    ...initialValues
  };
}
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkDataArray$1.extend(publicAPI, model, defaultValues(initialValues));
  vtkCellArray(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkCellArray");
var vtkCellArray$1 = {
  newInstance: newInstance2,
  extend: extend2,
  ...STATIC
};

// node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
function vtkCell(publicAPI, model) {
  model.classHierarchy.push("vtkCell");
  publicAPI.initialize = function(points) {
    let pointIdsList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      let triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      const pointsData = points.getData();
      model.pointsIds.forEach((pointId, index) => {
        let pointOffset = 3 * pointId;
        let trianglePointOffset = 3 * index;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.getLength2 = () => {
    const lengths = vtkBoundingBox.getLengths(publicAPI.getBounds());
    return lengths[0] * lengths[0] + lengths[1] * lengths[1] + lengths[2] * lengths[2];
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    for (let i = 0; i < 3; i++) {
      if (pcoords[i] < 0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1) {
        pDist = pcoords[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.deepCopy = (cell) => {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = () => {
  };
  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {
  };
  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {
    macro.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
  };
}
var DEFAULT_VALUES2 = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: []
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  }
  macro.get(publicAPI, model, ["points", "pointsIds"]);
  vtkCell(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkCell");
var vtkCell$1 = {
  newInstance: newInstance3,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length) model.array.push({
    ncells: 0,
    cells: null
  });
  model.array.length = newSize;
}
function vtkCellLinks(publicAPI, model) {
  model.classHierarchy.push("vtkCellLinks");
  publicAPI.buildLinks = (data) => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();
    const linkLoc = new Uint32Array(numPts);
    if (data.isA("vtkPolyData")) {
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } else {
      for (let cellId = 0; cellId < numCells; cellId++) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    }
  };
  publicAPI.allocate = function(numLinks) {
    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.array = Array(numLinks).fill().map(() => ({
      ncells: 0,
      cells: null
    }));
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = () => {
    model.array = null;
  };
  publicAPI.getLink = (ptId) => model.array[ptId];
  publicAPI.getNcells = (ptId) => model.array[ptId].ncells;
  publicAPI.getCells = (ptId) => model.array[ptId].cells;
  publicAPI.insertNextPoint = (numLinks) => {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.deletePoint = (ptId) => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter((cell) => cell !== cellId);
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.resizeCellList = (ptId, size) => {
    model.array[ptId].cells.length = size;
  };
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };
  publicAPI.incrementLinkCount = (ptId) => {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = (n) => {
    for (let i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}
var DEFAULT_VALUES3 = {
  array: null,
  // pointer to data
  maxId: 0,
  // maximum index inserted thus far
  extend: 0
  // grow array by this point
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend4, "vtkCellLinks");
var vtkCellLinks$1 = {
  newInstance: newInstance4,
  extend: extend4
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
var CellType = {
  // Linear cells
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,
  // Quadratic, isoparametric cells
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,
  // Cubic, isoparametric cell
  VTK_CUBIC_LINE: 35,
  // Special class of cells formed by convex group of points
  VTK_CONVEX_POINT_SET: 41,
  // Polyhedron cell (consisting of polygonal faces)
  VTK_POLYHEDRON: 42,
  // Higher order cells in parametric form
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,
  // Higher order cells
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,
  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,
  VTK_NUMBER_OF_CELL_TYPES: 75
};
var CellTypesStrings = ["vtkEmptyCell", "vtkVertex", "vtkPolyVertex", "vtkLine", "vtkPolyLine", "vtkTriangle", "vtkTriangleStrip", "vtkPolygon", "vtkPixel", "vtkQuad", "vtkTetra", "vtkVoxel", "vtkHexahedron", "vtkWedge", "vtkPyramid", "vtkPentagonalPrism", "vtkHexagonalPrism", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkQuadraticEdge", "vtkQuadraticTriangle", "vtkQuadraticQuad", "vtkQuadraticTetra", "vtkQuadraticHexahedron", "vtkQuadraticWedge", "vtkQuadraticPyramid", "vtkBiQuadraticQuad", "vtkTriQuadraticHexahedron", "vtkQuadraticLinearQuad", "vtkQuadraticLinearWedge", "vtkBiQuadraticQuadraticWedge", "vtkBiQuadraticQuadraticHexahedron", "vtkBiQuadraticTriangle", "vtkCubicLine", "vtkQuadraticPolygon", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkConvexPointSet", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkParametricCurve", "vtkParametricSurface", "vtkParametricTriSurface", "vtkParametricQuadSurface", "vtkParametricTetraRegion", "vtkParametricHexRegion", "UnknownClass", "UnknownClass", "UnknownClass", "vtkHigherOrderEdge", "vtkHigherOrderTriangle", "vtkHigherOrderQuad", "vtkHigherOrderPolygon", "vtkHigherOrderTetrahedron", "vtkHigherOrderWedge", "vtkHigherOrderPyramid", "vtkHigherOrderHexahedron"];

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : "UnknownClass";
}
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function hasSubCells(cellType) {
  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
}
var STATIC2 = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
  hasSubCells
};
function vtkCellTypes(publicAPI, model) {
  model.classHierarchy.push("vtkCellTypes");
  publicAPI.allocate = function() {
    let sz = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512;
    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };
  publicAPI.insertCell = (cellId, type, loc) => {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };
  publicAPI.insertNextCell = (type, loc) => {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };
  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };
  publicAPI.getCellLocation = (cellId) => model.locationArray[cellId];
  publicAPI.deleteCell = (cellId) => {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };
  publicAPI.getNumberOfTypes = () => model.maxId + 1;
  publicAPI.isType = (type) => {
    const numTypes = publicAPI.getNumberOfTypes();
    for (let i = 0; i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.insertNextType = (type) => publicAPI.insertNextCell(type, -1);
  publicAPI.getCellType = (cellId) => model.typeArray[cellId];
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}
var DEFAULT_VALUES4 = {
  // typeArray: null, // pointer to types array
  // locationArray: null;   // pointer to array of offsets
  size: 0,
  // allocated size of data
  maxId: -1,
  // maximum index inserted thus far
  extend: 1e3
  // grow array by this point
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["size", "maxId", "extend"]);
  macro.getArray(publicAPI, model, ["typeArray", "locationArray"]);
  vtkCellTypes(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend5, "vtkCellTypes");
var vtkCellTypes$1 = {
  newInstance: newInstance5,
  extend: extend5,
  ...STATIC2
};

// node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
var IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2
};
var Constants = {
  IntersectionState
};

// node_modules/@kitware/vtk.js/Common/DataModel/Line.js
var {
  IntersectionState: IntersectionState2
} = Constants;
function distanceToLine(x, p1, p2) {
  let closestPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  const outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  const p21 = [];
  let closest;
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];
  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  const denom = dot(p21, p21);
  let tolerance = 1e-5 * num;
  if (denom !== 0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0 || outObj.t < 0) {
    closest = p1;
  } else if (outObj.t > 1) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = distance2BetweenPoints(closest, x);
  return outObj;
}
function intersection(a1, a2, b1, b2, u, v) {
  const a21 = [];
  const b21 = [];
  const b1a1 = [];
  u[0] = 0;
  v[0] = 0;
  subtract(a2, a1, a21);
  subtract(b2, b1, b21);
  subtract(b1, a1, b1a1);
  const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];
  const c = [];
  c[0] = dot(a21, b1a1);
  c[1] = -dot(b21, b1a1);
  if (solveLinearSystem(A, c, 2) === 0) {
    let minDist = Number.MAX_VALUE;
    const p = [a1, a2, b1, b2];
    const l1 = [b1, b1, a1, a1];
    const l2 = [b2, b2, a2, a2];
    [v[0], v[0], u[0], u[0]];
    [u[0], u[0], v[0], v[0]];
    let obj;
    for (let i = 0; i < 4; i++) {
      obj = distanceToLine(p[i], l1[i], l2[i]);
      if (obj.distance < minDist) {
        minDist = obj.distance;
        obj.t;
      }
    }
    return IntersectionState2.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];
  if (u[0] >= 0 && u[0] <= 1 && v[0] >= 0 && v[0] <= 1) {
    return IntersectionState2.YES_INTERSECTION;
  }
  return IntersectionState2.NO_INTERSECTION;
}
var STATIC3 = {
  distanceToLine,
  intersection
};
function vtkLine(publicAPI, model) {
  model.classHierarchy.push("vtkLine");
  function isBetweenPoints(t) {
    return t >= 0 && t <= 1;
  }
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0;
    pcoords[2] = 0;
    const projXYZ = [];
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    const u = [];
    const v = [];
    const intersect = intersection(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v[0];
    if (intersect === IntersectionState2.YES_INTERSECTION) {
      for (let i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      let outDistance;
      if (outObj.t < 0) {
        outDistance = distanceToLine(p1, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1) {
        outDistance = distanceToLine(p2, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0) {
        pcoords[0] = 0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1) {
        pcoords[0] = 1;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    for (let i = 0; i < 3; i++) {
      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
    }
    weights[0] = 1 - pcoords[0];
    weights[1] = pcoords[0];
  };
  publicAPI.evaluateOrientation = (pcoords, q, weights) => {
    if (model.orientations) {
      quat_exports.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
      weights[0] = 1 - pcoords[0];
      weights[1] = pcoords[0];
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES5 = {
  orientations: null
  // an array of two quat or null
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["orientations"]);
  vtkLine(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend6, "vtkLine");
var vtkLine$1 = {
  newInstance: newInstance6,
  extend: extend6,
  ...STATIC3,
  ...Constants
};

// node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
function vtkPointSet(publicAPI, model) {
  model.classHierarchy.push("vtkPointSet");
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  } else {
    model.points = vtk(model.points);
  }
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = vtkPoints$1.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
  const superGetMTime = publicAPI.getMTime;
  publicAPI.getMTime = () => {
    var _a;
    const mTime = superGetMTime();
    return Math.max(mTime, ((_a = model.points) == null ? void 0 : _a.getMTime()) ?? mTime);
  };
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = () => {
    var _a;
    (_a = model.points) == null ? void 0 : _a.initialize();
    return superInitialize();
  };
}
var DEFAULT_VALUES6 = {
  // points: null,
};
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points"]);
  vtkPointSet(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend7, "vtkPointSet");
var vtkPointSet$1 = {
  newInstance: newInstance7,
  extend: extend7
};

// node_modules/@kitware/vtk.js/Common/DataModel/PolyLine.js
function vtkPolyLine(publicAPI, model) {
  model.classHierarchy.push("vtkPolyLine");
  const line = vtkLine$1.newInstance();
  line.getPoints().setNumberOfPoints(2);
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (t1, t2, p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    const numLines = publicAPI.getNumberOfPoints() - 1;
    let pDistMin = Number.MAX_VALUE;
    for (let subId = 0; subId < numLines; subId++) {
      const pCoords = [0, 0, 0];
      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
      const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);
      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {
        outObj.intersect = 1;
        const pDist = line.getParametricDistance(pCoords);
        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {
          outObj.subId = subId;
          outObj.t = lineIntersected.t;
          pDistMin = pDist;
          for (let k = 0; k < 3; k++) {
            x[k];
            pCoords[k];
          }
        }
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {
    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
    return line.evaluateLocation(pcoords, x, weights);
  };
  publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {
    if (model.orientations) {
      line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);
    } else {
      line.setOrientations(null);
    }
    return line.evaluateOrientation(pcoords, q, weights);
  };
  publicAPI.getDistancesToFirstPoint = () => {
    const dTime = model.distancesTime.getMTime();
    if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {
      const numPoints = publicAPI.getNumberOfPoints();
      if (!model.distances) {
        model.distances = new Array(numPoints);
      } else {
        model.distances.length = numPoints;
      }
      if (numPoints > 0) {
        const previousPoint = new Array(3);
        const currentPoint = new Array(3);
        let totalDistance = 0;
        model.distances[0] = totalDistance;
        model.points.getPoint(0, previousPoint);
        for (let i = 1; i < numPoints; ++i) {
          model.points.getPoint(i, currentPoint);
          totalDistance += model.distanceFunction(previousPoint, currentPoint);
          model.distances[i] = totalDistance;
          vec3_exports.copy(previousPoint, currentPoint);
        }
      }
      model.distancesTime.modified();
    }
    return model.distances;
  };
  publicAPI.findPointIdAtDistanceFromFirstPoint = (distance) => {
    const distances = publicAPI.getDistancesToFirstPoint();
    if (distances.length < 2) {
      return -1;
    }
    let minId = 0;
    let maxId = distances.length - 1;
    if (distance < distances[minId] || distance > distances[maxId] || distances[maxId] === 0) {
      return -1;
    }
    while (maxId - minId > 1) {
      const midId = Math.floor((minId + maxId) / 2);
      if (distances[midId] <= distance) {
        minId = midId;
      } else {
        maxId = midId;
      }
    }
    return minId;
  };
}
var DEFAULT_VALUES7 = {
  orientations: null,
  // an array of quat or null
  distanceFunction: vec3_exports.dist
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["orientations", "distanceFunction"]);
  model.distancesTime = {};
  macro.obj(model.distancesTime, {
    mtime: 0
  });
  vtkPolyLine(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend8, "vtkPolyLine");
var vtkPolyLine$1 = {
  newInstance: newInstance8,
  extend: extend8
};

// node_modules/@kitware/vtk.js/Common/Core/PriorityQueue.js
function vtkPriorityQueue(publicAPI, model) {
  model.classHierarchy.push("vtkPriorityQueue");
  publicAPI.push = (priority, element) => {
    const i = model.elements.findIndex((e) => e.priority > priority);
    model.elements.splice(i, 0, {
      priority,
      element
    });
  };
  publicAPI.pop = () => {
    if (model.elements.length > 0) {
      return model.elements.shift().element;
    }
    return null;
  };
  publicAPI.deleteById = (id) => {
    model.elements = model.elements.filter((_ref) => {
      let {
        element
      } = _ref;
      return element.id !== id;
    });
  };
  publicAPI.length = () => model.elements.length;
}
var DEFAULT_VALUES8 = {
  elements: []
};
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  vtkPriorityQueue(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend9, "vtkPriorityQueue");
var vtkPriorityQueue$1 = {
  newInstance: newInstance9,
  extend: extend9
};

// node_modules/@kitware/vtk.js/Common/DataModel/Polygon/Constants.js
var EPSILON = 1e-6;
var FLOAT_EPSILON = 11920929e-14;
var TOLERANCE = 1e-8;
var PolygonWithPointIntersectionState = {
  FAILURE: -1,
  OUTSIDE: 0,
  INSIDE: 1,
  INTERSECTION: 2,
  ON_LINE: 3
};

// node_modules/@kitware/vtk.js/Common/DataModel/Polygon.js
function pointLocation(axis0, axis1, p0, p1, point) {
  return (p1[axis0] - p0[axis0]) * (point[axis1] - p0[axis1]) - (point[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);
}
function pointInPolygon(point, vertices, bounds, normal) {
  if (point[0] < bounds[0] || point[0] > bounds[1] || point[1] < bounds[2] || point[1] > bounds[3] || point[2] < bounds[4] || point[2] > bounds[5]) {
    return PolygonWithPointIntersectionState.OUTSIDE;
  }
  if (normalize(normal) <= FLOAT_EPSILON) {
    return PolygonWithPointIntersectionState.FAILURE;
  }
  let tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));
  tol2 *= tol2;
  tol2 = tol2 === 0 ? FLOAT_EPSILON : tol2;
  const p0 = [];
  const p1 = [];
  for (let i = 0; i < vertices.length; ) {
    p0[0] = vertices[i++];
    p0[1] = vertices[i++];
    p0[2] = vertices[i++];
    if (distance2BetweenPoints(point, p0) <= tol2) {
      return PolygonWithPointIntersectionState.INSIDE;
    }
    const {
      distance,
      t
    } = vtkLine$1.distanceToLine(point, p0, p1);
    if (distance <= tol2 && t > 0 && t < 1) {
      return PolygonWithPointIntersectionState.INSIDE;
    }
  }
  let axis0;
  let axis1;
  if (Math.abs(normal[0]) > Math.abs(normal[1])) {
    if (Math.abs(normal[0]) > Math.abs(normal[2])) {
      axis0 = 1;
      axis1 = 2;
    } else {
      axis0 = 0;
      axis1 = 1;
    }
  } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {
    axis0 = 0;
    axis1 = 2;
  } else {
    axis0 = 0;
    axis1 = 1;
  }
  let wn = 0;
  for (let i = 0; i < vertices.length; ) {
    p0[0] = vertices[i++];
    p0[1] = vertices[i++];
    p0[2] = vertices[i++];
    if (i < vertices.length) {
      p1[0] = vertices[i];
      p1[1] = vertices[i + 1];
      p1[2] = vertices[i + 2];
    } else {
      p1[0] = vertices[0];
      p1[1] = vertices[1];
      p1[2] = vertices[2];
    }
    if (p0[axis1] <= point[axis1]) {
      if (p1[axis1] > point[axis1]) {
        if (pointLocation(axis0, axis1, p0, p1, point) > 0) {
          ++wn;
        }
      }
    } else if (p1[axis1] <= point[axis1]) {
      if (pointLocation(axis0, axis1, p0, p1, point) < 0) {
        --wn;
      }
    }
  }
  return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;
}
function getBounds(poly, points, bounds) {
  const n = poly.length;
  const p = [];
  points.getPoint(poly[0], p);
  bounds[0] = p[0];
  bounds[1] = p[0];
  bounds[2] = p[1];
  bounds[3] = p[1];
  bounds[4] = p[2];
  bounds[5] = p[2];
  for (let j = 1; j < n; j++) {
    points.getPoint(poly[j], p);
    vtkBoundingBox.addPoint(bounds, ...p);
  }
  const length = vtkBoundingBox.getLengths(bounds);
  return dot(length, length);
}
function getNormal(poly, points, normal) {
  normal.length = 3;
  normal[0] = 0;
  normal[1] = 0;
  normal[2] = 0;
  const p0 = [];
  let p1 = [];
  let p2 = [];
  const v1 = [];
  const v2 = [];
  points.getPoint(poly[0], p0);
  points.getPoint(poly[1], p1);
  for (let j = 2; j < poly.length; j++) {
    points.getPoint(poly[j], p2);
    subtract(p2, p1, v1);
    subtract(p0, p1, v2);
    const n = [0, 0, 0];
    cross(v1, v2, n);
    add(normal, n, normal);
    [p1, p2] = [p2, p1];
  }
  return normalize(normal);
}
function computeCentroid(poly, points) {
  let centroid = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
  centroid[0] = 0;
  centroid[1] = 0;
  centroid[2] = 0;
  const n = poly.length;
  const p = [];
  for (let i = 0; i < n; i++) {
    points.getPoint(poly[i], p);
    centroid[0] += p[0];
    centroid[1] += p[1];
    centroid[2] += p[2];
  }
  centroid[0] /= n;
  centroid[1] /= n;
  centroid[2] /= n;
  return centroid;
}
var STATIC4 = {
  PolygonWithPointIntersectionState,
  pointInPolygon,
  getBounds,
  getNormal,
  computeCentroid
};
function vtkPolygon(publicAPI, model) {
  model.classHierarchy.push("vtkPolygon");
  function computeNormal2() {
    const v1 = [0, 0, 0];
    const v2 = [0, 0, 0];
    model.normal = [0, 0, 0];
    const anchor = [...model.firstPoint.point];
    let point = model.firstPoint;
    for (let i = 0; i < model.pointCount; i++) {
      subtract(point.point, anchor, v1);
      subtract(point.next.point, anchor, v2);
      const n = [0, 0, 0];
      cross(v1, v2, n);
      add(model.normal, n, model.normal);
      point = point.next;
    }
    return normalize(model.normal);
  }
  function computeMeasure(point) {
    const v1 = [0, 0, 0];
    const v2 = [0, 0, 0];
    const v3 = [0, 0, 0];
    const v4 = [0, 0, 0];
    subtract(point.point, point.previous.point, v1);
    subtract(point.next.point, point.point, v2);
    subtract(point.previous.point, point.next.point, v3);
    cross(v1, v2, v4);
    const area = dot(v4, model.normal);
    if (area <= 0) {
      return -1;
    }
    const perimeter = norm(v1) + norm(v2) + norm(v3);
    return perimeter * perimeter / area;
  }
  function canRemoveVertex(point) {
    if (model.pointCount <= 3) {
      return true;
    }
    const previous = point.previous;
    const next = point.next;
    const v = [0, 0, 0];
    subtract(next.point, previous.point, v);
    const sN = [0, 0, 0];
    cross(v, model.normal, sN);
    normalize(sN);
    if (norm(sN) === 0) {
      return false;
    }
    let val = vtkPlane$1.evaluate(sN, previous.point, next.next.point);
    let currentSign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;
    let oneNegative = currentSign < 0 ? 1 : 0;
    for (let vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {
      const previousVertex = vertex.previous;
      val = vtkPlane$1.evaluate(sN, previous.point, vertex.point);
      const sign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;
      if (sign !== currentSign) {
        if (!oneNegative) {
          oneNegative = sign <= 0 ? 1 : 0;
        }
        if (vtkLine$1.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {
          return false;
        }
        currentSign = sign;
      }
    }
    return oneNegative === 1;
  }
  function removePoint(point, queue) {
    model.pointCount -= 1;
    const previous = point.previous;
    const next = point.next;
    model.tris = model.tris.concat(point.point);
    model.tris = model.tris.concat(next.point);
    model.tris = model.tris.concat(previous.point);
    previous.next = next;
    next.previous = previous;
    queue.deleteById(previous.id);
    queue.deleteById(next.id);
    const previousMeasure = computeMeasure(previous);
    if (previousMeasure > 0) {
      queue.push(previousMeasure, previous);
    }
    const nextMeasure = computeMeasure(next);
    if (nextMeasure > 0) {
      queue.push(nextMeasure, next);
    }
    if (point.id === model.firstPoint.id) {
      model.firstPoint = next;
    }
  }
  function earCutTriangulation() {
    computeNormal2();
    const vertexQueue = vtkPriorityQueue$1.newInstance();
    let point = model.firstPoint;
    for (let i = 0; i < model.pointCount; i++) {
      const measure = computeMeasure(point);
      if (measure > 0) {
        vertexQueue.push(measure, point);
      }
      point = point.next;
    }
    while (model.pointCount > 2 && vertexQueue.length() > 0) {
      if (model.pointCount === vertexQueue.length()) {
        const pointToRemove = vertexQueue.pop();
        removePoint(pointToRemove, vertexQueue);
      } else {
        const pointToRemove = vertexQueue.pop();
        if (canRemoveVertex(pointToRemove)) {
          removePoint(pointToRemove, vertexQueue);
        }
      }
    }
    return model.pointCount <= 2;
  }
  publicAPI.triangulate = () => {
    if (!model.firstPoint) {
      return null;
    }
    return earCutTriangulation();
  };
  publicAPI.setPoints = (points) => {
    model.pointCount = points.length;
    model.firstPoint = {
      id: 0,
      point: points[0],
      next: null,
      previous: null
    };
    let currentPoint = model.firstPoint;
    for (let i = 1; i < model.pointCount; i++) {
      currentPoint.next = {
        id: i,
        point: points[i],
        next: null,
        previous: currentPoint
      };
      currentPoint = currentPoint.next;
    }
    model.firstPoint.previous = currentPoint;
    currentPoint.next = model.firstPoint;
  };
  publicAPI.getPointArray = () => model.tris;
}
var DEFAULT_VALUES9 = {
  firstPoint: null,
  pointCount: 0,
  tris: []
};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  macro.obj(publicAPI, model);
  vtkPolygon(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend10, "vtkPolygon");
var vtkPolygon$1 = {
  newInstance: newInstance10,
  extend: extend10,
  ...STATIC4
};

// node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
function computeNormalDirection(v1, v2, v3, n) {
  const ax = v3[0] - v2[0];
  const ay = v3[1] - v2[1];
  const az = v3[2] - v2[2];
  const bx = v1[0] - v2[0];
  const by = v1[1] - v2[1];
  const bz = v1[2] - v2[2];
  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v3, n) {
  computeNormalDirection(v1, v2, v3, n);
  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length !== 0) {
    n[0] /= length;
    n[1] /= length;
    n[2] /= length;
  }
}
function interpolationDerivs(derivs) {
  derivs[0] = -1;
  derivs[1] = 1;
  derivs[2] = 0;
  derivs[3] = -1;
  derivs[4] = 0;
  derivs[5] = 1;
}
function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
  let tolerance = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6;
  let coplanar = false;
  const pt1 = [];
  const pt2 = [];
  const surfaceId = [];
  const n1 = [];
  const n2 = [];
  computeNormal(p1, q1, r1, n1);
  computeNormal(p2, q2, r2, n2);
  const s1 = -dot(n1, p1);
  const s2 = -dot(n2, p2);
  const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];
  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
    coplanar = true;
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const pts1 = [p1, q1, r1];
  const pts2 = [p2, q2, r2];
  const n1n2 = dot(n1, n2);
  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1);
  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1);
  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
  const v = cross(n1, n2, []);
  normalize(v);
  let index1 = 0;
  let index2 = 0;
  const t1 = [];
  const t2 = [];
  let ts1 = 50;
  let ts2 = 50;
  for (let i = 0; i < 3; i++) {
    const id1 = i;
    const id2 = (i + 1) % 3;
    const val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t1[index1++] = dot(val1.x, v) - dot(p, v);
    }
    const val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t2[index2++] = dot(val2.x, v) - dot(p, v);
    }
  }
  if (index1 > 2) {
    index1--;
    const t12 = t1[2];
    t1[2] = t1[ts1];
    t1[ts1] = t12;
  }
  if (index2 > 2) {
    index2--;
    const t22 = t2[2];
    t2[2] = t2[ts2];
    t2[ts2] = t22;
  }
  if (index1 !== 2 || index2 !== 2) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] > t1[1]) {
    const t11 = t1[1];
    t1[1] = t1[0];
    t1[0] = t11;
  }
  if (t2[0] > t2[1]) {
    const t21 = t2[1];
    t2[1] = t2[0];
    t2[0] = t21;
  }
  let tt1;
  let tt2;
  if (t1[1] < t2[0] || t2[1] < t1[0]) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] < t2[0]) {
    if (t1[1] < t2[1]) {
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t2[0];
      tt2 = t1[1];
    } else {
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t2[0];
      tt2 = t2[1];
    }
  } else if (t1[1] < t2[1]) {
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t1[0];
    tt2 = t1[1];
  } else {
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t1[0];
    tt2 = t2[1];
  }
  multiplyAccumulate(p, v, tt1, pt1);
  multiplyAccumulate(p, v, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}
var STATIC5 = {
  computeNormalDirection,
  computeNormal,
  interpolationDerivs,
  intersectWithTriangle
};
function vtkTriangle(publicAPI, model) {
  model.classHierarchy.push("vtkTriangle");
  publicAPI.getCellDimension = () => 2;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0;
    const closestPoint = [];
    const tol2 = tol * tol;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    const n = [];
    const weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      const plane = vtkPlane$1.intersectWithLine(p1, p2, pt1, n);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0;
        pcoords[1] = 0;
        outObj.intersect = 0;
        return outObj;
      }
      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }
    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      const pt3Pt1 = [];
      const pt3Pt2 = [];
      const pt3X = [];
      for (let i = 0; i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0;
    pcoords[1] = 0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
    const outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    let i;
    let j;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    const n = [];
    let fabsn;
    const rhs = [];
    const c1 = [];
    const c2 = [];
    let det = 0;
    let idx = 0;
    const indices = [];
    let dist2Point;
    let dist2Line1;
    let dist2Line2;
    let closest = [];
    const closestPoint1 = [];
    const closestPoint2 = [];
    const cp = [];
    outObj.subId = 0;
    pcoords[2] = 0;
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n);
    vtkPlane$1.generalizedProjectPoint(x, pt1, n, cp);
    let maxComponent = 0;
    for (i = 0; i < 3; i++) {
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }
    for (j = 0, i = 0; i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }
    for (i = 0; i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = determinant2x2(c1, c2);
    if (det === 0) {
      pcoords[0] = 0;
      pcoords[1] = 0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = determinant2x2(rhs, c2) / det;
    pcoords[1] = determinant2x2(c1, rhs) / det;
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0 && weights[0] <= 1 && weights[1] >= 0 && weights[1] <= 1 && weights[2] >= 0 && weights[2] <= 1) {
      if (closestPoint) {
        outObj.dist2 = distance2BetweenPoints(cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      let t;
      if (closestPoint) {
        if (weights[1] < 0 && weights[2] < 0) {
          dist2Point = distance2BetweenPoints(x, pt3);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt1);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt2);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[2] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const p0 = [];
    const p1 = [];
    const p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    const u3 = 1 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }
    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    const pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      if (pc[i] < 0) {
        pDist = -pc[i];
      } else if (pc[i] > 1) {
        pDist = pc[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {
    const x0 = model.points.getPoint(0);
    const x1 = model.points.getPoint(1);
    const x2 = model.points.getPoint(2);
    const n = [];
    const v10 = [];
    const v20 = [];
    const v = [];
    computeNormal(x0, x1, x2, n);
    subtract(x1, x0, v10);
    subtract(x2, x0, v);
    cross(n, v10, v20);
    const lenX = normalize(v10);
    if (lenX <= 0 || normalize(v20) <= 0) {
      for (let j = 0; j < dim; j++) {
        for (let i = 0; i < 3; i++) {
          derivs[j * dim + i] = 0;
        }
      }
      return;
    }
    const v0 = [0, 0];
    const v1 = [lenX, 0];
    const v2 = [dot(v, v10), dot(v, v20)];
    const functionDerivs = new Array(6);
    interpolationDerivs(functionDerivs);
    const J = [v1[0] - v0[0], v1[1] - v0[1], v2[0] - v0[0], v2[1] - v0[1]];
    const JI = macro.newTypedArray(TYPED_ARRAYS.Float64Array, 4);
    invertMatrix(J, JI, 2);
    for (let j = 0; j < dim; j++) {
      let sum0 = 0;
      let sum1 = 0;
      for (let i = 0; i < 3; i++) {
        sum0 += functionDerivs[i] * values[dim * i + j];
        sum1 += functionDerivs[3 + i] * values[dim * i + j];
      }
      const dBydx = sum0 * JI[0] + sum1 * JI[1];
      const dBydy = sum0 * JI[2] + sum1 * JI[3];
      derivs[3 * j] = dBydx * v10[0] + dBydy * v20[0];
      derivs[3 * j + 1] = dBydx * v10[1] + dBydy * v20[1];
      derivs[3 * j + 2] = dBydx * v10[2] + dBydy * v20[2];
    }
  };
  publicAPI.cellBoundary = (subId, pcoords, pts) => {
    const t1 = pcoords[0] - pcoords[1];
    const t2 = 0.5 * (1 - pcoords[0]) - pcoords[1];
    const t3 = 2 * pcoords[0] + pcoords[1] - 1;
    if (t1 >= 0 && t2 >= 0) {
      pts[0] = model.pointsIds[0];
      pts[1] = model.pointsIds[1];
    } else if (t2 < 0 && t3 >= 0) {
      pts[0] = model.pointsIds[1];
      pts[1] = model.pointsIds[2];
    } else {
      pts[0] = model.pointsIds[2];
      pts[1] = model.pointsIds[0];
    }
    if (pcoords[0] < 0 || pcoords[1] < 0 || pcoords[0] > 1 || pcoords[1] > 1 || 1 - pcoords[0] - pcoords[1] < 0) {
      return false;
    }
    return true;
  };
}
var DEFAULT_VALUES10 = {};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}
var newInstance11 = macro.newInstance(extend11, "vtkTriangle");
var vtkTriangle$1 = {
  newInstance: newInstance11,
  extend: extend11,
  ...STATIC5
};

// node_modules/@kitware/vtk.js/Common/DataModel/Quad.js
function intersectionStruct() {
  return {
    intersected: false,
    subId: -1,
    x: [0, 0, 0],
    pCoords: [0, 0, 0],
    t: -1
  };
}
function vtkQuad(publicAPI, model) {
  model.classHierarchy.push("vtkQuad");
  publicAPI.getCellDimension = () => 2;
  publicAPI.getCellType = () => CellType.VTK_QUAD;
  publicAPI.getNumberOfEdges = () => 4;
  publicAPI.getNumberOfFaces = () => 0;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    let outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    let diagonalCase;
    const point0 = model.points.getPoint(0, []);
    const point1 = model.points.getPoint(1, []);
    const point2 = model.points.getPoint(2, []);
    const point3 = model.points.getPoint(3, []);
    const d1 = distance2BetweenPoints(point0, point2);
    const d2 = distance2BetweenPoints(point1, point3);
    if (d1 === d2) {
      let id;
      let maxId = 0;
      let maxIdx = 0;
      for (let i = 0; i < 4; i++) {
        id = model.pointsIds[i];
        if (id > maxId) {
          maxId = id;
          maxIdx = i;
        }
      }
      if (maxIdx === 0 || maxIdx === 2) {
        diagonalCase = 0;
      } else {
        diagonalCase = 1;
      }
    } else if (d1 < d2) {
      diagonalCase = 0;
    } else {
      diagonalCase = 1;
    }
    let points = null;
    if (!model.triangle) {
      model.triangle = vtkTriangle$1.newInstance();
      points = vtkPoints$1.newInstance();
      points.setNumberOfPoints(3);
      model.triangle.initialize(points);
    } else {
      points = model.triangle.getPoints();
    }
    let firstIntersect;
    const firstIntersectTmpObj = intersectionStruct();
    let secondIntersect;
    const secondIntersectTmpObj = intersectionStruct();
    let useFirstIntersection;
    let useSecondIntersection;
    switch (diagonalCase) {
      case 0:
        points.setPoint(0, ...point0);
        points.setPoint(1, ...point1);
        points.setPoint(2, ...point2);
        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
        points.setPoint(0, ...point2);
        points.setPoint(1, ...point3);
        points.setPoint(2, ...point0);
        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }
        break;
      case 1:
        points.setPoint(0, ...point0);
        points.setPoint(1, ...point1);
        points.setPoint(2, ...point3);
        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
        points.setPoint(0, ...point2);
        points.setPoint(1, ...point3);
        points.setPoint(2, ...point1);
        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }
        break;
    }
    return outObj;
  };
  publicAPI.interpolationFunctions = (pcoords, weights) => {
    const rm = 1 - pcoords[0];
    const sm = 1 - pcoords[1];
    weights[0] = rm * sm;
    weights[1] = pcoords[0] * sm;
    weights[2] = pcoords[0] * pcoords[1];
    weights[3] = rm * pcoords[1];
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const point = [];
    publicAPI.interpolationFunctions(pcoords, weights);
    x[0] = 0;
    x[1] = 0;
    x[2] = 0;
    for (let i = 0; i < 4; i++) {
      model.points.getPoint(i, point);
      for (let j = 0; j < 3; j++) {
        x[j] += point[j] * weights[i];
      }
    }
  };
}
var DEFAULT_VALUES11 = {};
function extend12(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkQuad(publicAPI, model);
}
var newInstance12 = macro.newInstance(extend12, "vtkQuad");
var vtkQuad$1 = {
  newInstance: newInstance12,
  extend: extend12
};

// node_modules/@kitware/vtk.js/Common/DataModel/TriangleStrip.js
var {
  vtkErrorMacro: vtkErrorMacro2
} = macro;
function notImplemented(method) {
  return () => vtkErrorMacro2(`vtkTriangleStrip.${method} - NOT IMPLEMENTED`);
}
function decomposeStrip(pts, polys) {
  if (!Array.isArray(pts) || pts.length < 3) {
    vtkErrorMacro2("decomposeStrip - Invalid points array");
    return;
  }
  let p1 = pts[0];
  let p2 = pts[1];
  for (let i = 0; i < pts.length - 2; i++) {
    const p3 = pts[i + 2];
    if (i % 2) {
      polys.insertNextCell([p2, p1, p3]);
    } else {
      polys.insertNextCell([p1, p2, p3]);
    }
    p1 = p2;
    p2 = p3;
  }
}
var STATIC6 = {
  decomposeStrip
};
function vtkTriangleStrip(publicAPI, model) {
  model.classHierarchy.push("vtkTriangleStrip");
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = (points, pointsIds) => {
    model.triangle.initialize(points, pointsIds);
    superInitialize(points, pointsIds);
  };
  publicAPI.getCellType = () => CellType.VTK_TRIANGLE_STRIP;
  publicAPI.getCellDimension = () => 2;
  publicAPI.getNumberOfEdges = () => model.pointsIds.length;
  publicAPI.getNumberOfFaces = () => 0;
  publicAPI.evaluatePosition = (x, closestPoint, pcoords, dist2, weights) => {
    const pc = [0, 0, 0];
    let minDist2 = Number.MAX_VALUE;
    let returnStatus = 0;
    const tempWeights = [];
    const activeWeights = [];
    const closest = [];
    pcoords[2] = 0;
    activeWeights[0] = 0;
    activeWeights[1] = 0;
    activeWeights[2] = 0;
    const points = model.triangle.getPoints();
    points.setNumberOfPoints(3);
    const pointsIds = model.triangle.getPointsIds();
    const numPoints = pointsIds.length;
    for (let i = 0; i < numPoints; i++) {
      weights[i] = 0;
    }
    for (let i = 0; i < numPoints - 2; i++) {
      const pt0 = [];
      points.getPoint(i, pt0);
      const pt1 = [];
      points.getPoint(i + 1, pt1);
      const pt2 = [];
      points.getPoint(i + 2, pt2);
      points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);
      const status = model.triangle.evaluatePosition(x, closest, pc, tempWeights);
      const currentDist2 = status.dist2;
      if (status.evaluation >= 0 && (currentDist2 < minDist2 || currentDist2 === minDist2 && returnStatus === 0)) {
        returnStatus = status;
        if (closestPoint) {
          closestPoint[0] = closest[0];
          closestPoint[1] = closest[1];
          closestPoint[2] = closest[2];
        }
        pcoords[0] = pc[0];
        pcoords[1] = pc[1];
        minDist2 = currentDist2;
        activeWeights[0] = tempWeights[0];
        activeWeights[1] = tempWeights[1];
        activeWeights[2] = tempWeights[2];
      }
    }
    dist2[0] = minDist2;
    weights[0] = activeWeights[0];
    weights[1] = activeWeights[1];
    weights[2] = activeWeights[2];
    return returnStatus;
  };
  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {
    const idx = [[0, 1, 2], [1, 0, 2]];
    const order = subId % 2;
    const numPoints = model.pointsIds.length;
    for (let i = 0; i < numPoints; i++) {
      weights[i] = 0;
    }
    const u3 = 1 - pcoords[0] - pcoords[1];
    weights[subId] = u3;
    weights[subId + 1] = pcoords[0];
    weights[subId + 2] = pcoords[1];
    const pt1 = [];
    model.points.getPoint(subId + idx[order][0], pt1);
    const pt2 = [];
    model.points.getPoint(subId + idx[order][1], pt2);
    const pt3 = [];
    model.points.getPoint(subId + idx[order][2], pt3);
    for (let i = 0; i < 3; i++) {
      x[i] = pt1[i] * weights[subId] + pt2[i] * weights[subId + 1] + pt3[i] * weights[subId + 2];
    }
  };
  publicAPI.cellBoundary = (subId, pcoords, pts) => {
    const idx = [[0, 1, 2], [1, 0, 2]];
    const order = subId % 2;
    const pointsIds = model.triangle.getPointsIds();
    pointsIds[0] = model.pointsIds[idx[order][0]];
    pointsIds[1] = model.pointsIds[idx[order][1]];
    pointsIds[2] = model.pointsIds[idx[order][2]];
    return model.triangle.cellBoundary(0, pcoords, pts);
  };
  publicAPI.getEdge = (edgeId) => {
    let id1;
    let id2;
    const numPoints = model.pointsIds.length;
    if (edgeId === 0) {
      id1 = 0;
      id2 = 1;
    } else if (edgeId === numPoints - 1) {
      id1 = edgeId - 1;
      id2 = edgeId;
    } else {
      id1 = edgeId - 1;
      id2 = edgeId + 1;
    }
    model.line.getPointsIds()[0] = model.pointsIds[id1];
    model.line.getPointsIds()[1] = model.pointsIds[id2];
    model.line.getPoints().setPoint(0, model.points.getPoint(id1));
    model.line.getPoints().setPoint(1, model.points.getPoint(id2));
    return model.line;
  };
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const numTris = model.pointsIds.length - 2;
    const points = model.triangle.getPoints();
    points.setNumberOfPoints(3);
    for (let i = 0; i < numTris; i++) {
      const pt0 = [];
      model.points.getPoint(model.pointsIds[i], pt0);
      const pt1 = [];
      model.points.getPoint(model.pointsIds[i + 1], pt1);
      const pt2 = [];
      model.points.getPoint(model.pointsIds[i + 2], pt2);
      points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);
      const ret = model.triangle.intersectWithLine(p1, p2, tol, x, pcoords);
      if (ret.intersect) {
        return ret;
      }
    }
    return false;
  };
  publicAPI.triangulate = () => {
    const numTris = model.points.getNumberOfPoints() - 2;
    model.tris = new Array(3 * numTris);
    const idx = [[0, 1, 2], [1, 0, 2]];
    for (let subId = 0; subId < numTris; subId++) {
      const order = subId % 2;
      for (let i = 0; i < 3; i++) {
        model.tris[subId * 3 + i] = subId + idx[order][i];
      }
    }
    return true;
  };
  publicAPI.getPointArray = () => model.tris;
  publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {
    const pt0 = [];
    model.points.getPoint(subId, pt0);
    const pt1 = [];
    model.points.getPoint(subId + 1, pt1);
    const pt2 = [];
    model.points.getPoint(subId + 2, pt2);
    const points = model.triangle.getPoints();
    points.setPoint(0, ...pt0);
    points.setPoint(1, ...pt1);
    points.setPoint(2, ...pt2);
    model.triangle.derivatives(0, pcoords, values, dim, derivs);
  };
  publicAPI.getParametricCenter = (pcoords) => {
    pcoords[0] = 0.333333;
    pcoords[1] = 0.333333;
    pcoords[2] = 0;
    return Math.floor((model.pointsIds.length - 2) / 2);
  };
  publicAPI.contour = (value, cellScalars, locator, verts, lines, polys, inPd, outPd, inCd, cellId, outCd) => notImplemented("contour")();
  publicAPI.clip = (value, cellScalars, locator, tris, inPd, outPd, inCd, cellId, outCd, insideOut) => notImplemented("clip")();
}
var DEFAULT_VALUES12 = {
  line: null,
  triangle: null,
  tris: null
};
function extend13(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  if (!model.line) {
    model.line = vtkLine$1.newInstance();
  }
  if (!model.triangle) {
    model.triangle = vtkTriangle$1.newInstance();
  }
  vtkTriangleStrip(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend13, "vtkTriangleStrip");
var vtkTriangleStrip$1 = {
  newInstance: newInstance13,
  extend: extend13,
  ...STATIC6
};

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
var POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
var {
  vtkWarningMacro
} = macro;
var CELL_FACTORY = {
  [CellType.VTK_LINE]: vtkLine$1,
  [CellType.VTK_QUAD]: vtkQuad$1,
  [CellType.VTK_POLY_LINE]: vtkLine$1,
  [CellType.VTK_TRIANGLE]: vtkTriangle$1,
  [CellType.VTK_TRIANGLE_STRIP]: vtkTriangleStrip$1,
  [CellType.VTK_POLY_LINE]: vtkPolyLine$1,
  [CellType.VTK_POLYGON]: vtkPolygon$1
};
function vtkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkPolyData");
  function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
  }
  function clearCells() {
    model.cells = void 0;
    model.links = void 0;
  }
  POLYDATA_FIELDS.forEach((type) => {
    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = vtkCellArray$1.newInstance();
    } else {
      model[type] = vtk(model[type]);
    }
    model[`_on${camelize(type)}Changed`] = clearCells;
  });
  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach((type) => {
      model[type] = vtkCellArray$1.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  const superGetMTime = publicAPI.getMTime;
  publicAPI.getMTime = () => POLYDATA_FIELDS.reduce((mTime, type) => {
    var _a;
    return Math.max(mTime, ((_a = model[type]) == null ? void 0 : _a.getMTime()) ?? mTime);
  }, superGetMTime());
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = () => {
    POLYDATA_FIELDS.forEach((type) => {
      var _a;
      return (_a = model[type]) == null ? void 0 : _a.initialize();
    });
    clearCells();
    return superInitialize();
  };
  publicAPI.buildCells = () => {
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();
    const nCells = nVerts + nLines + nPolys + nStrips;
    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro("Building VTK_LINE ", index, " with only one point, but VTK_LINE needs at least two points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro("Building VTK_TRIANGLE ", index, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };
  publicAPI.buildLinks = function() {
    let initialSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.cells == null) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = (cellId) => model.cells.getCellType(cellId);
  publicAPI.getCellPoints = (cellId) => {
    const cellType = publicAPI.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = (ptId) => model.links.getCells(ptId);
  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);
    return link1.cells.filter((cell) => cell !== cellId && link2.cells.indexOf(cell) !== -1);
  };
  publicAPI.getCell = function(cellId) {
    let cellHint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
  publicAPI.getMaxCellSize = () => POLYDATA_FIELDS.reduce((max, type) => {
    var _a, _b;
    return Math.max(max, ((_b = (_a = model[type]) == null ? void 0 : _a.getMaxCellSize) == null ? void 0 : _b.call(_a)) ?? 0);
  }, 0);
}
var DEFAULT_VALUES13 = {
  // verts: null,
  // lines: null,
  // polys: null,
  // strips: null,
  // cells: null,
  // links: null,
};
function extend14(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["cells", "links"]);
  macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
  vtkPolyData(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend14, "vtkPolyData");
var vtkPolyData$1 = {
  newInstance: newInstance14,
  extend: extend14
};

export {
  vtkCellArray$1,
  vtkPoints$1,
  vtkCell$1,
  CellType,
  vtkCellTypes$1,
  vtkLine$1,
  vtkPointSet$1,
  vtkPolyLine$1,
  PolygonWithPointIntersectionState,
  vtkPolygon$1,
  vtkTriangle$1,
  vtkQuad$1,
  vtkTriangleStrip$1,
  POLYDATA_FIELDS,
  vtkPolyData$1
};
//# sourceMappingURL=chunk-3WRJRU3H.js.map
