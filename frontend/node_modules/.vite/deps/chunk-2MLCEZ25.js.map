{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/Core/AbstractMapper.js", "../../@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js", "../../@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js", "../../@kitware/vtk.js/Common/DataModel/StructuredData.js", "../../@kitware/vtk.js/Common/DataModel/ImageData.js", "../../@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js", "../../@kitware/vtk.js/Rendering/Core/Mapper/Constants.js", "../../@kitware/vtk.js/Common/Core/ScalarsToColors.js", "../../@kitware/vtk.js/Common/Core/LookupTable.js", "../../@kitware/vtk.js/Rendering/Core/Mapper/Static.js", "../../@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js", "../../@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js", "../../@kitware/vtk.js/Rendering/Core/Mapper.js"],
  "sourcesContent": ["import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkAbstractMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAbstractMapper(publicAPI, model) {\n  model.classHierarchy.push('vtkAbstractMapper');\n  publicAPI.update = () => {\n    publicAPI.getInputData();\n  };\n  publicAPI.addClippingPlane = plane => {\n    if (!plane.isA('vtkPlane')) {\n      return false;\n    }\n    if (!model.clippingPlanes.includes(plane)) {\n      model.clippingPlanes.push(plane);\n      publicAPI.modified();\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;\n  publicAPI.removeAllClippingPlanes = () => {\n    if (model.clippingPlanes.length === 0) {\n      return false;\n    }\n    model.clippingPlanes.length = 0;\n    publicAPI.modified();\n    return true;\n  };\n  publicAPI.removeClippingPlane = clippingPlane => {\n    const i = model.clippingPlanes.indexOf(clippingPlane);\n    if (i === -1) {\n      return false;\n    }\n    model.clippingPlanes.splice(i, 1);\n    publicAPI.modified();\n    return true;\n  };\n  publicAPI.getClippingPlanes = () => model.clippingPlanes;\n  publicAPI.setClippingPlanes = planes => {\n    if (!planes) {\n      return;\n    }\n    if (!Array.isArray(planes)) {\n      publicAPI.addClippingPlane(planes);\n    } else {\n      const nbPlanes = planes.length;\n      for (let i = 0; i < nbPlanes && i < 6; i++) {\n        publicAPI.addClippingPlane(planes[i]);\n      }\n    }\n  };\n  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {\n    const clipPlanes = model.clippingPlanes;\n    const mat = propMatrix;\n    if (clipPlanes) {\n      const n = clipPlanes.length;\n      if (i >= 0 && i < n) {\n        // Get the plane\n        const plane = clipPlanes[i];\n        const normal = plane.getNormal();\n        const origin = plane.getOrigin();\n\n        // Compute the plane equation\n        const v1 = normal[0];\n        const v2 = normal[1];\n        const v3 = normal[2];\n        const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);\n\n        // Transform normal from world to data coords\n        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];\n        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];\n        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];\n        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];\n        return;\n      }\n    }\n    macro.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clippingPlanes: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 1, 0);\n  if (!model.clippingPlanes) {\n    model.clippingPlanes = [];\n  }\n  vtkAbstractMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nvar vtkAbstractMapper$1 = {\n  extend\n};\n\nexport { vtkAbstractMapper$1 as default, extend };\n", "import { m as macro } from '../../macros2.js';\nimport vtkAbstractMapper from './AbstractMapper.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport { I as createUninitializedBounds } from '../../Common/Core/Math/index.js';\n\n// ----------------------------------------------------------------------------\n// vtkAbstractMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAbstractMapper3D(publicAPI, model) {\n  publicAPI.getBounds = () => {\n    macro.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);\n    return createUninitializedBounds();\n  };\n  publicAPI.getCenter = () => {\n    const bounds = publicAPI.getBounds();\n    model.center = vtkBoundingBox.isValid(bounds) ? vtkBoundingBox.getCenter(bounds) : null;\n    return model.center?.slice();\n  };\n  publicAPI.getLength = () => {\n    const bounds = publicAPI.getBounds();\n    return vtkBoundingBox.getDiagonalLength(bounds);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst defaultValues = initialValues => ({\n  bounds: [...vtkBoundingBox.INIT_BOUNDS],\n  center: [0, 0, 0],\n  viewSpecificProperties: {},\n  ...initialValues\n});\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n  // Inheritance\n  vtkAbstractMapper.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['viewSpecificProperties']);\n  vtkAbstractMapper3D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkAbstractMapper3D$1 = {\n  extend\n};\n\nexport { vtkAbstractMapper3D$1 as default, extend };\n", "const StructuredType = {\n  UNCHANGED: 0,\n  SINGLE_POINT: 1,\n  X_LINE: 2,\n  Y_LINE: 3,\n  Z_LINE: 4,\n  XY_PLANE: 5,\n  YZ_PLANE: 6,\n  XZ_PLANE: 7,\n  XYZ_GRID: 8,\n  EMPTY: 9\n};\nvar Constants = {\n  StructuredType\n};\n\nexport { StructuredType, Constants as default };\n", "import Constants from './StructuredData/Constants.js';\n\nconst {\n  StructuredType\n} = Constants;\nfunction getDataDescriptionFromExtent(inExt) {\n  let dataDim = 0;\n  for (let i = 0; i < 3; ++i) {\n    if (inExt[i * 2] < inExt[i * 2 + 1]) {\n      dataDim++;\n    }\n  }\n  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {\n    return StructuredType.EMPTY;\n  }\n  if (dataDim === 3) {\n    return StructuredType.XYZ_GRID;\n  }\n  if (dataDim === 2) {\n    if (inExt[0] === inExt[1]) {\n      return StructuredType.YZ_PLANE;\n    }\n    if (inExt[2] === inExt[3]) {\n      return StructuredType.XZ_PLANE;\n    }\n    return StructuredType.XY_PLANE;\n  }\n  if (dataDim === 1) {\n    if (inExt[0] < inExt[1]) {\n      return StructuredType.X_LINE;\n    }\n    if (inExt[2] < inExt[3]) {\n      return StructuredType.Y_LINE;\n    }\n    return StructuredType.Z_LINE;\n  }\n  return StructuredType.SINGLE_POINT;\n}\nvar vtkStructuredData = {\n  getDataDescriptionFromExtent,\n  ...Constants\n};\n\nexport { vtkStructuredData as default, getDataDescriptionFromExtent };\n", "import { m as macro } from '../../macros2.js';\nimport { c as roundVector, e as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  model._onOriginChanged = publicAPI.computeTransforms;\n  model._onDirectionChanged = publicAPI.computeTransforms;\n  model._onSpacingChanged = publicAPI.computeTransforms;\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n  const superInitialize = publicAPI.initialize;\n  publicAPI.initialize = () => {\n    publicAPI.set({\n      direction: mat3.identity(model.direction),\n      spacing: [1.0, 1.0, 1.0],\n      origin: [0.0, 0.0, 0.0],\n      extent: [0, -1, 0, -1, 0, -1],\n      dataDescription: StructuredType.EMPTY\n    });\n    return superInitialize();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n", "const VectorMode = {\n  MAGNITUDE: 0,\n  COMPONENT: 1,\n  RGBCOLORS: 2\n};\nconst ScalarMappingTarget = {\n  LUMINANCE: 1,\n  LUMINANCE_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nconst Scale = {\n  LINEAR: 0,\n  LOG10: 1\n};\nvar vtkScalarsToColors = {\n  VectorMode,\n  ScalarMappingTarget,\n  Scale\n};\n\nexport { ScalarMappingTarget, Scale, VectorMode, vtkScalarsToColors as default };\n", "const ColorMode = {\n  DEFAULT: 0,\n  MAP_SCALARS: 1,\n  DIRECT_SCALARS: 2\n};\nconst ScalarMode = {\n  DEFAULT: 0,\n  USE_POINT_DATA: 1,\n  USE_CELL_DATA: 2,\n  USE_POINT_FIELD_DATA: 3,\n  USE_CELL_FIELD_DATA: 4,\n  USE_FIELD_DATA: 5\n};\nconst GetArray = {\n  BY_ID: 0,\n  BY_NAME: 1\n};\nvar Constants = {\n  ColorMode,\n  GetArray,\n  ScalarMode\n};\n\nexport { ColorMode, GetArray, ScalarMode, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport vtkScalarsToColors$2 from './ScalarsToColors/Constants.js';\nimport Constants from '../../Rendering/Core/Mapper/Constants.js';\n\nconst {\n  ScalarMappingTarget,\n  Scale,\n  VectorMode\n} = vtkScalarsToColors$2;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  ColorMode\n} = Constants;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n}\n\n// ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode.COMPONENT);\n  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n  publicAPI.build = () => {};\n  publicAPI.isOpaque = () => true;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotations = (values, annotations) => {\n    if (values && !annotations || !values && annotations) {\n      return;\n    }\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');\n      return;\n    }\n    model.annotationArray = [];\n    if (annotations && values) {\n      const num = annotations.length;\n      for (let i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i])\n        });\n      }\n    }\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setAnnotation = (value, annotation) => {\n    let i = publicAPI.checkForAnnotatedValue(value);\n    let modified = false;\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({\n        value,\n        annotation\n      });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return i;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValue = idx => {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n    return model.annotationArray[idx].value;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotation = idx => {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n    return model.annotationArray[idx].annotation;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotatedValueIndex = val => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;\n\n  //----------------------------------------------------------------------------\n  publicAPI.removeAnnotation = value => {\n    const i = publicAPI.checkForAnnotatedValue(value);\n    const needToRemove = i >= 0;\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return needToRemove;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetAnnotations = () => {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getAnnotationColor = (val, rgba) => {\n    if (model.indexedLookup) {\n      const i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.checkForAnnotatedValue = value => publicAPI.getAnnotatedValueIndexInternal(value);\n\n  //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n  publicAPI.getAnnotatedValueIndexInternal = value => {\n    if (model.annotatedValueMap[value] !== undefined) {\n      const na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    }\n    // Treat as a NaN\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (val, rgba) => {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateAnnotatedValueMap = () => {\n    model.annotatedValueMap = [];\n    const na = model.annotationArray.length;\n    for (let i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  };\n\n  // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {\n    const numberOfComponents = scalars.getNumberOfComponents();\n    let newColors = null;\n\n    // map scalars through lookup table only if needed\n    if (colorMode === ColorMode.DEFAULT && (scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode.DIRECT_SCALARS && scalars) {\n      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());\n    } else {\n      const newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR\n      };\n      const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n      let component = componentIn;\n\n      // If mapper did not specify a component, use the VectorMode\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        }\n\n        // Map the scalars to colors\n        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);\n      }\n    }\n    return newColors;\n  };\n  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    for (let i = 0; i < length; i++) {\n      let sum = 0.0;\n      for (let j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n      outputV[i] = Math.sqrt(sum);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {\n    let vectorMode = publicAPI.getVectorMode();\n    let vectorSize = vectorSizeIn;\n    let vectorComponent = vectorComponentIn;\n    const inComponents = input.getNumberOfComponents();\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    }\n\n    // increment input pointer to the first component to map\n    let inputOffset = 0;\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    }\n\n    // map according to the current vector mode\n    switch (vectorMode) {\n      case VectorMode.COMPONENT:\n        {\n          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);\n          break;\n        }\n      case VectorMode.RGBCOLORS:\n        {\n          // publicAPI.mapColorsToColors(\n          //   input, output, inComponents, vectorSize,\n          //   outputFormat);\n          break;\n        }\n\n      // MAGNITUDE is considered default\n      case VectorMode.MAGNITUDE:\n      default:\n        {\n          const magValues = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values: new Float32Array(input.getNumberOfTuples())\n          });\n          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n          break;\n        }\n    }\n  };\n  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = convtFun(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 1;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 2;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      const l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {\n    const a = floatColorToUChar(alpha);\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 3;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {\n    const values = colors.getData();\n    const newValues = newColors.getData();\n    const size = values.length;\n    const component = 0;\n    const tuple = 4;\n    let count = 0;\n    for (let i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {\n    let {\n      alpha\n    } = model;\n    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {\n      return colors;\n    }\n    const newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR\n    });\n    if (numTuples <= 0) {\n      return newColors;\n    }\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n    let convtFun = intColorToUChar;\n    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {\n      convtFun = floatColorToUChar;\n    }\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n    return newColors;\n  };\n  publicAPI.usingLogScale = () => false;\n  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;\n  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);\n  publicAPI.getRange = () => publicAPI.getMappingRange();\n  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {\n    if (!scalars) {\n      return publicAPI.isOpaque();\n    }\n    const numberOfComponents = scalars.getNumberOfComponents();\n\n    // map scalars through lookup table only if needed\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS) {\n      // we will be using the scalars directly, so look at the number of\n      // components and the range\n      if (numberOfComponents === 3 || numberOfComponents === 1) {\n        return model.alpha >= 1.0;\n      }\n      // otherwise look at the range of the alpha channel\n      const range = scalars.getRange(numberOfComponents - 1);\n      return range[0] === 255;\n    }\n    return true;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false,\n  scale: Scale.LINEAR\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']);\n\n  // Create set macros for array (needs to know size)\n  macro.setArray(publicAPI, model, ['mappingRange'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['mappingRange']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkScalarsToColors(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkScalarsToColors');\n\n// ----------------------------------------------------------------------------\n\nvar vtkScalarsToColors$1 = {\n  newInstance,\n  extend,\n  ...vtkScalarsToColors$2\n};\n\nexport { vtkScalarsToColors$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport { i as isNan, h as hsv2rgb } from './Math/index.js';\nimport vtkScalarsToColors from './ScalarsToColors.js';\nimport { ScalarMappingTarget } from './ScalarsToColors/Constants.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst BELOW_RANGE_COLOR_INDEX = 0;\nconst ABOVE_RANGE_COLOR_INDEX = 1;\nconst NAN_COLOR_INDEX = 2;\n\n// ----------------------------------------------------------------------------\n// vtkMyClass methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLookupTable(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLookupTable');\n\n  //----------------------------------------------------------------------------\n  // Description:\n  // Return true if all of the values defining the mapping have an opacity\n  // equal to 1. Default implementation return true.\n  publicAPI.isOpaque = () => {\n    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {\n      let opaque = true;\n      if (model.nanColor[3] < 1.0) {\n        opaque = 0;\n      }\n      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1.0) {\n        opaque = 0;\n      }\n      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1.0) {\n        opaque = 0;\n      }\n      for (let i = 3; i < model.table.length && opaque; i += 4) {\n        if (model.table[i] < 255) {\n          opaque = false;\n        }\n      }\n      model.opaqueFlag = opaque;\n      model.opaqueFlagBuildTime.modified();\n    }\n    return model.opaqueFlag;\n  };\n  publicAPI.usingLogScale = () => false;\n\n  //----------------------------------------------------------------------------\n  // Don't count special colors (min, max, NaN) as available colors\n  publicAPI.getNumberOfAvailableColors = () => model.table.length / 4 - 3;\n\n  //----------------------------------------------------------------------------\n  // Apply shift/scale to the scalar value v and return the index.\n  publicAPI.linearIndexLookup = (v, p) => {\n    let dIndex = 0;\n    const nv = Number(v);\n    if (nv < p.range[0]) {\n      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;\n    } else if (nv > p.range[1]) {\n      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;\n    } else {\n      dIndex = (nv + p.shift) * p.scale;\n\n      // This conditional is needed because when v is very close to\n      // p.Range[1], it may map above p.MaxIndex in the linear mapping\n      // above.\n      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;\n    }\n    return Math.floor(dIndex);\n  };\n  publicAPI.linearLookup = (v, table, p) => {\n    let index = 0;\n    if (isNan(v)) {\n      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);\n    } else {\n      index = publicAPI.linearIndexLookup(v, p);\n    }\n    const offset = 4 * index;\n    return table.slice(offset, offset + 4);\n  };\n  publicAPI.indexedLookupFunction = (v, table, p) => {\n    let index = publicAPI.getAnnotatedValueIndexInternal(v);\n    if (index === -1) {\n      index = model.numberOfColors + NAN_COLOR_INDEX;\n    }\n    const offset = 4 * index;\n    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.lookupShiftAndScale = (range, p) => {\n    p.shift = -range[0];\n    p.scale = Number.MAX_VALUE;\n    if (range[1] > range[0]) {\n      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);\n    }\n  };\n\n  // Public API methods\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    let lookupFunc = publicAPI.linearLookup;\n    if (model.indexedLookup) {\n      lookupFunc = publicAPI.indexedLookupFunction;\n    }\n    const trange = publicAPI.getMappingRange();\n    const p = {\n      maxIndex: publicAPI.getNumberOfColors() - 1,\n      range: trange,\n      shift: 0.0,\n      scale: 0.0\n    };\n    publicAPI.lookupShiftAndScale(trange, p);\n    const alpha = publicAPI.getAlpha();\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    if (alpha >= 1.0) {\n      if (outFormat === ScalarMappingTarget.RGBA) {\n        for (let i = 0; i < length; i++) {\n          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);\n          outputV[i * 4] = cptr[0];\n          outputV[i * 4 + 1] = cptr[1];\n          outputV[i * 4 + 2] = cptr[2];\n          outputV[i * 4 + 3] = cptr[3];\n        }\n      }\n    } else {\n      /* eslint-disable no-lonely-if */\n      if (outFormat === ScalarMappingTarget.RGBA) {\n        for (let i = 0; i < length; i++) {\n          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);\n          outputV[i * 4] = cptr[0];\n          outputV[i * 4 + 1] = cptr[1];\n          outputV[i * 4 + 2] = cptr[2];\n          outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);\n        }\n      }\n    } // alpha blending\n  };\n\n  publicAPI.forceBuild = () => {\n    let hinc = 0.0;\n    let sinc = 0.0;\n    let vinc = 0.0;\n    let ainc = 0.0;\n    const maxIndex = model.numberOfColors - 1;\n    if (maxIndex) {\n      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;\n      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;\n      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;\n      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;\n    }\n    model.table.length = 4 * maxIndex + 16;\n    const hsv = [];\n    const rgba = [];\n    for (let i = 0; i <= maxIndex; i++) {\n      hsv[0] = model.hueRange[0] + i * hinc;\n      hsv[1] = model.saturationRange[0] + i * sinc;\n      hsv[2] = model.valueRange[0] + i * vinc;\n      hsv2rgb(hsv, rgba);\n      rgba[3] = model.alphaRange[0] + i * ainc;\n\n      //  case VTK_RAMP_LINEAR:\n      model.table[i * 4] = rgba[0] * 255.0 + 0.5;\n      model.table[i * 4 + 1] = rgba[1] * 255.0 + 0.5;\n      model.table[i * 4 + 2] = rgba[2] * 255.0 + 0.5;\n      model.table[i * 4 + 3] = rgba[3] * 255.0 + 0.5;\n    }\n    publicAPI.buildSpecialColors();\n    model.buildTime.modified();\n  };\n  publicAPI.setTable = table => {\n    // Handle JS array (assume 2D array)\n    if (Array.isArray(table)) {\n      const nbComponents = table[0].length;\n      model.numberOfColors = table.length;\n      const colorOffset = 4 - nbComponents;\n      let offset = 0;\n      // fill table\n      for (let i = 0; i < model.numberOfColors; i++) {\n        model.table[i * 4] = 255;\n        model.table[i * 4 + 1] = 255;\n        model.table[i * 4 + 2] = 255;\n        model.table[i * 4 + 3] = 255;\n      }\n      // extract colors\n      for (let i = 0; i < table.length; i++) {\n        const color = table[i];\n        for (let j = 0; j < nbComponents; j++) {\n          model.table[offset++] = color[j];\n        }\n        offset += colorOffset;\n      }\n      publicAPI.buildSpecialColors();\n      model.insertTime.modified();\n      publicAPI.modified();\n      return true;\n    }\n    if (table.getNumberOfComponents() !== 4) {\n      vtkErrorMacro('Expected 4 components for RGBA colors');\n      return false;\n    }\n    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {\n      vtkErrorMacro('Expected unsigned char values for RGBA colors');\n      return false;\n    }\n    model.numberOfColors = table.getNumberOfTuples();\n    const data = table.getData();\n    model.table.length = data.length;\n    for (let i = 0; i < data.length; i++) {\n      model.table[i] = data[i];\n    }\n    publicAPI.buildSpecialColors();\n    model.insertTime.modified();\n    publicAPI.modified();\n    return true;\n  };\n  publicAPI.buildSpecialColors = () => {\n    // Add \"special\" colors (NaN, below range, above range) to table here.\n    const {\n      numberOfColors\n    } = model;\n    const tptr = model.table;\n    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;\n\n    // Below range color\n    if (model.useBelowRangeColor || numberOfColors === 0) {\n      tptr[base] = model.belowRangeColor[0] * 255.0 + 0.5;\n      tptr[base + 1] = model.belowRangeColor[1] * 255.0 + 0.5;\n      tptr[base + 2] = model.belowRangeColor[2] * 255.0 + 0.5;\n      tptr[base + 3] = model.belowRangeColor[3] * 255.0 + 0.5;\n    } else {\n      // Duplicate the first color in the table.\n      tptr[base] = tptr[0];\n      tptr[base + 1] = tptr[1];\n      tptr[base + 2] = tptr[2];\n      tptr[base + 3] = tptr[3];\n    }\n\n    // Above range color\n    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;\n    if (model.useAboveRangeColor || numberOfColors === 0) {\n      tptr[base] = model.aboveRangeColor[0] * 255.0 + 0.5;\n      tptr[base + 1] = model.aboveRangeColor[1] * 255.0 + 0.5;\n      tptr[base + 2] = model.aboveRangeColor[2] * 255.0 + 0.5;\n      tptr[base + 3] = model.aboveRangeColor[3] * 255.0 + 0.5;\n    } else {\n      // Duplicate the last color in the table.\n      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];\n      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];\n      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];\n      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];\n    }\n\n    // Always use NanColor\n    base = (numberOfColors + NAN_COLOR_INDEX) * 4;\n    tptr[base] = model.nanColor[0] * 255.0 + 0.5;\n    tptr[base + 1] = model.nanColor[1] * 255.0 + 0.5;\n    tptr[base + 2] = model.nanColor[2] * 255.0 + 0.5;\n    tptr[base + 3] = model.nanColor[3] * 255.0 + 0.5;\n  };\n  publicAPI.build = () => {\n    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {\n      publicAPI.forceBuild();\n    }\n  };\n  if (model.table.length > 0) {\n    // Ensure that special colors are properly included in the table\n    publicAPI.buildSpecialColors();\n\n    // ensure insertTime is more recently modified than buildTime if\n    // a table is provided via the constructor\n    model.insertTime.modified();\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  numberOfColors: 256,\n  // table: null,\n\n  hueRange: [0.0, 0.66667],\n  saturationRange: [1.0, 1.0],\n  valueRange: [1.0, 1.0],\n  alphaRange: [1.0, 1.0],\n  nanColor: [0.5, 0.0, 0.0, 1.0],\n  belowRangeColor: [0.0, 0.0, 0.0, 1.0],\n  aboveRangeColor: [1.0, 1.0, 1.0, 1.0],\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  alpha: 1.0\n  // buildTime: null,\n  // opaqueFlagBuildTime: null,\n  // insertTime: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  if (!model.table) {\n    model.table = [];\n  }\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n  model.opaqueFlagBuildTime = {};\n  macro.obj(model.opaqueFlagBuildTime, {\n    mtime: 0\n  });\n  model.insertTime = {};\n  macro.obj(model.insertTime, {\n    mtime: 0\n  });\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['numberOfColors', 'useAboveRangeColor', 'useBelowRangeColor']);\n\n  // Create set macros for array (needs to know size)\n  macro.setArray(publicAPI, model, ['alphaRange', 'hueRange', 'saturationRange', 'valueRange'], 2);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['hueRange', 'saturationRange', 'valueRange', 'alphaRange', 'nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkLookupTable(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkLookupTable');\n\n// ----------------------------------------------------------------------------\n\nvar vtkLookupTable$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkLookupTable$1 as default, extend, newInstance };\n", "const Resolve = {\n  Off: 0,\n  PolygonOffset: 1\n};\nlet resolveCoincidentTopologyPolygonOffsetFaces = Resolve.PolygonOffset;\nlet resolveCoincidentTopology = Resolve.Off;\nconst RESOLVE_COINCIDENT_TOPOLOGY_MODE = ['VTK_RESOLVE_OFF', 'VTK_RESOLVE_POLYGON_OFFSET'];\nfunction getResolveCoincidentTopologyPolygonOffsetFaces() {\n  return resolveCoincidentTopologyPolygonOffsetFaces;\n}\nfunction setResolveCoincidentTopologyPolygonOffsetFaces(value) {\n  const changed = resolveCoincidentTopologyPolygonOffsetFaces === value;\n  resolveCoincidentTopologyPolygonOffsetFaces = value;\n  return changed;\n}\nfunction getResolveCoincidentTopology() {\n  return resolveCoincidentTopology;\n}\nfunction setResolveCoincidentTopology() {\n  let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  const changed = resolveCoincidentTopology === mode;\n  resolveCoincidentTopology = mode;\n  return changed;\n}\nfunction setResolveCoincidentTopologyToDefault() {\n  return setResolveCoincidentTopology(Resolve.Off);\n}\nfunction setResolveCoincidentTopologyToOff() {\n  return setResolveCoincidentTopology(Resolve.Off);\n}\nfunction setResolveCoincidentTopologyToPolygonOffset() {\n  return setResolveCoincidentTopology(Resolve.PolygonOffset);\n}\nfunction getResolveCoincidentTopologyAsString() {\n  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];\n}\nvar otherStaticMethods = {\n  Resolve,\n  getResolveCoincidentTopologyAsString,\n  getResolveCoincidentTopologyPolygonOffsetFaces,\n  getResolveCoincidentTopology,\n  setResolveCoincidentTopology,\n  setResolveCoincidentTopologyPolygonOffsetFaces,\n  setResolveCoincidentTopologyToDefault,\n  setResolveCoincidentTopologyToOff,\n  setResolveCoincidentTopologyToPolygonOffset\n};\n\nexport { RESOLVE_COINCIDENT_TOPOLOGY_MODE, Resolve, otherStaticMethods as default, getResolveCoincidentTopology, getResolveCoincidentTopologyAsString, getResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopology, setResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopologyToDefault, setResolveCoincidentTopologyToOff, setResolveCoincidentTopologyToPolygonOffset };\n", "import otherStaticMethods, { Resolve } from './Static.js';\nexport { Resolve } from './Static.js';\nimport { m as macro } from '../../../macros2.js';\n\n/* eslint-disable arrow-body-style */\nfunction addCoincidentTopologyMethods(publicAPI, model, nameList) {\n  nameList.forEach(item => {\n    publicAPI[`get${item.method}`] = () => model[item.key];\n    publicAPI[`set${item.method}`] = macro.objectSetterMap.object(publicAPI, model, {\n      name: item.key,\n      params: ['factor', 'offset']\n    });\n  });\n}\nconst CATEGORIES = ['Polygon', 'Line', 'Point'];\n\n// CoincidentTopology static methods ------------------------------------------\n\nconst staticOffsetModel = {\n  Polygon: {\n    factor: 2,\n    offset: 0\n  },\n  Line: {\n    factor: 1,\n    offset: -1\n  },\n  Point: {\n    factor: 0,\n    offset: -2\n  }\n};\nconst noOp = () => undefined;\nconst staticOffsetAPI = {\n  modified: noOp\n};\naddCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map(key => ({\n  key,\n  method: `ResolveCoincidentTopology${key}OffsetParameters`\n})));\nfunction implementCoincidentTopologyMethods(publicAPI, model) {\n  if (model.resolveCoincidentTopology === undefined) {\n    model.resolveCoincidentTopology = false;\n  }\n  macro.setGet(publicAPI, model, ['resolveCoincidentTopology']);\n\n  // Relative methods\n  model.topologyOffset = {\n    Polygon: {\n      factor: 0,\n      offset: 0\n    },\n    Line: {\n      factor: 0,\n      offset: 0\n    },\n    Point: {\n      factor: 0,\n      offset: 0\n    }\n  };\n\n  // Add Static methods to our instance\n  Object.keys(otherStaticMethods).forEach(methodName => {\n    publicAPI[methodName] = otherStaticMethods[methodName];\n  });\n  Object.keys(staticOffsetAPI).filter(methodName => methodName !== 'modified') // don't override instance's modified\n  .forEach(methodName => {\n    publicAPI[methodName] = staticOffsetAPI[methodName];\n  });\n  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(key => ({\n    key,\n    method: `RelativeCoincidentTopology${key}OffsetParameters`\n  })));\n  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {\n    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();\n    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();\n    return {\n      factor: globalValue.factor + localValue.factor,\n      offset: globalValue.offset + localValue.offset\n    };\n  };\n  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {\n    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();\n    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();\n    return {\n      factor: globalValue.factor + localValue.factor,\n      offset: globalValue.offset + localValue.offset\n    };\n  };\n  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {\n    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();\n    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();\n    return {\n      factor: globalValue.factor + localValue.factor,\n      offset: globalValue.offset + localValue.offset\n    };\n  };\n}\nvar CoincidentTopologyHelper = {\n  implementCoincidentTopologyMethods,\n  staticOffsetAPI,\n  otherStaticMethods,\n  CATEGORIES,\n  Resolve\n};\n\nexport { CATEGORIES, CoincidentTopologyHelper as default };\n", "const PassTypes = {\n  MIN_KNOWN_PASS: 0,\n  ACTOR_PASS: 0,\n  COMPOSITE_INDEX_PASS: 1,\n  ID_LOW24: 2,\n  ID_HIGH24: 3,\n  MAX_KNOWN_PASS: 3\n};\nvar Constants = {\n  PassTypes\n};\n\nexport { PassTypes, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { I as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\n\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  ColorMode,\n  ScalarMode,\n  GetArray\n} = Constants;\nconst {\n  VectorMode\n} = vtkScalarsToColors;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\n\n// ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);\n}\n\n/**\n * Increase by one the 3D coordinates\n * It will follow a zigzag pattern so that each coordinate is the neighbor of the next coordinate\n * This enables interpolation between two texels without issues\n * Note: texture coordinates can't be interpolated using this pattern\n * @param {vec3} coordinates The 3D coordinates using integers for each coorinate\n * @param {vec3} dimensions The 3D dimensions of the volume\n */\nfunction updateZigzaggingCoordinates(coordinates, dimensions) {\n  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;\n  coordinates[0] += directionX;\n  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {\n    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;\n    coordinates[0] -= directionX;\n    coordinates[1] += directionY;\n    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {\n      coordinates[1] -= directionY;\n      coordinates[2]++;\n    }\n  }\n}\n\n/**\n * Returns the index in the array representing the volume from a 3D coordinate\n * @param {vec3} coordinates The 3D integer coordinates\n * @param {vec3} dimensions The 3D dimensions of the volume\n * @returns The index in a flat array representing the volume\n */\nfunction getIndexFromCoordinates(coordinates, dimensions) {\n  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);\n}\n\n/**\n * Write texture coordinates for the given `texelIndexPosition` in `textureCoordinate`.\n * The `texelIndexPosition` is a floating point number that represents the distance in index space\n * from the center of the first texel to the final output position.\n * The output is given in texture coordinates and not in index coordinates (this is done at the very end of the function)\n * @param {vec3} textureCoordinate The output texture coordinates (to avoid allocating a new Array)\n * @param {Number} texelIndexPosition The floating point distance from the center of the first texel, following a zigzag pattern\n * @param {vec3} dimensions The 3D dimensions of the volume\n */\nfunction getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {\n  // First compute the integer textureCoordinate\n  const intTexelIndex = Math.floor(texelIndexPosition);\n  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);\n  let xDirection;\n  let xEndFlag;\n  if (xCoordBeforeWrap < dimensions[0]) {\n    textureCoordinate[0] = xCoordBeforeWrap;\n    xDirection = 1;\n    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;\n  } else {\n    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;\n    xDirection = -1;\n    xEndFlag = textureCoordinate[0] === 0;\n  }\n  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);\n  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);\n  let yDirection;\n  let yEndFlag;\n  if (yCoordBeforeWrap < dimensions[1]) {\n    textureCoordinate[1] = yCoordBeforeWrap;\n    yDirection = 1;\n    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;\n  } else {\n    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;\n    yDirection = -1;\n    yEndFlag = textureCoordinate[1] === 0;\n  }\n  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);\n\n  // Now add the remainder either in x, y or z\n  const remainder = texelIndexPosition - intTexelIndex;\n  if (xEndFlag) {\n    if (yEndFlag) {\n      textureCoordinate[2] += remainder;\n    } else {\n      textureCoordinate[1] += yDirection * remainder;\n    }\n  } else {\n    textureCoordinate[0] += xDirection * remainder;\n  }\n\n  // textureCoordinates are in index space, convert to texture space\n  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];\n  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];\n  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];\n}\n\n// Associate an input vtkDataArray to an object { stringHash, textureCoordinates }\n// A single dataArray only caches one array of texture coordinates, so this cache is useless when\n// the input data array is used with two different lookup tables (which is very unlikely)\nconst colorTextureCoordinatesCache = new WeakMap();\n/**\n * The minimum of the range is mapped to the center of the first texel excluding min texel (texel at index distance 1)\n * The maximum of the range is mapped to the center of the last texel excluding max and NaN texels (texel at index distance numberOfColorsInRange)\n * The result is cached, and is reused if the arguments are the same and the input doesn't change\n * @param {vtkDataArray} input The input data array used for coloring\n * @param {Number} component The component of the input data array that is used for coloring (-1 for magnitude of the vectors)\n * @param {Range} range The range of the scalars\n * @param {boolean} useLogScale Should the values be transformed to logarithmic scale. When true, the range must already be in logarithmic scale.\n * @param {Number} numberOfColorsInRange The number of colors that are used in the range\n * @param {vec3} dimensions The dimensions of the texture\n * @param {boolean} useZigzagPattern If a zigzag pattern should be used. Otherwise 1 row for colors (including min and max) and 1 row for NaN are used.\n * @returns A vtkDataArray containing the texture coordinates (2D or 3D)\n */\nfunction getOrCreateColorTextureCoordinates(input, component, range, useLogScale, numberOfColorsInRange, dimensions, useZigzagPattern) {\n  // Caching using the \"arguments\" special object (because it is a pure function)\n  const argStrings = new Array(arguments.length);\n  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {\n    // eslint-disable-next-line prefer-rest-params\n    const arg = arguments[argIndex];\n    argStrings[argIndex] = arg.getMTime?.() ?? arg;\n  }\n  const stringHash = argStrings.join('/');\n  const cachedResult = colorTextureCoordinatesCache.get(input);\n  if (cachedResult && cachedResult.stringHash === stringHash) {\n    return cachedResult.textureCoordinates;\n  }\n\n  // The range used for computing coordinates have to change\n  // slightly to accommodate the special above- and below-range\n  // colors that are the first and last texels, respectively.\n  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);\n  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];\n\n  // Use the center of the voxel\n  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;\n  const textureSCoeff = 1.0 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);\n\n  // Compute in index space first\n  const texelIndexOrigin = paddedRangeMin;\n  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);\n  const inputV = input.getData();\n  const numScalars = input.getNumberOfTuples();\n  const numComps = input.getNumberOfComponents();\n  const useMagnitude = component < 0 || component >= numComps;\n  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;\n  const output = vtkDataArray.newInstance({\n    numberOfComponents: numberOfOutputComponents,\n    values: new Float32Array(numScalars * numberOfOutputComponents)\n  });\n  const outputV = output.getData();\n  const nanTextureCoordinate = [0, 0, 0];\n  // Distance of NaN from the beginning:\n  // min: 0, ...colorsInRange, max: numberOfColorsInRange + 1, NaN = numberOfColorsInRange + 2\n  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);\n\n  // Set a texture coordinate in the output for each tuple in the input\n  let inputIdx = 0;\n  let outputIdx = 0;\n  const textureCoordinate = [0.5, 0.5, 0.5];\n  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n    // Get scalar value from magnitude or a single component\n    let scalarValue;\n    if (useMagnitude) {\n      let sum = 0;\n      for (let compIdx = 0; compIdx < numComps; ++compIdx) {\n        const compValue = Number(inputV[inputIdx + compIdx]);\n        sum += compValue * compValue;\n      }\n      scalarValue = Math.sqrt(sum);\n    } else {\n      scalarValue = Number(inputV[inputIdx + component]);\n    }\n    if (useLogScale) {\n      scalarValue = Math.log10(scalarValue);\n    }\n    inputIdx += numComps;\n\n    // Convert to texture coordinates and update output\n    if (isNan(scalarValue)) {\n      // Last texels are NaN colors (there is at least one NaN color)\n      textureCoordinate[0] = nanTextureCoordinate[0];\n      textureCoordinate[1] = nanTextureCoordinate[1];\n      textureCoordinate[2] = nanTextureCoordinate[2];\n    } else if (useZigzagPattern) {\n      // Texel position is in [0, numberOfColorsInRange + 1]\n      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;\n      if (texelIndexPosition < 1) {\n        // Use min color when smaller than range\n        texelIndexPosition = 0;\n      } else if (texelIndexPosition > numberOfColorsInRange) {\n        // Use max color when greater than range\n        texelIndexPosition = numberOfColorsInRange + 1;\n      }\n\n      // Convert the texel position into texture coordinate following a zigzag pattern\n      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);\n    } else {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      textureCoordinate[1] = 0.49;\n\n      // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;\n      if (textureS > 1000.0) {\n        textureCoordinate[0] = 1000.0;\n      } else if (textureS < -1000.0) {\n        textureCoordinate[0] = -1000.0;\n      } else {\n        textureCoordinate[0] = textureS;\n      }\n    }\n    for (let i = 0; i < numberOfOutputComponents; ++i) {\n      outputV[outputIdx++] = textureCoordinate[i];\n    }\n  }\n  colorTextureCoordinatesCache.set(input, {\n    stringHash,\n    textureCoordinates: output\n  });\n  return output;\n}\n\n// ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n  publicAPI.getBounds = () => {\n    const input = publicAPI.getInputData();\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n      model.bounds = input.getBounds();\n    }\n    return model.bounds;\n  };\n  publicAPI.setForceCompileOnly = v => {\n    model.forceCompileOnly = v;\n    // make sure we do NOT call modified()\n  };\n\n  publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {\n    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;\n    // make sure we do NOT call modified()\n    // this attribute is only used when processing a selection made with the hardware selector\n    // the mtime of the mapper doesn't need to be changed\n  };\n\n  publicAPI.createDefaultLookupTable = () => {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);\n  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);\n  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);\n  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);\n  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode, model.scalarMode);\n  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);\n  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);\n  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);\n  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);\n  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);\n  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);\n  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFlag: false\n      };\n    }\n    let scalars = null;\n    let cellFlag = false;\n\n    // get and scalar data according to scalar mode\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      const pd = input.getPointData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      const cd = input.getCellData();\n      cellFlag = true;\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      const fd = input.getFieldData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n    return {\n      scalars,\n      cellFlag\n    };\n  };\n  publicAPI.mapScalars = (input, alpha) => {\n    const {\n      scalars,\n      cellFlag\n    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    model.areScalarsMappedFromCells = cellFlag;\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    }\n\n    // we want to only recompute when something has changed\n    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n    if (model.colorBuildString === toString) return;\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    }\n\n    // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {\n      model.mapScalarsToTexture(scalars, cellFlag, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      const lut = publicAPI.getLookupTable();\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n  };\n\n  // Protected method\n  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {\n    const range = model.lookupTable.getRange();\n    const useLogScale = model.lookupTable.usingLogScale();\n    const origAlpha = model.lookupTable.getAlpha();\n    const scaledRange = useLogScale ? [Math.log10(range[0]), Math.log10(range[1])] : range;\n\n    // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n    model.colorMapColors = null;\n\n    // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null;\n\n      // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n      model.lookupTable.build();\n      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();\n\n      // Maximum dimensions and number of colors in range\n      const maxTextureWidthForCells = 2048;\n      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3; // 3D but keep a color for min, max and NaN\n      const maxTextureWidthForPoints = 4096;\n      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2; // 1D but keep a color for min and max (NaN is in a different row)\n      // Minimum number of colors in range (excluding special colors like minColor, maxColor and NaNColor)\n      const minColorsInRange = 2;\n      // Maximum number of colors, limited by the maximum possible texture size\n      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;\n      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);\n      const numberOfColorsForCells = model.numberOfColorsInRange + 3; // Add min, max and NaN\n      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2; // Add min and max ; the lower row will be used for NaN color\n      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];\n      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];\n      const scalarsArray = new Float64Array(textureSize);\n\n      // Colors for NaN by default\n      scalarsArray.fill(NaN);\n\n      // Colors in range\n      // Add 2 to also get color for min and max\n      const numberOfNonSpecialColors = model.numberOfColorsInRange;\n      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;\n      const textureCoordinates = [0, 0, 0];\n      const rangeMin = scaledRange[0];\n      const rangeDifference = scaledRange[1] - scaledRange[0];\n      for (let i = 0; i < numberOfNonNaNColors; ++i) {\n        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);\n\n        // Minus 1 start at min color\n        const intermediateValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);\n        const scalarValue = useLogScale ? 10.0 ** intermediateValue : intermediateValue;\n        scalarsArray[scalarsArrayIndex] = scalarValue;\n\n        // Colors are zigzagging to allow interpolation between two neighbor colors when coloring cells\n        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);\n      }\n      const scalarsDataArray = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: scalarsArray\n      });\n      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setDimensions(textureDimensions);\n      model.colorTextureMap.getPointData().setScalars(colorsDataArray);\n      model.lookupTable.setAlpha(origAlpha);\n    }\n\n    // Although I like the feature of applying magnitude to single component\n    // scalars, it is not how the old MapScalars for vertex coloring works.\n    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();\n\n    // Create new coordinates if necessary, this function uses cache if possible.\n    // A zigzag pattern can't be used with point data, as interpolation of texture coordinates will be wrong\n    // A zigzag pattern can be used with cell data, as there will be no texture coordinates interpolation\n    // The texture generated using a zigzag pattern in one dimension is the same as without zigzag\n    // Therefore, the same code can be used for texture generation of point/cell data but not for texture coordinates\n    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, scaledRange, useLogScale, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), cellFlag);\n  };\n  publicAPI.getIsOpaque = () => {\n    const input = publicAPI.getInputData();\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n    if (!model.scalarVisibility || scalars == null) {\n      // No scalar colors.\n      return true;\n    }\n    const lut = publicAPI.getLookupTable();\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.areScalarsOpaque(scalars, model.colorMode, -1);\n    }\n    return true;\n  };\n  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {\n    if (cellFlag && !(model.colorMode === ColorMode.DIRECT_SCALARS)) {\n      return true; // cell data always use textures.\n    }\n\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    }\n\n    // index color does not use textures\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n    return true;\n  };\n  publicAPI.clearColorArrays = () => {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n  publicAPI.getLookupTable = () => {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n    return model.lookupTable;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.lookupTable !== null) {\n      const time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getPrimitiveCount = () => {\n    const input = publicAPI.getInputData();\n    const pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    const currentPass = selector.getCurrentPass();\n    const fieldAssociation = selector.getFieldAssociation();\n    let idMap = null;\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n    if (!idMap) {\n      return;\n    }\n    pixelOffsets.forEach(pos => {\n      if (currentPass === PassTypes.ID_LOW24) {\n        let inValue = 0;\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        let inValue = 0;\n        inValue += rawHighData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n  areScalarsMappedFromCells: false,\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  numberOfColorsInRange: 0,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  customShaderAttributes: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['areScalarsMappedFromCells', 'colorCoordinates', 'colorMapColors', 'colorTextureMap', 'numberOfColorsInRange', 'selectionWebGLIdsToVTKIds']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\n\nexport { vtkMapper$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["extend", "StructuredType", "DEFAULT_VALUES", "extend", "Constants", "ScalarMappingTarget", "Scale", "VectorMode", "VtkDataTypes", "ColorMode", "Constants", "vtkErrorMacro", "vtkScalarsToColors", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "Constants", "staticOffsetAPI", "otherStaticMethods", "ColorMode", "ScalarMode", "GetArray", "Constants", "VectorMode", "VtkDataTypes", "DEFAULT_VALUES", "extend", "newInstance"]
}
