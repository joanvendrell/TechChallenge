import {
  linear,
  vtkScalarBarActor$1
} from "./chunk-GVGJFJN3.js";
import {
  registerOverride,
  registerOverride2,
  vtkHelper,
  vtkOpenGLTexture$1,
  vtkShaderProgram$1,
  vtkViewNode$1,
  vtkWebGPUBindGroup$1,
  vtkWebGPUBufferManager$1,
  vtkWebGPUFullScreenQuad$1,
  vtkWebGPUShaderCache$1,
  vtkWebGPUSimpleMapper$1,
  vtkWebGPUStorageBuffer$1,
  vtkWebGPUTypes,
  vtkWebGPUUniformBuffer$1
} from "./chunk-IC7NYLFI.js";
import {
  vtkTexture$1
} from "./chunk-ZYJT6S5S.js";
import {
  PassTypes,
  Resolve,
  vtkMapper$1
} from "./chunk-2MLCEZ25.js";
import {
  Representation,
  vtkActor$1,
  vtkProp$1,
  vtkProperty$1
} from "./chunk-KHTNCV3C.js";
import {
  vtkPoints$1,
  vtkPolyData$1
} from "./chunk-3WRJRU3H.js";
import {
  vtkDataArray$1,
  vtkDataSet$1
} from "./chunk-QTSXRC5W.js";
import {
  get,
  getArray,
  macro,
  macro$1,
  mat3_exports,
  mat4_exports,
  moveToProtected,
  nearestPowerOfTwo,
  newInstance,
  normalize,
  normalize2D,
  obj,
  radiansFromDegrees,
  round,
  setGet,
  vec3_exports,
  vtkBoundingBox,
  vtkErrorMacro
} from "./chunk-UJ7GCCMN.js";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
function vtkOpenGLActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0; index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.traverseZBufferPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = (renderPass) => publicAPI.traverseOpaquePass(renderPass);
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0; index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(model._openGLRenderer.getSelector() && model.renderable.getNestedPickable());
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      if (model.renderable.getIsIdentity()) {
        mat3_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
        mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat3_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null,
  activeTextures: null
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: mat3_exports.identity(new Float64Array(9)),
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor(publicAPI, model);
}
var newInstance2 = newInstance(extend);
var vtkActor = {
  newInstance: newInstance2,
  extend
};
registerOverride("vtkActor", newInstance2);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
function vtkOpenGLActor2D(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0; index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOverlayActorCount();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOverlayPass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0; index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.overlayPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
}
var DEFAULT_VALUES2 = {
  context: null,
  activeTextures: null
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor2D(publicAPI, model);
}
var newInstance3 = newInstance(extend2);
var vtkActor2D = {
  newInstance: newInstance3,
  extend: extend2
};
registerOverride("vtkActor2D", newInstance3);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
function vtkOpenGLCamera(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCamera");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.zBufferPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = (ren) => {
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      mat4_exports.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      mat4_exports.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      mat4_exports.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES3 = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };
  setGet(publicAPI, model, ["context", "keyMatrixTime"]);
  vtkOpenGLCamera(publicAPI, model);
}
var newInstance4 = newInstance(extend3);
var vtkCamera = {
  newInstance: newInstance4,
  extend: extend3
};
registerOverride("vtkCamera", newInstance4);

// node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js
var faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
var faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];
var edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];
var edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];
var faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];
var ptv3 = new Float64Array(3);
var pt2v3 = new Float64Array(3);
var tmpv3 = new Float64Array(3);
var tmp2v3 = new Float64Array(3);
var xDir = new Float64Array(3);
var yDir = new Float64Array(3);
var invmat = new Float64Array(16);
function applyTextStyle(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}
function defaultGenerateTicks(dataBounds) {
  const ticks = [];
  const tickStrings = [];
  for (let i = 0; i < 3; i++) {
    const scale = linear().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);
    ticks[i] = scale.ticks(5);
    const format = scale.tickFormat(5);
    tickStrings[i] = ticks[i].map(format);
  }
  return {
    ticks,
    tickStrings
  };
}
function vtkCubeAxesActorHelper(publicAPI, model) {
  model.classHierarchy.push("vtkCubeAxesActorHelper");
  publicAPI.setRenderable = (renderable) => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.tmActor.addTexture(model.renderable.getTmTexture());
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    publicAPI.modified();
  };
  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {
    const value = model.renderable.get_tmAtlas().get(text);
    if (!value) {
      return;
    }
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const size = model.lastSize;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    vec3_exports.transformMat4(tmpv3, ptv3, cmat);
    tmpv3[0] += 0.1;
    vec3_exports.transformMat4(pt2v3, tmpv3, imat);
    vec3_exports.subtract(xDir, pt2v3, ptv3);
    tmpv3[0] -= 0.1;
    tmpv3[1] += 0.1;
    vec3_exports.transformMat4(pt2v3, tmpv3, imat);
    vec3_exports.subtract(yDir, pt2v3, ptv3);
    for (let i = 0; i < 3; i++) {
      xDir[i] /= 0.5 * 0.1 * size[0];
      yDir[i] /= 0.5 * 0.1 * size[1];
    }
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    if (dir[0] < -0.5) {
      vec3_exports.scale(tmpv3, xDir, dir[0] * offset - value.width);
    } else if (dir[0] > 0.5) {
      vec3_exports.scale(tmpv3, xDir, dir[0] * offset);
    } else {
      vec3_exports.scale(tmpv3, xDir, dir[0] * offset - value.width / 2);
    }
    vec3_exports.add(ptv3, ptv3, tmpv3);
    vec3_exports.scale(tmpv3, yDir, dir[1] * offset - value.height / 2);
    vec3_exports.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    vec3_exports.scale(tmpv3, xDir, value.width);
    vec3_exports.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    vec3_exports.scale(tmpv3, yDir, value.height);
    vec3_exports.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    vec3_exports.scale(tmpv3, xDir, value.width);
    vec3_exports.subtract(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };
  publicAPI.updateTexturePolyData = () => {
    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);
    mat4_exports.transpose(cmat, cmat);
    const numLabels = model.renderable.getTextValues().length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    mat4_exports.invert(invmat, cmat);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };
    let ptIdx = 0;
    let textIdx = 0;
    let axisIdx = 0;
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const textValues = model.renderable.getTextValues();
    while (ptIdx < coords.length / 3) {
      ptv3[0] = coords[ptIdx * 3];
      ptv3[1] = coords[ptIdx * 3 + 1];
      ptv3[2] = coords[ptIdx * 3 + 2];
      vec3_exports.transformMat4(tmpv3, ptv3, cmat);
      ptv3[0] = coords[ptIdx * 3 + 3];
      ptv3[1] = coords[ptIdx * 3 + 4];
      ptv3[2] = coords[ptIdx * 3 + 5];
      vec3_exports.transformMat4(tmp2v3, ptv3, cmat);
      vec3_exports.subtract(tmpv3, tmpv3, tmp2v3);
      const dir = [tmpv3[0], tmpv3[1]];
      normalize2D(dir);
      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);
      ptIdx += 2;
      textIdx++;
      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {
        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);
        ptIdx++;
        textIdx++;
      }
      axisIdx++;
    }
    const tcoordDA = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: "TextureCoordinates"
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    model.camera = camera;
    publicAPI.updateTexturePolyData();
  };
}
var newCubeAxesActorHelper = macro.newInstance(function(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);
  macro.obj(publicAPI, model);
  model.tmPolyData = vtkPolyData$1.newInstance();
  model.tmMapper = vtkMapper$1.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  macro.setGet(publicAPI, model, ["renderable"]);
  macro.get(publicAPI, model, ["lastSize", "lastAspectRatio", "axisTextStyle", "tickTextStyle", "tmActor", "ticks"]);
  model.forceUpdate = false;
  model.lastRedrawTime = {};
  macro.obj(model.lastRedrawTime, {
    mtime: 0
  });
  model.lastRebuildTime = {};
  macro.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];
  model.lastTickBounds = [];
  vtkCubeAxesActorHelper(publicAPI, model);
}, "vtkCubeAxesActorHelper");
function vtkCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkCubeAxesActor");
  publicAPI.setCamera = (cam) => {
    if (model.camera === cam) {
      return;
    }
    if (model.cameraModifiedSub) {
      model.cameraModifiedSub.unsubscribe();
      model.cameraModifiedSub = null;
    }
    model.camera = cam;
    if (cam) {
      model.cameraModifiedSub = cam.onModified(publicAPI.update);
    }
    publicAPI.update();
    publicAPI.modified();
  };
  publicAPI.computeFacesToDraw = () => {
    const cmat = model.camera.getViewMatrix();
    mat4_exports.transpose(cmat, cmat);
    let changed = false;
    const length = vtkBoundingBox.getDiagonalLength(model.dataBounds);
    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180);
    for (let f = 0; f < 6; f++) {
      let drawit = false;
      const faceAxis = Math.floor(f / 2);
      const otherAxis1 = (faceAxis + 1) % 3;
      const otherAxis2 = (faceAxis + 2) % 3;
      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {
        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];
        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);
        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);
        vec3_exports.transformMat4(tmpv3, ptv3, cmat);
        ptv3[faceAxis] = model.dataBounds[f];
        vec3_exports.transformMat4(tmp2v3, ptv3, cmat);
        vec3_exports.subtract(tmpv3, tmp2v3, tmpv3);
        vec3_exports.normalize(tmpv3, tmpv3);
        drawit = tmpv3[2] > faceDot;
        if (!model.camera.getParallelProjection()) {
          vec3_exports.normalize(tmp2v3, tmp2v3);
          drawit = vec3_exports.dot(tmp2v3, tmpv3) > faceDot;
        }
      }
      if (drawit !== model.lastFacesToDraw[f]) {
        model.lastFacesToDraw[f] = drawit;
        changed = true;
      }
    }
    return changed;
  };
  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {
    let numPts = 0;
    let numLines = 0;
    numPts += 8;
    let numEdgesToDraw = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        numEdgesToDraw++;
      }
    }
    numLines += numEdgesToDraw;
    if (model.gridLines) {
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;
          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;
        }
      }
    }
    const points = new Float64Array(numPts * 3);
    const lines = new Uint32Array(numLines * 3);
    let ptIdx = 0;
    let lineIdx = 0;
    for (let z = 0; z < 2; z++) {
      for (let y = 0; y < 2; y++) {
        for (let x = 0; x < 2; x++) {
          points[ptIdx * 3] = model.dataBounds[x];
          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];
          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];
          ptIdx++;
        }
      }
    }
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        lines[lineIdx * 3] = 2;
        lines[lineIdx * 3 + 1] = edgePoints[e][0];
        lines[lineIdx * 3 + 2] = edgePoints[e][1];
        lineIdx++;
      }
    }
    if (model.gridLines) {
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          const faceIdx = Math.floor(f / 2);
          let aticks = ticks[faceAxes[f][0]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
          aticks = ticks[faceAxes[f][1]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
        }
      }
    }
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getLines().setData(lines, 1);
    model.polyData.getLines().modified();
    model.polyData.modified();
  };
  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {
    let textPointCount = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] === 1) {
        textPointCount += 2;
        textPointCount += ticks[edgeAxes[e]].length;
      }
    }
    const points = model.polyData.getPoints().getData();
    const textPoints = new Float64Array(textPointCount * 3);
    let ptIdx = 0;
    let textIdx = 0;
    let axisCount = 0;
    for (let f = 0; f < 6; f++) {
      if (facesToDraw[f]) {
        for (let e = 0; e < 4; e++) {
          const edgeIdx = faceEdges[f][e];
          if (edgesToDraw[edgeIdx] === 1) {
            const edgeAxis = edgeAxes[edgeIdx];
            const ptIdx1 = edgePoints[edgeIdx][0] * 3;
            const ptIdx2 = edgePoints[edgeIdx][1] * 3;
            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);
            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);
            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);
            ptIdx++;
            const faceIdx = Math.floor(f / 2);
            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);
            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);
            ptIdx++;
            model.textValues[textIdx] = model.axisLabels[edgeAxis];
            textIdx++;
            const otherAxis1 = (edgeAxis + 1) % 3;
            const otherAxis2 = (edgeAxis + 2) % 3;
            const aticks = ticks[edgeAxis];
            const atickStrings = tickStrings[edgeAxis];
            model.tickCounts[axisCount] = aticks.length;
            for (let t = 0; t < aticks.length; t++) {
              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];
              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];
              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];
              ptIdx++;
              model.textValues[textIdx] = atickStrings[t];
              textIdx++;
            }
            axisCount++;
          }
        }
      }
    }
    model.textPolyData.getPoints().setData(textPoints, 3);
    model.textPolyData.modified();
  };
  publicAPI.update = () => {
    if (!model.camera) {
      return;
    }
    const facesChanged = publicAPI.computeFacesToDraw();
    const facesToDraw = model.lastFacesToDraw;
    let boundsChanged = false;
    for (let i = 0; i < 6; i++) {
      if (model.dataBounds[i] !== model.lastTickBounds[i]) {
        boundsChanged = true;
        model.lastTickBounds[i] = model.dataBounds[i];
      }
    }
    if (facesChanged || boundsChanged || model.forceUpdate) {
      const edgesToDraw = new Array(12).fill(0);
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          for (let e = 0; e < 4; e++) {
            edgesToDraw[faceEdges[f][e]]++;
          }
        }
      }
      const t = model.generateTicks(model.dataBounds);
      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);
      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);
      if (boundsChanged || model.forceUpdate) {
        publicAPI.updateTextureAtlas(t.tickStrings);
      }
    }
    model.forceUpdate = false;
  };
  publicAPI.updateTextureAtlas = (tickStrings) => {
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model._tmAtlas.clear();
    let maxWidth = 0;
    let totalHeight = 1;
    for (let i = 0; i < 3; i++) {
      if (!model._tmAtlas.has(model.axisLabels[i])) {
        applyTextStyle(model.tmContext, model.axisTextStyle);
        const metrics = model.tmContext.measureText(model.axisLabels[i]);
        const entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.axisTextStyle
        };
        model._tmAtlas.set(model.axisLabels[i], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
      }
      applyTextStyle(model.tmContext, model.tickTextStyle);
      for (let t = 0; t < tickStrings[i].length; t++) {
        if (!model._tmAtlas.has(tickStrings[i][t])) {
          const metrics = model.tmContext.measureText(tickStrings[i][t]);
          const entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.tickTextStyle
          };
          model._tmAtlas.set(tickStrings[i][t], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
        }
      }
    }
    maxWidth = nearestPowerOfTwo(maxWidth);
    totalHeight = nearestPowerOfTwo(totalHeight);
    model._tmAtlas.forEach((value) => {
      value.tcoords = [0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0, (totalHeight - value.startingHeight) / totalHeight];
    });
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);
    model._tmAtlas.forEach((value, key) => {
      applyTextStyle(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    model.tmTexture.modified();
  };
  publicAPI.onModified(() => {
    model.forceUpdate = true;
    publicAPI.update();
  });
  publicAPI.setTickTextStyle = (tickStyle) => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = (axisStyle) => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.get_tmAtlas = () => model._tmAtlas;
  publicAPI.getBounds = () => {
    publicAPI.update();
    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());
    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);
    return model.bounds;
  };
  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);
  publicAPI.setProperty = (p) => _setProp(p)[0];
}
function defaultValues(publicAPI, model, initialValues) {
  return {
    boundsScaleFactor: 1.3,
    camera: null,
    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],
    faceVisibilityAngle: 8,
    gridLines: true,
    axisLabels: null,
    axisTitlePixelOffset: 35,
    tickLabelPixelOffset: 12,
    generateTicks: defaultGenerateTicks,
    ...initialValues,
    axisTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 18,
      fontFamily: "serif",
      ...initialValues == null ? void 0 : initialValues.axisTextStyle
    },
    tickTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 14,
      fontFamily: "serif",
      ...initialValues == null ? void 0 : initialValues.tickTextStyle
    }
  };
}
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkActor$1.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));
  model.lastFacesToDraw = [false, false, false, false, false, false];
  model.axisLabels = ["X-Axis", "Y-Axis", "Z-Axis"];
  model.tickCounts = [];
  model.textValues = [];
  model.lastTickBounds = [];
  model.tmCanvas = document.createElement("canvas");
  model.tmContext = model.tmCanvas.getContext("2d");
  model._tmAtlas = /* @__PURE__ */ new Map();
  model.tmTexture = vtkTexture$1.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  publicAPI.getProperty().setDiffuse(0);
  publicAPI.getProperty().setAmbient(1);
  model.gridMapper = vtkMapper$1.newInstance();
  model.polyData = vtkPolyData$1.newInstance();
  model.gridMapper.setInputData(model.polyData);
  model.gridActor = vtkActor$1.newInstance();
  model.gridActor.setMapper(model.gridMapper);
  model.gridActor.setProperty(publicAPI.getProperty());
  model.gridActor.setParentProp(publicAPI);
  model.textPolyData = vtkPolyData$1.newInstance();
  macro.setGet(publicAPI, model, ["axisTitlePixelOffset", "boundsScaleFactor", "faceVisibilityAngle", "gridLines", "tickLabelPixelOffset", "generateTicks"]);
  macro.setGetArray(publicAPI, model, ["dataBounds"], 6);
  macro.setGetArray(publicAPI, model, ["axisLabels"], 3);
  macro.get(publicAPI, model, ["axisTextStyle", "tickTextStyle", "camera", "tmTexture", "textValues", "textPolyData", "tickCounts", "gridActor"]);
  vtkCubeAxesActor(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend4, "vtkCubeAxesActor");
var vtkCubeAxesActor$1 = {
  newInstance: newInstance5,
  extend: extend4,
  newCubeAxesActorHelper,
  defaultGenerateTicks
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/CubeAxesActor.js
function vtkOpenGLCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCubeAxesActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES4 = {};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
  vtkOpenGLCubeAxesActor(publicAPI, model);
}
var newInstance6 = newInstance(extend5, "vtkOpenGLCubeAxesActor");
registerOverride("vtkCubeAxesActor", newInstance6);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
    const cp = publicAPI.getCoincidentParameters(ren, actor);
    if (cp && (cp.factor !== 0 || cp.offset !== 0)) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Coincident::Dec", ["uniform float cfactor;", "uniform float coffset;"]).result;
      if (model.context.getExtension("EXT_frag_depth")) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
function implementBuildShadersWithReplacements(publicAPI, model) {
  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
    let shaderReplacements = null;
    if (viewSpec) {
      shaderReplacements = viewSpec.ShaderReplacements;
    }
    if (shaderReplacements) {
      for (let i = 0; i < shaderReplacements.length; i++) {
        const currReplacement = shaderReplacements[i];
        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = vtkShaderProgram$1.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
    publicAPI.replaceShaderValues(shaders, ren, actor);
    publicAPI.applyShaderReplacements(shaders, openGLSpec);
  };
  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.getShaderTemplate(shaders, ren, actor);
    let vertexShaderCode = shaders.Vertex;
    if (openGLSpecProp) {
      const vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== void 0 && vertexSpecProp !== "") {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;
    let fragmentShaderCode = shaders.Fragment;
    if (openGLSpecProp) {
      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== void 0 && fragmentSpecProp !== "") {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;
    let geometryShaderCode = shaders.Geometry;
    if (openGLSpecProp) {
      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== void 0) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };
}
var vtkReplacementShaderMapper = {
  implementReplaceShaderCoincidentOffset,
  implementBuildShadersWithReplacements
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var {
  FieldAssociations
} = vtkDataSet$1;
var {
  primTypes
} = vtkHelper;
var {
  Representation: Representation2,
  Shading
} = vtkProperty$1;
var {
  ScalarMode
} = vtkMapper$1;
var {
  Filter,
  Wrap
} = vtkOpenGLTexture$1;
var {
  vtkErrorMacro: vtkErrorMacro2
} = macro$1;
var StartEvent = {
  type: "StartEvent"
};
var EndEvent = {
  type: "EndEvent"
};
var {
  CoordinateSystem
} = vtkProp$1;
function getPickState(renderer) {
  const selector = renderer.getSelector();
  if (selector) {
    return selector.getCurrentPass();
  }
  return PassTypes.MIN_KNOWN_PASS - 1;
}
function vtkOpenGLPolyDataMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPolyDataMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLActor = publicAPI.getFirstAncestorOfType("vtkOpenGLActor");
      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera(), model.openGLCamera);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    let colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity", "uniform vec3 ambientColorUniform;", "uniform vec3 diffuseColorUniform;"];
    if (lastLightComplexity) {
      colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
    }
    let colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
    }
    colorImpl = colorImpl.concat(["  ambientColor = ambientColorUniform;", "  diffuseColor = diffuseColorUniform;", "  opacity = opacityUniform;"]);
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
    } else {
      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  ambientColor = texColor.rgb;", "  opacity = opacity*texColor.a;"])).result;
      } else {
        if (actor.getBackfaceProperty() && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform float opacityUniformBF; // the fragment opacity", "uniform float ambientIntensityBF; // the material ambient", "uniform float diffuseIntensityBF; // the material diffuse", "uniform vec3 ambientColorUniformBF; // ambient material color", "uniform vec3 diffuseColorUniformBF; // diffuse material color"]);
          if (lastLightComplexity) {
            colorDec = colorDec.concat(["uniform float specularIntensityBF; // the material specular intensity", "uniform vec3 specularColorUniformBF; // intensity weighted color", "uniform float specularPowerUniformBF;"]);
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  specularColor = specularIntensityBF * specularColorUniformBF;", "  specularPower = specularPowerUniformBF;", "  opacity = opacityUniformBF; }"]);
          } else {
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  opacity = opacityUniformBF; }"]);
          }
        }
        if (model.haveCellScalars && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform samplerBuffer texture1;"]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    const shadowFactor = "";
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    let sstring = [];
    switch (lastLightComplexity) {
      case 0:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 1:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  float df = max(0.0, normalVCVSOutput.z);", "  float sf = pow(df, specularPower);", "  vec3 diffuseL = df * diffuseColor;", "  vec3 specularL = sf * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 2:
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  float df;"];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, "    {", `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      case 3:
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  vec3 vertLightDirectionVC;", "  float attenuation;", "  float df;"];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat(["  attenuation = 1.0;", `  if (lightPositional${lc} == 0)`, "    {", `      vertLightDirectionVC = lightDirectionVC${lc};`, "    }", "  else", "    {", `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, "    float distanceVC = length(vertLightDirectionVC);", "    vertLightDirectionVC = normalize(vertLightDirectionVC);", "    attenuation = 1.0 /", `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, "    // per OpenGL standard cone angle is 90 or less for a spot light", `    if (lightConeAngle${lc} <= 90.0)`, "      {", `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, "      // if inside the cone", `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, "        {", `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, "        }", "      else", "        {", "        attenuation = 0.0;", "        }", "      }", "    }", "    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));", `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, "    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)", "      {", `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${lc},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      default:
        vtkErrorMacro2("bad light complexity");
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.lastBoundBO.getCABO().getNormalOffset()) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * normalMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Dec", ["in vec3 normalVCVSOutput[];", "out vec3 normalVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Impl", ["normalVCGSOutput = normalVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["varying vec3 normalVCVSOutput;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
          "vec3 normalVCVSOutput = normalize(normalVCVSOutput);",
          //  if (!gl_FrontFacing) does not work in intel hd4000 mac
          //  if (int(gl_FrontFacing) == 0) does not work on mesa
          "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
        ]).result;
      } else {
        if (model.haveCellNormals) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform mat3 normalMatrix;", "uniform samplerBuffer textureN;"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput = normalize(normalMatrix *", "    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);", "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result;
        } else {
          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {
            FSSource = vtkShaderProgram$1.substitute(
              FSSource,
              "//VTK::UniformFlow::Impl",
              ["  vec3 fdx = dFdx(vertexVC.xyz);", "  vec3 fdy = dFdy(vertexVC.xyz);", "  //VTK::UniformFlow::Impl"]
              // For further replacements
            ).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput;", "  if (abs(fdx.x) > 0.0)", "    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }", "  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform int cameraParallel;"]).result;
            FSSource = vtkShaderProgram$1.substitute(
              FSSource,
              "//VTK::UniformFlow::Impl",
              [
                // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
                // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
                "  vec3 fdx = dFdx(vertexVC.xyz);",
                "  vec3 fdy = dFdy(vertexVC.xyz);",
                "  //VTK::UniformFlow::Impl"
              ]
              // For further replacements
            ).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
              "  fdx = normalize(fdx);",
              "  fdy = normalize(fdy);",
              "  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));",
              // the code below is faster, but does not work on some devices
              // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',
              "  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }",
              "  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"
            ]).result;
          }
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vertexVCVSOutput = MCVCMatrix * vertexMC;", "  gl_Position = MCPCMatrix * vertexMC;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Dec", ["in vec4 vertexVCVSOutput[];", "out vec4 vertexVCGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Impl", ["vertexVCGSOutput = vertexVCVSOutput[i];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", ["vec4 vertexVC = vertexVCVSOutput;"]).result;
    } else {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.drawingEdges) {
        return;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
      const tus = model.openGLActor.getActiveTextures();
      let tNumComp = 2;
      let tcdim = 2;
      if (tus && tus.length > 0) {
        tNumComp = tus[0].getComponents();
        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
          tcdim = 3;
        }
      }
      if (model.renderable.getColorTextureMap()) {
        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
        tcdim = 2;
      }
      if (tcdim === 2) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];", "out vec2 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        if (tus && tus.length >= 1) {
          switch (tNumComp) {
            case 1:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
              break;
            case 2:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
              break;
            default:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
          }
        }
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec3 tcoordVCVSOutput[];", "out vec3 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec3 tcoordVCVSOutput;", "uniform samplerCube texture1;"]).result;
        switch (tNumComp) {
          case 1:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
            break;
          case 2:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
            break;
          default:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    let cp = {
      factor: 0,
      offset: 0
    };
    const prop = actor.getProperty();
    if (
      // backwards compat with code that (errorneously) set this to boolean
      // eslint-disable-next-line eqeqeq
      model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation2.SURFACE
    ) {
      const primType = model.lastBoundBO.getPrimitiveType();
      if (primType === primTypes.Points || prop.getRepresentation() === Representation2.POINTS) {
        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation2.WIREFRAME) {
        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
      }
      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        cp.factor /= 2;
        cp.offset /= 2;
      }
    }
    const selector = model._openGLRenderer.getSelector();
    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      cp.offset -= 2;
    }
    return cp;
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    let VSSource = shaders.Vertex;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform int picking;", "//VTK::Picking::Dec"]).result;
    if (!model._openGLRenderer.getSelector()) {
      return;
    }
    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Dec", ["flat out int vertexIDVSOutput;\n", "uniform int VertexIDOffset;\n"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Impl", "  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", "flat in int vertexIDVSOutput;\n").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", ["  int idx = vertexIDVSOutput;", "//VTK::Picking::Impl"]).result;
    }
    switch (model.lastSelectionState) {
      case PassTypes.ID_LOW24:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;
        break;
      case PassTypes.ID_HIGH24:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;
        break;
      default:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", "uniform vec3 mapperIndex;").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
    }
    shaders.Fragment = FSSource;
    shaders.Vertex = VSSource;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderNormal(shaders, ren, actor);
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    let lightComplexity = 0;
    let numberOfLights = 0;
    const primType = cellBO.getPrimitiveType();
    const poly = model.currentInput;
    let needLighting = false;
    const pointNormals = poly.getPointData().getNormals();
    const cellNormals = poly.getCellData().getNormals();
    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;
    const representation = actor.getProperty().getRepresentation();
    const mode = cellBO.getOpenGLMode(representation, primType);
    if (mode === model.context.TRIANGLES) {
      needLighting = true;
    } else if (cellNormals && !pointNormals) {
      needLighting = true;
    } else if (!flat && pointNormals) {
      needLighting = true;
    } else if (!flat && mode === model.context.LINES) {
      needLighting = true;
    }
    if (actor.getProperty().getLighting() && needLighting) {
      lightComplexity = 0;
      const lights = ren.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0) {
          numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      }
    }
    let needRebuild = false;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
      model.lastBoundBO.set({
        lastLightComplexity: lightComplexity
      }, true);
      model.lastBoundBO.set({
        lastLightCount: numberOfLights
      }, true);
      needRebuild = true;
    }
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      return true;
    }
    return false;
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach((object) => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
      cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isUniformUsed("VertexIDOffset")) {
      cellBO.getProgram().setUniformi("VertexIDOffset", model.vertexIDOffset);
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro2("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("normalMC") && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "normalMC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro2("Error setting normalMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("normalMC");
      }
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro2(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro2("Error setting tcoordMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("tcoordMC");
      }
      if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro2("Error setting scalarColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("scalarColor");
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      const planeEquations = [];
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
      cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
    }
    const tus = model.openGLActor.getActiveTextures();
    if (tus) {
      for (let index = 0; index < tus.length; ++index) {
        const tex = tus[index];
        const texUnit = tex.getTextureUnit();
        const tname = `texture${texUnit + 1}`;
        if (cellBO.getProgram().isUniformUsed(tname)) {
          cellBO.getProgram().setUniformi(tname, texUnit);
        }
      }
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
    const selector = model._openGLRenderer.getSelector();
    cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
    cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 2) {
      return;
    }
    const program = cellBO.getProgram();
    let numberOfLights = 0;
    const lights = ren.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0) {
        const dColor = light.getColorByReference();
        const intensity = light.getIntensity();
        model.lightColor[0] = dColor[0] * intensity;
        model.lightColor[1] = dColor[1] * intensity;
        model.lightColor[2] = dColor[2] * intensity;
        const ld = light.getDirection();
        const transform = ren.getActiveCamera().getViewMatrix();
        const newLightDirection = [...ld];
        if (light.lightTypeIsSceneLight()) {
          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
          normalize(newLightDirection);
        }
        model.lightDirection[0] = newLightDirection[0];
        model.lightDirection[1] = newLightDirection[1];
        model.lightDirection[2] = newLightDirection[2];
        normalize(model.lightDirection);
        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);
        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);
        numberOfLights++;
      }
    }
    if (lastLightComplexity < 3) {
      return;
    }
    const cam = ren.getActiveCamera();
    const viewTF = cam.getViewMatrix();
    mat4_exports.transpose(viewTF, viewTF);
    numberOfLights = 0;
    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0) {
        const lp = light.getTransformedPosition();
        const np = new Float64Array(3);
        vec3_exports.transformMat4(np, lp, viewTF);
        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());
        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());
        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());
        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());
        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);
        numberOfLights++;
      }
    }
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const cam = ren.getActiveCamera();
    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
    const progm = program.getLastCameraMTime();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const actorIsIdentity = actor.getIsIdentity();
    const actMats = actorIsIdentity ? {
      mcwc: null,
      normalMatrix: null
    } : model.openGLActor.getKeyMatrices();
    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {
      const size = model._openGLRenderer.getTiledSizeAndOrigin();
      mat4_exports.identity(model.tmpMat4);
      model.tmpMat4[0] = 2 / size.usize;
      model.tmpMat4[12] = -1;
      model.tmpMat4[5] = 2 / size.vsize;
      model.tmpMat4[13] = -1;
      mat4_exports.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
      program.setUniformMatrix("MCPCMatrix", model.tmpMat4);
    } else {
      program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
    if (program.isUniformUsed("normalMatrix")) {
      program.setUniformMatrix3x3("normalMatrix", safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3_exports, model.tmpMat3));
    }
    if (progm !== camm) {
      if (program.isUniformUsed("cameraParallel")) {
        program.setUniformi("cameraParallel", cam.getParallelProjection());
      }
      program.setLastCameraMTime(camm);
    }
    if (!actorIsIdentity) {
      program.setLastCameraMTime(0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    let ppty = actor.getProperty();
    let opacity = ppty.getOpacity();
    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
    let aIntensity = model.drawingEdges ? 1 : ppty.getAmbient();
    let dIntensity = model.drawingEdges ? 0 : ppty.getDiffuse();
    let sIntensity = model.drawingEdges ? 0 : ppty.getSpecular();
    const specularPower = ppty.getSpecularPower();
    program.setUniformf("opacityUniform", opacity);
    program.setUniform3fArray("ambientColorUniform", aColor);
    program.setUniform3fArray("diffuseColorUniform", dColor);
    program.setUniformf("ambient", aIntensity);
    program.setUniformf("diffuse", dIntensity);
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 1) {
      return;
    }
    let sColor = ppty.getSpecularColorByReference();
    program.setUniform3fArray("specularColorUniform", sColor);
    program.setUniformf("specularPowerUniform", specularPower);
    program.setUniformf("specular", sIntensity);
    if (program.isUniformUsed("ambientIntensityBF")) {
      ppty = actor.getBackfaceProperty();
      opacity = ppty.getOpacity();
      aColor = ppty.getAmbientColor();
      aIntensity = ppty.getAmbient();
      dColor = ppty.getDiffuseColor();
      dIntensity = ppty.getDiffuse();
      sColor = ppty.getSpecularColor();
      sIntensity = ppty.getSpecular();
      program.setUniformf("ambientIntensityBF", aIntensity);
      program.setUniformf("diffuseIntensityBF", dIntensity);
      program.setUniformf("opacityUniformBF", opacity);
      program.setUniform3fArray("ambientColorUniformBF", aColor);
      program.setUniform3fArray("diffuseColorUniformBF", dColor);
      if (lastLightComplexity < 1) {
        return;
      }
      program.setUniformf("specularIntensityBF", sIntensity);
      program.setUniform3fArray("specularColorUniformBF", sColor);
      program.setUniformf("specularPowerUniformBF", specularPower);
    }
  };
  publicAPI.updateMaximumPointCellIds = (ren, actor) => {
    var _a, _b, _c, _d;
    const selector = model._openGLRenderer.getSelector();
    if (!selector) {
      return;
    }
    if ((_b = (_a = model.selectionWebGLIdsToVTKIds) == null ? void 0 : _a.points) == null ? void 0 : _b.length) {
      const length = model.selectionWebGLIdsToVTKIds.points.length;
      selector.setMaximumPointId(length - 1);
    }
    if ((_d = (_c = model.selectionWebGLIdsToVTKIds) == null ? void 0 : _c.cells) == null ? void 0 : _d.length) {
      const length = model.selectionWebGLIdsToVTKIds.cells.length;
      selector.setMaximumCellId(length - 1);
    }
    const fieldAssociation = selector.getFieldAssociation();
    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      model.pointPicking = true;
    }
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    model.vertexIDOffset = 0;
    const picking = getPickState(model._openGLRenderer);
    if (model.lastSelectionState !== picking) {
      model.selectionStateChanged.modified();
      model.lastSelectionState = picking;
    }
    if (model._openGLRenderer.getSelector()) {
      switch (picking) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    publicAPI.updateBufferObjects(ren, actor);
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation2.SURFACE;
    const selector = model._openGLRenderer.getSelector();
    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);
    for (let i = primTypes.Start; i < primTypes.End; i++) {
      model.primitives[i].setPointPicking(pointPicking);
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);
        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {
          model.lastBoundBO = model.primitives[i];
          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();
        }
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.LastBoundBO) {
      model.LastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro2("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    const gl = model.context;
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    publicAPI.updateMaximumPointCellIds();
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }
    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;
    if (n === null && poly.getCellData().getNormals()) {
      model.haveCellNormals = true;
      n = poly.getCellData().getNormals();
    }
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor.getActiveTextures()) {
      tcoords = null;
    }
    let useTCoordsPerCell = false;
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
      if (!model.internalColorTexture) {
        model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
      }
      const tex = model.internalColorTexture;
      tex.setMinificationFilter(Filter.NEAREST);
      tex.setMagnificationFilter(Filter.NEAREST);
      tex.setWrapS(Wrap.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw({
        width: ext[1] - ext[0] + 1,
        height: ext[3] - ext[2] + 1,
        numComps: inScalars.getNumberOfComponents(),
        dataType: inScalars.getDataType(),
        data: inScalars.getData()
      });
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    const customAttributes = model.renderable.getCustomShaderAttributes();
    const customAttributesArrays = customAttributes.map((arrayName) => poly.getPointData().getArrayByName(arrayName));
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}E${actor.getProperty().getEdgeVisibility()}F${tcoords ? tcoords.getMTime() : 1}G${customAttributesArrays.map((attributeArray) => attributeArray.getMTime()).join(",")}`;
    if (model.VBOBuildString !== toString) {
      const points = poly.getPoints();
      const options = {
        points,
        normals: n,
        tcoords,
        colors: c,
        cellOffset: 0,
        vertexOffset: 0,
        // Used to keep track of vertex ids across primitives for selection
        useTCoordsPerCell,
        haveCellScalars: model.haveCellScalars,
        haveCellNormals: model.haveCellNormals,
        customAttributes: customAttributesArrays
      };
      if (model.renderable.getPopulateSelectionSettings()) {
        model.selectionWebGLIdsToVTKIds = {
          points: null,
          cells: null
        };
      }
      const primitives = [{
        inRep: "verts",
        cells: poly.getVerts()
      }, {
        inRep: "lines",
        cells: poly.getLines()
      }, {
        inRep: "polys",
        cells: poly.getPolys()
      }, {
        inRep: "strips",
        cells: poly.getStrips()
      }, {
        inRep: "polys",
        cells: poly.getPolys()
      }, {
        inRep: "strips",
        cells: poly.getStrips()
      }];
      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation2.SURFACE;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {
          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);
          options.vertexOffset += model.primitives[i].getCABO().getElementCount();
        } else {
          if (drawSurfaceWithEdges) {
            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation2.WIREFRAME, {
              ...options,
              tcoords: null,
              colors: null,
              haveCellScalars: false,
              haveCellNormals: false
            });
          } else {
            model.primitives[i].releaseGraphicsResources();
          }
        }
      }
      if (model.renderable.getPopulateSelectionSettings()) {
        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);
      }
      model.VBOBuildString = toString;
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach((prim) => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
}
var DEFAULT_VALUES5 = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null,
  tmpMat4: null,
  ambientColor: [],
  // used internally
  diffuseColor: [],
  // used internally
  specularColor: [],
  // used internally
  lightColor: [],
  // used internally
  lightDirection: [],
  // used internally
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,
  selectionStateChanged: null,
  selectionWebGLIdsToVTKIds: null,
  pointPicking: false
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes;
  model.tmpMat3 = mat3_exports.identity(new Float64Array(9));
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  for (let i = primTypes.Start; i < primTypes.End; i++) {
    model.primitives[i] = vtkHelper.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }
  setGet(publicAPI, model, ["context"]);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.selectionStateChanged = {};
  obj(model.selectionStateChanged, {
    mtime: 0
  });
  vtkOpenGLPolyDataMapper(publicAPI, model);
}
var newInstance7 = newInstance(extend6, "vtkOpenGLPolyDataMapper");
var vtkOpenGLPolyDataMapper$1 = {
  newInstance: newInstance7,
  extend: extend6
};
registerOverride("vtkMapper", newInstance7);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var {
  vtkDebugMacro
} = macro$1;
function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
    model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
    const aspectRatio = model._openGLRenderer.getAspectRatio();
    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
    let texels = null;
    if (model.renderable.getUseZValues()) {
      const zbt = renderPass.getZBufferTexture();
      const width = Math.floor(zbt.getWidth());
      const height = Math.floor(zbt.getHeight());
      const gl = model._openGLRenderWindow.getContext();
      zbt.bind();
      const fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro("No framebuffer to save/restore");
      } else {
        fb.saveCurrentBindingsAndBuffers();
      }
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}
var DEFAULT_VALUES6 = {};
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance8 = newInstance(extend7, "vtkOpenGLPixelSpaceCallbackMapper");
var vtkPixelSpaceCallbackMapper = {
  newInstance: newInstance8,
  extend: extend7
};
registerOverride("vtkPixelSpaceCallbackMapper", newInstance8);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DFS.glsl.js
var vtkPolyData2DFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DVS.glsl.js
var vtkPolyData2DVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/Core/Property2D/Constants.js
var DisplayLocation = {
  BACKGROUND: 0,
  FOREGROUND: 1
};
var Constants = {
  DisplayLocation
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper2D.js
var {
  primTypes: primTypes2
} = vtkHelper;
var {
  Filter: Filter2,
  Wrap: Wrap2
} = vtkOpenGLTexture$1;
var {
  vtkErrorMacro: vtkErrorMacro3
} = macro$1;
var StartEvent2 = {
  type: "StartEvent"
};
var EndEvent2 = {
  type: "EndEvent"
};
function vtkOpenGLPolyDataMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPolyDataMapper2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLActor2D = publicAPI.getFirstAncestorOfType("vtkOpenGLActor2D");
      model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera(), model.openGLCamera);
    }
  };
  publicAPI.overlayPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyData2DVS;
    shaders.Fragment = vtkPolyData2DFS;
    shaders.Geometry = "";
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes2.Start; i < primTypes2.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor2D.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent2);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent2);
    if (!model.currentInput) {
      vtkErrorMacro3("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    const gl = model.context;
    model._openGLRenderWindow.enableCullFace();
    gl.cullFace(gl.BACK);
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    if (model._openGLRenderer.getSelector()) {
      switch (model._openGLRenderer.getSelector().getCurrentPass()) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, actor.getProperty().getOpacity());
    const c = model.renderable.getColorMapColors();
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor2D.getActiveTextures()) {
      tcoords = null;
    }
    let useTCoordsPerCell = false;
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
      if (!model.internalColorTexture) {
        model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
      }
      const tex = model.internalColorTexture;
      tex.setMinificationFilter(Filter2.NEAREST);
      tex.setMagnificationFilter(Filter2.NEAREST);
      tex.setWrapS(Wrap2.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap2.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw({
        width: ext[1] - ext[0] + 1,
        height: ext[3] - ext[2] + 1,
        numComps: inScalars.getNumberOfComponents(),
        dataType: inScalars.getDataType(),
        data: inScalars.getData()
      });
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    const transformCoordinate = model.renderable.getTransformCoordinate();
    const view = ren.getRenderWindow().getViews()[0];
    const vsize = view.getViewportSize(ren);
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}C${c ? c.getMTime() : 1}D${tcoords ? tcoords.getMTime() : 1}E${transformCoordinate ? ren.getMTime() : 1}F${vsize}`;
    if (model.VBOBuildString !== toString) {
      let points = poly.getPoints();
      if (transformCoordinate) {
        const p = vtkPoints$1.newInstance();
        const numPts = points.getNumberOfPoints();
        p.setNumberOfPoints(numPts);
        const point = [];
        for (let i = 0; i < numPts; ++i) {
          points.getPoint(i, point);
          transformCoordinate.setValue(point);
          const v = transformCoordinate.getComputedDoubleViewportValue(ren);
          p.setPoint(i, v[0], v[1], 0);
        }
        points = p;
      }
      const options = {
        points,
        tcoords,
        colors: c,
        cellOffset: 0,
        useTCoordsPerCell,
        haveCellScalars: model.renderable.getAreScalarsMappedFromCells(),
        customAttributes: model.renderable.getCustomShaderAttributes().map((arrayName) => poly.getPointData().getArrayByName(arrayName))
      };
      options.cellOffset += model.primitives[primTypes2.Points].getCABO().createVBO(poly.getVerts(), "verts", representation, options);
      options.cellOffset += model.primitives[primTypes2.Lines].getCABO().createVBO(poly.getLines(), "lines", representation, options);
      options.cellOffset += model.primitives[primTypes2.Tris].getCABO().createVBO(poly.getPolys(), "polys", representation, options);
      options.cellOffset += model.primitives[primTypes2.TriStrips].getCABO().createVBO(poly.getStrips(), "strips", representation, options);
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    gl.depthMask(true);
    for (let i = primTypes2.Start; i < primTypes2.End; i++) {
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.lastBoundBO = model.primitives[i];
        model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.lastBoundBO) {
      model.lastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    let colorDec = ["uniform vec3 diffuseColorUniform;", "uniform float opacityUniform;"];
    let colorImpl = ["vec3 diffuseColor = diffuseColorUniform;", "float opacity = opacityUniform;"];
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {
      colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
    } else if (model.renderable.getAreScalarsMappedFromCells()) {
      colorImpl = colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  opacity = opacity*texColor.a;"]);
    }
    colorImpl = colorImpl.concat(["gl_FragData[0] = vec4(diffuseColor, opacity);"]);
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();
      if (tcdim === 1) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in float tcoordMC;", "out float tcoordVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in float tcoordVCVSOutput[];\n", "out float tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, ["//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in float tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result;
      } else if (tcdim === 2) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordMC;", "out vec2 tcoordVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];\n", "out vec2 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", ["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result;
      }
      if (model.renderable.getAreScalarsMappedFromCells()) {
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PrimID::Impl", ["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform vec3 mapperIndex;", "uniform int picking;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach((object) => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
      cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isAttributeUsed("vertexWC")) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexWC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
        vtkErrorMacro3("Error setting vertexWC in shader VAO.");
      }
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro3(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro3("Error setting tcoordMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("tcoordMC");
      }
      if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro3("Error setting scalarColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("scalarColor");
      }
      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
        const texUnit = model.internalColorTexture.getTextureUnit();
        if (texUnit > -1) {
          cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
        }
      }
      const tus = model.openGLActor2D.getActiveTextures();
      if (tus) {
        for (let index = 0; index < tus.length; ++index) {
          const tex = tus[index];
          const texUnit = tex.getTextureUnit();
          const tname = `texture${texUnit + 1}`;
          if (cellBO.getProgram().isUniformUsed(tname)) {
            cellBO.getProgram().setUniformi(tname, texUnit);
          }
        }
      }
      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
      const selector = model._openGLRenderer.getSelector();
      cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
      cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const c = model.renderable.getColorMapColors();
    if (!c || c.getNumberOfComponents() === 0) {
      const program = cellBO.getProgram();
      const ppty = actor.getProperty();
      const opacity = ppty.getOpacity();
      program.setUniformf("opacityUniform", opacity);
      const dColor = ppty.getColor();
      program.setUniform3fArray("diffuseColorUniform", dColor);
    }
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const view = ren.getRenderWindow().getViews()[0];
    const size = view.getViewportSize(ren);
    const vport = ren.getViewport();
    const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);
    const tileViewport = [0, 0, 1, 1];
    const visVP = [0, 0, 1, 1];
    visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];
    visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];
    visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];
    visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];
    if (visVP[0] >= visVP[2]) {
      return;
    }
    if (visVP[1] >= visVP[3]) {
      return;
    }
    size[0] = round(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));
    size[1] = round(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));
    const winSize = model._openGLRenderer.getParent().getSize();
    const xoff = round(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);
    const yoff = round(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);
    const left = -xoff;
    let right = -xoff + size[0];
    const bottom = -yoff;
    let top = -yoff + size[1];
    if (left === right) {
      right = left + 1;
    }
    if (bottom === top) {
      top = bottom + 1;
    }
    const tmpMat4 = mat4_exports.identity(new Float64Array(16));
    tmpMat4[0] = 2 / (right - left);
    tmpMat4[1 * 4 + 1] = 2 / (top - bottom);
    tmpMat4[0 * 4 + 3] = -1 * (right + left) / (right - left);
    tmpMat4[1 * 4 + 3] = -1 * (top + bottom) / (top - bottom);
    tmpMat4[2 * 4 + 2] = 0;
    tmpMat4[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? -1 : 1;
    tmpMat4[3 * 4 + 3] = 1;
    mat4_exports.transpose(tmpMat4, tmpMat4);
    program.setUniformMatrix("WCVCMatrix", safeMatrixMultiply([tmpMat4, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach((prim) => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
}
var DEFAULT_VALUES7 = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes2;
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  for (let i = primTypes2.Start; i < primTypes2.End; i++) {
    model.primitives[i] = vtkHelper.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }
  setGet(publicAPI, model, ["context"]);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLPolyDataMapper2D(publicAPI, model);
}
var newInstance9 = newInstance(extend8, "vtkOpenGLPolyDataMapper2D");
var vtkPolyDataMapper2D = {
  newInstance: newInstance9,
  extend: extend8
};
registerOverride("vtkMapper2D", newInstance9);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro2
} = macro$1;
function vtkOpenGLRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps(), true);
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro2("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1, 0, 0, 1);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.cameraPass = (prepass) => {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = () => {
    let clearMask = 0;
    const gl = model.context;
    if (!model.renderable.getTransparent()) {
      const background = model.renderable.getBackgroundByReference();
      gl.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      gl.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    const ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    if (clearMask) {
      gl.clear(clearMask);
    }
    gl.enable(gl.DEPTH_TEST);
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
    if (model.renderable) {
      model.renderable.getViewProps().forEach((prop) => {
        prop.modified();
      });
    }
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES8 = {
  context: null,
  _openGLRenderWindow: null,
  selector: null
};
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  get(publicAPI, model, ["shaderCache"]);
  setGet(publicAPI, model, ["selector"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLRenderer(publicAPI, model);
}
var newInstance10 = newInstance(extend9, "vtkOpenGLRenderer");
var vtkRenderer = {
  newInstance: newInstance10,
  extend: extend9
};
registerOverride("vtkRenderer", newInstance10);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ScalarBarActor.js
function vtkOpenGLScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLScalarBarActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES9 = {};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
  vtkOpenGLScalarBarActor(publicAPI, model);
}
var newInstance11 = newInstance(extend10, "vtkOpenGLScalarBarActor");
registerOverride("vtkScalarBarActor", newInstance11);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var {
  vtkErrorMacro: vtkErrorMacro4
} = macro$1;
function vtkOpenGLSkybox(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLSkybox");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera(), model.openGLCamera);
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOpaqueActorCount();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass && !model._openGLRenderer.getSelector()) {
      publicAPI.updateBufferObjects();
      model.context.depthMask(true);
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
      model.openGLTexture.render(model._openGLRenderWindow);
      const texUnit = model.openGLTexture.getTextureUnit();
      model.tris.getProgram().setUniformi("sbtexture", texUnit);
      const ren = model._openGLRenderer.getRenderable();
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const imat = new Float64Array(16);
      mat4_exports.invert(imat, keyMats.wcpc);
      model.tris.getProgram().setUniformMatrix("IMCPCMatrix", imat);
      if (model.lastFormat === "box") {
        const camPos = ren.getActiveCamera().getPosition();
        model.tris.getProgram().setUniform3f("camPos", camPos[0], camPos[1], camPos[2]);
      }
      model.tris.getVAO().bind();
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
      model.openGLTexture.deactivate();
    }
  };
  publicAPI.updateBufferObjects = () => {
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1;
        ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
        ptsArray[i * 3 + 2] = 1;
      }
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    if (model.renderable.getFormat() !== model.lastFormat) {
      model.lastFormat = model.renderable.getFormat();
      if (model.lastFormat === "box") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, ""));
      }
      if (model.lastFormat === "background") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, ""));
      }
      model.tris.getShaderSourceTime().modified();
      model.tris.getVAO().bind();
      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), "vertexMC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
        vtkErrorMacro4("Error setting vertexMC in shader VAO.");
      }
    }
    const tmaps = model.renderable.getTextures();
    if (!tmaps.length) {
      vtkErrorMacro4("vtkSkybox requires a texture map");
    }
    if (model.openGLTexture.getRenderable() !== tmaps[0]) {
      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.openGLTexture.setRenderable(tmaps[0]);
    }
  };
}
var DEFAULT_VALUES10 = {
  context: null
};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.openGLTexture = vtkOpenGLTexture$1.newInstance();
  model.tris = vtkHelper.newInstance();
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: mat3_exports.identity(new Float64Array(9)),
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLSkybox(publicAPI, model);
}
var newInstance12 = newInstance(extend11);
var vtkSkybox = {
  newInstance: newInstance12,
  extend: extend11
};
registerOverride("vtkSkybox", newInstance12);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor.js
var {
  CoordinateSystem: CoordinateSystem2
} = vtkProp$1;
function vtkWebGPUActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      model.bufferShift[0] = mcwc[3];
      model.bufferShift[1] = mcwc[7];
      model.bufferShift[2] = mcwc[11];
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem2.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        mat4_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat4_exports.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      if (model.renderable.getCoordinateSystem() === CoordinateSystem2.WORLD) {
        mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        mat4_exports.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES11 = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: void 0,
  bufferShift: void 0
};
function extend12(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  model.bufferShift = [0, 0, 0, 0];
  vtkWebGPUActor(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend12);
registerOverride2("vtkActor", newInstance13);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor2D.js
var {
  CoordinateSystem: CoordinateSystem3
} = vtkProp$1;
function vtkWebGPUActor2D(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUActor2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.bufferShift[0] = 0;
      model.bufferShift[1] = 0;
      model.bufferShift[2] = 0;
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem3.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      mat4_exports.identity(model.keyMatrices.bcwc);
      mat4_exports.identity(model.keyMatrices.normalMatrix);
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      if (model.renderable.getCoordinateSystem() === CoordinateSystem3.WORLD) {
        mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        mat4_exports.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES12 = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: void 0,
  bufferShift: void 0
};
function extend13(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  model.bufferShift = [0, 0, 0, 0];
  vtkWebGPUActor2D(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend13);
registerOverride2("vtkActor2D", newInstance14);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
function vtkWebGPUCamera(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCamera");
  publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
    mat4_exports.identity(outMat);
    if (model.renderable.getParallelProjection()) {
      const parallelScale = model.renderable.getParallelScale();
      const width = parallelScale * aspect;
      const height = parallelScale;
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      const xr = 1 / (xmax - xmin);
      const yr = 1 / (ymax - ymin);
      outMat[0] = 2 * xr;
      outMat[5] = 2 * yr;
      outMat[10] = 1 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360);
      let width;
      let height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        width = cRange[0] * tmp;
        height = cRange[0] * tmp / aspect;
      } else {
        width = cRange[0] * tmp * aspect;
        height = cRange[0] * tmp;
      }
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      outMat[0] = 2 * cRange[0] / (xmax - xmin);
      outMat[5] = 2 * cRange[0] / (ymax - ymin);
      outMat[12] = (xmin + xmax) / (xmax - xmin);
      outMat[13] = (ymin + ymax) / (ymax - ymin);
      outMat[10] = 0;
      outMat[14] = cRange[0];
      outMat[11] = -1;
      outMat[15] = 0;
    }
  };
  publicAPI.convertToOpenGLDepth = (val) => {
    if (model.renderable.getParallelProjection()) {
      return 1 - val;
    }
    const cRange = model.renderable.getClippingRangeByReference();
    let zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = (webGPURenderer) => {
    const ren = webGPURenderer.getRenderable();
    const webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      const wcvc = model.renderable.getViewMatrix();
      mat4_exports.copy(model.keyMatrices.normalMatrix, wcvc);
      model.keyMatrices.normalMatrix[3] = 0;
      model.keyMatrices.normalMatrix[7] = 0;
      model.keyMatrices.normalMatrix[11] = 0;
      mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, wcvc);
      const center = webGPURenderer.getStabilizedCenterByReference();
      mat4_exports.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      const aspectRatio = webGPURenderer.getAspectRatio();
      const cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      mat4_exports.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      mat4_exports.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES13 = {
  keyMatrixTime: null,
  keyMatrices: null
};
function extend14(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  macro.obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };
  macro.setGet(publicAPI, model, ["keyMatrixTime"]);
  vtkWebGPUCamera(publicAPI, model);
}
var newInstance15 = macro.newInstance(extend14);
registerOverride2("vtkCamera", newInstance15);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/CubeAxesActor.js
function vtkWebGPUCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCubeAxesActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES14 = {};
function extend15(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
  vtkWebGPUCubeAxesActor(publicAPI, model);
}
var newInstance16 = newInstance(extend15, "vtkWebGPUCubeAxesActor");
registerOverride2("vtkCubeAxesActor", newInstance16);

// node_modules/@kitware/vtk.js/Rendering/Core/Property2D.js
var {
  DisplayLocation: DisplayLocation2
} = Constants;
function vtkProperty2D(publicAPI, model) {
  model.classHierarchy.push("vtkProperty2D");
  publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(DisplayLocation2.BACKGROUND);
  publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(DisplayLocation2.FOREGROUND);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation.POINTS);
  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation, model.representation);
}
var DEFAULT_VALUES15 = {
  color: [1, 1, 1],
  opacity: 1,
  pointSize: 1,
  lineWidth: 1,
  representation: Representation.SURFACE,
  displayLocation: DisplayLocation2.FOREGROUND
};
function extend16(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["opacity", "lineWidth", "pointSize", "displayLocation", "representation"]);
  macro.setGetArray(publicAPI, model, ["color"], 3);
  vtkProperty2D(publicAPI, model);
}
var newInstance17 = macro.newInstance(extend16, "vtkProperty2D");
var vtkProperty2D$1 = {
  newInstance: newInstance17,
  extend: extend16,
  ...Constants
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js
var {
  BufferUsage,
  PrimitiveTypes
} = vtkWebGPUBufferManager$1;
var {
  Representation: Representation3
} = vtkProperty$1;
var {
  ScalarMode: ScalarMode2
} = vtkMapper$1;
var {
  CoordinateSystem: CoordinateSystem4
} = vtkProp$1;
var {
  DisplayLocation: DisplayLocation3
} = vtkProperty2D$1;
var vtkWebGPUPolyDataVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
var vtkWebGPUPolyDataFS = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

struct Material {
  ior: f32,
  roughness: f32,
  metallic: f32,
  base: vec3<f32>,
};

struct DirectionalLight {
  direction: vec3<f32>,
  color: vec3<f32>,
};

struct PointLight {
  position: vec3<f32>,
  color: vec3<f32>,
};

struct SpotLight {
  position: vec3<f32>,
  direction: vec3<f32>,
  cones: vec2<f32>,
  color: vec3<f32>,
};

const pi: f32 = 3.14159265359;

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;

  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, mat: Material, light: DirectionalLight) -> PBRData {
  var L: vec3<f32> = normalize(light.direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = light.color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf * incoming * angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: PointLight) -> PBRData {
  var L: vec3<f32> = normalize(light.position - fragPos);
  var H: vec3<f32> = normalize(L + V);
  var dist = distance(light.position, fragPos);

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  var F: f32 = schlickFresnelIOR(V, N, mat.ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = light.color * (1.0 / (dist * dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" between light sources

  var specular: vec3<f32> = brdf * incoming * angle;
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);
  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: SpotLight) -> PBRData {
  var L: vec3<f32> = normalize(light.position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(light.position, fragPos);

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);

  var theta: f32 = mdot(normalize(light.direction), L);
  var epsilon: f32 = light.cones.x - light.cones.y;
  var intensity: f32 = (theta - light.cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist * dist;

  var incoming: vec3<f32> = light.color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" between light sources

  var specular: vec3<f32> = brdf * incoming * angle;
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;
  var ior: f32 = mapperUBO.BaseIOR;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  // Use texture alpha for transparency
  computedColor.a = mapperUBO.Opacity * _diffuseMap.a;
  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
function isEdges(hash) {
  return hash.indexOf("edge") >= 0;
}
function vtkWebGPUCellArrayMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCellArrayMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (model.is2D) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
        model.forceZValue = true;
      } else {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
        model.forceZValue = false;
      }
      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();
      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem4.DISPLAY;
      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
    }
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.updateUBO = () => {
    var _a, _b;
    const actor = model.WebGPUActor.getRenderable();
    const ppty = actor.getProperty();
    const utime = model.UBO.getSendTime();
    if (publicAPI.getMTime() <= utime && ppty.getMTime() <= utime && model.renderable.getMTime() <= utime) {
      return;
    }
    const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
    model.UBO.setArray("BCWCMatrix", keyMats.bcwc);
    model.UBO.setArray("BCSCMatrix", keyMats.bcsc);
    model.UBO.setArray("MCWCNormals", keyMats.normalMatrix);
    if (model.is2D) {
      const displayLoc = ((_a = ppty.getDisplayLocation) == null ? void 0 : _a.call(ppty)) ?? DisplayLocation3.BACKGROUND;
      model.UBO.setValue("ZValue", displayLoc === DisplayLocation3.FOREGROUND ? 1 : 0);
      const aColor = ppty.getColorByReference();
      model.UBO.setValue("AmbientIntensity", 1);
      model.UBO.setArray("DiffuseColor", [...aColor, 1]);
      model.UBO.setValue("DiffuseIntensity", 0);
      model.UBO.setValue("SpecularIntensity", 0);
    } else {
      model.UBO.setValue("AmbientIntensity", ppty.getAmbient());
      model.UBO.setArray("AmbientColor", [...ppty.getAmbientColorByReference(), 1]);
      model.UBO.setValue("DiffuseIntensity", ppty.getDiffuse());
      model.UBO.setArray("DiffuseColor", [...ppty.getDiffuseColorByReference(), 1]);
      model.UBO.setValue("Roughness", ppty.getRoughness());
      model.UBO.setValue("BaseIOR", ppty.getBaseIOR());
      model.UBO.setValue("Metallic", ppty.getMetallic());
      model.UBO.setValue("NormalStrength", ppty.getNormalStrength());
      model.UBO.setValue("Emission", ppty.getEmission());
      model.UBO.setValue("SpecularIntensity", ppty.getSpecular());
      if (ppty.getSpecularColorByReference()) {
        model.UBO.setArray("SpecularColor", [...ppty.getSpecularColorByReference(), 1]);
      }
    }
    const edgeColor = (_b = ppty.getEdgeColorByReference) == null ? void 0 : _b.call(ppty);
    if (edgeColor) model.UBO.setArray("EdgeColor", [...edgeColor, 1]);
    model.UBO.setValue("LineWidth", ppty.getLineWidth());
    model.UBO.setValue("Opacity", ppty.getOpacity());
    model.UBO.setValue("PropID", model.WebGPUActor.getPropID());
    model.UBO.sendIfNeeded(model.WebGPURenderWindow.getDevice());
  };
  publicAPI.haveWideLines = () => {
    const actor = model.WebGPUActor.getRenderable();
    const representation = actor.getProperty().getRepresentation();
    if (actor.getProperty().getLineWidth() <= 1) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes.Verts) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {
      return representation === Representation3.WIREFRAME;
    }
    return true;
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    if (!vDesc.hasOutput("vertexVC")) vDesc.addOutput("vec4<f32>", "vertexVC");
    let code = vDesc.getCode();
    if (model.useRendererMatrix) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;", "    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);", "//VTK::Position::Impl"]).result;
      if (model.forceZValue) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);", "pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
      }
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;", "    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;", "    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;", "    pCoord.z = 0.5 - 0.5 * pCoord.z;", "//VTK::Position::Impl"]).result;
      if (model.forceZValue) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
      }
    }
    if (publicAPI.haveWideLines()) {
      vDesc.addBuiltinInput("u32", "@builtin(instance_index) instanceIndex");
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", [
        "    var tmpPos: vec4<f32> = pCoord;",
        "    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);",
        "    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;",
        "    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;",
        "    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;",
        "    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;",
        "    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);",
        // could become a setting
        "    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);",
        "//VTK::Position::Impl"
      ]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = pCoord;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    const normalBuffer = vertexInput.getBuffer("normalMC");
    const actor = model.WebGPUActor.getRenderable();
    if (normalBuffer) {
      const vDesc = pipeline.getShaderDescription("vertex");
      if (!vDesc.hasOutput("normalVC")) {
        vDesc.addOutput("vec3<f32>", "normalVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput("tangentVC")) {
        vDesc.addOutput("vec3<f32>", "tangentVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput("bitangentVC")) {
        vDesc.addOutput("vec3<f32>", "bitangentVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", [
        "  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);",
        // This is just an approximation, but it happens to work extremely well
        // It only works well for normals that are head on and not super angled though
        // Definitely needs to be replaced
        "  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));",
        "  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));",
        "  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));",
        "  output.tangentVC = normalize(tangent);",
        "  output.bitangentVC = normalize(cross(output.normalVC, tangent));"
      ]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      code = fDesc.getCode();
      if (actor.getProperty().getNormalTexture()) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  var tangent: vec3<f32> = input.tangentVC;", "  var bitangent: vec3<f32> = input.bitangentVC;", "  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(", "    tangent.x, bitangent.x, normal.x,", "    tangent.y, bitangent.y, normal.y,", "    tangent.z, bitangent.z, normal.z,", "  );", "  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);", "  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);", "  normal = normalize(normal);"]).result;
      } else {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  normal = normalize(normal);"]).result;
      }
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderNormal", publicAPI.replaceShaderNormal);
  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {
    var _a;
    if (hash.includes("sel")) return;
    const vDesc = pipeline.getShaderDescription("vertex");
    if (!vDesc.hasOutput("vertexVC")) vDesc.addOutput("vec4<f32>", "vertexVC");
    const renderer = model.WebGPURenderer.getRenderable();
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    if (code.includes("var normal:") && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes("sel")) {
      const lightingCode = [
        // Vectors needed for light calculations
        "  let fragPos = vec3<f32>(input.vertexVC.xyz);",
        "  let V = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector",
        // Values needed for light calculations
        "  let baseColor = _diffuseMap.rgb * diffuseColor.rgb;",
        "  let roughness = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);",
        // Need to have a different way of sampling greyscale values aside from .r
        "  let metallic = mapperUBO.Metallic * _metallicMap.r;",
        "  let alpha = roughness * roughness;",
        "  let k = alpha * alpha / 2.0;",
        // Split diffuse and specular components
        "  var diffuse = vec3<f32>(0.);",
        "  var specular = vec3<f32>(0.);",
        "  let emission = _emissionMap.rgb * mapperUBO.Emission;",
        "",
        "  // Material struct",
        "  let mat = Material(ior, roughness, metallic, baseColor);",
        "",
        // Summing diffuse and specular components of directional lights
        "  {",
        "    var i = 0;",
        "    loop {",
        "      if (!(i < rendererUBO.LightCount)) { break; }",
        "      switch (i32(rendererLightSSBO.values[i].LightData.x)) {",
        "         // Point Light",
        "         case 0 {",
        "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           let pos = (rendererLightSSBO.values[i].LightPos).xyz;",
        "           let pointLight = PointLight(pos, color);",
        "           let result = calcPointLight(normal, V, fragPos, mat, pointLight);",
        "           diffuse += max(vec3<f32>(0), result.diffuse);",
        "           specular += max(vec3<f32>(0), result.specular);",
        "          }",
        "         // Directional light",
        "         case 1 {",
        "           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);",
        "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           let dirLight = DirectionalLight(dir, color);",
        "           let result = calcDirectionalLight(normal, V, mat, dirLight); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color",
        "           diffuse += max(vec3<f32>(0), result.diffuse);",
        "           specular += max(vec3<f32>(0), result.specular);",
        "         }",
        "         // Spot Light",
        "         case 2 {",
        "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           let pos = (rendererLightSSBO.values[i].LightPos).xyz;",
        "           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);",
        "           let cones = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);",
        "           let spotLight = SpotLight(pos, dir, cones, color);",
        "           let result = calcSpotLight(normal, V, fragPos, mat, spotLight);",
        "           diffuse += max(vec3<f32>(0), result.diffuse);",
        "           specular += max(vec3<f32>(0), result.specular);",
        "         }",
        "         default { continue; }",
        "       }",
        "      continuing { i++; }",
        "    }",
        "  }",
        // Final variables for combining specular and diffuse
        "  let fresnel = min(1.0, schlickFresnelIOR(V, normal, ior, k)); // Fresnel",
        "  // This could be controlled with its own variable (that isnt base color) for better artistic control",
        "  let fresnelMetallic = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account",
        "  let kS = min(vec3<f32>(1.0), mix(vec3<f32>(fresnel), fresnelMetallic, metallic));",
        "  let kD = (1.0 - kS) * (1.0 - metallic);",
        "  let PBR = mapperUBO.DiffuseIntensity * kD * diffuse + kS * specular;",
        "  computedColor = vec4<f32>(PBR + emission, mapperUBO.Opacity);"
      ];
      if ((_a = renderer.getEnvironmentTexture()) == null ? void 0 : _a.getImageLoaded()) {
        lightingCode.push(
          "  // To get diffuse IBL, the texture is sampled with normals in worldspace",
          "  let diffuseIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;",
          "  let diffuseCoords = vecToRectCoord(diffuseIBLCoords);",
          "  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors",
          "  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment",
          "  let VreflN = normalize(reflect(-V, normal));",
          "  let reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;",
          "  let specularCoords = vecToRectCoord(reflectionIBLCoords);",
          "  let diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);",
          // Level multiplier should be set by UBO
          "  let level = roughness * rendererUBO.MaxEnvironmentMipLevel;",
          "  let specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);",
          // Manual mip smoothing since not all formats support smooth level sampling
          "  let specularIBLContribution = specularIBL.rgb * rendererUBO.BackgroundSpecularStrength;",
          "  computedColor += vec4<f32>(specularIBLContribution * kS, 0);",
          "  let diffuseIBLContribution = diffuseIBL.rgb * rendererUBO.BackgroundDiffuseStrength;",
          "  computedColor += vec4<f32>(diffuseIBLContribution * baseColor * _ambientOcclusionMap.rgb * kD, 0);"
        );
      }
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", lightingCode).result;
      fDesc.setCode(code);
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", ["  let diffuse = diffuseColor.rgb;", "  let specular = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;", "  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);"]).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderLight", publicAPI.replaceShaderLight);
  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
    if (isEdges(hash)) {
      const fDesc2 = pipeline.getShaderDescription("fragment");
      let code2 = fDesc2.getCode();
      code2 = vtkWebGPUShaderCache$1.substitute(code2, "//VTK::Color::Impl", ["ambientColor = mapperUBO.EdgeColor;", "diffuseColor = mapperUBO.EdgeColor;"]).result;
      fDesc2.setCode(code2);
      return;
    }
    const colorBuffer = vertexInput.getBuffer("colorVI");
    if (!colorBuffer) return;
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec4<f32>", "color", colorBuffer.getArrayInformation()[0].interpolation);
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["  output.color = colorVI;"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["ambientColor = input.color;", "diffuseColor = input.color;", "opacity = mapperUBO.Opacity * input.color.a;"]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderColor", publicAPI.replaceShaderColor);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!vertexInput.hasAttribute("tcoord")) return;
    const vDesc = pipeline.getShaderDescription("vertex");
    const tcoords = vertexInput.getBuffer("tcoord");
    const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
    let code = vDesc.getCode();
    vDesc.addOutput(`vec${numComp}<f32>`, "tcoordVS");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", ["  output.tcoordVS = tcoord;"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    const actor = model.WebGPUActor.getRenderable();
    const property = actor.getProperty();
    const checkDims = (texture) => {
      if (!texture) return false;
      const dims = texture.getDimensionality();
      return dims === numComp;
    };
    const usedTextures = [];
    const diffuseTexture = (_a = property.getDiffuseTexture) == null ? void 0 : _a.call(property);
    if ((diffuseTexture == null ? void 0 : diffuseTexture.getImageLoaded()) || actor.getTextures()[0] || model.colorTexture) {
      if (
        // Chained or statements here are questionable
        checkDims(diffuseTexture) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)
      ) {
        usedTextures.push("_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);");
      }
    }
    const ormTexture = (_b = property.getORMTexture) == null ? void 0 : _b.call(property);
    const rmTexture = (_c = property.getRMTexture) == null ? void 0 : _c.call(property);
    const roughnessTexture = (_d = property.getRoughnessTexture) == null ? void 0 : _d.call(property);
    const metallicTexture = (_e = property.getMetallicTexture) == null ? void 0 : _e.call(property);
    const ambientOcclusionTexture = (_f = property.getAmbientOcclusionTexture) == null ? void 0 : _f.call(property);
    const emissionTexture = (_g = property.getEmissionTexture) == null ? void 0 : _g.call(property);
    const normalTexture = (_h = property.getNormalTexture) == null ? void 0 : _h.call(property);
    if (ormTexture == null ? void 0 : ormTexture.getImageLoaded()) {
      if (checkDims(ormTexture)) {
        usedTextures.push("_ambientOcclusionMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).rrra;", "_roughnessMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).ggga;", "_metallicMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).bbba;");
      }
    } else if (rmTexture == null ? void 0 : rmTexture.getImageLoaded()) {
      if (checkDims(rmTexture)) {
        usedTextures.push("_roughnessMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).ggga;", "_metallicMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).bbba;");
      }
    } else {
      if (roughnessTexture == null ? void 0 : roughnessTexture.getImageLoaded()) {
        if (checkDims(roughnessTexture)) {
          usedTextures.push("_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS).ggga;");
        }
      }
      if (metallicTexture == null ? void 0 : metallicTexture.getImageLoaded()) {
        if (checkDims(metallicTexture)) {
          usedTextures.push("_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS).bbba;");
        }
      }
      if (ambientOcclusionTexture == null ? void 0 : ambientOcclusionTexture.getImageLoaded()) {
        if (checkDims(ambientOcclusionTexture)) {
          usedTextures.push("_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS).rrra;");
        }
      }
    }
    if (emissionTexture == null ? void 0 : emissionTexture.getImageLoaded()) {
      if (checkDims(emissionTexture)) {
        usedTextures.push("_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);");
      }
    }
    if (normalTexture == null ? void 0 : normalTexture.getImageLoaded()) {
      if (checkDims(normalTexture)) {
        usedTextures.push("_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);");
      }
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", usedTextures).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
    if (hash.includes("sel")) {
      const fDesc = pipeline.getShaderDescription("fragment");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Select::Impl", ["  var compositeID: u32 = 0u;"]).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderSelect", publicAPI.replaceShaderSelect);
  publicAPI.getUsage = (rep, i) => {
    if (rep === Representation3.POINTS || i === PrimitiveTypes.Points) {
      return BufferUsage.Verts;
    }
    if (i === PrimitiveTypes.Lines) {
      return BufferUsage.Lines;
    }
    if (rep === Representation3.WIREFRAME) {
      if (i === PrimitiveTypes.Triangles) {
        return BufferUsage.LinesFromTriangles;
      }
      return BufferUsage.LinesFromStrips;
    }
    if (i === PrimitiveTypes.Triangles) {
      return BufferUsage.Triangles;
    }
    if (i === PrimitiveTypes.TriangleStrips) {
      return BufferUsage.Strips;
    }
    if (i === PrimitiveTypes.TriangleEdges) {
      return BufferUsage.LinesFromTriangles;
    }
    return BufferUsage.LinesFromStrips;
  };
  publicAPI.getHashFromUsage = (usage) => `pt${usage}`;
  publicAPI.getTopologyFromUsage = (usage) => {
    switch (usage) {
      case BufferUsage.Triangles:
        return "triangle-list";
      case BufferUsage.Verts:
        return "point-list";
      case BufferUsage.Lines:
      default:
        return "line-list";
    }
  };
  publicAPI.buildVertexInput = () => {
    var _a, _b, _c;
    const pd = model.currentInput;
    const cells = model.cellArray;
    const primType = model.primitiveType;
    const actor = model.WebGPUActor.getRenderable();
    let representation = actor.getProperty().getRepresentation();
    const device = model.WebGPURenderWindow.getDevice();
    let edges = false;
    if (primType === PrimitiveTypes.TriangleEdges) {
      edges = true;
      representation = Representation3.WIREFRAME;
    }
    const vertexInput = model.vertexInput;
    const points = pd.getPoints();
    let indexBuffer = null;
    if (cells) {
      indexBuffer = device.getBufferManager().getBuffer({
        hash: `R${representation}P${primType}${cells.getMTime()}`,
        usage: BufferUsage.Index,
        cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: primType,
        representation
      });
      vertexInput.setIndexBuffer(indexBuffer);
    } else {
      vertexInput.setIndexBuffer(null);
    }
    if (points) {
      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
      vertexInput.addBuffer(device.getBufferManager().getBuffer({
        hash: `${points.getMTime()}I${((_a = indexBuffer == null ? void 0 : indexBuffer.getMTime) == null ? void 0 : _a.call(indexBuffer)) ?? 0}${shift.join()}float32x4`,
        usage: BufferUsage.PointArray,
        format: "float32x4",
        dataArray: points,
        indexBuffer,
        shift,
        packExtra: true
      }), ["vertexBC"]);
    } else {
      vertexInput.removeBufferIfPresent("vertexBC");
    }
    const usage = publicAPI.getUsage(representation, primType);
    model._usesCellNormals = false;
    if (!model.is2D && // no lighting on Property2D
    (usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {
      const normals = pd.getPointData().getNormals();
      const buffRequest = {
        format: "snorm8x4",
        indexBuffer,
        packExtra: true,
        shift: 0,
        scale: 127
      };
      if (normals) {
        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = normals;
        buffRequest.usage = BufferUsage.PointArray;
        vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ["normalMC"]);
      } else if (primType === PrimitiveTypes.Triangles) {
        model._usesCellNormals = true;
        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = points;
        buffRequest.cells = cells;
        buffRequest.usage = BufferUsage.NormalsFromPoints;
        vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ["normalMC"]);
      } else {
        vertexInput.removeBufferIfPresent("normalMC");
      }
    } else {
      vertexInput.removeBufferIfPresent("normalMC");
    }
    let haveColors = false;
    if (model.renderable.getScalarVisibility()) {
      const c = model.renderable.getColorMapColors();
      if (c && !edges) {
        const scalarMode = model.renderable.getScalarMode();
        const haveCellScalars = (scalarMode === ScalarMode2.USE_CELL_DATA || scalarMode === ScalarMode2.USE_CELL_FIELD_DATA || scalarMode === ScalarMode2.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode2.USE_POINT_FIELD_DATA && c;
        vertexInput.addBuffer(device.getBufferManager().getBuffer({
          usage: BufferUsage.PointArray,
          format: "unorm8x4",
          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,
          dataArray: c,
          indexBuffer,
          cellData: haveCellScalars,
          cellOffset: 0
        }), ["colorVI"]);
        haveColors = true;
      }
    }
    if (!haveColors) vertexInput.removeBufferIfPresent("colorVI");
    let tcoords = null;
    if (((_c = (_b = model.renderable).getInterpolateScalarsBeforeMapping) == null ? void 0 : _c.call(_b)) && model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
    } else {
      tcoords = pd.getPointData().getTCoords();
    }
    if (tcoords && !edges) {
      vertexInput.addBuffer(device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer()), ["tcoord"]);
    } else {
      vertexInput.removeBufferIfPresent("tcoord");
    }
  };
  publicAPI.updateTextures = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    const usedTextures = [];
    const newTextures = [];
    const idata = (_b = (_a = model.renderable).getColorTextureMap) == null ? void 0 : _b.call(_a);
    if (idata && !model.colorTexture) {
      model.colorTexture = vtkTexture$1.newInstance({
        label: "polyDataColor"
      });
    }
    if (idata) {
      model.colorTexture.setInputData(idata);
      newTextures.push(["DiffuseTexture", model.colorTexture]);
    }
    const actor = model.WebGPUActor.getRenderable();
    const renderer = model.WebGPURenderer.getRenderable();
    const textures = [["DiffuseTexture", (_d = (_c = actor.getProperty()).getDiffuseTexture) == null ? void 0 : _d.call(_c)], ["DiffuseTexture", actor.getTextures()[0]], ["DiffuseTexture", model.colorTexture], ["ORMTexture", (_f = (_e = actor.getProperty()).getORMTexture) == null ? void 0 : _f.call(_e)], ["RMTexture", (_h = (_g = actor.getProperty()).getRMTexture) == null ? void 0 : _h.call(_g)], ["RoughnessTexture", (_j = (_i = actor.getProperty()).getRoughnessTexture) == null ? void 0 : _j.call(_i)], ["MetallicTexture", (_l = (_k = actor.getProperty()).getMetallicTexture) == null ? void 0 : _l.call(_k)], ["NormalTexture", (_n = (_m = actor.getProperty()).getNormalTexture) == null ? void 0 : _n.call(_m)], ["AmbientOcclusionTexture", (_p = (_o = actor.getProperty()).getAmbientOcclusionTexture) == null ? void 0 : _p.call(_o)], ["EmissionTexture", (_r = (_q = actor.getProperty()).getEmissionTexture) == null ? void 0 : _r.call(_q)], ["EnvironmentTexture", (_s = renderer.getEnvironmentTexture) == null ? void 0 : _s.call(renderer)]];
    textures.forEach((_ref) => {
      let [name, tex] = _ref;
      if (!tex) return;
      if (tex.getInputData() || tex.getJsImageData() || tex.getCanvas() || tex.getImageBitmap()) {
        newTextures.push([name, tex]);
      }
      if (tex.getImage() && tex.getImageLoaded()) {
        newTextures.push([name, tex]);
      }
    });
    newTextures.forEach((_ref2) => {
      let [textureName, srcTexture] = _ref2;
      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture, textureName);
      if (!newTex.getReady()) return;
      let found = false;
      for (let t = 0; t < model.textures.length; ++t) {
        if (model.textures[t] === newTex) {
          found = true;
          usedTextures[t] = true;
          break;
        }
      }
      if (!found) {
        usedTextures[model.textures.length] = true;
        const tview = newTex.createView(textureName);
        model.textures.push(newTex);
        model.textureViews.push(tview);
        const interpolate = srcTexture.getInterpolate() ? "linear" : "nearest";
        let addressMode = null;
        if (srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = "mirror-repeat";
        else if (srcTexture.getEdgeClamp()) addressMode = "clamp-to-edge";
        else if (srcTexture.getRepeat()) addressMode = "repeat";
        let options = {
          addressModeU: addressMode,
          addressModeV: addressMode,
          addressModeW: addressMode,
          minFilter: interpolate,
          magFilter: interpolate
        };
        if (textureName === "EnvironmentTexture") {
          options = {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge",
            addressModeW: "repeat",
            minFilter: interpolate,
            magFilter: interpolate,
            mipmapFilter: "linear"
          };
        }
        tview.addSampler(model.device, options);
      }
    });
    for (let i = model.textures.length - 1; i >= 0; i--) {
      if (!usedTextures[i]) {
        model.textures.splice(i, 1);
        model.textureViews.splice(i, 1);
      }
    }
  };
  publicAPI.computePipelineHash = () => {
    let pipelineHash = `pd${model.useRendererMatrix ? "r" : ""}${model.forceZValue ? "z" : ""}`;
    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {
      pipelineHash += "edge";
    } else {
      if (model.vertexInput.hasAttribute(`normalMC`)) {
        pipelineHash += `n`;
      }
      if (model.vertexInput.hasAttribute(`colorVI`)) {
        pipelineHash += `c`;
      }
      if (model.vertexInput.hasAttribute(`tcoord`)) {
        const tcoords = model.vertexInput.getBuffer("tcoord");
        const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
        pipelineHash += `t${numComp}`;
      }
      if (model.textures.length) {
        pipelineHash += `tx${model.textures.length}`;
      }
    }
    if (model._usesCellNormals) {
      pipelineHash += `cn`;
    }
    if (model.SSBO) {
      pipelineHash += `ssbo`;
    }
    const uhash = publicAPI.getHashFromUsage(model.usage);
    pipelineHash += uhash;
    pipelineHash += model.renderEncoder.getPipelineHash();
    model.pipelineHash = pipelineHash;
  };
  publicAPI.updateBuffers = () => {
    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {
      publicAPI.updateTextures();
    }
    const actor = model.WebGPUActor.getRenderable();
    const rep = actor.getProperty().getRepresentation();
    model.usage = publicAPI.getUsage(rep, model.primitiveType);
    publicAPI.buildVertexInput();
    const vbo = model.vertexInput.getBuffer("vertexBC");
    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
    publicAPI.updateUBO();
    if (publicAPI.haveWideLines()) {
      const ppty = actor.getProperty();
      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2));
    } else {
      publicAPI.setNumberOfInstances(1);
    }
  };
}
var DEFAULT_VALUES16 = {
  is2D: false,
  cellArray: null,
  currentInput: null,
  cellOffset: 0,
  primitiveType: 0,
  colorTexture: null,
  renderEncoder: null,
  textures: null
};
function extend17(publicAPI, model) {
  let initiaLalues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initiaLalues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initiaLalues);
  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
  model._tmpMat3 = mat3_exports.identity(new Float64Array(9));
  model._tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("BCWCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("BCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("MCWCNormals", "mat4x4<f32>");
  model.UBO.addEntry("AmbientColor", "vec4<f32>");
  model.UBO.addEntry("DiffuseColor", "vec4<f32>");
  model.UBO.addEntry("EdgeColor", "vec4<f32>");
  model.UBO.addEntry("SpecularColor", "vec4<f32>");
  model.UBO.addEntry("AmbientIntensity", "f32");
  model.UBO.addEntry("DiffuseIntensity", "f32");
  model.UBO.addEntry("Roughness", "f32");
  model.UBO.addEntry("Metallic", "f32");
  model.UBO.addEntry("Ambient", "f32");
  model.UBO.addEntry("Normal", "f32");
  model.UBO.addEntry("Emission", "f32");
  model.UBO.addEntry("NormalStrength", "f32");
  model.UBO.addEntry("BaseIOR", "f32");
  model.UBO.addEntry("SpecularIntensity", "f32");
  model.UBO.addEntry("LineWidth", "f32");
  model.UBO.addEntry("Opacity", "f32");
  model.UBO.addEntry("ZValue", "f32");
  model.UBO.addEntry("PropID", "u32");
  model.UBO.addEntry("ClipNear", "f32");
  model.UBO.addEntry("ClipFar", "f32");
  model.UBO.addEntry("Time", "u32");
  setGet(publicAPI, model, ["cellArray", "currentInput", "cellOffset", "is2D", "primitiveType", "renderEncoder"]);
  model.textures = [];
  vtkWebGPUCellArrayMapper(publicAPI, model);
}
var newInstance18 = newInstance(extend17, "vtkWebGPUCellArrayMapper");
var vtkWebGPUCellArrayMapper$1 = {
  newInstance: newInstance18,
  extend: extend17
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper.js
var {
  PrimitiveTypes: PrimitiveTypes2
} = vtkWebGPUBufferManager$1;
function vtkWebGPUPolyDataMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPolyDataMapper");
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = (poly) => {
    if (!poly) {
      vtkErrorMacro("No input!");
      return;
    }
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PrimitiveTypes2.Points; i <= PrimitiveTypes2.TriangleStrips; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {
      if (prims[PrimitiveTypes2.Triangles].getNumberOfValues() > 0) {
        const i = PrimitiveTypes2.TriangleEdges;
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[PrimitiveTypes2.Triangles]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(model.primitives[PrimitiveTypes2.Triangles].getCellOffset());
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMappers.push(cellMapper);
      } else {
        model.primitives[PrimitiveTypes2.TriangleEdges] = null;
      }
      if (prims[PrimitiveTypes2.TriangleStrips].getNumberOfValues() > 0) {
        const i = PrimitiveTypes2.TriangleStripEdges;
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[PrimitiveTypes2.TriangleStrips]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(model.primitives[PrimitiveTypes2.TriangleStrips].getCellOffset());
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMappers.push(cellMapper);
      } else {
        model.primitives[PrimitiveTypes2.TriangleStripEdges] = null;
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}
var DEFAULT_VALUES17 = {
  primitives: null
};
function extend18(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.primitives = [];
  vtkWebGPUPolyDataMapper(publicAPI, model);
}
var newInstance19 = newInstance(extend18, "vtkWebGPUPolyDataMapper");
var vtkWebGPUPolyDataMapper$1 = {
  newInstance: newInstance19,
  extend: extend18
};
registerOverride2("vtkMapper", newInstance19);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    const aspectRatio = model.WebGPURenderer.getAspectRatio();
    const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    const texels = null;
    if (model.renderable.getUseZValues()) ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}
var DEFAULT_VALUES18 = {};
function extend19(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend19, "vtkWebGPUPixelSpaceCallbackMapper");
registerOverride2("vtkPixelSpaceCallbackMapper", newInstance20);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper2D.js
var {
  PrimitiveTypes: PrimitiveTypes3
} = vtkWebGPUBufferManager$1;
function vtkWebGPUPolyDataMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPolyDataMapper2D");
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = (poly) => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PrimitiveTypes3.Points; i <= PrimitiveTypes3.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMapper.setIs2D(true);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}
function defaultValues2(initialValues) {
  return {
    primitives: [],
    ...initialValues
  };
}
function extend20(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues2(initialValues));
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.primitives = [];
  vtkWebGPUPolyDataMapper2D(publicAPI, model);
}
var newInstance21 = newInstance(extend20, "vtkWebGPUPolyDataMapper2D");
registerOverride2("vtkMapper2D", newInstance21);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro3
} = macro$1;
var clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var _fsqClearMat4 = new Float64Array(16);
var _tNormalMat4 = new Float64Array(16);
function getLightTypeIndex(light) {
  if (light.getPositional()) {
    if (light.getConeAngle() >= 90) {
      return 0;
    }
    return 2;
  }
  return 1;
}
function vtkWebGPURenderer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera, model.webgpuCamera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = () => {
    const clipRange = model.camera.getClippingRange();
    const pos = model.camera.getPositionByReference();
    const dop = model.camera.getDirectionOfProjectionByReference();
    const center = [];
    const offset = [];
    vec3_exports.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
    vec3_exports.add(center, pos, offset);
    vec3_exports.sub(offset, center, model.stabilizedCenter);
    const length = vec3_exports.len(offset);
    if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro3("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.updateUBO = () => {
    var _a;
    const utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray("WCVCMatrix", keyMats.wcvc);
      model.UBO.setArray("SCPCMatrix", keyMats.scpc);
      model.UBO.setArray("PCSCMatrix", keyMats.pcsc);
      model.UBO.setArray("SCVCMatrix", keyMats.scvc);
      model.UBO.setArray("VCPCMatrix", keyMats.vcpc);
      model.UBO.setArray("WCVCNormals", keyMats.normalMatrix);
      model.UBO.setValue("LightCount", model.renderable.getLights().length);
      model.UBO.setValue("MaxEnvironmentMipLevel", (_a = model.renderable.getEnvironmentTexture()) == null ? void 0 : _a.getMipLevel());
      model.UBO.setValue("BackgroundDiffuseStrength", model.renderable.getEnvironmentTextureDiffuseStrength());
      model.UBO.setValue("BackgroundSpecularStrength", model.renderable.getEnvironmentTextureSpecularStrength());
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray("viewportSize", [tsize.usize, tsize.vsize]);
      model.UBO.setValue("cameraParallel", model.camera.getParallelProjection());
      const device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateSSBO = () => {
    const lights = model.renderable.getLights();
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    let lightTimeString = `${model.renderable.getMTime()}`;
    for (let i = 0; i < lights.length; i++) {
      lightTimeString += lights[i].getMTime();
    }
    if (lightTimeString !== model.lightTimeString) {
      const lightPosArray = new Float32Array(lights.length * 4);
      const lightDirArray = new Float32Array(lights.length * 4);
      const lightColorArray = new Float32Array(lights.length * 4);
      const lightTypeArray = new Float32Array(lights.length * 4);
      for (let i = 0; i < lights.length; i++) {
        const offset = i * 4;
        const viewCoordinatePosition = lights[i].getPosition();
        vec3_exports.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
        lightPosArray[offset] = viewCoordinatePosition[0];
        lightPosArray[offset + 1] = viewCoordinatePosition[1];
        lightPosArray[offset + 2] = viewCoordinatePosition[2];
        lightPosArray[offset + 3] = 0;
        lightDirArray[offset] = -lights[i].getDirection()[0];
        lightDirArray[offset + 1] = -lights[i].getDirection()[1];
        lightDirArray[offset + 2] = -lights[i].getDirection()[2];
        lightDirArray[offset + 3] = 0;
        lightColorArray[offset] = lights[i].getColor()[0];
        lightColorArray[offset + 1] = lights[i].getColor()[1];
        lightColorArray[offset + 2] = lights[i].getColor()[2];
        lightColorArray[offset + 3] = lights[i].getIntensity() * 5;
        lightTypeArray[offset] = getLightTypeIndex(lights[i]);
        lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle()));
        lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff()));
        lightTypeArray[offset + 3] = 0;
      }
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(lights.length);
      model.SSBO.addEntry("LightPos", "vec4<f32>");
      model.SSBO.addEntry("LightDir", "vec4<f32>");
      model.SSBO.addEntry("LightColor", "vec4<f32>");
      model.SSBO.addEntry("LightData", "vec4<f32>");
      model.SSBO.setAllInstancesFromArray("LightPos", lightPosArray);
      model.SSBO.setAllInstancesFromArray("LightDir", lightDirArray);
      model.SSBO.setAllInstancesFromArray("LightColor", lightColorArray);
      model.SSBO.setAllInstancesFromArray("LightData", lightTypeArray);
      const device = model._parent.getDevice();
      model.SSBO.send(device);
    }
    model.lightTimeString = lightTimeString;
  };
  publicAPI.scissorAndViewport = (encoder) => {
    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0, 1);
    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = (renderEncoder) => {
    renderEncoder.activateBindGroup(model.bindGroup);
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
      publicAPI.updateSSBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = () => {
    var _a;
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    const device = model._parent.getDevice();
    if (!model.clearFSQ) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      model.backgroundTex = model.renderable.getEnvironmentTexture();
    }
    if (model.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && model.renderable.getUseEnvironmentTextureAsBackground() && ((_a = model.backgroundTex) == null ? void 0 : _a.getImageLoaded())) {
      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex, "EnvironmentTexture");
      if (environmentTextureHash.getReady()) {
        const tview = environmentTextureHash.createView(`EnvironmentTexture`);
        model.clearFSQ.setTextureViews([tview]);
        model.backgroundTexLoaded = true;
        const interpolate = model.backgroundTex.getInterpolate() ? "linear" : "nearest";
        tview.addSampler(device, {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge",
          addressModeW: "repeat",
          minFilter: interpolate,
          magFilter: interpolate,
          mipmapFilter: "linear"
        });
      }
      model.clearFSQ.setPipelineHash("clearfsqwithtexture");
    } else if (model.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !model.renderable.getUseEnvironmentTextureAsBackground()) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
    }
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    const background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray("BackgroundColor", background);
    mat4_exports.transpose(_tNormalMat4, keyMats.normalMatrix);
    mat4_exports.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
    mat4_exports.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
    model.clearFSQ.getUBO().setArray("FSQMatrix", _fsqClearMat4);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.prepareAndDraw(model.renderEncoder);
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.convertToOpenGLDepth = (val) => model.webgpuCamera.convertToOpenGLDepth(val);
  publicAPI.getYInvertedTiledSizeAndOrigin = () => {
    const res = publicAPI.getTiledSizeAndOrigin();
    const size = model._parent.getSizeByReference();
    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = (id) => {
    for (let i = 0; i < model.children.length; i++) {
      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
      if (res === id) {
        return model.children[i];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}
var DEFAULT_VALUES19 = {
  bindGroup: null,
  selector: null,
  renderEncoder: null,
  recenterThreshold: 20,
  suppressClear: false,
  stabilizedCenter: [0, 0, 0]
};
function extend21(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "rendererUBO"
  });
  model.UBO.addEntry("WCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("PCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("VCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("WCVCNormals", "mat4x4<f32>");
  model.UBO.addEntry("viewportSize", "vec2<f32>");
  model.UBO.addEntry("LightCount", "i32");
  model.UBO.addEntry("MaxEnvironmentMipLevel", "f32");
  model.UBO.addEntry("BackgroundDiffuseStrength", "f32");
  model.UBO.addEntry("BackgroundSpecularStrength", "f32");
  model.UBO.addEntry("cameraParallel", "u32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "rendererLightSSBO"
  });
  model.lightTimeString = "";
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "rendererBG"
  });
  model.bindGroup.setBindables([model.UBO, model.SSBO]);
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.stabilizedTime = {};
  obj(model.stabilizedTime, {
    mtime: 0
  });
  get(publicAPI, model, ["bindGroup", "stabilizedTime"]);
  getArray(publicAPI, model, ["stabilizedCenter"]);
  setGet(publicAPI, model, ["renderEncoder", "selector", "suppressClear", "UBO"]);
  vtkWebGPURenderer(publicAPI, model);
}
var newInstance22 = newInstance(extend21, "vtkWebGPURenderer");
registerOverride2("vtkRenderer", newInstance22);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ScalarBarActor.js
function vtkWebGPUScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUScalarBarActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES20 = {};
function extend22(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
  vtkWebGPUScalarBarActor(publicAPI, model);
}
var newInstance23 = newInstance(extend22, "vtkWebGPUScalarBarActor");
registerOverride2("vtkScalarBarActor", newInstance23);

export {
  vtkProperty2D$1,
  vtkCubeAxesActor$1,
  vtkActor,
  vtkActor2D,
  vtkCamera,
  vtkPolyDataVS,
  vtkPolyDataFS,
  vtkReplacementShaderMapper,
  vtkOpenGLPolyDataMapper$1,
  vtkPixelSpaceCallbackMapper,
  vtkPolyDataMapper2D,
  vtkRenderer,
  vtkSkybox,
  vtkWebGPUCellArrayMapper$1,
  vtkWebGPUPolyDataMapper$1
};
//# sourceMappingURL=chunk-X35NBDZJ.js.map
