import {
  macro,
  macro$1,
  newInstance,
  newTypedArray,
  newTypedArrayFrom,
  norm,
  obj,
  set,
  vtk,
  vtkBoundingBox,
  vtkMath
} from "./chunk-UJ7GCCMN.js";

// node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var DataTypeByteSize = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var VtkDataTypes = {
  VOID: "",
  // not sure to know what that should be
  CHAR: "Int8Array",
  SIGNED_CHAR: "Int8Array",
  UNSIGNED_CHAR: "Uint8Array",
  UNSIGNED_CHAR_CLAMPED: "Uint8ClampedArray",
  // should be used for VTK.js internal purpose only
  SHORT: "Int16Array",
  UNSIGNED_SHORT: "Uint16Array",
  INT: "Int32Array",
  UNSIGNED_INT: "Uint32Array",
  FLOAT: "Float32Array",
  DOUBLE: "Float64Array"
};
var DefaultDataType = VtkDataTypes.FLOAT;
var Constants = {
  DefaultDataType,
  DataTypeByteSize,
  VtkDataTypes
};

// node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var {
  vtkErrorMacro
} = macro$1;
var {
  DefaultDataType: DefaultDataType2
} = Constants;
var EPSILON = 1e-6;
function fastComputeRange(arr, offset, numberOfComponents) {
  const len = arr.length;
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  let x;
  let i;
  for (i = offset; i < len; i += numberOfComponents) {
    if (!Number.isNaN(arr[i])) {
      min = arr[i];
      max = min;
      break;
    }
  }
  for (; i < len; i += numberOfComponents) {
    x = arr[i];
    if (x < min) {
      min = x;
    } else if (x > max) {
      max = x;
    }
  }
  return {
    min,
    max
  };
}
function createRangeHelper() {
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  let count = 0;
  let sum = 0;
  return {
    add(value) {
      if (min > value) {
        min = value;
      }
      if (max < value) {
        max = value;
      }
      count++;
      sum += value;
    },
    get() {
      return {
        min,
        max,
        count,
        sum,
        mean: sum / count
      };
    },
    getRange() {
      return {
        min,
        max
      };
    }
  };
}
function computeRange(values) {
  let component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let numberOfComponents = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (component < 0 && numberOfComponents > 1) {
    const size = values.length;
    const numberOfValues = size / numberOfComponents;
    const data = new Float64Array(numberOfValues);
    for (let i = 0, j = 0; i < numberOfValues; ++i) {
      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {
        data[i] += values[j] * values[j];
      }
      data[i] **= 0.5;
    }
    return fastComputeRange(data, 0, 1);
  }
  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
}
function ensureRangeSize(rangeArray) {
  let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const ranges = rangeArray || [];
  while (ranges.length <= size) {
    ranges.push(null);
  }
  return ranges;
}
function getDataType(typedArray) {
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}
function getMaxNorm(normArray) {
  const numComps = normArray.getNumberOfComponents();
  let maxNorm = 0;
  const tuple = new Array(numComps);
  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {
    normArray.getTuple(i, tuple);
    const norm$1 = norm(tuple, numComps);
    if (norm$1 > maxNorm) {
      maxNorm = norm$1;
    }
  }
  return maxNorm;
}
var STATIC = {
  computeRange,
  createRangeHelper,
  fastComputeRange,
  getDataType,
  getMaxNorm
};
function vtkDataArray(publicAPI, model) {
  model.classHierarchy.push("vtkDataArray");
  function resize(requestedNumTuples) {
    if (requestedNumTuples < 0) {
      return false;
    }
    const numComps = publicAPI.getNumberOfComponents();
    const numAllocatedTuples = model.values.length / (numComps > 0 ? numComps : 1);
    if (requestedNumTuples === numAllocatedTuples) {
      return true;
    }
    if (requestedNumTuples > numAllocatedTuples) {
      const oldValues = model.values;
      model.values = newTypedArray(model.dataType, (requestedNumTuples + numAllocatedTuples) * numComps);
      model.values.set(oldValues);
      return true;
    }
    if (model.size > requestedNumTuples * numComps) {
      model.size = requestedNumTuples * numComps;
      publicAPI.dataChange();
    }
    return true;
  }
  publicAPI.dataChange = () => {
    model.ranges = null;
    publicAPI.modified();
  };
  publicAPI.allocate = (extraNumTuples) => {
    resize(publicAPI.getNumberOfTuples() + extraNumTuples);
  };
  publicAPI.resize = (requestedNumTuples) => {
    resize(requestedNumTuples);
    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();
    if (model.size !== newSize) {
      model.size = newSize;
      publicAPI.dataChange();
      return true;
    }
    return false;
  };
  publicAPI.initialize = () => {
    publicAPI.resize(0);
    return publicAPI;
  };
  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;
  publicAPI.getComponent = function(tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.dataChange();
    }
  };
  publicAPI.getValue = (valueIdx) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    return publicAPI.getComponent(idx, comp);
  };
  publicAPI.setValue = (valueIdx, value) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    publicAPI.setComponent(idx, comp, value);
  };
  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
  publicAPI.getRange = function() {
    let componentIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
    let rangeIdx = componentIndex;
    if (rangeIdx < 0) {
      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;
    }
    let range = null;
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];
    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }
    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setRange = (rangeValue, componentIndex) => {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    const range = {
      min: rangeValue.min,
      max: rangeValue.max
    };
    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.getRanges = function() {
    let computeRanges = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!computeRanges) {
      return structuredClone(model.ranges);
    }
    const ranges = [];
    for (let i = 0; i < model.numberOfComponents; i++) {
      const [min, max] = publicAPI.getRange(i);
      const range = {
        min,
        max
      };
      ranges.push(range);
    }
    if (model.numberOfComponents > 1) {
      const [min, max] = publicAPI.getRange(-1);
      const range = {
        min,
        max
      };
      ranges.push(range);
    }
    return ranges;
  };
  publicAPI.setTuple = (idx, tuple) => {
    const offset = idx * model.numberOfComponents;
    for (let i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = tuple[i];
    }
  };
  publicAPI.setTuples = (idx, tuples) => {
    let i = idx * model.numberOfComponents;
    const last = Math.min(tuples.length, model.size - i);
    for (let j = 0; j < last; ) {
      model.values[i++] = tuples[j++];
    }
  };
  publicAPI.insertTuple = (idx, tuple) => {
    if (model.size <= idx * model.numberOfComponents) {
      model.size = (idx + 1) * model.numberOfComponents;
      resize(idx + 1);
    }
    publicAPI.setTuple(idx, tuple);
    return idx;
  };
  publicAPI.insertTuples = (idx, tuples) => {
    const end = idx + tuples.length / model.numberOfComponents;
    if (model.size < end * model.numberOfComponents) {
      model.size = end * model.numberOfComponents;
      resize(end);
    }
    publicAPI.setTuples(idx, tuples);
    return end;
  };
  publicAPI.insertNextTuple = (tuple) => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuple(idx, tuple);
  };
  publicAPI.insertNextTuples = (tuples) => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuples(idx, tuples);
  };
  publicAPI.findTuple = function(tuple) {
    let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : EPSILON;
    for (let i = 0; i < model.size; i += model.numberOfComponents) {
      if (Math.abs(tuple[0] - model.values[i]) <= precision) {
        let match = true;
        for (let j = 1; j < model.numberOfComponents; ++j) {
          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {
            match = false;
            break;
          }
        }
        if (match) {
          return i / model.numberOfComponents;
        }
      }
    }
    return -1;
  };
  publicAPI.getTuple = function(idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    const offset = idx * numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        tupleToFill[3] = model.values[offset + 3];
      case 3:
        tupleToFill[2] = model.values[offset + 2];
      case 2:
        tupleToFill[1] = model.values[offset + 1];
      case 1:
        tupleToFill[0] = model.values[offset];
        break;
      default:
        for (let i = numberOfComponents - 1; i >= 0; --i) {
          tupleToFill[i] = model.values[offset + i];
        }
    }
    return tupleToFill;
  };
  publicAPI.getTuples = (fromId, toId) => {
    const from = (fromId ?? 0) * model.numberOfComponents;
    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;
    const arr = publicAPI.getData().subarray(from, to);
    return arr.length > 0 ? arr : null;
  };
  publicAPI.getTupleLocation = function() {
    let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.size;
  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  publicAPI.newClone = () => newInstance2({
    empty: true,
    name: model.name,
    dataType: model.dataType,
    numberOfComponents: model.numberOfComponents
  });
  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.modified();
      model.name = `vtkDataArray${publicAPI.getMTime()}`;
    }
    return model.name;
  };
  publicAPI.setData = (typedArray, numberOfComponents) => {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.dataChange();
  };
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = {
      ...model,
      vtkClass: publicAPI.getClassName()
    };
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;
    Object.keys(jsonArchive).forEach((keyName) => {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach((name) => {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.deepCopy = (other) => {
    const currentType = publicAPI.getDataType();
    const currentArray = model.values;
    publicAPI.shallowCopy(other);
    model.ranges = structuredClone(other.getRanges());
    if ((currentArray == null ? void 0 : currentArray.length) >= other.getNumberOfValues() && currentType === other.getDataType()) {
      currentArray.set(other.getData());
      model.values = currentArray;
      publicAPI.dataChange();
    } else {
      publicAPI.setData(other.getData().slice());
    }
  };
  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {
    const numberOfComponents = model.numberOfComponents || 1;
    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
      vtkErrorMacro("numberOfComponents must match");
    }
    const tuple1 = source1.getTuple(source1Idx);
    const tuple2 = source2.getTuple(source2Idx);
    const out = [];
    out.length = numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;
      case 3:
        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;
      case 2:
        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;
      case 1:
        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;
        break;
      default:
        for (let i = 0; i < numberOfComponents; i++) {
          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;
        }
    }
    return publicAPI.insertTuple(idx, out);
  };
}
var DEFAULT_VALUES = {
  name: "",
  numberOfComponents: 1,
  dataType: DefaultDataType2,
  rangeTuple: [0, 0]
  // size: undefined,
  // values: null,
  // ranges: null,
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  if (Array.isArray(initialValues.values) && initialValues.dataType === void 0) {
    console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array");
  }
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
  }
  if (!model.values) {
    model.values = newTypedArray(model.dataType, model.size);
  } else if (Array.isArray(model.values)) {
    model.values = newTypedArrayFrom(model.dataType, model.values);
  }
  if (model.values) {
    model.size = model.size ?? model.values.length;
    model.dataType = getDataType(model.values);
  }
  obj(publicAPI, model);
  set(publicAPI, model, ["name", "numberOfComponents"]);
  if (model.size % model.numberOfComponents !== 0) {
    throw new RangeError("model.size is not a multiple of model.numberOfComponents");
  }
  vtkDataArray(publicAPI, model);
}
var newInstance2 = newInstance(extend, "vtkDataArray");
var vtkDataArray$1 = {
  newInstance: newInstance2,
  extend,
  ...STATIC,
  ...Constants
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js
var {
  vtkErrorMacro: vtkErrorMacro2,
  vtkWarningMacro
} = macro;
function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push("vtkFieldData");
  const superGetState = publicAPI.getState;
  if (model.arrays) {
    model.arrays = model.arrays.map((item) => ({
      data: vtk(item.data)
    }));
  }
  publicAPI.initialize = () => {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };
  publicAPI.initializeFields = () => {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };
  publicAPI.copyStructure = (other) => {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map((x) => x);
    model.arrays = other.getArrays().map((x) => ({
      data: x
    }));
  };
  publicAPI.getNumberOfArrays = () => model.arrays.length;
  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;
  publicAPI.addArray = (arr) => {
    const name = arr.getName();
    const {
      array,
      index
    } = publicAPI.getArrayWithIndex(name);
    if (array != null) {
      model.arrays[index] = {
        data: arr
      };
      return index;
    }
    model.arrays = [].concat(model.arrays, {
      data: arr
    });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = () => {
    model.arrays = [];
  };
  publicAPI.removeArray = (arrayName) => {
    const index = model.arrays.findIndex((array) => array.data.getName() === arrayName);
    return publicAPI.removeArrayByIndex(index);
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {
      model.arrays.splice(arrayIdx, 1);
      return true;
    }
    return false;
  };
  publicAPI.getArrays = () => model.arrays.map((entry) => entry.data);
  publicAPI.getArray = (arraySpec) => typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
  publicAPI.getArrayByName = (arrayName) => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);
  publicAPI.getArrayWithIndex = (arrayName) => {
    const index = model.arrays.findIndex((array) => array.data.getName() === arrayName);
    return {
      array: index !== -1 ? model.arrays[index].data : null,
      index
    };
  };
  publicAPI.getArrayByIndex = (idx) => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  publicAPI.hasArray = (arrayName) => publicAPI.getArrayWithIndex(arrayName).index >= 0;
  publicAPI.getArrayName = (idx) => {
    const arr = model.arrays[idx];
    return arr ? arr.data.getName() : "";
  };
  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;
  publicAPI.getFlag = (arrayName) => model.copyFieldFlags[arrayName];
  publicAPI.passData = function(other) {
    let fromId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let toId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.insertTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId;
            destArr.insertTuple(tId, arr.getTuple(fromId));
          } else {
            destArr.insertTuples(0, arr.getTuples());
          }
        } else {
          vtkErrorMacro2("Unhandled case in passData");
        }
      }
    });
  };
  publicAPI.interpolateData = function(other) {
    let fromId1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let fromId2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    let toId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
    let t = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId1;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId1;
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            vtkWarningMacro("Unexpected case in interpolateData");
          } else {
            destArr.insertTuples(arr.getTuples());
          }
        } else {
          vtkErrorMacro2("Unhandled case in interpolateData");
        }
      }
    });
  };
  publicAPI.copyFieldOn = (arrayName) => {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = (arrayName) => {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = () => {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = () => {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = () => {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = (other) => {
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.copyFlags = (other) => other.getCopyFieldFlags().map((x) => x);
  publicAPI.reset = () => model.arrays.forEach((entry) => entry.data.reset());
  publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime);
  publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);
  publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
  publicAPI.getState = () => {
    const result = superGetState();
    if (result) {
      result.arrays = model.arrays.map((item) => ({
        data: item.data.getState()
      }));
    }
    return result;
  };
}
var DEFAULT_VALUES2 = {
  arrays: [],
  copyFieldFlags: [],
  // fields not to copy
  doCopyAllOn: true,
  doCopyAllOff: false
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  vtkFieldData(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkFieldData");
var vtkFieldData$1 = {
  newInstance: newInstance3,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js
var AttributeTypes = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8
};
var AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2
};
var CellGhostTypes = {
  DUPLICATECELL: 1,
  // the cell is present on multiple processors
  HIGHCONNECTIVITYCELL: 2,
  // the cell has more neighbors than in a regular mesh
  LOWCONNECTIVITYCELL: 4,
  // the cell has less neighbors than in a regular mesh
  REFINEDCELL: 8,
  // other cells are present that refines it.
  EXTERIORCELL: 16,
  // the cell is on the exterior of the data set
  HIDDENCELL: 32
  // the cell is needed to maintain connectivity, but the data values should be ignored.
};
var PointGhostTypes = {
  DUPLICATEPOINT: 1,
  // the cell is present on multiple processors
  HIDDENPOINT: 2
  // the point is needed to maintain connectivity, but the data values should be ignored.
};
var AttributeCopyOperations = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3
  // all of the above
};
var ghostArrayName = "vtkGhostType";
var DesiredOutputPrecision = {
  DEFAULT: 0,
  // use the point type that does not truncate any data
  SINGLE: 1,
  // use Float32Array
  DOUBLE: 2
  // use Float64Array
};
var Constants2 = {
  AttributeCopyOperations,
  AttributeLimitTypes,
  AttributeTypes,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js
var {
  AttributeTypes: AttributeTypes2,
  AttributeCopyOperations: AttributeCopyOperations2
} = Constants2;
var {
  vtkWarningMacro: vtkWarningMacro2
} = macro;
function vtkDataSetAttributes(publicAPI, model) {
  const attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
  function cleanAttributeType(attType) {
    let cleanAttType = attrTypes.find((ee) => AttributeTypes2[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase());
    if (typeof cleanAttType === "undefined") {
      cleanAttType = null;
    }
    return cleanAttType;
  }
  model.classHierarchy.push("vtkDataSetAttributes");
  const superClass = {
    ...publicAPI
  };
  publicAPI.checkNumberOfComponents = (x) => true;
  publicAPI.setAttribute = (arr, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
      vtkWarningMacro2(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro2(`Cannot set attribute ${attType}. Incorrect number of components.`);
      return -1;
    }
    if (arr) {
      const currentAttribute = publicAPI.addArray(arr);
      model[`active${attType}`] = currentAttribute;
    } else {
      model[`active${attType}`] = -1;
    }
    publicAPI.modified();
    return model[`active${attType}`];
  };
  publicAPI.getAttributes = (arr) => attrTypes.filter((attrType) => publicAPI[`get${attrType}`]() === arr);
  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== "PEDIGREEIDS") {
        const arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA("vtkDataArray")) {
          vtkWarningMacro2(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro2(`Cannot set attribute ${attType}. Incorrect number of components.`);
          return -1;
        }
      }
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }
    if (arrayIdx === -1) {
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
    }
    return -1;
  };
  publicAPI.getActiveAttribute = (attType) => {
    const cleanAttType = cleanAttributeType(attType);
    return publicAPI[`get${cleanAttType}`]();
  };
  publicAPI.removeAllArrays = () => {
    attrTypes.forEach((attType) => {
      model[`active${attType}`] = -1;
    });
    superClass.removeAllArrays();
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1) {
      attrTypes.forEach((attType) => {
        if (arrayIdx === model[`active${attType}`]) {
          model[`active${attType}`] = -1;
        } else if (arrayIdx < model[`active${attType}`]) {
          model[`active${attType}`] -= 1;
        }
      });
    }
    return superClass.removeArrayByIndex(arrayIdx);
  };
  attrTypes.forEach((value) => {
    const activeVal = `active${value}`;
    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);
    publicAPI[`set${value}`] = (da) => publicAPI.setAttribute(da, value);
    publicAPI[`setActive${value}`] = (arrayName) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
    publicAPI[`copy${value}Off`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = false;
    };
    publicAPI[`copy${value}On`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = true;
    };
  });
  publicAPI.initializeAttributeCopyFlags = () => {
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations2).filter((op) => op !== "ALLCOPY").forEach((attCopyOp) => {
      model.copyAttributeFlags[AttributeCopyOperations2[attCopyOp]] = Object.keys(AttributeTypes2).filter((ty) => ty !== "NUM_ATTRIBUTES").reduce((a, b) => {
        a[AttributeTypes2[b]] = true;
        return a;
      }, []);
    });
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.INTERPOLATE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.PEDIGREEIDS] = false;
  };
  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach((name) => {
      if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
        publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
      }
    });
  }
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug) => {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.initializeAttributeCopyFlags();
}
var DEFAULT_VALUES3 = {
  activeScalars: -1,
  activeVectors: -1,
  activeTensors: -1,
  activeNormals: -1,
  activeTCoords: -1,
  activeGlobalIds: -1,
  activePedigreeIds: -1
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkFieldData$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
  if (!model.arrays) {
    model.arrays = {};
  }
  vtkDataSetAttributes(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkDataSetAttributes");
var vtkDataSetAttributes$1 = {
  newInstance: newInstance4,
  extend: extend3,
  ...Constants2
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js
var FieldDataTypes = {
  UNIFORM: 0,
  // data that does not vary over points/cells/etc.
  DATA_OBJECT_FIELD: 0,
  // to match VTK
  COORDINATE: 1,
  // data that specifies the location of each point
  POINT_DATA: 1,
  // to match VTK
  POINT: 2,
  // data defined at each point, but that does not specify the point location
  POINT_FIELD_DATA: 2,
  // to match VTK
  CELL: 3,
  // data defined at each cell, but that does not specify the cell
  CELL_FIELD_DATA: 3,
  // to match VTK
  VERTEX: 4,
  // data defined at each graph vertex, but that does not specify the graph vertex
  VERTEX_FIELD_DATA: 4,
  // to match VTK
  EDGE: 5,
  // data defined at each graph edge, but that does not specify the graph edge
  EDGE_FIELD_DATA: 5,
  // to match VTK
  ROW: 6,
  // data specifying a table row
  ROW_DATA: 6
  // to match VTK
};
var FieldAssociations = {
  FIELD_ASSOCIATION_POINTS: 0,
  FIELD_ASSOCIATION_CELLS: 1,
  FIELD_ASSOCIATION_NONE: 2,
  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
  FIELD_ASSOCIATION_VERTICES: 4,
  FIELD_ASSOCIATION_EDGES: 5,
  FIELD_ASSOCIATION_ROWS: 6,
  NUMBER_OF_ASSOCIATIONS: 7
};
var Constants3 = {
  FieldDataTypes,
  FieldAssociations
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js
var DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
function vtkDataSet(publicAPI, model) {
  model.classHierarchy.push("vtkDataSet");
  DATASET_FIELDS.forEach((fieldName) => {
    if (!model[fieldName]) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
    } else {
      model[fieldName] = vtk(model[fieldName]);
    }
  });
  publicAPI.computeBounds = () => {
    if (model.modifiedTime && model.computeTime && model.modifiedTime > model.computeTime || !model.computeTime) {
      const points = publicAPI.getPoints();
      if (points == null ? void 0 : points.getNumberOfPoints()) {
        vtkBoundingBox.setBounds(model.bounds, points.getBoundsByReference());
      } else {
        model.bounds = vtkMath.createUninitializedBounds();
      }
      model.computeTime = macro.getCurrentGlobalMTime();
    }
  };
  publicAPI.getLength2 = () => {
    const bounds = publicAPI.getBoundsByReference();
    if (!bounds || bounds.length !== 6) return 0;
    return vtkBoundingBox.getDiagonalLength2(bounds);
  };
  publicAPI.getLength = () => Math.sqrt(publicAPI.getLength2());
  publicAPI.getCenter = () => {
    const bounds = publicAPI.getBoundsByReference();
    if (!bounds || bounds.length !== 6) return [0, 0, 0];
    return vtkBoundingBox.getCenter(bounds);
  };
  publicAPI.getCellBounds = (cellId) => {
    const cell = publicAPI.getCell(cellId);
    if (cell) {
      return cell.getBounds();
    }
    return vtkMath.createUninitializedBounds();
  };
  publicAPI.getBounds = macro.chain(() => publicAPI.computeBounds, publicAPI.getBounds);
  publicAPI.getBoundsByReference = macro.chain(() => publicAPI.computeBounds, publicAPI.getBoundsByReference);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach((fieldName) => {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
  const superGetMTime = publicAPI.getMTime;
  publicAPI.getMTime = () => DATASET_FIELDS.reduce((mTime, fieldName) => {
    var _a;
    return Math.max(mTime, ((_a = model[fieldName]) == null ? void 0 : _a.getMTime()) ?? mTime);
  }, superGetMTime());
  publicAPI.initialize = () => {
    DATASET_FIELDS.forEach((fieldName) => {
      var _a;
      return (_a = model[fieldName]) == null ? void 0 : _a.initialize();
    });
    return publicAPI;
  };
}
var DEFAULT_VALUES4 = {
  // pointData: null,
  // cellData: null,
  // fieldData: null,
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, DATASET_FIELDS);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkDataSet(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend4, "vtkDataSet");
var vtkDataSet$1 = {
  newInstance: newInstance5,
  extend: extend4,
  ...Constants3
};

export {
  DataTypeByteSize,
  VtkDataTypes,
  vtkDataArray$1,
  AttributeTypes,
  DesiredOutputPrecision,
  vtkDataSetAttributes$1,
  FieldDataTypes,
  FieldAssociations,
  vtkDataSet$1
};
//# sourceMappingURL=chunk-QTSXRC5W.js.map
